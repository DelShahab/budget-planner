var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
import { H as css$e, K as themeRegistry, T as stylesFromTemplate, W as unsafeCSS, Z as DomModule, a0 as registerStyles$1, a1 as detailsSummary, a2 as ActiveMixin, a3 as html, a4 as defineCustomElement, a5 as DirMixin, a6 as ThemableMixin, a7 as PolymerElement, a8 as details, a9 as CollapsibleMixin, aa as DelegateFocusMixin, ab as DelegateStateMixin, ac as SummaryController, ad as TooltipController, ae as ControllerMixin, af as KeyboardDirectionMixin, ag as isElementFocused, ah as SlotObserver, ai as ElementMixin, aj as isIOS, ak as AriaModalController, al as FocusTrapController, am as beforeNextRender, an as afterNextRender, ao as button, ap as ButtonMixin, aq as isEmptyTextNode, ar as buttonStyles, as as overlay, at as PositionMixin, au as OverlayMixin, av as overlayStyles, aw as OverlayClassMixin, ax as generateUniqueId, ay as SlotController, az as Debouncer$1, aA as microTask, aB as isKeyboardActive, aC as removeValueFromAttribute, aD as addValueToAttribute, aE as ThemePropertyMixin, aF as addLumoGlobalStyles, aG as FocusMixin, aH as item, aI as menuOverlayCore, aJ as listBox, aK as ListMixin, aL as ItemMixin, aM as nothing, aN as ResizeMixin, aO as render, aP as html$1, aQ as announce, aR as wrap$e, aS as microTask$1, aT as dedupingMixin, aU as DisabledMixin, aV as InputMixin, aW as FieldMixin, aX as InputController, aY as LabelledInputController, aZ as requiredField, a_ as helper, a$ as legacyOptimizations, b0 as useShadow, b1 as PropertyEffects, b2 as strictTemplatePolicy, b3 as legacyWarnings, b4 as fastDomIf, b5 as root, b6 as suppressTemplateNotifications, b7 as Directive, b8 as isSingleExpression, b9 as PartType, ba as directive, bb as noChange, bc as idlePeriod, bd as ComboBoxPlaceholder, be as timeOut, bf as fieldButton, bg as comboBoxOverlay, bh as loader, bi as comboBoxLoader, bj as comboBoxItem, bk as inputFieldShared, bl as InputContainer, bm as ComboBoxItemMixin, bn as ComboBoxOverlayMixin, bo as ComboBoxScrollerMixin, bp as ComboBoxDataProviderMixin, bq as ComboBoxMixin, br as InputControlMixin, bs as processTemplates, bt as inputFieldShared$1, bu as dialogOverlay, bv as dialogOverlay$1, bw as DialogBaseMixin, bx as setAriaIDReference, by as gestures, bz as addListener, bA as removeListener, bB as KeyboardMixin, bC as getFlattenedElements, bD as menuOverlay, bE as isFirefox$4, bF as timeOut$1, bG as matches, bH as translate, bI as setTouchAction, bJ as MediaQueryController, bK as InputConstraintsMixin, bL as VirtualKeyboardController, bM as hideOthers, bN as PatternMixin, bO as ColumnBaseMixin, bP as updateColumnOrders, bQ as animationFrame, bR as ColumnObserver, bS as GridColumn, bT as animationFrame$1, bU as Grid, bV as isFocusable, bW as SlotStylesMixin, bX as TextField, bY as color$h, bZ as typography, b_ as isTemplateResult, b$ as LabelMixin, c0 as get, c1 as set, c2 as LitElement, c3 as screenReaderOnly, c4 as getNormalizedScrollLeft, c5 as InputFieldMixin, c6 as setCommittedValue, c7 as isTouch, c8 as Virtualizer, c9 as Iconset } from "./indexhtml-BRNpU1Lv.js";
var require_generated_flow_imports_00c = __commonJS({
  "VAADIN/build/generated-flow-imports-sZ3g2gWJ.js"(exports) {
    const { toString } = Object.prototype;
    function isRegexp(value) {
      return toString.call(value) === "[object RegExp]";
    }
    function stripCssComments(cssString, { preserve = true, whitespace = true, all } = {}) {
      if (all) {
        throw new Error("The `all` option is no longer supported. Use the `preserve` option instead.");
      }
      let preserveImportant = preserve;
      let preserveFilter;
      if (typeof preserve === "function") {
        preserveImportant = false;
        preserveFilter = preserve;
      } else if (isRegexp(preserve)) {
        preserveImportant = false;
        preserveFilter = (comment2) => preserve.test(comment2);
      }
      let isInsideString = false;
      let currentCharacter = "";
      let comment = "";
      let returnValue = "";
      for (let index = 0; index < cssString.length; index++) {
        currentCharacter = cssString[index];
        if (cssString[index - 1] !== "\\" && (currentCharacter === '"' || currentCharacter === "'")) {
          if (isInsideString === currentCharacter) {
            isInsideString = false;
          } else if (!isInsideString) {
            isInsideString = currentCharacter;
          }
        }
        if (!isInsideString && currentCharacter === "/" && cssString[index + 1] === "*") {
          const isImportantComment = cssString[index + 2] === "!";
          let index2 = index + 2;
          for (; index2 < cssString.length; index2++) {
            if (cssString[index2] === "*" && cssString[index2 + 1] === "/") {
              if (preserveImportant && isImportantComment || preserveFilter && preserveFilter(comment)) {
                returnValue += `/*${comment}*/`;
              } else if (!whitespace) {
                if (cssString[index2 + 2] === "\n") {
                  index2++;
                } else if (cssString[index2 + 2] + cssString[index2 + 3] === "\r\n") {
                  index2 += 2;
                }
              }
              comment = "";
              break;
            }
            comment += cssString[index2];
          }
          index = index2 + 1;
          continue;
        }
        returnValue += currentCharacter;
      }
      return returnValue;
    }
    const polyfilledSafari = CSSStyleSheet.toString().includes("document.createElement");
    const createLinkReferences = (css2, target) => {
      const importMatcher = /(?:@media\s(.+?))?(?:\s{)?\@import\s*(?:url\(\s*['"]?(.+?)['"]?\s*\)|(["'])((?:\\.|[^\\])*?)\3)([^;]*);(?:})?/g;
      if (/\/\*(.|[\r\n])*?\*\//gm.exec(css2) != null) {
        css2 = stripCssComments(css2);
      }
      var match2;
      var styleCss = css2;
      while ((match2 = importMatcher.exec(css2)) !== null) {
        styleCss = styleCss.replace(match2[0], "");
        const link = document.createElement("link");
        link.rel = "stylesheet";
        link.href = match2[2] || match2[4];
        const media = match2[1] || match2[5];
        if (media) {
          link.media = media;
        }
        if (target === document) {
          document.head.appendChild(link);
        } else {
          target.appendChild(link);
        }
      }
      return styleCss;
    };
    const addAdoptedStyleSafariPolyfill = (sheet, target, first) => {
      {
        target.adoptedStyleSheets = [...target.adoptedStyleSheets, sheet];
      }
      return () => {
        target.adoptedStyleSheets = target.adoptedStyleSheets.filter((ss) => ss !== sheet);
      };
    };
    const addAdoptedStyle = (cssText, target, first) => {
      const sheet = new CSSStyleSheet();
      sheet.replaceSync(cssText);
      if (polyfilledSafari) {
        return addAdoptedStyleSafariPolyfill(sheet, target);
      }
      {
        target.adoptedStyleSheets.push(sheet);
      }
      return () => {
        target.adoptedStyleSheets.splice(target.adoptedStyleSheets.indexOf(sheet), 1);
      };
    };
    const addStyleTag = (cssText, referenceComment) => {
      const styleTag = document.createElement("style");
      styleTag.type = "text/css";
      styleTag.textContent = cssText;
      let beforeThis = void 0;
      {
        const comments = Array.from(document.head.childNodes).filter((elem) => elem.nodeType === Node.COMMENT_NODE);
        const container = comments.find((comment) => comment.data.trim() === referenceComment);
        if (container) {
          beforeThis = container;
        }
      }
      document.head.insertBefore(styleTag, beforeThis);
      return () => {
        styleTag.remove();
      };
    };
    const injectGlobalCss = (css2, referenceComment, target, first) => {
      if (target === document) {
        const hash = getHash(css2);
        if (window.Vaadin.theme.injectedGlobalCss.indexOf(hash) !== -1) {
          return;
        }
        window.Vaadin.theme.injectedGlobalCss.push(hash);
      }
      const cssText = createLinkReferences(css2, target);
      if (target === document) {
        return addStyleTag(cssText, referenceComment);
      }
      return addAdoptedStyle(cssText, target);
    };
    window.Vaadin = window.Vaadin || {};
    window.Vaadin.theme = window.Vaadin.theme || {};
    window.Vaadin.theme.injectedGlobalCss = [];
    function hashFnv32a(str) {
      let i, l, hval = 2166136261;
      for (i = 0, l = str.length; i < l; i++) {
        hval ^= str.charCodeAt(i);
        hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
      }
      return ("0000000" + (hval >>> 0).toString(16)).substr(-8);
    }
    function getHash(input) {
      let h1 = hashFnv32a(input);
      return h1 + hashFnv32a(h1 + input);
    }
    const $cssFromFile_0 = css$e`/* Budget Dashboard Dark Theme Styles */

/* Viewport and base styles */
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow-x: auto;
}

.budget-dashboard {
    background: var(--lumo-base-color);
    color: var(--lumo-body-text-color);
    height: 100vh;
    width: 100%;
    overflow: hidden;
}

/* Sidebar Styles */
.sidebar {
    background: var(--lumo-contrast-5pct);
    border-right: 1px solid var(--lumo-contrast-10pct);
    padding: var(--lumo-space-m);
}

.month-header {
    color: var(--lumo-primary-text-color);
    font-size: var(--lumo-font-size-xl);
    font-weight: 600;
    margin: 0 0 var(--lumo-space-xs) 0;
}

.budget-label {
    color: var(--lumo-secondary-text-color);
    font-size: var(--lumo-font-size-s);
    font-weight: 500;
    letter-spacing: 0.5px;
    margin-bottom: var(--lumo-space-m);
    display: block;
}

.navigation-tree {
    background: transparent;
}

/* Main Dashboard Styles */
.main-dashboard {
    background: var(--lumo-contrast-5pct);
    border: 1px solid var(--lumo-contrast-10pct);
    border-radius: var(--lumo-border-radius-m);
    padding: var(--lumo-space-m);
    flex: 1;
    height: calc(100vh - var(--lumo-space-m));
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}

/* Summary Cards */
.summary-cards {
    display: flex;
    gap: var(--lumo-space-m);
    margin-bottom: var(--lumo-space-l);
    flex-wrap: wrap;
    justify-content: center;
    flex-shrink: 0;
}

.summary-card {
    background: var(--lumo-contrast-5pct);
    border: 1px solid var(--lumo-contrast-10pct);
    border-radius: var(--lumo-border-radius-m);
    padding: var(--lumo-space-m);
    text-align: center;
    min-width: 120px;
}

.summary-card .card-title {
    font-size: var(--lumo-font-size-s);
    font-weight: 500;
    color: var(--lumo-secondary-text-color);
    display: block;
    margin-bottom: var(--lumo-space-xs);
}

.summary-card .card-value {
    font-size: var(--lumo-font-size-xl);
    font-weight: 600;
    color: var(--lumo-primary-text-color);
    display: block;
}

.income-card {
    border-left: 4px solid var(--lumo-success-color);
}

.expenses-card {
    border-left: 4px solid var(--lumo-error-color);
}

.bills-card {
    border-left: 4px solid var(--lumo-primary-color);
}

.savings-card {
    border-left: 4px solid var(--lumo-success-color-50pct);
}

.debt-card {
    border-left: 4px solid var(--lumo-error-color-50pct);
}

.rollover-card {
    border-left: 4px solid var(--lumo-primary-color-50pct);
}

.leftover-card {
    border-left: 4px solid var(--lumo-success-color);
}

/* Amount Left Chart */
.amount-left-chart {
    background: var(--lumo-contrast-5pct);
    border: 1px solid var(--lumo-contrast-10pct);
    border-radius: var(--lumo-border-radius-m);
    padding: var(--lumo-space-m);
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Charts */
.cash-flow-chart,
.allocation-chart {
    background: var(--lumo-contrast-5pct);
    border: 1px solid var(--lumo-contrast-10pct);
    border-radius: var(--lumo-border-radius-m);
    padding: var(--lumo-space-m);
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Split Layout and Form Panel */
.budget-split-layout {
    height: 100%;
}

.form-panel {
    background: var(--lumo-contrast-5pct);
    border-top: 2px solid var(--lumo-primary-color);
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
    min-height: 300px;
    max-height: 400px;
    overflow-y: auto;
}

.form-title {
    margin: 0;
    color: var(--lumo-primary-text-color);
    font-size: var(--lumo-font-size-l);
    font-weight: 600;
}

/* Floating Add Button */
.floating-add-button {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 1000;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    min-width: 60px;
    padding: 0;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.floating-add-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
}

.floating-add-button vaadin-icon {
    width: 24px;
    height: 24px;
}

/* Grids */
.financial-overview-grid,
.category-grid {
    background: var(--lumo-contrast-5pct);
    border: 1px solid var(--lumo-contrast-10pct);
    border-radius: var(--lumo-border-radius-m);
}

.category-grids {
    margin-top: var(--lumo-space-l);
}

.category-grid {
    margin-right: var(--lumo-space-m);
}

.category-grid:last-child {
    margin-right: 0;
}


/* Grid specific colors */
.income-grid {
    border-top: 3px solid var(--lumo-success-color);
}

.expenses-grid {
    border-top: 3px solid var(--lumo-error-color);
}

.bills-grid {
    border-top: 3px solid var(--lumo-primary-color);
}

.savings-grid {
    border-top: 3px solid var(--lumo-success-color-50pct);
}

/* Grid Headers */
.grid-header {
    background: var(--lumo-contrast-10pct);
    padding: var(--lumo-space-s) var(--lumo-space-m);
    font-weight: 600;
    font-size: var(--lumo-font-size-s);
    color: var(--lumo-primary-text-color);
    border-bottom: 1px solid var(--lumo-contrast-20pct);
    text-align: center;
    letter-spacing: 0.5px;
}

/* Category Grid Containers */
.category-grid-container {
    background: var(--lumo-contrast-5pct);
    border: 1px solid var(--lumo-contrast-10pct);
    border-radius: var(--lumo-border-radius-m);
    overflow: hidden;
    min-width: 280px;
    flex: 1;
    max-width: calc(25% - var(--lumo-space-m));
    height: 100%;
    display: flex;
    flex-direction: column;
}


.financial-overview-container {
    background: var(--lumo-contrast-5pct);
    border: 1px solid var(--lumo-contrast-10pct);
    border-radius: var(--lumo-border-radius-m);
    overflow: hidden;
}

/* Responsive Layout Classes */
.responsive-summary {
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--lumo-space-s);
}

.responsive-top-row {
    flex-wrap: nowrap;
    align-items: stretch;
    justify-content: space-between;
    gap: var(--lumo-space-l);
    height: 400px;
    flex-shrink: 0;
}

.responsive-category-grids {
    flex-wrap: wrap;
    align-items: stretch;
    justify-content: space-between;
    gap: var(--lumo-space-m);
    flex: 1;
    min-height: 300px;
}

/* Responsive Design */
@media (max-width: 1000px) {
    .responsive-top-row {
        flex-direction: column;
    }
    
    .responsive-top-row > * {
        width: 100% !important;
        min-width: unset !important;
        flex-grow: unset !important;
    }
}

@media (max-width: 1200px) {
    .sidebar {
        width: 250px !important;
    }
    
    .responsive-summary {
        justify-content: space-between;
    }
    
    .summary-card {
        min-width: 18%;
        flex: 1;
    }
    
    .responsive-category-grids {
        flex-direction: column;
    }
    
    .category-grid-container {
        width: 100% !important;
        min-width: unset !important;
    }
}

@media (max-width: 900px) {
    .responsive-summary {
        flex-direction: column;
        align-items: center;
    }
    
    .summary-card {
        width: 100%;
        max-width: 200px;
        margin-bottom: var(--lumo-space-s);
    }
}

@media (max-width: 768px) {
    .sidebar {
        width: 200px !important;
    }
    
    .main-dashboard {
        padding: var(--lumo-space-s);
    }
    
    .responsive-summary {
        gap: var(--lumo-space-xs);
    }
    
    .summary-card {
        padding: var(--lumo-space-s);
    }
    
    .summary-card .card-title {
        font-size: var(--lumo-font-size-xs);
    }
    
    .summary-card .card-value {
        font-size: var(--lumo-font-size-l);
    }
}

@media (max-width: 600px) {
    .sidebar {
        width: 180px !important;
    }
    
    .main-dashboard {
        padding: var(--lumo-space-xs);
    }
    
    .grid-header {
        font-size: var(--lumo-font-size-xs);
        padding: var(--lumo-space-xs) var(--lumo-space-s);
    }
    
    .category-grid {
        height: 200px !important;
    }
    
    .financial-overview-grid {
        height: 250px !important;
    }
}
`;
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    let moduleIdIndex = 0;
    function registerStyles(themeFor, styles = [], options = {}) {
      const themeId = options.moduleId || `custom-style-module-${moduleIdIndex}`;
      moduleIdIndex += 1;
      const module2 = document.createElement("dom-module");
      if (themeFor) {
        module2.setAttribute("theme-for", themeFor);
      }
      const includeStylesToTemplate = !!(styles.length && options.moduleId);
      const moduleIncludes = [].concat(options.include || []);
      if (moduleIncludes.length === 0) {
        module2.__allStyles = styles;
      } else if (!includeStylesToTemplate) {
        module2.__partialStyles = styles;
      }
      module2.innerHTML = `
    <template>
      ${moduleIncludes.map((include) => `<style include=${include}></style>`)}
      ${includeStylesToTemplate ? `<style>${styles.map((style) => style.cssText).join("\n")}</style>` : ""}
    </template>
  `;
      module2.register(themeId);
    }
    function getModuleStyles(module2) {
      return stylesFromTemplate(module2.querySelector("template")).map((styleElement) => {
        return unsafeCSS(styleElement.textContent);
      });
    }
    function getAllThemes() {
      const domModule = DomModule;
      const modules = domModule.prototype.modules;
      return Object.keys(modules).map((moduleId) => {
        const module2 = modules[moduleId];
        const themeFor = module2.getAttribute("theme-for");
        if (!module2.__allStyles) {
          module2.__allStyles = getModuleStyles(module2).concat(module2.__partialStyles || []);
        }
        return {
          themeFor,
          moduleId,
          styles: module2.__allStyles
        };
      });
    }
    if (!window.Vaadin) {
      window.Vaadin = {};
    }
    window.Vaadin.styleModules = {
      getAllThemes,
      registerStyles
    };
    if (themeRegistry && themeRegistry.length > 0) {
      themeRegistry.forEach((theme2) => {
        registerStyles(theme2.themeFor, theme2.styles, {
          moduleId: theme2.moduleId,
          include: theme2.include
        });
      });
      themeRegistry.length = 0;
    }
    const accordionHeading$1 = css$e`
  :host {
    padding: 0;
  }

  [part='content'] {
    padding: var(--lumo-space-s) 0;
  }

  :host([theme~='filled']) {
    padding-top: 0;
    padding-bottom: 0;
  }
`;
    registerStyles$1("vaadin-accordion-heading", [detailsSummary, accordionHeading$1], { moduleId: "lumo-accordion-heading" });
    /**
     * @license
     * Copyright (c) 2019 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const accordionHeading = css$e`
  :host {
    display: block;
    outline: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
  }

  :host([hidden]) {
    display: none !important;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: inherit;
    width: 100%;
    margin: 0;
    padding: 0;
    background-color: initial;
    color: inherit;
    border: initial;
    outline: none;
    font: inherit;
    text-align: inherit;
  }
`;
    /**
     * @license
     * Copyright (c) 2019 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-accordion-heading", accordionHeading, { moduleId: "vaadin-accordion-heading-styles" });
    class AccordionHeading extends ActiveMixin(DirMixin(ThemableMixin(PolymerElement))) {
      static get is() {
        return "vaadin-accordion-heading";
      }
      static get template() {
        return html`
      <button id="button" part="content" disabled$="[[disabled]]" aria-expanded$="[[__updateAriaExpanded(opened)]]">
        <span part="toggle" aria-hidden="true"></span>
        <slot></slot>
      </button>
    `;
      }
      static get properties() {
        return {
          /**
           * When true, the element is opened.
           */
          opened: {
            type: Boolean,
            reflectToAttribute: true
          }
        };
      }
      /**
       * @param {DocumentFragment} dom
       * @return {null}
       * @protected
       * @override
       */
      _attachDom(dom) {
        const root2 = this.attachShadow({ mode: "open", delegatesFocus: true });
        root2.appendChild(dom);
        return root2;
      }
      /** @protected */
      ready() {
        super.ready();
        if (!this.hasAttribute("role")) {
          this.setAttribute("role", "heading");
        }
      }
      /** @private */
      __updateAriaExpanded(opened) {
        return opened ? "true" : "false";
      }
    }
    defineCustomElement(AccordionHeading);
    const accordionPanel$1 = css$e`
  :host {
    margin: 0;
    border-bottom: solid 1px var(--lumo-contrast-10pct);
  }

  :host(:last-child) {
    border-bottom: none;
  }

  :host([theme~='filled']) {
    border-bottom: none;
  }

  :host([theme~='filled']:not(:last-child)) {
    margin-bottom: 2px;
  }
`;
    registerStyles$1("vaadin-accordion-panel", [details, accordionPanel$1], { moduleId: "lumo-accordion-panel" });
    /**
     * @license
     * Copyright (c) 2019 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const AccordionPanelMixin = (superClass) => class AccordionPanelMixinClass extends CollapsibleMixin(DelegateFocusMixin(DelegateStateMixin(superClass))) {
      static get properties() {
        return {
          /**
           * A text that is displayed in the heading, if no
           * element is assigned to the `summary` slot.
           */
          summary: {
            type: String,
            observer: "_summaryChanged"
          }
        };
      }
      static get observers() {
        return ["__updateAriaAttributes(focusElement, _contentElements)"];
      }
      static get delegateAttrs() {
        return ["theme"];
      }
      static get delegateProps() {
        return ["disabled", "opened"];
      }
      constructor() {
        super();
        this._summaryController = new SummaryController(this, "vaadin-accordion-heading");
        this._summaryController.addEventListener("slot-content-changed", (event) => {
          const { node } = event.target;
          this._setFocusElement(node);
          this.stateTarget = node;
          this._tooltipController.setTarget(node);
        });
        this._tooltipController = new TooltipController(this);
        this._tooltipController.setPosition("bottom-start");
      }
      /** @protected */
      ready() {
        super.ready();
        this.addController(this._summaryController);
        this.addController(this._tooltipController);
      }
      /**
       * Override method inherited from `DisabledMixin`
       * to not set `aria-disabled` on the host element.
       *
       * @protected
       * @override
       */
      _setAriaDisabled() {
      }
      /** @private */
      _summaryChanged(summary) {
        this._summaryController.setSummary(summary);
      }
      /** @private */
      __updateAriaAttributes(focusElement, contentElements) {
        if (focusElement && contentElements) {
          const node = contentElements[0];
          if (node) {
            node.setAttribute("role", "region");
            node.setAttribute("aria-labelledby", focusElement.id);
          }
          if (node && node.id) {
            focusElement.setAttribute("aria-controls", node.id);
          } else {
            focusElement.removeAttribute("aria-controls");
          }
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2019 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const accordionPanel = css$e`
  :host {
    display: block;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='content'] {
    display: none;
    overflow: hidden;
  }

  :host([opened]) [part='content'] {
    display: block;
    overflow: visible;
  }
`;
    /**
     * @license
     * Copyright (c) 2019 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-accordion-panel", accordionPanel, { moduleId: "vaadin-accordion-panel-styles" });
    class AccordionPanel extends AccordionPanelMixin(ThemableMixin(ControllerMixin(PolymerElement))) {
      static get is() {
        return "vaadin-accordion-panel";
      }
      static get template() {
        return html`
      <slot name="summary"></slot>

      <div part="content">
        <slot></slot>
      </div>

      <slot name="tooltip"></slot>
    `;
      }
    }
    defineCustomElement(AccordionPanel);
    /**
     * @license
     * Copyright (c) 2019 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const AccordionMixin = (superClass) => class AccordionMixinClass extends KeyboardDirectionMixin(superClass) {
      static get properties() {
        return {
          /**
           * The index of currently opened panel. First panel is opened by
           * default. Only one panel can be opened at the same time.
           * Setting null or undefined closes all the accordion panels.
           * @type {number}
           */
          opened: {
            type: Number,
            value: 0,
            notify: true,
            reflectToAttribute: true
          },
          /**
           * The list of `<vaadin-accordion-panel>` child elements.
           * It is populated from the elements passed to the light DOM,
           * and updated dynamically when adding or removing panels.
           * @type {!Array<!AccordionPanel>}
           */
          items: {
            type: Array,
            readOnly: true,
            notify: true
          }
        };
      }
      static get observers() {
        return ["_updateItems(items, opened)"];
      }
      constructor() {
        super();
        this._boundUpdateOpened = this._updateOpened.bind(this);
      }
      /**
       * Override getter from `KeyboardDirectionMixin`
       * to check if the heading element has focus.
       *
       * @return {Element | null}
       * @protected
       * @override
       */
      get focused() {
        return (this._getItems() || []).find((item2) => isElementFocused(item2.focusElement));
      }
      /**
       * @protected
       * @override
       */
      focus() {
        if (this._observer) {
          this._observer.flush();
        }
        super.focus();
      }
      /** @protected */
      ready() {
        super.ready();
        const slot = this.shadowRoot.querySelector("slot");
        this._observer = new SlotObserver(slot, (info) => {
          this._setItems(this._filterItems(Array.from(this.children)));
          this._filterItems(info.addedNodes).forEach((el) => {
            el.addEventListener("opened-changed", this._boundUpdateOpened);
          });
        });
      }
      /**
       * Override method inherited from `KeyboardDirectionMixin`
       * to use the stored list of accordion panels as items.
       *
       * @return {Element[]}
       * @protected
       * @override
       */
      _getItems() {
        return this.items;
      }
      /**
       * @param {!Array<!Element>} array
       * @return {!Array<!AccordionPanel>}
       * @protected
       */
      _filterItems(array) {
        return array.filter((el) => el instanceof customElements.get("vaadin-accordion-panel"));
      }
      /** @private */
      _updateItems(items, opened) {
        if (items) {
          const itemToOpen = items[opened];
          items.forEach((item2) => {
            item2.opened = item2 === itemToOpen;
          });
        }
      }
      /**
       * Override an event listener from `KeyboardMixin`
       * to only handle details toggle buttons events.
       *
       * @param {!KeyboardEvent} event
       * @protected
       * @override
       */
      _onKeyDown(event) {
        if (!this.items.some((item2) => item2.focusElement === event.target)) {
          return;
        }
        super._onKeyDown(event);
      }
      /** @private */
      _updateOpened(e2) {
        const target = this._filterItems(e2.composedPath())[0];
        const idx = this.items.indexOf(target);
        if (e2.detail.value) {
          if (target.disabled || idx === -1) {
            return;
          }
          this.opened = idx;
        } else if (!this.items.some((item2) => item2.opened)) {
          this.opened = null;
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2019 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class Accordion extends AccordionMixin(ThemableMixin(ElementMixin(PolymerElement))) {
      static get template() {
        return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <slot></slot>
    `;
      }
      static get is() {
        return "vaadin-accordion";
      }
    }
    defineCustomElement(Accordion);
    registerStyles$1(
      "vaadin-app-layout",
      css$e`
    [part='navbar'],
    [part='drawer'] {
      background-color: var(--lumo-base-color);
      background-clip: padding-box;
    }

    [part='navbar'] {
      min-height: var(--lumo-size-xl);
      border-bottom: 1px solid var(--lumo-contrast-10pct);
    }

    [part='navbar'][bottom] {
      border-bottom: none;
      border-top: 1px solid var(--lumo-contrast-10pct);
    }

    [part='drawer'] {
      border-inline-end: 1px solid var(--lumo-contrast-10pct);
    }

    :host([overlay]) [part='drawer'] {
      border-inline-end: none;
      box-shadow: var(--lumo-box-shadow-s);
    }

    :host([primary-section='navbar']) [part='navbar'] {
      border: none;
      background-image: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
    }

    :host([primary-section='drawer']:not([overlay])) [part='drawer'] {
      background-image: linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));
    }

    [part='backdrop'] {
      background-color: var(--lumo-shade-20pct);
      opacity: 1;
    }

    [part] ::slotted(h2),
    [part] ::slotted(h3),
    [part] ::slotted(h4) {
      margin-top: var(--lumo-space-xs) !important;
      margin-bottom: var(--lumo-space-xs) !important;
    }
  `,
      { moduleId: "lumo-app-layout" }
    );
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    function _detectIosNavbar() {
      if (isIOS) {
        const innerHeight = window.innerHeight;
        const innerWidth = window.innerWidth;
        const landscape = innerWidth > innerHeight;
        const clientHeight = document.documentElement.clientHeight;
        if (landscape && clientHeight > innerHeight) {
          document.documentElement.style.setProperty("--vaadin-viewport-offset-bottom", `${clientHeight - innerHeight}px`);
        } else {
          document.documentElement.style.setProperty("--vaadin-viewport-offset-bottom", "");
        }
      }
    }
    _detectIosNavbar();
    window.addEventListener("resize", _detectIosNavbar);
    const template$7 = document.createElement("template");
    template$7.innerHTML = `
  <style>
    /* Use units so that the values can be used in calc() */
    html {
      --safe-area-inset-top: env(safe-area-inset-top, 0px);
      --safe-area-inset-right: env(safe-area-inset-right, 0px);
      --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
      --safe-area-inset-left: env(safe-area-inset-left, 0px);
    }
  </style>
`;
    document.head.appendChild(template$7.content);
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class AppLayout extends ElementMixin(ThemableMixin(ControllerMixin(PolymerElement))) {
      static get template() {
        return html`
      <style>
        :host {
          display: block;
          box-sizing: border-box;
          height: 100%;
          --vaadin-app-layout-transition: 200ms;
          transition: padding var(--vaadin-app-layout-transition);
          --_vaadin-app-layout-drawer-width: var(--vaadin-app-layout-drawer-width, 16em);
          --vaadin-app-layout-touch-optimized: false;
          --vaadin-app-layout-navbar-offset-top: var(--_vaadin-app-layout-navbar-offset-size);
          --vaadin-app-layout-navbar-offset-bottom: var(--_vaadin-app-layout-navbar-offset-size-bottom);
          padding-block: var(--vaadin-app-layout-navbar-offset-top) var(--vaadin-app-layout-navbar-offset-bottom);
          padding-inline-start: var(--vaadin-app-layout-navbar-offset-left);
        }

        :host([hidden]),
        [hidden] {
          display: none !important;
        }

        :host([no-anim]) {
          --vaadin-app-layout-transition: none !important;
        }

        :host([drawer-opened]) {
          --vaadin-app-layout-drawer-offset-left: var(--_vaadin-app-layout-drawer-offset-size);
        }

        :host([overlay]) {
          --vaadin-app-layout-drawer-offset-left: 0;
          --vaadin-app-layout-navbar-offset-left: 0;
        }

        :host(:not([no-scroll])) [content] {
          overflow: auto;
        }

        [content] {
          height: 100%;
        }

        @media (pointer: coarse) and (max-width: 800px) and (min-height: 500px) {
          :host {
            --vaadin-app-layout-touch-optimized: true;
          }
        }

        [part='navbar'] {
          position: fixed;
          display: flex;
          align-items: center;
          top: 0;
          inset-inline: 0;
          transition: inset-inline-start var(--vaadin-app-layout-transition);
          padding-top: var(--safe-area-inset-top);
          padding-left: var(--safe-area-inset-left);
          padding-right: var(--safe-area-inset-right);
          z-index: 1;
        }

        :host([primary-section='drawer'][drawer-opened]:not([overlay])) [part='navbar'] {
          inset-inline-start: var(--vaadin-app-layout-drawer-offset-left, 0);
        }

        :host([primary-section='drawer']) [part='drawer'] {
          top: 0;
        }

        [part='navbar'][bottom] {
          top: auto;
          bottom: 0;
          padding-bottom: var(--safe-area-inset-bottom);
        }

        [part='drawer'] {
          overflow: auto;
          position: fixed;
          top: var(--vaadin-app-layout-navbar-offset-top, 0);
          bottom: var(--vaadin-app-layout-navbar-offset-bottom, var(--vaadin-viewport-offset-bottom, 0));
          inset-inline: var(--vaadin-app-layout-navbar-offset-left, 0) auto;
          transition: transform var(--vaadin-app-layout-transition), visibility var(--vaadin-app-layout-transition);
          transform: translateX(-100%);
          max-width: 90%;
          width: var(--_vaadin-app-layout-drawer-width);
          box-sizing: border-box;
          padding: var(--safe-area-inset-top) 0 var(--safe-area-inset-bottom) var(--safe-area-inset-left);
          outline: none;
          /* The drawer should be inaccessible by the tabbing navigation when it is closed. */
          visibility: hidden;
          display: flex;
          flex-direction: column;
        }

        :host([drawer-opened]) [part='drawer'] {
          /* The drawer should be accessible by the tabbing navigation when it is opened. */
          visibility: visible;
          transform: translateX(0%);
          touch-action: manipulation;
        }

        [part='backdrop'] {
          background-color: #000;
          opacity: 0.3;
        }

        :host(:not([drawer-opened])) [part='backdrop'] {
          opacity: 0;
        }

        :host([overlay]) [part='backdrop'] {
          position: fixed;
          inset: 0;
          pointer-events: none;
          transition: opacity var(--vaadin-app-layout-transition);
          -webkit-tap-highlight-color: transparent;
        }

        :host([overlay]) [part='drawer'] {
          top: 0;
          bottom: 0;
        }

        :host([overlay]) [part='drawer'],
        :host([overlay]) [part='backdrop'] {
          z-index: 2;
        }

        :host([drawer-opened][overlay]) [part='backdrop'] {
          pointer-events: auto;
          touch-action: manipulation;
        }

        :host([dir='rtl']) [part='drawer'] {
          transform: translateX(100%);
        }

        :host([dir='rtl'][drawer-opened]) [part='drawer'] {
          transform: translateX(0%);
        }

        :host([drawer-opened]:not([overlay])) {
          padding-inline-start: var(--vaadin-app-layout-drawer-offset-left);
        }

        @media (max-width: 800px), (max-height: 600px) {
          :host {
            --vaadin-app-layout-drawer-overlay: true;
            --_vaadin-app-layout-drawer-width: var(--vaadin-app-layout-drawer-width, 20em);
          }
        }

        /* If a vaadin-scroller is used in the drawer, allow it to take all remaining space and contain scrolling */
        [part='drawer'] ::slotted(vaadin-scroller) {
          flex: 1;
          overscroll-behavior: contain;
        }
      </style>
      <div part="navbar" id="navbarTop">
        <slot name="navbar" on-slotchange="_updateTouchOptimizedMode"></slot>
      </div>
      <div part="backdrop" on-click="_onBackdropClick" on-touchend="_onBackdropTouchend"></div>
      <div part="drawer" id="drawer">
        <slot name="drawer" id="drawerSlot" on-slotchange="_updateDrawerSize"></slot>
      </div>
      <div content>
        <slot></slot>
      </div>
      <div part="navbar" id="navbarBottom" bottom hidden>
        <slot name="navbar-bottom"></slot>
      </div>
      <div hidden>
        <slot id="touchSlot" name="navbar touch-optimized" on-slotchange="_updateTouchOptimizedMode"></slot>
      </div>
    `;
      }
      static get is() {
        return "vaadin-app-layout";
      }
      static get properties() {
        return {
          /**
           * The object used to localize this component.
           * To change the default localization, replace the entire
           * `i18n` object with a custom one.
           *
           * To update individual properties, extend the existing i18n object as follows:
           * ```js
           * appLayout.i18n = {
           *   ...appLayout.i18n,
           *   drawer: 'Drawer'
           * }
           * ```
           *
           * The object has the following structure and default values:
           * ```
           * {
           *   drawer: 'Drawer'
           * }
           * ```
           *
           * @type {AppLayoutI18n}
           * @default {English/US}
           */
          i18n: {
            type: Object,
            observer: "__i18nChanged",
            value: () => {
              return {
                drawer: "Drawer"
              };
            }
          },
          /**
           * Defines whether navbar or drawer will come first visually.
           * - By default (`primary-section="navbar"`), the navbar takes the full available width and moves the drawer down.
           * - If `primary-section="drawer"` is set, then the drawer will move the navbar, taking the full available height.
           * @attr {navbar|drawer} primary-section
           * @type {!PrimarySection}
           */
          primarySection: {
            type: String,
            value: "navbar",
            notify: true,
            reflectToAttribute: true,
            observer: "__primarySectionChanged"
          },
          /**
           * Controls whether the drawer is opened (visible) or not.
           * Its default value depends on the viewport:
           * - `true`, for desktop size views
           * - `false`, for mobile size views
           * @attr {boolean} drawer-opened
           * @type {boolean}
           */
          drawerOpened: {
            type: Boolean,
            notify: true,
            value: true,
            reflectToAttribute: true,
            observer: "__drawerOpenedChanged"
          },
          /**
           * Drawer is an overlay on top of the content
           * Controlled via CSS using `--vaadin-app-layout-drawer-overlay: true|false`;
           * @type {boolean}
           */
          overlay: {
            type: Boolean,
            notify: true,
            readOnly: true,
            value: false,
            reflectToAttribute: true
          },
          /**
           * A global event that causes the drawer to close (be hidden) when it is in overlay mode.
           * - The default is `vaadin-router-location-changed` dispatched by Vaadin Router
           *
           * @attr {string} close-drawer-on
           * @type {string}
           */
          closeDrawerOn: {
            type: String,
            value: "vaadin-router-location-changed",
            observer: "_closeDrawerOnChanged"
          }
        };
      }
      /**
       * Helper static method that dispatches a `close-overlay-drawer` event
       */
      static dispatchCloseOverlayDrawerEvent() {
        window.dispatchEvent(new CustomEvent("close-overlay-drawer"));
      }
      constructor() {
        super();
        this.__boundResizeListener = this._resize.bind(this);
        this.__drawerToggleClickListener = this._drawerToggleClick.bind(this);
        this.__onDrawerKeyDown = this.__onDrawerKeyDown.bind(this);
        this.__closeOverlayDrawerListener = this.__closeOverlayDrawer.bind(this);
        this.__trapFocusInDrawer = this.__trapFocusInDrawer.bind(this);
        this.__releaseFocusFromDrawer = this.__releaseFocusFromDrawer.bind(this);
        this.__ariaModalController = new AriaModalController(this, () => [
          ...this.querySelectorAll('vaadin-drawer-toggle, [slot="drawer"]')
        ]);
        this.__focusTrapController = new FocusTrapController(this);
      }
      /** @protected */
      connectedCallback() {
        super.connectedCallback();
        this._blockAnimationUntilAfterNextRender();
        window.addEventListener("resize", this.__boundResizeListener);
        this.addEventListener("drawer-toggle-click", this.__drawerToggleClickListener);
        beforeNextRender(this, this._afterFirstRender);
        this._updateTouchOptimizedMode();
        this._updateDrawerSize();
        this._updateOverlayMode();
        this._navbarSizeObserver = new ResizeObserver(() => {
          requestAnimationFrame(() => {
            if (this.__isDrawerAnimating) {
              this.__updateOffsetSizePending = true;
            } else {
              this._updateOffsetSize();
            }
          });
        });
        this._navbarSizeObserver.observe(this.$.navbarTop);
        this._navbarSizeObserver.observe(this.$.navbarBottom);
        window.addEventListener("close-overlay-drawer", this.__closeOverlayDrawerListener);
        window.addEventListener("keydown", this.__onDrawerKeyDown);
      }
      /** @protected */
      ready() {
        super.ready();
        this.addController(this.__focusTrapController);
        this.__setAriaExpanded();
        this.$.drawer.addEventListener("transitionstart", () => {
          this.__isDrawerAnimating = true;
        });
        this.$.drawer.addEventListener("transitionend", () => {
          if (this.__updateOffsetSizePending) {
            this.__updateOffsetSizePending = false;
            this._updateOffsetSize();
          }
          requestAnimationFrame(() => {
            this.__isDrawerAnimating = false;
          });
        });
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback();
        window.removeEventListener("resize", this.__boundResizeListener);
        this.removeEventListener("drawer-toggle-click", this.__drawerToggleClickListener);
        window.removeEventListener("close-overlay-drawer", this.__drawerToggleClickListener);
        window.removeEventListener("keydown", this.__onDrawerKeyDown);
      }
      /**
       * A callback for the `primarySection` property observer.
       *
       * Ensures the property is set to its default value `navbar`
       * whenever the new value is not one of the valid values: `navbar`, `drawer`.
       *
       * @param {string} value
       * @private
       */
      __primarySectionChanged(value) {
        const isValid2 = ["navbar", "drawer"].includes(value);
        if (!isValid2) {
          this.set("primarySection", "navbar");
        }
      }
      /**
       * A callback for the `drawerOpened` property observer.
       *
       * When the drawer opens, the method ensures the drawer has a proper height and sets focus on it.
       * As long as the drawer is open, the focus is trapped within the drawer.
       *
       * When the drawer closes, the method releases focus from the drawer, setting focus on the drawer toggle.
       *
       * @param {boolean} drawerOpened
       * @param {boolean} oldDrawerOpened
       * @private
       */
      __drawerOpenedChanged(drawerOpened, oldDrawerOpened) {
        if (this.overlay) {
          if (drawerOpened) {
            this.__trapFocusInDrawer();
          } else if (oldDrawerOpened) {
            this.__releaseFocusFromDrawer();
          }
        }
        this.__setAriaExpanded();
      }
      /**
       * A callback for the `i18n` property observer.
       *
       * The method ensures the drawer has ARIA attributes updated
       * once the `i18n` property changes.
       *
       * @private
       */
      __i18nChanged() {
        this.__updateDrawerAriaAttributes();
      }
      /** @protected */
      _afterFirstRender() {
        this._blockAnimationUntilAfterNextRender();
        this._updateOffsetSize();
      }
      /** @private */
      _drawerToggleClick(e2) {
        e2.stopPropagation();
        this.drawerOpened = !this.drawerOpened;
      }
      /** @private */
      __closeOverlayDrawer() {
        if (this.overlay) {
          this.drawerOpened = false;
        }
      }
      /** @private */
      __setAriaExpanded() {
        const toggle = this.querySelector("vaadin-drawer-toggle");
        if (toggle) {
          toggle.setAttribute("aria-expanded", this.drawerOpened);
        }
      }
      /** @protected */
      _updateDrawerSize() {
        const childCount = this.querySelectorAll("[slot=drawer]").length;
        const drawer = this.$.drawer;
        if (childCount === 0) {
          drawer.setAttribute("hidden", "");
          this.style.setProperty("--_vaadin-app-layout-drawer-width", 0);
        } else {
          drawer.removeAttribute("hidden");
          this.style.removeProperty("--_vaadin-app-layout-drawer-width");
        }
        this._updateOffsetSize();
      }
      /** @private */
      _resize() {
        this._blockAnimationUntilAfterNextRender();
        this._updateTouchOptimizedMode();
        this._updateOverlayMode();
      }
      /** @protected */
      _updateOffsetSize() {
        const navbar = this.$.navbarTop;
        const navbarRect = navbar.getBoundingClientRect();
        const navbarBottom = this.$.navbarBottom;
        const navbarBottomRect = navbarBottom.getBoundingClientRect();
        const drawer = this.$.drawer;
        const drawerRect = drawer.getBoundingClientRect();
        this.style.setProperty("--_vaadin-app-layout-navbar-offset-size", `${navbarRect.height}px`);
        this.style.setProperty("--_vaadin-app-layout-navbar-offset-size-bottom", `${navbarBottomRect.height}px`);
        this.style.setProperty("--_vaadin-app-layout-drawer-offset-size", `${drawerRect.width}px`);
      }
      /** @protected */
      _updateOverlayMode() {
        const overlay2 = this._getCustomPropertyValue("--vaadin-app-layout-drawer-overlay") === "true";
        if (!this.overlay && overlay2) {
          this._drawerStateSaved = this.drawerOpened;
          this.drawerOpened = false;
        }
        this._setOverlay(overlay2);
        if (!this.overlay && this._drawerStateSaved) {
          this.drawerOpened = this._drawerStateSaved;
          this._drawerStateSaved = null;
        }
        this.__updateDrawerAriaAttributes();
      }
      /**
       * Updates ARIA attributes on the drawer depending on the drawer mode.
       *
       * - In the overlay mode, the method marks the drawer with ARIA attributes as a dialog
       * labelled with the `i18n.drawer` property.
       * - In the normal mode, the method removes the ARIA attributes that has been set for the overlay mode.
       *
       * @private
       */
      __updateDrawerAriaAttributes() {
        const drawer = this.$.drawer;
        if (this.overlay) {
          drawer.setAttribute("role", "dialog");
          drawer.setAttribute("aria-modal", "true");
          drawer.setAttribute("aria-label", this.i18n.drawer);
        } else {
          drawer.removeAttribute("role");
          drawer.removeAttribute("aria-modal");
          drawer.removeAttribute("aria-label");
        }
      }
      /**
       * Returns a promise that resolves when the drawer opening/closing CSS transition ends.
       *
       * The method relies on the `--vaadin-app-layout-transition` CSS variable to detect whether
       * the drawer has a CSS transition that needs to be awaited. If the CSS variable equals `none`,
       * the promise resolves immediately.
       *
       * @return {Promise}
       * @private
       */
      __drawerTransitionComplete() {
        return new Promise((resolve) => {
          if (this._getCustomPropertyValue("--vaadin-app-layout-transition") === "none") {
            resolve();
            return;
          }
          this.$.drawer.addEventListener("transitionend", resolve, { once: true });
        });
      }
      /** @private */
      async __trapFocusInDrawer() {
        await this.__drawerTransitionComplete();
        if (!this.drawerOpened) {
          return;
        }
        this.$.drawer.setAttribute("tabindex", "0");
        this.__ariaModalController.showModal();
        this.__focusTrapController.trapFocus(this.$.drawer);
      }
      /** @private */
      async __releaseFocusFromDrawer() {
        await this.__drawerTransitionComplete();
        if (this.drawerOpened) {
          return;
        }
        this.__ariaModalController.close();
        this.__focusTrapController.releaseFocus();
        this.$.drawer.removeAttribute("tabindex");
        const toggle = this.querySelector("vaadin-drawer-toggle");
        if (toggle) {
          toggle.focus();
          toggle.setAttribute("focus-ring", "focus");
        }
      }
      /**
       * Closes the drawer on Escape press if it has been opened in the overlay mode.
       *
       * @param {KeyboardEvent} event
       * @private
       */
      __onDrawerKeyDown(event) {
        if (event.key === "Escape" && this.overlay) {
          this.drawerOpened = false;
        }
      }
      /** @private */
      _closeDrawerOnChanged(closeDrawerOn, oldCloseDrawerOn) {
        if (oldCloseDrawerOn) {
          window.removeEventListener(oldCloseDrawerOn, this.__closeOverlayDrawerListener);
        }
        if (closeDrawerOn) {
          window.addEventListener(closeDrawerOn, this.__closeOverlayDrawerListener);
        }
      }
      /** @private */
      _onBackdropClick() {
        this._close();
      }
      /** @private */
      _onBackdropTouchend(event) {
        event.preventDefault();
        this._close();
      }
      /** @protected */
      _close() {
        this.drawerOpened = false;
      }
      /** @private */
      _getCustomPropertyValue(customProperty) {
        const customPropertyValue = getComputedStyle(this).getPropertyValue(customProperty);
        return (customPropertyValue || "").trim().toLowerCase();
      }
      /** @protected */
      _updateTouchOptimizedMode() {
        const touchOptimized = this._getCustomPropertyValue("--vaadin-app-layout-touch-optimized") === "true";
        const navbarItems = this.querySelectorAll('[slot*="navbar"]');
        if (navbarItems.length > 0) {
          Array.from(navbarItems).forEach((navbar) => {
            if (navbar.getAttribute("slot").indexOf("touch-optimized") > -1) {
              navbar.__touchOptimized = true;
            }
            if (touchOptimized && navbar.__touchOptimized) {
              navbar.setAttribute("slot", "navbar-bottom");
            } else {
              navbar.setAttribute("slot", "navbar");
            }
          });
        }
        if (this.$.navbarTop.querySelector("[name=navbar]").assignedNodes().length === 0) {
          this.$.navbarTop.setAttribute("hidden", "");
        } else {
          this.$.navbarTop.removeAttribute("hidden");
        }
        if (this.$.navbarBottom.querySelector("[name=navbar-bottom]").assignedNodes().length === 0) {
          this.$.navbarBottom.setAttribute("hidden", "");
        } else {
          this.$.navbarBottom.removeAttribute("hidden");
        }
        this._updateOffsetSize();
      }
      /** @protected */
      _blockAnimationUntilAfterNextRender() {
        this.setAttribute("no-anim", "");
        afterNextRender(this, () => {
          this.removeAttribute("no-anim");
        });
      }
      /**
       * App Layout listens to `close-overlay-drawer` on the window level.
       * A custom event can be dispatched and the App Layout will close the drawer in overlay.
       *
       * That can be used, for instance, when a navigation occurs when user clicks in a menu item inside the drawer.
       *
       * See `dispatchCloseOverlayDrawerEvent()` helper method.
       *
       * @event close-overlay-drawer
       */
    }
    defineCustomElement(AppLayout);
    function disableOnClickListener({ currentTarget: button2 }) {
      if (button2.hasAttribute("disableOnClick")) {
        button2.disabled = true;
      }
    }
    window.Vaadin.Flow.button = {
      initDisableOnClick: (button2) => {
        if (!button2.__hasDisableOnClickListener) {
          button2.addEventListener("click", disableOnClickListener);
          button2.__hasDisableOnClickListener = true;
        }
      }
    };
    const drawerToggle$1 = css$e`
  :host {
    width: var(--lumo-size-l);
    height: var(--lumo-size-l);
    min-width: auto;
    margin: 0 var(--lumo-space-s);
    padding: 0;
    background: transparent;
  }

  [part='icon'],
  [part='icon']::after,
  [part='icon']::before {
    position: inherit;
    height: auto;
    width: auto;
    background: transparent;
    top: auto;
  }

  [part='icon']::before {
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-m);
    content: var(--lumo-icons-menu);
  }

  :host([slot~='navbar']) {
    color: var(--lumo-secondary-text-color);
  }
`;
    registerStyles$1("vaadin-drawer-toggle", [button, drawerToggle$1], { moduleId: "lumo-drawer-toggle" });
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const drawerToggle = css$e`
  :host {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: default;
    position: relative;
    outline: none;
    height: 24px;
    width: 24px;
    padding: 4px;
  }

  [part='icon'],
  [part='icon']::after,
  [part='icon']::before {
    position: absolute;
    top: 8px;
    height: 3px;
    width: 24px;
    background-color: #000;
  }

  [part='icon']::after,
  [part='icon']::before {
    content: '';
  }

  [part='icon']::after {
    top: 6px;
  }

  [part='icon']::before {
    top: 12px;
  }
`;
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-drawer-toggle", [buttonStyles, drawerToggle], { moduleId: "vaadin-drawer-toggle-styles" });
    class DrawerToggle extends ButtonMixin(DirMixin(ThemableMixin(PolymerElement))) {
      static get template() {
        return html`
      <slot id="slot">
        <div part="icon"></div>
      </slot>
      <div part="icon" hidden$="[[!_showFallbackIcon]]"></div>
    `;
      }
      static get is() {
        return "vaadin-drawer-toggle";
      }
      static get properties() {
        return {
          ariaLabel: {
            type: String,
            value: "Toggle navigation panel",
            reflectToAttribute: true
          },
          /** @private */
          _showFallbackIcon: {
            type: Boolean,
            value: false
          }
        };
      }
      constructor() {
        super();
        this.addEventListener("click", () => {
          this.dispatchEvent(new CustomEvent("drawer-toggle-click", { bubbles: true, composed: true }));
        });
      }
      /** @protected */
      ready() {
        super.ready();
        this._toggleFallbackIcon();
        this.$.slot.addEventListener("slotchange", () => {
          this._toggleFallbackIcon();
        });
      }
      /** @private */
      _toggleFallbackIcon() {
        const nodes = this.$.slot.assignedNodes();
        this._showFallbackIcon = nodes.length > 0 && nodes.every((node) => isEmptyTextNode(node));
      }
    }
    defineCustomElement(DrawerToggle);
    const tooltipOverlay = css$e`
  :host {
    --vaadin-tooltip-offset-top: var(--lumo-space-xs);
    --vaadin-tooltip-offset-bottom: var(--lumo-space-xs);
    --vaadin-tooltip-offset-start: var(--lumo-space-xs);
    --vaadin-tooltip-offset-end: var(--lumo-space-xs);
  }

  [part='overlay'] {
    background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-s);
  }

  [part='content'] {
    padding: var(--lumo-space-xs) var(--lumo-space-s);
  }
`;
    registerStyles$1("vaadin-tooltip-overlay", [overlay, tooltipOverlay], { moduleId: "lumo-tooltip-overlay" });
    /**
     * @license
     * Copyright (c) 2022 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const TooltipOverlayMixin = (superClass) => class TooltipOverlayMixinClass extends PositionMixin(OverlayMixin(superClass)) {
      static get properties() {
        return {
          position: {
            type: String,
            reflectToAttribute: true
          }
        };
      }
      requestContentUpdate() {
        super.requestContentUpdate();
        this.toggleAttribute("hidden", this.textContent.trim() === "");
        if (this.positionTarget && this.owner) {
          const style = getComputedStyle(this.owner);
          ["top", "bottom", "start", "end"].forEach((prop) => {
            this.style.setProperty(
              `--vaadin-tooltip-offset-${prop}`,
              style.getPropertyValue(`--vaadin-tooltip-offset-${prop}`)
            );
          });
        }
      }
      /**
       * @protected
       * @override
       */
      _updatePosition() {
        super._updatePosition();
        if (!this.positionTarget) {
          return;
        }
        if (this.position === "bottom" || this.position === "top") {
          const targetRect = this.positionTarget.getBoundingClientRect();
          const overlayRect = this.$.overlay.getBoundingClientRect();
          const offset2 = targetRect.width / 2 - overlayRect.width / 2;
          if (this.style.left) {
            const left = overlayRect.left + offset2;
            if (left > 0) {
              this.style.left = `${left}px`;
            }
          }
          if (this.style.right) {
            const right = parseFloat(this.style.right) + offset2;
            if (right > 0) {
              this.style.right = `${right}px`;
            }
          }
        }
        if (this.position === "start" || this.position === "end") {
          const targetRect = this.positionTarget.getBoundingClientRect();
          const overlayRect = this.$.overlay.getBoundingClientRect();
          const offset2 = targetRect.height / 2 - overlayRect.height / 2;
          this.style.top = `${overlayRect.top + offset2}px`;
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2022 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const tooltipOverlayStyles = css$e`
  :host {
    z-index: 1100;
  }

  [part='overlay'] {
    max-width: 40ch;
  }

  :host([position^='top'][top-aligned]) [part='overlay'],
  :host([position^='bottom'][top-aligned]) [part='overlay'] {
    margin-top: var(--vaadin-tooltip-offset-top, 0);
  }

  :host([position^='top'][bottom-aligned]) [part='overlay'],
  :host([position^='bottom'][bottom-aligned]) [part='overlay'] {
    margin-bottom: var(--vaadin-tooltip-offset-bottom, 0);
  }

  :host([position^='start'][start-aligned]) [part='overlay'],
  :host([position^='end'][start-aligned]) [part='overlay'] {
    margin-inline-start: var(--vaadin-tooltip-offset-start, 0);
  }

  :host([position^='start'][end-aligned]) [part='overlay'],
  :host([position^='end'][end-aligned]) [part='overlay'] {
    margin-inline-end: var(--vaadin-tooltip-offset-end, 0);
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 1px dashed;
    }
  }
`;
    /**
     * @license
     * Copyright (c) 2022 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-tooltip-overlay", [overlayStyles, tooltipOverlayStyles], {
      moduleId: "vaadin-tooltip-overlay-styles"
    });
    class TooltipOverlay extends TooltipOverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
      static get is() {
        return "vaadin-tooltip-overlay";
      }
      static get template() {
        return html`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
      }
      /** @protected */
      ready() {
        super.ready();
        this.owner = this.__dataHost;
        this.owner._overlayElement = this;
      }
    }
    defineCustomElement(TooltipOverlay);
    /**
     * @license
     * Copyright (c) 2022 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const DEFAULT_DELAY = 500;
    let defaultFocusDelay$1 = DEFAULT_DELAY;
    let defaultHoverDelay$1 = DEFAULT_DELAY;
    let defaultHideDelay$1 = DEFAULT_DELAY;
    const closing = /* @__PURE__ */ new Set();
    let warmedUp = false;
    let warmUpTimeout = null;
    let cooldownTimeout = null;
    class TooltipStateController {
      constructor(host) {
        this.host = host;
      }
      /** @private */
      get openedProp() {
        return this.host.manual ? "opened" : "_autoOpened";
      }
      /** @private */
      get focusDelay() {
        const tooltip = this.host;
        return tooltip.focusDelay != null && tooltip.focusDelay > 0 ? tooltip.focusDelay : defaultFocusDelay$1;
      }
      /** @private */
      get hoverDelay() {
        const tooltip = this.host;
        return tooltip.hoverDelay != null && tooltip.hoverDelay > 0 ? tooltip.hoverDelay : defaultHoverDelay$1;
      }
      /** @private */
      get hideDelay() {
        const tooltip = this.host;
        return tooltip.hideDelay != null && tooltip.hideDelay > 0 ? tooltip.hideDelay : defaultHideDelay$1;
      }
      /**
       * Whether closing is currently in progress.
       * @return {boolean}
       */
      get isClosing() {
        return closing.has(this.host);
      }
      /**
       * Schedule opening the tooltip.
       * @param {Object} options
       */
      open(options = { immediate: false }) {
        const { immediate, hover, focus } = options;
        const isHover = hover && this.hoverDelay > 0;
        const isFocus = focus && this.focusDelay > 0;
        if (!immediate && (isHover || isFocus) && !this.__closeTimeout) {
          this.__warmupTooltip(isFocus);
        } else {
          this.__showTooltip();
        }
      }
      /**
       * Schedule closing the tooltip.
       * @param {boolean} immediate
       */
      close(immediate) {
        if (!immediate && this.hideDelay > 0) {
          this.__scheduleClose();
        } else {
          this.__abortClose();
          this._setOpened(false);
        }
        this.__abortWarmUp();
        if (warmedUp) {
          this.__abortCooldown();
          this.__scheduleCooldown();
        }
      }
      /** @private */
      _isOpened() {
        return this.host[this.openedProp];
      }
      /** @private */
      _setOpened(opened) {
        this.host[this.openedProp] = opened;
      }
      /** @private */
      __flushClosingTooltips() {
        closing.forEach((tooltip) => {
          tooltip._stateController.close(true);
          closing.delete(tooltip);
        });
      }
      /** @private */
      __showTooltip() {
        this.__abortClose();
        this.__flushClosingTooltips();
        this._setOpened(true);
        warmedUp = true;
        this.__abortWarmUp();
        this.__abortCooldown();
      }
      /** @private */
      __warmupTooltip(isFocus) {
        if (!this._isOpened()) {
          if (!warmedUp) {
            this.__scheduleWarmUp(isFocus);
          } else {
            this.__showTooltip();
          }
        }
      }
      /** @private */
      __abortClose() {
        if (this.__closeTimeout) {
          clearTimeout(this.__closeTimeout);
          this.__closeTimeout = null;
        }
      }
      /** @private */
      __abortCooldown() {
        if (cooldownTimeout) {
          clearTimeout(cooldownTimeout);
          cooldownTimeout = null;
        }
      }
      /** @private */
      __abortWarmUp() {
        if (warmUpTimeout) {
          clearTimeout(warmUpTimeout);
          warmUpTimeout = null;
        }
      }
      /** @private */
      __scheduleClose() {
        if (this._isOpened()) {
          closing.add(this.host);
          this.__closeTimeout = setTimeout(() => {
            closing.delete(this.host);
            this.__closeTimeout = null;
            this._setOpened(false);
          }, this.hideDelay);
        }
      }
      /** @private */
      __scheduleCooldown() {
        cooldownTimeout = setTimeout(() => {
          cooldownTimeout = null;
          warmedUp = false;
        }, this.hideDelay);
      }
      /** @private */
      __scheduleWarmUp(isFocus) {
        const delay = isFocus ? this.focusDelay : this.hoverDelay;
        warmUpTimeout = setTimeout(() => {
          warmUpTimeout = null;
          warmedUp = true;
          this.__showTooltip();
        }, delay);
      }
    }
    const TooltipMixin = (superClass) => class TooltipMixinClass extends OverlayClassMixin(superClass) {
      static get properties() {
        return {
          /**
           * Element used to link with the `aria-describedby`
           * attribute. Supports array of multiple elements.
           * When not set, defaults to `target`.
           */
          ariaTarget: {
            type: Object
          },
          /**
           * Object with properties passed to `generator` and
           * `shouldShow` functions for generating tooltip text
           * or detecting whether to show the tooltip or not.
           */
          context: {
            type: Object,
            value: () => {
              return {};
            }
          },
          /**
           * The delay in milliseconds before the tooltip
           * is opened on keyboard focus, when not in manual mode.
           * @attr {number} focus-delay
           */
          focusDelay: {
            type: Number
          },
          /**
           * The id of the element used as a tooltip trigger.
           * The element should be in the DOM by the time when
           * the attribute is set, otherwise a warning is shown.
           */
          for: {
            type: String,
            observer: "__forChanged"
          },
          /**
           * Function used to generate the tooltip content.
           * When provided, it overrides the `text` property.
           * Use the `context` property to provide argument
           * that can be passed to the generator function.
           */
          generator: {
            type: Object
          },
          /**
           * The delay in milliseconds before the tooltip
           * is closed on losing hover, when not in manual mode.
           * On blur, the tooltip is closed immediately.
           * @attr {number} hide-delay
           */
          hideDelay: {
            type: Number
          },
          /**
           * The delay in milliseconds before the tooltip
           * is opened on hover, when not in manual mode.
           * @attr {number} hover-delay
           */
          hoverDelay: {
            type: Number
          },
          /**
           * When true, the tooltip is controlled programmatically
           * instead of reacting to focus and mouse events.
           */
          manual: {
            type: Boolean,
            value: false,
            sync: true
          },
          /**
           * When true, the tooltip is opened programmatically.
           * Only works if `manual` is set to `true`.
           */
          opened: {
            type: Boolean,
            value: false,
            sync: true
          },
          /**
           * Position of the tooltip with respect to its target.
           * Supported values: `top-start`, `top`, `top-end`,
           * `bottom-start`, `bottom`, `bottom-end`, `start-top`,
           * `start`, `start-bottom`, `end-top`, `end`, `end-bottom`.
           */
          position: {
            type: String
          },
          /**
           * Function used to detect whether to show the tooltip based on a condition,
           * called every time the tooltip is about to be shown on hover and focus.
           * The function takes two parameters: `target` and `context`, which contain
           * values of the corresponding tooltip properties at the time of calling.
           * The tooltip is only shown when the function invocation returns `true`.
           */
          shouldShow: {
            type: Object,
            value: () => {
              return (_target, _context) => true;
            }
          },
          /**
           * Reference to the element used as a tooltip trigger.
           * The target must be placed in the same shadow scope.
           * Defaults to an element referenced with `for`.
           */
          target: {
            type: Object,
            observer: "__targetChanged"
          },
          /**
           * String used as a tooltip content.
           */
          text: {
            type: String,
            observer: "__textChanged"
          },
          /**
           * Set to true when the overlay is opened using auto-added
           * event listeners: mouseenter and focusin (keyboard only).
           * @protected
           */
          _autoOpened: {
            type: Boolean,
            observer: "__autoOpenedChanged",
            sync: true
          },
          /**
           * Element used to link with the `aria-describedby`
           * attribute. When not set, defaults to `target`.
           * @protected
           */
          _effectiveAriaTarget: {
            type: Object,
            computed: "__computeAriaTarget(ariaTarget, target)",
            observer: "__effectiveAriaTargetChanged"
          },
          /** @private */
          __effectivePosition: {
            type: String,
            computed: "__computePosition(position, _position)"
          },
          /** @private */
          __isTargetHidden: {
            type: Boolean,
            value: false
          },
          /** @private */
          _isConnected: {
            type: Boolean,
            sync: true
          },
          /**
           * Default value used when `position` property is not set.
           * @protected
           */
          _position: {
            type: String,
            value: "bottom"
          },
          /** @private */
          _srLabel: {
            type: Object
          },
          /** @private */
          _overlayContent: {
            type: String
          }
        };
      }
      static get observers() {
        return [
          "__generatorChanged(_overlayElement, generator, context)",
          "__updateSrLabelText(_srLabel, _overlayContent)"
        ];
      }
      /**
       * Sets the default focus delay to be used by all tooltip instances,
       * except for those that have focus delay configured using property.
       *
       * @param {number} delay
       */
      static setDefaultFocusDelay(focusDelay) {
        defaultFocusDelay$1 = focusDelay != null && focusDelay >= 0 ? focusDelay : DEFAULT_DELAY;
      }
      /**
       * Sets the default hide delay to be used by all tooltip instances,
       * except for those that have hide delay configured using property.
       *
       * @param {number} hideDelay
       */
      static setDefaultHideDelay(hideDelay) {
        defaultHideDelay$1 = hideDelay != null && hideDelay >= 0 ? hideDelay : DEFAULT_DELAY;
      }
      /**
       * Sets the default hover delay to be used by all tooltip instances,
       * except for those that have hover delay configured using property.
       *
       * @param {number} delay
       */
      static setDefaultHoverDelay(hoverDelay) {
        defaultHoverDelay$1 = hoverDelay != null && hoverDelay >= 0 ? hoverDelay : DEFAULT_DELAY;
      }
      constructor() {
        super();
        this._uniqueId = `vaadin-tooltip-${generateUniqueId()}`;
        this._renderer = this.__tooltipRenderer.bind(this);
        this.__onFocusin = this.__onFocusin.bind(this);
        this.__onFocusout = this.__onFocusout.bind(this);
        this.__onMouseDown = this.__onMouseDown.bind(this);
        this.__onMouseEnter = this.__onMouseEnter.bind(this);
        this.__onMouseLeave = this.__onMouseLeave.bind(this);
        this.__onKeyDown = this.__onKeyDown.bind(this);
        this.__onOverlayOpen = this.__onOverlayOpen.bind(this);
        this.__targetVisibilityObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => this.__onTargetVisibilityChange(entry.isIntersecting));
          },
          { threshold: 0 }
        );
        this._stateController = new TooltipStateController(this);
      }
      /** @protected */
      connectedCallback() {
        super.connectedCallback();
        this._isConnected = true;
        document.body.addEventListener("vaadin-overlay-open", this.__onOverlayOpen);
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback();
        if (this._autoOpened) {
          this._stateController.close(true);
        }
        this._isConnected = false;
        document.body.removeEventListener("vaadin-overlay-open", this.__onOverlayOpen);
      }
      /** @protected */
      ready() {
        super.ready();
        this._srLabelController = new SlotController(this, "sr-label", "div", {
          initializer: (element) => {
            element.id = this._uniqueId;
            element.setAttribute("role", "tooltip");
            this._srLabel = element;
          }
        });
        this.addController(this._srLabelController);
      }
      /** @private */
      __computeHorizontalAlign(position) {
        return ["top-end", "bottom-end", "start-top", "start", "start-bottom"].includes(position) ? "end" : "start";
      }
      /** @private */
      __computeNoHorizontalOverlap(position) {
        return ["start-top", "start", "start-bottom", "end-top", "end", "end-bottom"].includes(position);
      }
      /** @private */
      __computeNoVerticalOverlap(position) {
        return ["top-start", "top-end", "top", "bottom-start", "bottom", "bottom-end"].includes(position);
      }
      /** @private */
      __computeVerticalAlign(position) {
        return ["top-start", "top-end", "top", "start-bottom", "end-bottom"].includes(position) ? "bottom" : "top";
      }
      /** @private */
      __computeOpened(manual, opened, autoOpened, connected) {
        return connected && (manual ? opened : autoOpened);
      }
      /** @private */
      __computePosition(position, defaultPosition) {
        return position || defaultPosition;
      }
      /** @private */
      __autoOpenedChanged(opened, oldOpened) {
        if (opened) {
          document.addEventListener("keydown", this.__onKeyDown, true);
        } else if (oldOpened) {
          document.removeEventListener("keydown", this.__onKeyDown, true);
        }
      }
      /** @private */
      __forChanged(forId) {
        if (forId) {
          this.__setTargetByIdDebouncer = Debouncer$1.debounce(
            this.__setTargetByIdDebouncer,
            microTask,
            () => this.__setTargetById(forId)
          );
        }
      }
      /** @private */
      __setTargetById(targetId) {
        if (!this.isConnected) {
          return;
        }
        const target = this.getRootNode().getElementById(targetId);
        if (target) {
          this.target = target;
        } else {
          console.warn(`No element with id="${targetId}" found to show tooltip.`);
        }
      }
      /** @private */
      __targetChanged(target, oldTarget) {
        if (oldTarget) {
          oldTarget.removeEventListener("mouseenter", this.__onMouseEnter);
          oldTarget.removeEventListener("mouseleave", this.__onMouseLeave);
          oldTarget.removeEventListener("focusin", this.__onFocusin);
          oldTarget.removeEventListener("focusout", this.__onFocusout);
          oldTarget.removeEventListener("mousedown", this.__onMouseDown);
          this.__targetVisibilityObserver.unobserve(oldTarget);
        }
        if (target) {
          target.addEventListener("mouseenter", this.__onMouseEnter);
          target.addEventListener("mouseleave", this.__onMouseLeave);
          target.addEventListener("focusin", this.__onFocusin);
          target.addEventListener("focusout", this.__onFocusout);
          target.addEventListener("mousedown", this.__onMouseDown);
          requestAnimationFrame(() => {
            this.__targetVisibilityObserver.observe(target);
          });
        }
      }
      /** @private */
      __onFocusin(event) {
        if (this.manual) {
          return;
        }
        if (!isKeyboardActive()) {
          return;
        }
        if (this.target.contains(event.relatedTarget)) {
          return;
        }
        if (!this.__isShouldShow()) {
          return;
        }
        this.__focusInside = true;
        if (!this.__isTargetHidden && (!this.__hoverInside || !this._autoOpened)) {
          this._stateController.open({ focus: true });
        }
      }
      /** @private */
      __onFocusout(event) {
        if (this.manual) {
          return;
        }
        if (this.target.contains(event.relatedTarget)) {
          return;
        }
        this.__focusInside = false;
        if (!this.__hoverInside) {
          this._stateController.close(true);
        }
      }
      /** @private */
      __onKeyDown(event) {
        if (event.key === "Escape") {
          event.stopPropagation();
          this._stateController.close(true);
        }
      }
      /** @private */
      __onMouseDown() {
        this._stateController.close(true);
      }
      /** @private */
      __onMouseEnter() {
        if (this.manual) {
          return;
        }
        if (!this.__isShouldShow()) {
          return;
        }
        if (this.__hoverInside) {
          return;
        }
        this.__hoverInside = true;
        if (!this.__isTargetHidden && (!this.__focusInside || !this._autoOpened)) {
          this._stateController.open({ hover: true });
        }
      }
      /** @private */
      __onMouseLeave(event) {
        if (event.relatedTarget !== this._overlayElement) {
          this.__handleMouseLeave();
        }
      }
      /** @protected */
      __onOverlayMouseEnter() {
        if (this._stateController.isClosing) {
          this._stateController.open({ immediate: true });
        }
      }
      /** @protected */
      __onOverlayMouseLeave(event) {
        if (event.relatedTarget !== this.target) {
          this.__handleMouseLeave();
        }
      }
      /** @private */
      __handleMouseLeave() {
        if (this.manual) {
          return;
        }
        this.__hoverInside = false;
        if (!this.__focusInside) {
          this._stateController.close();
        }
      }
      /** @private */
      __onOverlayOpen() {
        if (this.manual) {
          return;
        }
        if (this._overlayElement.opened && !this._overlayElement._last) {
          this._stateController.close(true);
        }
      }
      /** @private */
      __onTargetVisibilityChange(isVisible) {
        const oldHidden = this.__isTargetHidden;
        this.__isTargetHidden = !isVisible;
        if (oldHidden && isVisible && (this.__focusInside || this.__hoverInside)) {
          this._stateController.open({ immediate: true });
          return;
        }
        if (!isVisible && this._autoOpened) {
          this._stateController.close(true);
        }
      }
      /** @private */
      __isShouldShow() {
        if (typeof this.shouldShow === "function" && this.shouldShow(this.target, this.context) !== true) {
          return false;
        }
        return true;
      }
      /** @private */
      __textChanged(text, oldText) {
        if (this._overlayElement && (text || oldText)) {
          this._overlayElement.requestContentUpdate();
        }
      }
      /** @private */
      __tooltipRenderer(root2) {
        root2.textContent = typeof this.generator === "function" ? this.generator(this.context) : this.text;
        this._overlayContent = root2.textContent;
      }
      /** @private */
      __computeAriaTarget(ariaTarget, target) {
        const isElementNode = (el) => el && el.nodeType === Node.ELEMENT_NODE;
        const isAriaTargetSet = Array.isArray(ariaTarget) ? ariaTarget.some(isElementNode) : ariaTarget;
        return isAriaTargetSet ? ariaTarget : target;
      }
      /** @private */
      __effectiveAriaTargetChanged(ariaTarget, oldAriaTarget) {
        if (oldAriaTarget) {
          [oldAriaTarget].flat().forEach((target) => {
            removeValueFromAttribute(target, "aria-describedby", this._uniqueId);
          });
        }
        if (ariaTarget) {
          [ariaTarget].flat().forEach((target) => {
            addValueToAttribute(target, "aria-describedby", this._uniqueId);
          });
        }
      }
      /** @private */
      __generatorChanged(overlayElement, generator, context) {
        if (overlayElement) {
          if (generator !== this.__oldTextGenerator || context !== this.__oldContext) {
            overlayElement.requestContentUpdate();
          }
          this.__oldTextGenerator = generator;
          this.__oldContext = context;
        }
      }
      /** @private */
      __updateSrLabelText(srLabel, textContent) {
        if (srLabel) {
          srLabel.textContent = textContent;
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2022 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    let Tooltip$1 = class Tooltip extends TooltipMixin(ThemePropertyMixin(ElementMixin(ControllerMixin(PolymerElement)))) {
      static get is() {
        return "vaadin-tooltip";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: none;
        }
      </style>
      <vaadin-tooltip-overlay
        renderer="[[_renderer]]"
        theme$="[[_theme]]"
        opened="[[__computeOpened(manual, opened, _autoOpened, _isConnected)]]"
        position-target="[[target]]"
        position="[[__effectivePosition]]"
        no-horizontal-overlap$="[[__computeNoHorizontalOverlap(__effectivePosition)]]"
        no-vertical-overlap$="[[__computeNoVerticalOverlap(__effectivePosition)]]"
        horizontal-align="[[__computeHorizontalAlign(__effectivePosition)]]"
        vertical-align="[[__computeVerticalAlign(__effectivePosition)]]"
        on-mouseenter="__onOverlayMouseEnter"
        on-mouseleave="__onOverlayMouseLeave"
        modeless
      ></vaadin-tooltip-overlay>

      <slot name="sr-label"></slot>
    `;
      }
    };
    defineCustomElement(Tooltip$1);
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const userColors = css$e`
  :host {
    --vaadin-user-color-0: #df0b92;
    --vaadin-user-color-1: #650acc;
    --vaadin-user-color-2: #097faa;
    --vaadin-user-color-3: #ad6200;
    --vaadin-user-color-4: #bf16f3;
    --vaadin-user-color-5: #084391;
    --vaadin-user-color-6: #078836;
  }

  [theme~='dark'] {
    --vaadin-user-color-0: #ff66c7;
    --vaadin-user-color-1: #9d8aff;
    --vaadin-user-color-2: #8aff66;
    --vaadin-user-color-3: #ffbd66;
    --vaadin-user-color-4: #dc6bff;
    --vaadin-user-color-5: #66fffa;
    --vaadin-user-color-6: #e6ff66;
  }
`;
    addLumoGlobalStyles("user-color-props", userColors);
    const globalStyle = document.createElement("style");
    globalStyle.textContent = "html { --vaadin-avatar-size: var(--lumo-size-m); }";
    document.head.appendChild(globalStyle);
    registerStyles$1(
      "vaadin-avatar",
      css$e`
    :host {
      color: var(--lumo-secondary-text-color);
      background-color: var(--lumo-contrast-10pct);
      border-radius: 50%;
      outline: none;
      cursor: default;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    :host([has-color-index]) {
      color: var(--lumo-base-color);
    }

    :host([focus-ring]) {
      border-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    }

    [part='icon'],
    [part='abbr'] {
      fill: currentColor;
    }

    [part='abbr'] {
      font-family: var(--lumo-font-family);
      font-size: 2.4375em;
      font-weight: 500;
    }

    :host([theme~='xlarge']) [part='abbr'] {
      font-size: 2.5em;
    }

    :host([theme~='large']) [part='abbr'] {
      font-size: 2.375em;
    }

    :host([theme~='small']) [part='abbr'] {
      font-size: 2.75em;
    }

    :host([theme~='xsmall']) [part='abbr'] {
      font-size: 3em;
    }

    :host([theme~='xlarge']) {
      --vaadin-avatar-size: var(--lumo-size-xl);
    }

    :host([theme~='large']) {
      --vaadin-avatar-size: var(--lumo-size-l);
    }

    :host([theme~='small']) {
      --vaadin-avatar-size: var(--lumo-size-s);
    }

    :host([theme~='xsmall']) {
      --vaadin-avatar-size: var(--lumo-size-xs);
    }
  `,
      { moduleId: "lumo-avatar" }
    );
    /**
     * @license
     * Copyright (c) 2020 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const template$6 = document.createElement("template");
    template$6.innerHTML = `
  <style>
    @font-face {
      font-family: 'vaadin-avatar-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQAAAsAAAAABnwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAQwAAAFZAIUmEY21hcAAAAYgAAABLAAABcOspwa1nbHlmAAAB1AAAAEUAAABMYO4o1WhlYWQAAAIcAAAALgAAADYYaAmGaGhlYQAAAkwAAAAdAAAAJAZsA1VobXR4AAACbAAAAAgAAAAIA+gAAGxvY2EAAAJ0AAAABgAAAAYAJgAAbWF4cAAAAnwAAAAeAAAAIAEOACFuYW1lAAACnAAAAUIAAAKavFDYrHBvc3QAAAPgAAAAHQAAAC52hGZ4eJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGT8wjiBgZWBgamKaQ8DA0MPhGZ8wGDIyAQUZWBlZsAKAtJcUxgcXjG+YmQO+p/FEMUcxDANKMwIkgMADiUMJQB4nGNgYGBlYGBgBmIdIGZhYGAMYWBkAAE/oCgjWJyZgQsszsKgBFbDAhJ/xfj/P4wE8lnAJAMjG8Mo4AGTMlAeOKwgmIERADU0CX0AeJxjYGIAAmYJpkgGHgYRBgZGJT1GEztGIzlGET5GKEuU8YuSpZKSpQuI+LfLv21emz9jHJQPJP7dsUywsEiwBACG8g9CAAAAeJxjYGRgYADicIOnh+P5bb4ycDO/AIow3JZ4rIJMM0swRQIpDgYmEA8AKwgJOwAAeJxjYGRgYA76nwUkXzAAAbMEAyMDKmACAE2GAskAAAAAAAAAA+gAAAAAAAAAJgAAeJxjYGRgYGBiEAViBjCLgYELCBkY/oP5DAAKuwEwAAB4nI2Qu07DMBSG//SGaCWEhMSAGDx1QU0vYyemdmDrUDEhuamTpkriyHEj9RF4B56Bh2Bg5mmY+8d4Qh3qo9jf+c45thQAt/hGgGYFuHN7s1q4YvbHbdKD5w555LmLAZ499+hfPPfxhDfPA/p33hB0rmmG+PDcwg2+PLfpfzx3yL+eu7gPHj33MAxmnvtYB6+eB/SftZTbtBjJWlppRmmki2qlkkMmzZnKGbVWpkp1Iabh5Ex1qQplpFVbsTmKqk5m1sYiNjoXC11YlWValEbvVWTDnbXlfDyOvQ8jnaOGZGyRouCfky63/AyzFBE0fYUVFBIckLnKZTOXda15s+GZulxgihCTC2eXnC3cfFNV7BfY4Mi9eT3BjNYiZh6zRyMnLdxs050xNE3panuaiD7Ezk2VmGPMiP/1h+71/ATcWYAhAAB4nGNgYoAALgbsgImRiZGZgaW0OLWIgQEACl4B2QAAAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
    document.head.appendChild(template$6.content);
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const AvatarMixin = (superClass) => class AvatarMixinClass extends FocusMixin(superClass) {
      static get properties() {
        return {
          /**
           * The path to the image
           */
          img: {
            type: String,
            reflectToAttribute: true,
            observer: "__imgChanged"
          },
          /**
           * A shortened form of name that is displayed
           * in the avatar when `img` is not provided.
           */
          abbr: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Full name of the user
           * used for the tooltip of the avatar.
           */
          name: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Color index used for avatar background.
           * @attr {number} color-index
           */
          colorIndex: {
            type: Number,
            observer: "__colorIndexChanged"
          },
          /**
           * The object used to localize this component.
           * To change the default localization, replace the entire
           * _i18n_ object or just the property you want to modify.
           *
           * The object has the following JSON structure and default values:
           *
           * ```
           * {
           *   // Translation of the anonymous user avatar tooltip.
           *   anonymous: 'anonymous'
           * }
           * ```
           *
           * @type {!AvatarI18n}
           * @default {English/US}
           */
          i18n: {
            type: Object,
            value: () => {
              return {
                anonymous: "anonymous"
              };
            }
          },
          /**
           * When true, the avatar has tooltip shown on hover and focus.
           * The tooltip text is based on the `name` and `abbr` properties.
           * When neither is provided, `i18n.anonymous` is used instead.
           * @attr {boolean} with-tooltip
           */
          withTooltip: {
            type: Boolean,
            value: false,
            observer: "__withTooltipChanged"
          },
          /** @protected */
          __imgVisible: Boolean,
          /** @protected */
          __iconVisible: Boolean,
          /** @protected */
          __abbrVisible: Boolean,
          /** @private */
          __tooltipNode: Object
        };
      }
      static get observers() {
        return [
          "__imgOrAbbrOrNameChanged(img, abbr, name)",
          "__i18nChanged(i18n)",
          "__tooltipChanged(__tooltipNode, name, abbr)"
        ];
      }
      /** @protected */
      ready() {
        super.ready();
        this.__updateVisibility();
        if (!this.hasAttribute("role")) {
          this.setAttribute("role", "button");
        }
        if (!this.hasAttribute("tabindex")) {
          this.setAttribute("tabindex", "0");
        }
        if (!this.name && !this.abbr) {
          this.__setTooltip();
        }
      }
      /** @private */
      __colorIndexChanged(index) {
        if (index != null) {
          const prop = `--vaadin-user-color-${index}`;
          const isValid2 = Boolean(getComputedStyle(document.documentElement).getPropertyValue(prop));
          if (isValid2) {
            this.setAttribute("has-color-index", "");
            this.style.setProperty("--vaadin-avatar-user-color", `var(${prop})`);
          } else {
            this.removeAttribute("has-color-index");
            console.warn(`The CSS property --vaadin-user-color-${index} is not defined`);
          }
        } else {
          this.removeAttribute("has-color-index");
        }
      }
      /** @private */
      __imgChanged() {
        this.__imgFailedToLoad = false;
      }
      /** @private */
      __imgOrAbbrOrNameChanged(img, abbr, name) {
        this.__updateVisibility();
        if (abbr && abbr !== this.__generatedAbbr) {
          return;
        }
        if (name) {
          this.abbr = this.__generatedAbbr = name.split(" ").map((word) => word.charAt(0)).join("");
        } else {
          this.abbr = void 0;
        }
      }
      /** @private */
      __tooltipChanged(tooltipNode, name, abbr) {
        if (tooltipNode) {
          if (abbr && abbr !== this.__generatedAbbr) {
            this.__setTooltip(name ? `${name} (${abbr})` : abbr);
          } else {
            this.__setTooltip(name);
          }
        }
      }
      /** @private */
      __withTooltipChanged(withTooltip, oldWithTooltip) {
        if (withTooltip) {
          const tooltipNode = document.createElement("vaadin-tooltip");
          tooltipNode.setAttribute("slot", "tooltip");
          this.appendChild(tooltipNode);
          this.__tooltipNode = tooltipNode;
        } else if (oldWithTooltip) {
          this.__tooltipNode.target = null;
          this.__tooltipNode.remove();
          this.__tooltipNode = null;
        }
      }
      /** @private */
      __i18nChanged(i18n) {
        if (i18n && i18n.anonymous) {
          if (this.__oldAnonymous && this.__tooltipNode && this.__tooltipNode.text === this.__oldAnonymous) {
            this.__setTooltip();
          }
          this.__oldAnonymous = i18n.anonymous;
        }
      }
      /** @private */
      __updateVisibility() {
        this.__imgVisible = !!this.img && !this.__imgFailedToLoad;
        this.__abbrVisible = !this.__imgVisible && !!this.abbr;
        this.__iconVisible = !this.__imgVisible && !this.abbr;
      }
      /** @private */
      __setTooltip(tooltip) {
        const tooltipNode = this.__tooltipNode;
        if (tooltipNode) {
          tooltipNode.text = tooltip || this.i18n.anonymous;
        }
      }
      /** @protected */
      __onImageLoadError() {
        if (this.img) {
          console.warn(`<vaadin-avatar> The specified image could not be loaded: ${this.img}`);
          this.__imgFailedToLoad = true;
          this.__updateVisibility();
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const avatarStyles = css$e`
  :host {
    display: inline-block;
    flex: none;
    border-radius: 50%;
    overflow: hidden;
    height: var(--vaadin-avatar-size, 64px);
    width: var(--vaadin-avatar-size, 64px);
    border: var(--vaadin-avatar-outline-width) solid transparent;
    margin: calc(var(--vaadin-avatar-outline-width) * -1);
    background-clip: content-box;
    --vaadin-avatar-outline-width: var(--vaadin-focus-ring-width, 2px);
  }

  img {
    height: 100%;
    width: 100%;
    object-fit: cover;
  }

  [part='icon'] {
    font-size: 5.6em;
  }

  [part='abbr'] {
    font-size: 2.2em;
  }

  [part='icon'] > text {
    font-family: 'vaadin-avatar-icons';
  }

  :host([hidden]) {
    display: none !important;
  }

  svg[hidden] {
    display: none !important;
  }

  :host([has-color-index]) {
    position: relative;
    background-color: var(--vaadin-avatar-user-color);
  }

  :host([has-color-index])::before {
    position: absolute;
    content: '';
    inset: 0;
    border-radius: inherit;
    box-shadow: inset 0 0 0 2px var(--vaadin-avatar-user-color);
  }
`;
    /**
     * @license
     * Copyright (c) 2020 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-avatar", avatarStyles, { moduleId: "vaadin-avatar-styles" });
    class Avatar extends AvatarMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
      static get template() {
        return html`
      <img
        hidden$="[[!__imgVisible]]"
        src$="[[img]]"
        aria-hidden="true"
        on-error="__onImageLoadError"
        draggable="false"
      />
      <svg
        part="icon"
        hidden$="[[!__iconVisible]]"
        id="avatar-icon"
        viewBox="-50 -50 100 100"
        preserveAspectRatio="xMidYMid meet"
        aria-hidden="true"
      >
        <text dy=".35em" text-anchor="middle">&#xea01;</text>
      </svg>
      <svg
        part="abbr"
        hidden$="[[!__abbrVisible]]"
        id="avatar-abbr"
        viewBox="-50 -50 100 100"
        preserveAspectRatio="xMidYMid meet"
        aria-hidden="true"
      >
        <text dy=".35em" text-anchor="middle">[[abbr]]</text>
      </svg>

      <slot name="tooltip"></slot>
    `;
      }
      static get is() {
        return "vaadin-avatar";
      }
      /** @protected */
      ready() {
        super.ready();
        this._tooltipController = new TooltipController(this);
        this.addController(this._tooltipController);
      }
    }
    defineCustomElement(Avatar);
    registerStyles$1(
      "vaadin-avatar-group",
      css$e`
    :host {
      --vaadin-avatar-size: var(--lumo-size-m);
    }

    :host([theme~='xlarge']) {
      --vaadin-avatar-group-overlap: 12px;
      --vaadin-avatar-group-overlap-border: 3px;
      --vaadin-avatar-size: var(--lumo-size-xl);
    }

    :host([theme~='large']) {
      --vaadin-avatar-group-overlap: 10px;
      --vaadin-avatar-group-overlap-border: 3px;
      --vaadin-avatar-size: var(--lumo-size-l);
    }

    :host([theme~='small']) {
      --vaadin-avatar-group-overlap: 6px;
      --vaadin-avatar-group-overlap-border: 2px;
      --vaadin-avatar-size: var(--lumo-size-s);
    }

    :host([theme~='xsmall']) {
      --vaadin-avatar-group-overlap: 4px;
      --vaadin-avatar-group-overlap-border: 2px;
      --vaadin-avatar-size: var(--lumo-size-xs);
    }
  `,
      { moduleId: "lumo-avatar-group" }
    );
    const avatarGroupOverlay = css$e`
  :host {
    --_lumo-list-box-item-selected-icon-display: none;
    --_lumo-list-box-item-padding-left: calc(var(--lumo-space-m) + var(--lumo-border-radius-m) / 4);
  }

  [part='overlay'] {
    outline: none;
  }
`;
    registerStyles$1("vaadin-avatar-group-overlay", [overlay, menuOverlayCore, avatarGroupOverlay], {
      moduleId: "lumo-avatar-group-overlay"
    });
    registerStyles$1("vaadin-avatar-group-menu", listBox, { moduleId: "lumo-avatar-group-menu" });
    registerStyles$1(
      "vaadin-avatar-group-menu-item",
      [
        item,
        css$e`
      :host {
        padding: var(--lumo-space-xs);
        padding-inline-end: var(--lumo-space-m);
      }

      [part='content'] {
        display: flex;
        align-items: center;
      }

      [part='content'] ::slotted(vaadin-avatar) {
        width: var(--lumo-size-xs);
        height: var(--lumo-size-xs);
        margin-inline-end: var(--lumo-space-s);
      }
    `
      ],
      { moduleId: "lumo-avatar-group-menu-item" }
    );
    /**
     * @license
     * Copyright (c) 2020 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class AvatarGroupMenu extends ListMixin(ThemableMixin(DirMixin(ControllerMixin(PolymerElement)))) {
      static get is() {
        return "vaadin-avatar-group-menu";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>
    `;
      }
      static get properties() {
        return {
          // We don't need to define this property since super default is vertical,
          // but we don't want it to be modified, or be shown in the API docs.
          /** @private */
          orientation: {
            readOnly: true
          }
        };
      }
      /**
       * @return {!HTMLElement}
       * @protected
       * @override
       */
      get _scrollerElement() {
        return this.shadowRoot.querySelector('[part="items"]');
      }
      /** @protected */
      ready() {
        super.ready();
        this.setAttribute("role", "menu");
      }
    }
    defineCustomElement(AvatarGroupMenu);
    /**
     * @license
     * Copyright (c) 2020 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class AvatarGroupMenuItem extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
      static get is() {
        return "vaadin-avatar-group-menu-item";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
      }
      /** @protected */
      ready() {
        super.ready();
        this.setAttribute("role", "menuitem");
      }
    }
    defineCustomElement(AvatarGroupMenuItem);
    /**
     * @license
     * Copyright (c) 2020 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-avatar-group-overlay", [overlayStyles], {
      moduleId: "vaadin-avatar-group-overlay-styles"
    });
    class AvatarGroupOverlay extends PositionMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
      static get is() {
        return "vaadin-avatar-group-overlay";
      }
      static get template() {
        return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
      }
    }
    defineCustomElement(AvatarGroupOverlay);
    /**
    @license
    Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    function newSplice(index, removed, addedCount) {
      return {
        index,
        removed,
        addedCount
      };
    }
    const EDIT_LEAVE = 0;
    const EDIT_UPDATE = 1;
    const EDIT_ADD = 2;
    const EDIT_DELETE = 3;
    function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
      let rowCount = oldEnd - oldStart + 1;
      let columnCount = currentEnd - currentStart + 1;
      let distances = new Array(rowCount);
      for (let i = 0; i < rowCount; i++) {
        distances[i] = new Array(columnCount);
        distances[i][0] = i;
      }
      for (let j = 0; j < columnCount; j++)
        distances[0][j] = j;
      for (let i = 1; i < rowCount; i++) {
        for (let j = 1; j < columnCount; j++) {
          if (equals(current[currentStart + j - 1], old[oldStart + i - 1]))
            distances[i][j] = distances[i - 1][j - 1];
          else {
            let north = distances[i - 1][j] + 1;
            let west = distances[i][j - 1] + 1;
            distances[i][j] = north < west ? north : west;
          }
        }
      }
      return distances;
    }
    function spliceOperationsFromEditDistances(distances) {
      let i = distances.length - 1;
      let j = distances[0].length - 1;
      let current = distances[i][j];
      let edits = [];
      while (i > 0 || j > 0) {
        if (i == 0) {
          edits.push(EDIT_ADD);
          j--;
          continue;
        }
        if (j == 0) {
          edits.push(EDIT_DELETE);
          i--;
          continue;
        }
        let northWest = distances[i - 1][j - 1];
        let west = distances[i - 1][j];
        let north = distances[i][j - 1];
        let min;
        if (west < north)
          min = west < northWest ? west : northWest;
        else
          min = north < northWest ? north : northWest;
        if (min == northWest) {
          if (northWest == current) {
            edits.push(EDIT_LEAVE);
          } else {
            edits.push(EDIT_UPDATE);
            current = northWest;
          }
          i--;
          j--;
        } else if (min == west) {
          edits.push(EDIT_DELETE);
          i--;
          current = west;
        } else {
          edits.push(EDIT_ADD);
          j--;
          current = north;
        }
      }
      edits.reverse();
      return edits;
    }
    function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
      let prefixCount = 0;
      let suffixCount = 0;
      let splice;
      let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
      if (currentStart == 0 && oldStart == 0)
        prefixCount = sharedPrefix(current, old, minLength);
      if (currentEnd == current.length && oldEnd == old.length)
        suffixCount = sharedSuffix(current, old, minLength - prefixCount);
      currentStart += prefixCount;
      oldStart += prefixCount;
      currentEnd -= suffixCount;
      oldEnd -= suffixCount;
      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
        return [];
      if (currentStart == currentEnd) {
        splice = newSplice(currentStart, [], 0);
        while (oldStart < oldEnd)
          splice.removed.push(old[oldStart++]);
        return [splice];
      } else if (oldStart == oldEnd)
        return [newSplice(currentStart, [], currentEnd - currentStart)];
      let ops = spliceOperationsFromEditDistances(
        calcEditDistances(
          current,
          currentStart,
          currentEnd,
          old,
          oldStart,
          oldEnd
        )
      );
      splice = void 0;
      let splices = [];
      let index = currentStart;
      let oldIndex = oldStart;
      for (let i = 0; i < ops.length; i++) {
        switch (ops[i]) {
          case EDIT_LEAVE:
            if (splice) {
              splices.push(splice);
              splice = void 0;
            }
            index++;
            oldIndex++;
            break;
          case EDIT_UPDATE:
            if (!splice)
              splice = newSplice(index, [], 0);
            splice.addedCount++;
            index++;
            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
          case EDIT_ADD:
            if (!splice)
              splice = newSplice(index, [], 0);
            splice.addedCount++;
            index++;
            break;
          case EDIT_DELETE:
            if (!splice)
              splice = newSplice(index, [], 0);
            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
        }
      }
      if (splice) {
        splices.push(splice);
      }
      return splices;
    }
    function sharedPrefix(current, old, searchLength) {
      for (let i = 0; i < searchLength; i++)
        if (!equals(current[i], old[i]))
          return i;
      return searchLength;
    }
    function sharedSuffix(current, old, searchLength) {
      let index1 = current.length;
      let index2 = old.length;
      let count = 0;
      while (count < searchLength && equals(current[--index1], old[--index2]))
        count++;
      return count;
    }
    function calculateSplices(current, previous) {
      return calcSplices(
        current,
        0,
        current.length,
        previous,
        0,
        previous.length
      );
    }
    function equals(currentValue, previousValue) {
      return currentValue === previousValue;
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const ifDefined = (value) => value ?? nothing;
    /**
     * @license
     * Copyright (c) 2020 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const MINIMUM_DISPLAYED_AVATARS = 2;
    class AvatarGroup extends ResizeMixin(OverlayClassMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement))))) {
      static get template() {
        return html`
      <style>
        :host {
          display: block;
          width: 100%; /* prevent collapsing inside non-stretching column flex */
          --vaadin-avatar-group-overlap: 8px;
          --vaadin-avatar-group-overlap-border: 2px;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='container'] {
          display: flex;
          position: relative;
          width: 100%;
          flex-wrap: nowrap;
        }

        ::slotted(vaadin-avatar:not(:first-child)) {
          -webkit-mask-image: url('data:image/svg+xml;utf8,<svg viewBox=%220 0 300 300%22 fill=%22none%22 xmlns=%22http://www.w3.org/2000/svg%22><path fill-rule=%22evenodd%22 clip-rule=%22evenodd%22 d=%22M300 0H0V300H300V0ZM150 200C177.614 200 200 177.614 200 150C200 122.386 177.614 100 150 100C122.386 100 100 122.386 100 150C100 177.614 122.386 200 150 200Z%22 fill=%22black%22/></svg>');
          mask-image: url('data:image/svg+xml;utf8,<svg viewBox=%220 0 300 300%22 fill=%22none%22 xmlns=%22http://www.w3.org/2000/svg%22><path fill-rule=%22evenodd%22 clip-rule=%22evenodd%22 d=%22M300 0H0V300H300V0ZM150 200C177.614 200 200 177.614 200 150C200 122.386 177.614 100 150 100C122.386 100 100 122.386 100 150C100 177.614 122.386 200 150 200Z%22 fill=%22black%22/></svg>');
          -webkit-mask-size: calc(
            300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6
          );
          mask-size: calc(
            300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6
          );
        }

        ::slotted(vaadin-avatar:not([dir='rtl']):not(:first-child)) {
          margin-left: calc(var(--vaadin-avatar-group-overlap) * -1 - var(--vaadin-avatar-outline-width));
          -webkit-mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
          mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
        }

        ::slotted(vaadin-avatar[dir='rtl']:not(:first-child)) {
          margin-right: calc(var(--vaadin-avatar-group-overlap) * -1);
          -webkit-mask-position: calc(
            50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width)
          );
          mask-position: calc(
            50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width)
          );
        }
      </style>
      <div id="container" part="container">
        <slot></slot>
        <slot name="overflow"></slot>
      </div>
      <vaadin-avatar-group-overlay
        id="overlay"
        opened="{{_opened}}"
        position-target="[[_overflow]]"
        no-vertical-overlap
        on-vaadin-overlay-close="_onVaadinOverlayClose"
      ></vaadin-avatar-group-overlay>
    `;
      }
      static get is() {
        return "vaadin-avatar-group";
      }
      static get properties() {
        return {
          /**
           * An array containing the items which will be stamped as avatars.
           *
           * The items objects allow to configure [`name`](#/elements/vaadin-avatar#property-name),
           * [`abbr`](#/elements/vaadin-avatar#property-abbr), [`img`](#/elements/vaadin-avatar#property-img)
           * and [`colorIndex`](#/elements/vaadin-avatar#property-colorIndex) properties on the
           * stamped avatars, and set `className` to provide CSS class names.
           *
           * #### Example
           *
           * ```js
           * group.items = [
           *   {
           *     name: 'User name',
           *     img: 'url-to-image.png',
           *     className: 'even'
           *   },
           *   {
           *     abbr: 'JD',
           *     colorIndex: 1,
           *     className: 'odd'
           *   },
           * ];
           * ```
           *
           * @type {!Array<!AvatarGroupItem> | undefined}
           */
          items: {
            type: Array
          },
          /**
           * The maximum number of avatars to display. By default, all the avatars are displayed.
           * When _maxItemsVisible_ is set, the overflowing avatars are grouped into one avatar with
           * a dropdown. Setting 0 or 1 has no effect so there are always at least two avatars visible.
           * @attr {number} max-items-visible
           */
          maxItemsVisible: {
            type: Number
          },
          /**
           * The object used to localize this component.
           * To change the default localization, replace the entire
           * _i18n_ object or just the property you want to modify.
           *
           * The object has the following JSON structure and default values:
           * ```
           * {
           *   // Translation of the anonymous user avatar tooltip.
           *   anonymous: 'anonymous',
           *   // Translation of the avatar group accessible label.
           *   // {count} is replaced with the actual count of users.
           *   activeUsers: {
           *     one: 'Currently one active user',
           *     many: 'Currently {count} active users'
           *   },
           *   // Screen reader announcement when user joins group.
           *   // {user} is replaced with the name or abbreviation.
           *   // When neither is set, "anonymous" is used instead.
           *   joined: '{user} joined',
           *   // Screen reader announcement when user leaves group.
           *   // {user} is replaced with the name or abbreviation.
           *   // When neither is set, "anonymous" is used instead.
           *   left: '{user} left'
           * }
           * ```
           * @type {!AvatarGroupI18n}
           * @default {English/US}
           */
          i18n: {
            type: Object,
            value: () => {
              return {
                anonymous: "anonymous",
                activeUsers: {
                  one: "Currently one active user",
                  many: "Currently {count} active users"
                },
                joined: "{user} joined",
                left: "{user} left"
              };
            }
          },
          /** @private */
          _avatars: {
            type: Array,
            value: () => []
          },
          /** @private */
          __maxReached: {
            type: Boolean,
            computed: "__computeMaxReached(items.length, maxItemsVisible)"
          },
          /** @private */
          __items: {
            type: Array
          },
          /** @private */
          __itemsInView: {
            type: Number,
            value: null
          },
          /** @private */
          _overflow: {
            type: Object
          },
          /** @private */
          _overflowItems: {
            type: Array,
            observer: "__overflowItemsChanged",
            computed: "__computeOverflowItems(items.*, __itemsInView, maxItemsVisible)"
          },
          /** @private */
          _overflowTooltip: {
            type: Object
          },
          /** @private */
          _opened: {
            type: Boolean,
            observer: "__openedChanged"
          }
        };
      }
      static get observers() {
        return [
          "__itemsChanged(items.splices, items.*)",
          "__i18nItemsChanged(i18n.*, items.length)",
          "__updateAvatarsTheme(_overflow, _avatars, _theme)",
          "__updateAvatars(items.*, __itemsInView, maxItemsVisible, _overflow, i18n)",
          "__updateOverflowAbbr(_overflow, items.length, __itemsInView, maxItemsVisible)",
          "__updateOverflowHidden(_overflow, items.length, __itemsInView, __maxReached)",
          "__updateOverflowTooltip(_overflowTooltip, items.length, __itemsInView, maxItemsVisible)"
        ];
      }
      /** @protected */
      ready() {
        super.ready();
        this._overflowController = new SlotController(this, "overflow", "vaadin-avatar", {
          initializer: (overflow) => {
            overflow.setAttribute("aria-haspopup", "menu");
            overflow.setAttribute("aria-expanded", "false");
            overflow.addEventListener("click", (e2) => this._onOverflowClick(e2));
            overflow.addEventListener("keydown", (e2) => this._onOverflowKeyDown(e2));
            const tooltip = document.createElement("vaadin-tooltip");
            tooltip.setAttribute("slot", "tooltip");
            overflow.appendChild(tooltip);
            this._overflow = overflow;
            this._overflowTooltip = tooltip;
          }
        });
        this.addController(this._overflowController);
        const overlay2 = this.$.overlay;
        overlay2.renderer = this.__overlayRenderer.bind(this);
        this._overlayElement = overlay2;
        afterNextRender(this, () => {
          this.__setItemsInView();
        });
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback();
        this._opened = false;
      }
      /** @private */
      __getMessage(user, action) {
        return action.replace("{user}", user.name || user.abbr || this.i18n.anonymous);
      }
      /**
       * Renders items when they are provided by the `items` property and clears the content otherwise.
       * @param {!HTMLElement} root
       * @param {!Select} _select
       * @private
       */
      __overlayRenderer(root2) {
        let menu = root2.firstElementChild;
        if (!menu) {
          menu = document.createElement("vaadin-avatar-group-menu");
          menu.addEventListener("keydown", (event) => this._onListKeyDown(event));
          root2.appendChild(menu);
        }
        menu.textContent = "";
        if (!this._overflowItems) {
          return;
        }
        this._overflowItems.forEach((item2) => {
          menu.appendChild(this.__createItemElement(item2));
        });
      }
      /** @private */
      __createItemElement(item2) {
        const itemElement = document.createElement("vaadin-avatar-group-menu-item");
        const avatar = document.createElement("vaadin-avatar");
        itemElement.appendChild(avatar);
        avatar.setAttribute("aria-hidden", "true");
        avatar.setAttribute("tabindex", "-1");
        avatar.i18n = this.i18n;
        if (this._theme) {
          avatar.setAttribute("theme", this._theme);
        }
        avatar.name = item2.name;
        avatar.abbr = item2.abbr;
        avatar.img = item2.img;
        avatar.colorIndex = item2.colorIndex;
        if (item2.className) {
          avatar.className = item2.className;
        }
        if (item2.name) {
          const text = document.createTextNode(item2.name);
          itemElement.appendChild(text);
        }
        return itemElement;
      }
      /** @private */
      _onOverflowClick(e2) {
        e2.stopPropagation();
        if (this._opened) {
          this.$.overlay.close();
        } else if (!e2.defaultPrevented) {
          this._opened = true;
        }
      }
      /** @private */
      _onOverflowKeyDown(e2) {
        if (!this._opened) {
          if (/^(Enter|SpaceBar|\s)$/u.test(e2.key)) {
            e2.preventDefault();
            this._opened = true;
          }
        }
      }
      /** @private */
      _onListKeyDown(event) {
        if (event.key === "Escape" || event.key === "Tab") {
          this._opened = false;
        }
      }
      /**
       * @protected
       * @override
       */
      _onResize() {
        this.__setItemsInView();
      }
      /** @private */
      _onVaadinOverlayClose(e2) {
        if (e2.detail.sourceEvent && e2.detail.sourceEvent.composedPath().includes(this)) {
          e2.preventDefault();
        }
      }
      /** @private */
      __renderAvatars(items) {
        render(
          html$1`
        ${items.map(
            (item2) => html$1`
              <vaadin-avatar
                .name="${item2.name}"
                .abbr="${item2.abbr}"
                .img="${item2.img}"
                .colorIndex="${item2.colorIndex}"
                .i18n="${this.i18n}"
                class="${ifDefined(item2.className)}"
                with-tooltip
              ></vaadin-avatar>
            `
          )}
      `,
          this,
          { renderBefore: this._overflow }
        );
      }
      /** @private */
      __updateAvatars(arr, itemsInView, maxItemsVisible, overflow) {
        if (!overflow) {
          return;
        }
        const items = arr.base || [];
        const limit = this.__getLimit(items.length, itemsInView, maxItemsVisible);
        this.__renderAvatars(limit ? items.slice(0, limit) : items);
        this._avatars = [...this.querySelectorAll("vaadin-avatar")];
      }
      /** @private */
      __computeOverflowItems(arr, itemsInView, maxItemsVisible) {
        const items = arr.base || [];
        const limit = this.__getLimit(items.length, itemsInView, maxItemsVisible);
        return limit ? items.slice(limit) : [];
      }
      /** @private */
      __computeMaxReached(items, maxItemsVisible) {
        return maxItemsVisible != null && items > this.__getMax(maxItemsVisible);
      }
      /** @private */
      __updateOverflowAbbr(overflow, items, itemsInView, maxItemsVisible) {
        if (overflow) {
          overflow.abbr = `+${items - this.__getLimit(items, itemsInView, maxItemsVisible)}`;
        }
      }
      /** @private */
      __updateOverflowHidden(overflow, items, itemsInView, maxReached) {
        if (overflow) {
          overflow.toggleAttribute("hidden", !maxReached && !(itemsInView && itemsInView < items));
        }
      }
      /** @private */
      __updateAvatarsTheme(overflow, avatars, theme2) {
        if (overflow) {
          [overflow, ...avatars].forEach((avatar) => {
            if (theme2) {
              avatar.setAttribute("theme", theme2);
            } else {
              avatar.removeAttribute("theme");
            }
          });
        }
      }
      /** @private */
      __updateOverflowTooltip(tooltip, items, itemsInView, maxItemsVisible) {
        if (!tooltip) {
          return;
        }
        const limit = this.__getLimit(items, itemsInView, maxItemsVisible);
        if (limit == null) {
          return;
        }
        const result2 = [];
        for (let i = limit; i < items; i++) {
          const item2 = this.items[i];
          if (item2) {
            result2.push(item2.name || item2.abbr || "anonymous");
          }
        }
        tooltip.text = result2.join("\n");
      }
      /** @private */
      __getLimit(items, itemsInView, maxItemsVisible) {
        let limit = null;
        const adjustedMax = this.__getMax(maxItemsVisible);
        if (maxItemsVisible != null && adjustedMax < items) {
          limit = adjustedMax - 1;
        } else if (itemsInView && itemsInView < items) {
          limit = itemsInView;
        }
        return Math.min(limit, this.__calculateAvatarsFitWidth());
      }
      /** @private */
      __getMax(maxItemsVisible) {
        return Math.max(maxItemsVisible, MINIMUM_DISPLAYED_AVATARS);
      }
      /** @private */
      __itemsChanged(splices, itemsChange) {
        const items = itemsChange.base;
        this.__setItemsInView();
        if (splices && Array.isArray(splices.indexSplices)) {
          splices.indexSplices.forEach((mutation) => {
            this.__announceItemsChange(items, mutation);
          });
        } else if (Array.isArray(items) && Array.isArray(this.__oldItems)) {
          const diff = calculateSplices(items, this.__oldItems);
          diff.forEach((mutation) => {
            this.__announceItemsChange(items, mutation);
          });
        }
        this.__oldItems = items;
      }
      /** @private */
      __announceItemsChange(items, mutation) {
        const { addedCount, index, removed } = mutation;
        let addedMsg = [];
        let removedMsg = [];
        if (addedCount) {
          addedMsg = items.slice(index, index + addedCount).map((user) => this.__getMessage(user, this.i18n.joined || "{user} joined"));
        }
        if (removed) {
          removedMsg = removed.map((user) => this.__getMessage(user, this.i18n.left || "{user} left"));
        }
        const messages = removedMsg.concat(addedMsg);
        if (messages.length > 0) {
          announce(messages.join(", "));
        }
      }
      /** @private */
      __i18nItemsChanged(i18n, items) {
        const { base } = i18n;
        if (base && base.activeUsers) {
          const field = items === 1 ? "one" : "many";
          if (base.activeUsers[field]) {
            this.setAttribute("aria-label", base.activeUsers[field].replace("{count}", items || 0));
          }
          this._avatars.forEach((avatar) => {
            avatar.i18n = base;
          });
        }
      }
      /** @private */
      __openedChanged(opened, wasOpened) {
        if (opened) {
          if (!this._menuElement) {
            this._menuElement = this.$.overlay.querySelector("vaadin-avatar-group-menu");
          }
          this._openedWithFocusRing = this._overflow.hasAttribute("focus-ring");
          this._menuElement.focus();
        } else if (wasOpened) {
          this._overflow.focus();
          if (this._openedWithFocusRing) {
            this._overflow.setAttribute("focus-ring", "");
          }
        }
        this._overflow.setAttribute("aria-expanded", opened === true);
      }
      /** @private */
      __overflowItemsChanged(items, oldItems) {
        if (items || oldItems) {
          this.$.overlay.requestContentUpdate();
        }
      }
      /** @private */
      __setItemsInView() {
        const avatars = this._avatars;
        const items = this.items;
        if (!items || !avatars || avatars.length < 3) {
          return;
        }
        let result2 = this.__calculateAvatarsFitWidth();
        if (result2 === items.length - 1) {
          result2 = items.length;
        }
        if (result2 >= items.length && this._opened) {
          this.$.overlay.close();
          this.$.overlay._flushAnimation("closing");
        }
        this.__itemsInView = result2;
      }
      /** @private */
      __calculateAvatarsFitWidth() {
        if (!this.shadowRoot || this._avatars.length < MINIMUM_DISPLAYED_AVATARS) {
          return MINIMUM_DISPLAYED_AVATARS;
        }
        const avatars = this._avatars;
        const avatarWidth = avatars[0].clientWidth;
        const { marginLeft, marginRight } = getComputedStyle(avatars[1]);
        const offset2 = this.__isRTL ? parseInt(marginRight, 0) - parseInt(marginLeft, 0) : parseInt(marginLeft, 0) - parseInt(marginRight, 0);
        return Math.floor((this.$.container.offsetWidth - avatarWidth) / (avatarWidth + offset2));
      }
    }
    defineCustomElement(AvatarGroup);
    /**
     * @license
     * Copyright (c) 2000 - 2024 Vaadin Ltd.
     *
     * This program is available under Vaadin Commercial License and Service Terms.
     *
     *
     * See https://vaadin.com/commercial-license-and-service-terms for the full
     * license.
     */
    const chartBaseTheme = css$e`
  :host {
    font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Segoe UI', Helvetica, Arial, sans-serif,
      'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
    font-size: 12px;
    line-height: normal;
  }

  .highcharts-container {
    position: relative;
    overflow: hidden;
    width: 100%;
    height: 100%;
    text-align: left;
    z-index: 0;
    /* #1072 */
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  }

  :where([styled-mode]) .highcharts-root {
    display: block;
  }

  :where([styled-mode]) .highcharts-root text {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-strong {
    font-weight: 600;
  }

  :where([styled-mode]) .highcharts-emphasized {
    font-style: italic;
  }

  :where([styled-mode]) .highcharts-anchor {
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-background {
    fill: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-plot-border,
  :where([styled-mode]) .highcharts-plot-background {
    fill: none;
  }

  :where([styled-mode]) .highcharts-label-box {
    fill: none;
  }

  :where([styled-mode]) .highcharts-button-box {
    fill: inherit;
  }

  :where([styled-mode]) .highcharts-tracker-line {
    stroke-linejoin: round;
    stroke: rgba(192, 192, 192, 0.0001);
    stroke-width: 22;
    fill: none;
  }

  :where([styled-mode]) .highcharts-tracker-area {
    fill: rgba(192, 192, 192, 0.0001);
    stroke-width: 0;
  }

  /* Titles */
  :where([styled-mode]) .highcharts-title {
    fill: var(--vaadin-charts-title-label, hsl(214, 35%, 15%));
    font-size: 1.5em;
    font-weight: 600;
  }

  :where([styled-mode]) .highcharts-subtitle {
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  /* Axes */
  :where([styled-mode]) .highcharts-axis-line {
    fill: none;
    stroke: var(--vaadin-charts-axis-line, hsla(214, 61%, 25%, 0.05));
  }

  :where([styled-mode]) .highcharts-yaxis .highcharts-axis-line {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-axis-title {
    fill: var(--vaadin-charts-axis-title, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-axis-labels {
    fill: var(--vaadin-charts-axis-label, hsla(214, 42%, 18%, 0.72));
    cursor: default;
    font-size: 0.9em;
  }

  :where([styled-mode]) .highcharts-grid-line {
    fill: none;
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-xaxis-grid .highcharts-grid-line {
    stroke-width: var(--vaadin-charts-xaxis-line-width, 0px);
  }

  :where([styled-mode]) .highcharts-tick {
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-yaxis .highcharts-tick {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-minor-grid-line {
    stroke: var(--vaadin-charts-contrast-5pct, hsla(214, 61%, 25%, 0.05));
  }

  :where([styled-mode]) .highcharts-crosshair-thin {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-crosshair-category {
    stroke: var(--vaadin-charts-color-0, #5ac2f7);
    stroke-opacity: 0.25;
  }

  /* Credits */
  :where([styled-mode]) .highcharts-credits {
    cursor: pointer;
    fill: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26));
    font-size: 0.7em;
    transition: fill 250ms, font-size 250ms;
  }

  :where([styled-mode]) .highcharts-credits:hover {
    fill: black;
    font-size: 1em;
  }

  /* Tooltip */
  :where([styled-mode]) .highcharts-tooltip {
    cursor: default;
    pointer-events: none;
    white-space: nowrap;
    transition: stroke 150ms;
  }

  :where([styled-mode]) .highcharts-tooltip {
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.05)) !important;
  }

  :where([styled-mode]) .highcharts-tooltip text {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  :where([styled-mode]) .highcharts-tooltip .highcharts-header {
    font-size: 0.85em;
    color: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-tooltip-box {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-tooltip-border, inherit);
    fill: var(--vaadin-charts-tooltip-background, #fff);
    fill-opacity: var(--vaadin-charts-tooltip-background-opacity, 1);
  }

  :where([styled-mode]) .highcharts-tooltip-box .highcharts-label-box {
    fill: var(--vaadin-charts-tooltip-background, #fff);
    fill-opacity: var(--vaadin-charts-tooltip-background-opacity, 1);
  }

  :where([styled-mode]) .highcharts-tooltip-header {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) div.highcharts-tooltip {
    filter: none;
  }

  :where([styled-mode]) .highcharts-selection-marker {
    fill: var(--vaadin-charts-color-0, #5ac2f7);
    fill-opacity: 0.25;
  }

  :where([styled-mode]) .highcharts-graph {
    fill: none;
    stroke-width: 2px;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  :where([styled-mode]) .highcharts-state-hover .highcharts-graph {
    stroke-width: 3;
  }

  :where([styled-mode]) .highcharts-point-inactive {
    opacity: 0.2;
    transition: opacity 50ms;
    /* quick in */
  }

  :where([styled-mode]) .highcharts-series-inactive {
    opacity: 0.2;
    transition: opacity 50ms;
    /* quick in */
  }

  :where([styled-mode]) .highcharts-state-hover path {
    transition: stroke-width 50ms;
    /* quick in */
  }

  :where([styled-mode]) .highcharts-state-normal path {
    transition: stroke-width 250ms;
    /* slow out */
  }

  /* Legend hover affects points and series */
  :where([styled-mode]) g.highcharts-series,
  :where([styled-mode]) .highcharts-point,
  :where([styled-mode]) .highcharts-markers,
  :where([styled-mode]) .highcharts-data-labels {
    transition: opacity 250ms;
  }

  :where([styled-mode]) .highcharts-legend-series-active g.highcharts-series:not(.highcharts-series-hover),
  :where([styled-mode]) .highcharts-legend-point-active .highcharts-point:not(.highcharts-point-hover),
  :where([styled-mode]) .highcharts-legend-series-active .highcharts-markers:not(.highcharts-series-hover),
  :where([styled-mode]) .highcharts-legend-series-active .highcharts-data-labels:not(.highcharts-series-hover) {
    opacity: 0.2;
  }

  /* Series options */
  /* Default colors */
  /* vaadin-charts custom properties */
  /* Use of :where() function to avoid setting classes with high specificity */
  :where([styled-mode]) .highcharts-color-0 {
    fill: var(--vaadin-charts-color-0, #5ac2f7);
    stroke: var(--vaadin-charts-color-0, #5ac2f7);
  }

  :where([styled-mode]) .highcharts-color-1 {
    fill: var(--vaadin-charts-color-1, #1676f3);
    stroke: var(--vaadin-charts-color-1, #1676f3);
  }

  :where([styled-mode]) .highcharts-color-2 {
    fill: var(--vaadin-charts-color-2, #ff7d94);
    stroke: var(--vaadin-charts-color-2, #ff7d94);
  }

  :where([styled-mode]) .highcharts-color-3 {
    fill: var(--vaadin-charts-color-3, #c5164e);
    stroke: var(--vaadin-charts-color-3, #c5164e);
  }

  :where([styled-mode]) .highcharts-color-4 {
    fill: var(--vaadin-charts-color-4, #15c15d);
    stroke: var(--vaadin-charts-color-4, #15c15d);
  }

  :where([styled-mode]) .highcharts-color-5 {
    fill: var(--vaadin-charts-color-5, #0e8151);
    stroke: var(--vaadin-charts-color-5, #0e8151);
  }

  :where([styled-mode]) .highcharts-color-6 {
    fill: var(--vaadin-charts-color-6, #c18ed2);
    stroke: var(--vaadin-charts-color-6, #c18ed2);
  }

  :where([styled-mode]) .highcharts-color-7 {
    fill: var(--vaadin-charts-color-7, #9233b3);
    stroke: var(--vaadin-charts-color-7, #9233b3);
  }

  :where([styled-mode]) .highcharts-color-8 {
    fill: var(--vaadin-charts-color-8, #fda253);
    stroke: var(--vaadin-charts-color-8, #fda253);
  }

  :where([styled-mode]) .highcharts-color-9 {
    fill: var(--vaadin-charts-color-9, #e24932);
    stroke: var(--vaadin-charts-color-9, #e24932);
  }

  /* end of vaadin-charts custom properties */

  :where([styled-mode]) .highcharts-area {
    fill-opacity: 0.5;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-markers {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode])
    .highcharts-a11y-markers-hidden
    .highcharts-point:not(.highcharts-point-hover):not(.highcharts-a11y-marker-visible),
  :where([styled-mode]) .highcharts-a11y-marker-hidden {
    opacity: 0;
  }

  :where([styled-mode]) .highcharts-point {
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-dense-data .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-data-label {
    font-size: 0.9em;
    font-weight: normal;
  }

  :where([styled-mode]) .highcharts-data-label-box {
    fill: none;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-data-label text,
  :where([styled-mode]) text.highcharts-data-label {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  :where([styled-mode]) .highcharts-data-label-connector {
    fill: none;
  }

  :where([styled-mode]) .highcharts-data-label-hidden {
    pointer-events: none;
  }

  :where([styled-mode]) .highcharts-halo {
    fill-opacity: 0.25;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-series:not(.highcharts-pie-series) .highcharts-point-select,
  :where([styled-mode]) .highcharts-markers .highcharts-point-select {
    fill: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
    stroke: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
  }

  :where([styled-mode]) .highcharts-column-series rect.highcharts-point {
    stroke: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-column-series .highcharts-point {
    transition: fill-opacity 250ms;
  }

  :where([styled-mode]) .highcharts-column-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-pie-series .highcharts-point {
    stroke-linejoin: round;
    stroke: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-pie-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-funnel-series .highcharts-point {
    stroke-linejoin: round;
    stroke: var(--vaadin-charts-background, #fff);
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-funnel-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-funnel-series .highcharts-point-select {
    fill: inherit;
    stroke: inherit;
  }

  :where([styled-mode]) .highcharts-pyramid-series .highcharts-point {
    stroke-linejoin: round;
    stroke: var(--vaadin-charts-background, #fff);
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-pyramid-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-pyramid-series .highcharts-point-select {
    fill: inherit;
    stroke: inherit;
  }

  :where([styled-mode]) .highcharts-solidgauge-series .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-point {
    stroke-width: 2px;
    stroke: var(--vaadin-charts-background, #fff);
    transition: stroke 250ms, fill 250ms, fill-opacity 250ms;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-point-hover {
    stroke-width: 0px;
    stroke: var(--vaadin-charts-background, #fff);
    fill-opacity: 0.75;
    transition: stroke 25ms, fill 25ms, fill-opacity 25ms;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-above-level {
    display: none;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-internal-node {
    fill: none;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-internal-node-interactive {
    fill-opacity: 0.15;
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-internal-node-interactive:hover {
    fill-opacity: 0.75;
  }

  :where([styled-mode]) .highcharts-vector-series .highcharts-point {
    fill: none;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-windbarb-series .highcharts-point {
    fill: none;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-lollipop-stem {
    stroke: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
  }

  :where([styled-mode]) .highcharts-focus-border {
    fill: none;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-legend-item-hidden .highcharts-focus-border {
    fill: none !important;
  }

  /* Legend */
  :where([styled-mode]) .highcharts-legend-box {
    fill: none;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-legend-item > text {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
    font-weight: normal;
    font-size: 1em;
    cursor: pointer;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-legend-item > .highcharts-point {
    stroke-width: 0px;
  }

  :where([styled-mode]) .highcharts-legend-item:hover text {
    fill: var(--vaadin-charts-title-label, hsl(214, 35%, 15%));
  }

  :where([styled-mode]) .highcharts-legend-item-hidden * {
    fill: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26)) !important;
    stroke: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26)) !important;
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-legend-nav-active {
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-legend-nav-inactive {
    fill: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26));
  }

  :where([styled-mode]) circle.highcharts-legend-nav-active,
  :where([styled-mode]) circle.highcharts-legend-nav-inactive {
    /* tracker */
    fill: rgba(192, 192, 192, 0.0001);
  }

  :where([styled-mode]) .highcharts-legend-title-box {
    fill: none;
    stroke-width: 0;
  }

  /* Bubble legend */
  :where([styled-mode]) .highcharts-bubble-legend-symbol {
    stroke-width: 2;
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-bubble-legend-connectors {
    stroke-width: 1;
  }

  :where([styled-mode]) .highcharts-bubble-legend-labels {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  /* Loading */
  :where([styled-mode]) .highcharts-loading {
    position: absolute;
    background-color: var(--vaadin-charts-background, #fff);
    opacity: 0.5;
    text-align: center;
    z-index: 10;
    transition: opacity 250ms;
  }

  :where([styled-mode]) .highcharts-loading-hidden {
    height: 0 !important;
    opacity: 0;
    overflow: hidden;
    transition: opacity 250ms, height 250ms step-end;
  }

  :where([styled-mode]) .highcharts-loading-inner {
    font-weight: normal;
    position: relative;
    top: 45%;
  }

  /* Plot bands and polar pane backgrounds */
  :where([styled-mode]) .highcharts-plot-band,
  :where([styled-mode]) .highcharts-pane {
    fill: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
    fill-opacity: 0.05;
  }

  :where([styled-mode]) .highcharts-plot-line {
    fill: none;
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-plot-line-label {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  /* Highcharts More and modules */
  :where([styled-mode]) .highcharts-boxplot-box {
    fill: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-boxplot-median {
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-bubble-series .highcharts-point {
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-errorbar-series .highcharts-point {
    stroke: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
  }

  :where([styled-mode]) .highcharts-gauge-series .highcharts-data-label-box {
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-gauge-series .highcharts-dial {
    fill: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-polygon-series .highcharts-graph {
    fill: inherit;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-waterfall-series .highcharts-graph {
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
    stroke-dasharray: 1, 3;
  }

  :where([styled-mode]) .highcharts-sankey-series .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-sankey-series .highcharts-link {
    transition: fill 250ms, fill-opacity 250ms;
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-sankey-series .highcharts-point-hover.highcharts-link {
    transition: fill 50ms, fill-opacity 50ms;
    fill-opacity: 1;
  }

  :where([styled-mode]) .highcharts-venn-series .highcharts-point {
    fill-opacity: 0.75;
    stroke: var(--vaadin-charts-background, #fff);
    transition: stroke 250ms, fill-opacity 250ms;
  }

  :where([styled-mode]) .highcharts-venn-series .highcharts-point-hover {
    fill-opacity: 1;
    stroke: var(--vaadin-charts-background, #fff);
  }

  /* Highstock */
  :where([styled-mode]) .highcharts-navigator-mask-outside {
    fill-opacity: 0;
  }

  :where([styled-mode]) .highcharts-navigator-mask-inside {
    fill: var(--vaadin-charts-color-0, #5ac2f7);
    /* navigator.maskFill option */
    fill-opacity: 0.2;
    cursor: ew-resize;
  }

  :where([styled-mode]) .highcharts-navigator-outline {
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
    fill: none;
  }

  :where([styled-mode]) .highcharts-navigator-handle {
    stroke: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
    fill: var(--vaadin-charts-background, #fff);
    cursor: ew-resize;
  }

  :where([styled-mode]) .highcharts-navigator-series {
    fill: var(--vaadin-charts-color-1, #1676f3);
    stroke: var(--vaadin-charts-color-1, #1676f3);
  }

  :where([styled-mode]) .highcharts-navigator-series .highcharts-graph {
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-navigator-series .highcharts-area {
    fill-opacity: 0.05;
  }

  :where([styled-mode]) .highcharts-navigator-xaxis .highcharts-axis-line {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-navigator-xaxis .highcharts-grid-line {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-navigator-xaxis.highcharts-axis-labels {
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-navigator-yaxis .highcharts-grid-line {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-scrollbar-thumb {
    fill: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-scrollbar-button {
    fill: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-scrollbar-arrow {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  :where([styled-mode]) .highcharts-scrollbar-rifles {
    stroke: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-scrollbar-track {
    fill: var(--vaadin-charts-contrast-5pct, hsla(214, 61%, 25%, 0.05));
  }

  :where([styled-mode]) .highcharts-button {
    fill: var(--vaadin-charts-button-background, hsla(214, 61%, 25%, 0.05));
    cursor: default;
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-button text {
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
    font-weight: 600;
  }

  :where([styled-mode]) .highcharts-button-hover {
    transition: fill 0ms;
    fill: var(--vaadin-charts-button-hover-background, hsla(214, 90%, 52%, 0.1));
    stroke-width: 0px;
  }

  :where([styled-mode]) .highcharts-button-hover text {
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
  }

  :where([styled-mode]) .highcharts-button-pressed {
    fill: var(--vaadin-charts-button-active-background, hsl(214, 90%, 52%));
  }

  :where([styled-mode]) .highcharts-button-pressed text {
    fill: var(--vaadin-charts-button-active-label, #fff);
  }

  :where([styled-mode]) .highcharts-button-disabled text {
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
  }

  :where([styled-mode]) .highcharts-range-selector-buttons > text {
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-range-selector-buttons .highcharts-button {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-range-label rect {
    fill: none;
  }

  :where([styled-mode]) .highcharts-range-label text {
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-range-input rect {
    fill: var(--vaadin-charts-contrast-10pct, hsla(214, 57%, 24%, 0.1));
    rx: 2;
    ry: 2;
  }

  :where([styled-mode]) .highcharts-range-input:hover rect {
    fill: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-range-input text {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  :where([styled-mode]) input.highcharts-range-selector {
    position: absolute;
    border: 0;
    width: 1px;
    /* Chrome needs a pixel to see it */
    height: 1px;
    padding: 0;
    text-align: center;
    left: -9em;
    /* #4798 */
  }

  :where([styled-mode]) .highcharts-crosshair-label text {
    fill: var(--vaadin-charts-background, #fff);
    font-size: 1.1em;
  }

  :where([styled-mode]) .highcharts-crosshair-label .highcharts-label-box {
    fill: inherit;
  }

  :where([styled-mode]) .highcharts-candlestick-series .highcharts-point {
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-candlestick-series .highcharts-point-up {
    fill: var(--vaadin-charts-color-positive, #15c15d);
  }

  :where([styled-mode]) .highcharts-candlestick-series .highcharts-point-down {
    fill: var(--vaadin-charts-color-negative, #e24932);
  }

  :where([styled-mode]) .highcharts-ohlc-series .highcharts-point-hover {
    stroke-width: 3px;
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point .highcharts-label-box {
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
    fill: var(--vaadin-charts-background, #fff);
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point-hover .highcharts-label-box {
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
    fill: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point text {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
    font-size: 0.9em;
    font-weight: normal;
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point-hover text {
    fill: var(--vaadin-charts-title-label, hsl(214, 35%, 15%));
  }

  /* Highmaps */
  :where([styled-mode]) .highcharts-map-series .highcharts-point {
    transition: fill 500ms, fill-opacity 500ms, stroke-width 250ms;
    stroke: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-map-series .highcharts-point-hover {
    transition: fill 0ms, fill-opacity 0ms;
    fill-opacity: 0.5;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-mapline-series .highcharts-point {
    fill: none;
  }

  :where([styled-mode]) .highcharts-heatmap-series .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-map-navigation {
    font-size: 1.3em;
    font-weight: normal;
    text-align: center;
  }

  :where([styled-mode]) .highcharts-coloraxis {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-coloraxis-grid .highcharts-grid-line {
    stroke: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-coloraxis-marker {
    fill: var(--vaadin-charts-axis-label, hsla(214, 42%, 18%, 0.72));
    stroke-width: 0px;
  }

  :where([styled-mode]) .highcharts-null-point {
    fill: var(--vaadin-charts-contrast-5pct, hsla(214, 61%, 25%, 0.05));
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
  }

  /* 3d charts */
  :where([styled-mode]) .highcharts-3d-frame {
    fill: transparent;
  }

  /* Exporting module */
  :where([styled-mode]) .highcharts-contextbutton {
    fill: #fff;
    /* needed to capture hover */
    stroke: none;
    stroke-linecap: round;
  }

  :where([styled-mode]) .highcharts-contextbutton:hover {
    fill: #e6e6e6;
    stroke: #e6e6e6;
  }

  :where([styled-mode]) .highcharts-button-symbol {
    stroke: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
    stroke-width: 3px;
  }

  :where([styled-mode]) .highcharts-menu {
    border: 1px solid #999;
    background: #fff;
    padding: 5px 0;
    box-shadow: 3px 3px 10px #888;
  }

  :where([styled-mode]) .highcharts-menu-item {
    padding: 0.5em 1em;
    background: none;
    color: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
    cursor: pointer;
    transition: background 250ms, color 250ms;
  }

  :where([styled-mode]) .highcharts-menu-item:hover {
    background: #335cad;
    color: #fff;
  }

  /* Drilldown module */
  :where([styled-mode]) .highcharts-drilldown-point {
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-drilldown-data-label text,
  :where([styled-mode]) text.highcharts-drilldown-data-label,
  :where([styled-mode]) .highcharts-drilldown-axis-label {
    cursor: pointer;
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
    font-weight: normal;
    text-decoration: underline;
  }

  /* No-data module */
  :where([styled-mode]) .highcharts-no-data text {
    font-weight: normal;
    font-size: 1rem;
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  /* Drag-panes module */
  :where([styled-mode]) .highcharts-axis-resizer {
    cursor: ns-resize;
    stroke: black;
    stroke-width: 2px;
  }

  /* Bullet type series */
  :where([styled-mode]) .highcharts-bullet-target {
    stroke-width: 0;
  }

  /* Lineargauge type series */
  :where([styled-mode]) .highcharts-lineargauge-target {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
  }

  :where([styled-mode]) .highcharts-lineargauge-target-line {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
  }

  /* Annotations module */
  :where([styled-mode]) .highcharts-annotation-label-box {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
    fill: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
    fill-opacity: 0.75;
  }

  :where([styled-mode]) .highcharts-annotation-label text {
    fill: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26));
  }

  /* Gantt */
  :where([styled-mode]) .highcharts-treegrid-node-collapsed,
  :where([styled-mode]) .highcharts-treegrid-node-expanded {
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-point-connecting-path {
    fill: none;
  }

  :where([styled-mode]) .highcharts-grid-axis .highcharts-tick {
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-grid-axis .highcharts-axis-line {
    stroke-width: 1px;
  }

  /* RTL styles */
  :host([dir='rtl']) :where([styled-mode]) .highcharts-container {
    text-align: right;
  }

  :host([dir='rtl']) :where([styled-mode]) input.highcharts-range-selector {
    left: auto;
    right: -9em;
  }

  :host([dir='rtl']) :where([styled-mode]) .highcharts-menu {
    box-shadow: -3px 3px 10px #888;
  }

  /* https://github.com/highcharts/highcharts/issues/16282 */
  /* without this the resize callback always calls __reflow */
  ul[aria-hidden='false'] {
    margin: 0px;
  }
`;
    registerStyles$1("vaadin-chart", chartBaseTheme, { moduleId: "vaadin-chart-base-theme" });
    const chartColors = css$e`
  :host {
    --vaadin-charts-color-0: #5ac2f7;
    --vaadin-charts-color-1: #1676f3;
    --vaadin-charts-color-2: #ff7d94;
    --vaadin-charts-color-3: #c5164e;
    --vaadin-charts-color-4: #15c15d;
    --vaadin-charts-color-5: #0e8151;
    --vaadin-charts-color-6: #c18ed2;
    --vaadin-charts-color-7: #9233b3;
    --vaadin-charts-color-8: #fda253;
    --vaadin-charts-color-9: #e24932;
    --vaadin-charts-color-positive: var(--vaadin-charts-color-4, #15c15d);
    --vaadin-charts-color-negative: var(--vaadin-charts-color-9, #e24932);
  }

  :host([theme~='gradient']) {
    --vaadin-charts-color-0: #1676f3;
    --vaadin-charts-color-1: #13bbf0;
    --vaadin-charts-color-2: #1ee;
    --vaadin-charts-color-3: #0cd9bf;
    --vaadin-charts-color-4: #06be81;
    --vaadin-charts-color-5: #00a344;
    --vaadin-charts-color-6: #41c639;
    --vaadin-charts-color-7: #8aed2c;
    --vaadin-charts-color-8: #c0e632;
    --vaadin-charts-color-9: #f6db3a;
    --vaadin-charts-color-positive: var(--vaadin-charts-color-6);
    --vaadin-charts-color-negative: var(--vaadin-charts-color-1);
  }

  :host([theme~='monotone']) {
    --vaadin-charts-color-0: #1676f3;
    --vaadin-charts-color-1: #4795f5;
    --vaadin-charts-color-2: #71b0f7;
    --vaadin-charts-color-3: #a0cef9;
    --vaadin-charts-color-4: #bce0fa;
    --vaadin-charts-color-5: #a8d8ed;
    --vaadin-charts-color-6: #7fc3dd;
    --vaadin-charts-color-7: #54adcc;
    --vaadin-charts-color-8: #2b99bc;
    --vaadin-charts-color-9: #0284ac;
    --vaadin-charts-color-positive: var(--vaadin-charts-color-3);
    --vaadin-charts-color-negative: var(--vaadin-charts-color-9);
  }

  :host([theme~='classic']) {
    --vaadin-charts-color-0: #7cb5ec;
    --vaadin-charts-color-1: #434348;
    --vaadin-charts-color-2: #90ed7d;
    --vaadin-charts-color-3: #f7a35c;
    --vaadin-charts-color-4: #8085e9;
    --vaadin-charts-color-5: #f15c80;
    --vaadin-charts-color-6: #e4d354;
    --vaadin-charts-color-7: #2b908f;
    --vaadin-charts-color-8: #f45b5b;
    --vaadin-charts-color-9: #91e8e1;
  }
`;
    const chartTheme = css$e`
  :host {
    --vaadin-charts-background: var(--lumo-base-color);
    --vaadin-charts-title-label: var(--lumo-header-text-color);
    --vaadin-charts-axis-title: var(--lumo-secondary-text-color);
    --vaadin-charts-axis-label: var(--lumo-secondary-text-color);
    --vaadin-charts-data-label: var(--lumo-body-text-color);
    --vaadin-charts-secondary-label: var(--lumo-secondary-text-color);
    --vaadin-charts-axis-line: var(--lumo-contrast-5pct);
    --vaadin-charts-grid-line: var(--lumo-contrast-20pct);
    --vaadin-charts-disabled-label: var(--lumo-disabled-text-color);
    --vaadin-charts-contrast: var(--lumo-contrast);
    --vaadin-charts-contrast-5pct: var(--lumo-contrast-5pct);
    --vaadin-charts-contrast-10pct: var(--lumo-contrast-10pct);
    --vaadin-charts-contrast-20pct: var(--lumo-contrast-20pct);
    --vaadin-charts-contrast-60pct: var(--lumo-contrast-60pct);
    --vaadin-charts-tooltip-background: var(--lumo-base-color);
    --vaadin-charts-tooltip-border-color: inherit;
    --vaadin-charts-button-label: var(--lumo-primary-text-color);
    --vaadin-charts-button-background: var(--lumo-contrast-5pct);
    --vaadin-charts-button-hover-background: var(--lumo-primary-color-10pct);
    --vaadin-charts-button-active-label: var(--lumo-primary-contrast-color);
    --vaadin-charts-button-active-background: var(--lumo-primary-color);
    --vaadin-charts-xaxis-line-width: 0;
    --vaadin-charts-tooltip-background-opacity: 1;
    font-family: var(--lumo-font-family);
  }
`;
    registerStyles$1("vaadin-chart", [chartColors, chartTheme], { moduleId: "lumo-chart" });
    var w = typeof win !== "undefined" ? win : typeof window !== "undefined" ? window : {};
    var Globals;
    (function(Globals2) {
      Globals2.SVG_NS = "http://www.w3.org/2000/svg", Globals2.product = "Highcharts", Globals2.version = "9.2.2", Globals2.win = w, Globals2.doc = Globals2.win.document, Globals2.svg = Globals2.doc && Globals2.doc.createElementNS && !!Globals2.doc.createElementNS(Globals2.SVG_NS, "svg").createSVGRect, Globals2.userAgent = Globals2.win.navigator && Globals2.win.navigator.userAgent || "", Globals2.isChrome = Globals2.userAgent.indexOf("Chrome") !== -1, Globals2.isFirefox = Globals2.userAgent.indexOf("Firefox") !== -1, Globals2.isMS = /(edge|msie|trident)/i.test(Globals2.userAgent) && !Globals2.win.opera, Globals2.isSafari = !Globals2.isChrome && Globals2.userAgent.indexOf("Safari") !== -1, Globals2.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(Globals2.userAgent), Globals2.isWebKit = Globals2.userAgent.indexOf("AppleWebKit") !== -1, Globals2.deg2rad = Math.PI * 2 / 360, Globals2.hasBidiBug = Globals2.isFirefox && parseInt(Globals2.userAgent.split("Firefox/")[1], 10) < 4, Globals2.hasTouch = !!Globals2.win.TouchEvent, Globals2.marginNames = [
        "plotTop",
        "marginRight",
        "marginBottom",
        "plotLeft"
      ], Globals2.noop = function() {
      }, Globals2.supportsPassiveEvents = function() {
        var supportsPassive = false;
        if (!Globals2.isMS) {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassive = true;
            }
          });
          if (Globals2.win.addEventListener && Globals2.win.removeEventListener) {
            Globals2.win.addEventListener("testPassive", Globals2.noop, opts);
            Globals2.win.removeEventListener("testPassive", Globals2.noop, opts);
          }
        }
        return supportsPassive;
      }();
      Globals2.charts = [];
      Globals2.dateFormats = {};
      Globals2.seriesTypes = {};
      Globals2.symbolSizes = {};
      Globals2.chartCount = 0;
    })(Globals || (Globals = {}));
    const H = Globals;
    var charts$5 = H.charts, doc$m = H.doc, win$g = H.win;
    function error$a(code, stop2, chart, params) {
      var severity = stop2 ? "Highcharts error" : "Highcharts warning";
      if (code === 32) {
        code = severity + ": Deprecated member";
      }
      var isCode = isNumber$R(code);
      var message = isCode ? severity + " #" + code + ": www.highcharts.com/errors/" + code + "/" : code.toString();
      var defaultHandler = function() {
        if (stop2) {
          throw new Error(message);
        }
        if (win$g.console && error$a.messages.indexOf(message) === -1) {
          console.warn(message);
        }
      };
      if (typeof params !== "undefined") {
        var additionalMessages_1 = "";
        if (isCode) {
          message += "?";
        }
        objectEach$B(params, function(value, key) {
          additionalMessages_1 += "\n - " + key + ": " + value;
          if (isCode) {
            message += encodeURI(key) + "=" + encodeURI(value);
          }
        });
        message += additionalMessages_1;
      }
      fireEvent$B(H, "displayError", { chart, code, message, params }, defaultHandler);
      error$a.messages.push(message);
    }
    (function(error2) {
      error2.messages = [];
    })(error$a || (error$a = {}));
    function merge$1p() {
      var i, args = arguments, ret = {};
      var doCopy = function(copy, original) {
        if (typeof copy !== "object") {
          copy = {};
        }
        objectEach$B(original, function(value, key) {
          if (key === "__proto__" || key === "constructor") {
            return;
          }
          if (isObject$f(value, true) && !isClass(value) && !isDOMElement(value)) {
            copy[key] = doCopy(copy[key] || {}, value);
          } else {
            copy[key] = original[key];
          }
        });
        return copy;
      };
      if (args[0] === true) {
        ret = args[1];
        args = Array.prototype.slice.call(args, 2);
      }
      var len = args.length;
      for (i = 0; i < len; i++) {
        ret = doCopy(ret, args[i]);
      }
      return ret;
    }
    function clamp$j(value, min, max) {
      return value > min ? value < max ? value : max : min;
    }
    function cleanRecursively$2(newer, older) {
      var result2 = {};
      objectEach$B(newer, function(_val, key) {
        var ob;
        if (isObject$f(newer[key], true) && !newer.nodeType && // #10044
        older[key]) {
          ob = cleanRecursively$2(newer[key], older[key]);
          if (Object.keys(ob).length) {
            result2[key] = ob;
          }
        } else if (isObject$f(newer[key]) || newer[key] !== older[key]) {
          result2[key] = newer[key];
        }
      });
      return result2;
    }
    function pInt$a(s, mag) {
      return parseInt(s, mag || 10);
    }
    function isString$c(s) {
      return typeof s === "string";
    }
    function isArray$n(obj) {
      var str = Object.prototype.toString.call(obj);
      return str === "[object Array]" || str === "[object Array Iterator]";
    }
    function isObject$f(obj, strict) {
      return !!obj && typeof obj === "object" && (!strict || !isArray$n(obj));
    }
    function isDOMElement(obj) {
      return isObject$f(obj) && typeof obj.nodeType === "number";
    }
    function isClass(obj) {
      var c = obj && obj.constructor;
      return !!(isObject$f(obj, true) && !isDOMElement(obj) && (c && c.name && c.name !== "Object"));
    }
    function isNumber$R(n) {
      return typeof n === "number" && !isNaN(n) && n < Infinity && n > -Infinity;
    }
    function erase$9(arr, item2) {
      var i = arr.length;
      while (i--) {
        if (arr[i] === item2) {
          arr.splice(i, 1);
          break;
        }
      }
    }
    function defined$W(obj) {
      return typeof obj !== "undefined" && obj !== null;
    }
    function attr$8(elem, prop, value) {
      var ret;
      if (isString$c(prop)) {
        if (defined$W(value)) {
          elem.setAttribute(prop, value);
        } else if (elem && elem.getAttribute) {
          ret = elem.getAttribute(prop);
          if (!ret && prop === "class") {
            ret = elem.getAttribute(prop + "Name");
          }
        }
      } else {
        objectEach$B(prop, function(val, key) {
          elem.setAttribute(key, val);
        });
      }
      return ret;
    }
    function splat$j(obj) {
      return isArray$n(obj) ? obj : [obj];
    }
    function syncTimeout$9(fn, delay, context) {
      if (delay > 0) {
        return setTimeout(fn, delay, context);
      }
      fn.call(0, context);
      return -1;
    }
    function internalClearTimeout(id) {
      if (defined$W(id)) {
        clearTimeout(id);
      }
    }
    function extend$1q(a, b) {
      var n;
      if (!a) {
        a = {};
      }
      for (n in b) {
        a[n] = b[n];
      }
      return a;
    }
    function pick$1B() {
      var args = arguments;
      var length = args.length;
      for (var i = 0; i < length; i++) {
        var arg = args[i];
        if (typeof arg !== "undefined" && arg !== null) {
          return arg;
        }
      }
    }
    function css$d(el, styles) {
      if (H.isMS && !H.svg) {
        if (styles && typeof styles.opacity !== "undefined") {
          styles.filter = "alpha(opacity=" + styles.opacity * 100 + ")";
        }
      }
      extend$1q(el.style, styles);
    }
    function createElement$b(tag, attribs, styles, parent, nopad) {
      var el = doc$m.createElement(tag);
      if (attribs) {
        extend$1q(el, attribs);
      }
      if (nopad) {
        css$d(el, { padding: "0", border: "none", margin: "0" });
      }
      if (styles) {
        css$d(el, styles);
      }
      if (parent) {
        parent.appendChild(el);
      }
      return el;
    }
    function extendClass$2(parent, members) {
      var obj = function() {
      };
      obj.prototype = new parent();
      extend$1q(obj.prototype, members);
      return obj;
    }
    function pad$2(number, length, padder) {
      return new Array((length || 2) + 1 - String(number).replace("-", "").length).join(padder || "0") + number;
    }
    function relativeLength$a(value, base, offset2) {
      return /%$/.test(value) ? base * parseFloat(value) / 100 + (offset2 || 0) : parseFloat(value);
    }
    function wrap$d(obj, method, func) {
      var proceed = obj[method];
      obj[method] = function() {
        var args = Array.prototype.slice.call(arguments), outerArgs = arguments, ctx = this;
        ctx.proceed = function() {
          proceed.apply(ctx, arguments.length ? arguments : outerArgs);
        };
        args.unshift(proceed);
        var ret = func.apply(this, args);
        ctx.proceed = null;
        return ret;
      };
    }
    function getMagnitude$3(num) {
      return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
    }
    function normalizeTickInterval$3(interval, multiples, magnitude, allowDecimals, hasTickAmount) {
      var i, retInterval = interval;
      magnitude = pick$1B(magnitude, 1);
      var normalized = interval / magnitude;
      if (!multiples) {
        multiples = hasTickAmount ? (
          // Finer grained ticks when the tick amount is hard set, including
          // when alignTicks is true on multiple axes (#4580).
          [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10]
        ) : (
          // Else, let ticks fall on rounder numbers
          [1, 2, 2.5, 5, 10]
        );
        if (allowDecimals === false) {
          if (magnitude === 1) {
            multiples = multiples.filter(function(num) {
              return num % 1 === 0;
            });
          } else if (magnitude <= 0.1) {
            multiples = [1 / magnitude];
          }
        }
      }
      for (i = 0; i < multiples.length; i++) {
        retInterval = multiples[i];
        if (hasTickAmount && retInterval * magnitude >= interval || !hasTickAmount && normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
          break;
        }
      }
      retInterval = correctFloat$d(retInterval * magnitude, -Math.round(Math.log(1e-3) / Math.LN10));
      return retInterval;
    }
    function stableSort$7(arr, sortFunction) {
      var length = arr.length;
      var sortValue, i;
      for (i = 0; i < length; i++) {
        arr[i].safeI = i;
      }
      arr.sort(function(a, b) {
        sortValue = sortFunction(a, b);
        return sortValue === 0 ? a.safeI - b.safeI : sortValue;
      });
      for (i = 0; i < length; i++) {
        delete arr[i].safeI;
      }
    }
    function arrayMin$9(data) {
      var i = data.length, min = data[0];
      while (i--) {
        if (data[i] < min) {
          min = data[i];
        }
      }
      return min;
    }
    function arrayMax$a(data) {
      var i = data.length, max = data[0];
      while (i--) {
        if (data[i] > max) {
          max = data[i];
        }
      }
      return max;
    }
    function destroyObjectProperties$a(obj, except) {
      objectEach$B(obj, function(val, n) {
        if (val && val !== except && val.destroy) {
          val.destroy();
        }
        delete obj[n];
      });
    }
    function discardElement$7(element) {
      if (!garbageBin) {
        garbageBin = createElement$b("div");
      }
      if (element) {
        garbageBin.appendChild(element);
      }
      garbageBin.innerHTML = "";
    }
    var garbageBin;
    function correctFloat$d(num, prec) {
      return parseFloat(num.toPrecision(prec || 14));
    }
    var timeUnits$3 = {
      millisecond: 1,
      second: 1e3,
      minute: 6e4,
      hour: 36e5,
      day: 24 * 36e5,
      week: 7 * 24 * 36e5,
      month: 28 * 24 * 36e5,
      year: 364 * 24 * 36e5
    };
    Math.easeInOutSine = function(pos) {
      return -0.5 * (Math.cos(Math.PI * pos) - 1);
    };
    function getNestedProperty$3(path, parent) {
      var pathElements = path.split(".");
      while (pathElements.length && defined$W(parent)) {
        var pathElement = pathElements.shift();
        if (typeof pathElement === "undefined" || pathElement === "__proto__") {
          return;
        }
        var child = parent[pathElement];
        if (!defined$W(child) || typeof child === "function" || typeof child.nodeType === "number" || child === win$g) {
          return;
        }
        parent = child;
      }
      return parent;
    }
    function getStyle$2(el, prop, toInt) {
      var customGetStyle = H.getStyle || // oldie getStyle
      getStyle$2;
      var style;
      if (prop === "width") {
        var offsetWidth = Math.min(el.offsetWidth, el.scrollWidth);
        var boundingClientRectWidth = el.getBoundingClientRect && el.getBoundingClientRect().width;
        if (boundingClientRectWidth < offsetWidth && boundingClientRectWidth >= offsetWidth - 1) {
          offsetWidth = Math.floor(boundingClientRectWidth);
        }
        return Math.max(
          0,
          // #8377
          offsetWidth - (customGetStyle(el, "padding-left", true) || 0) - (customGetStyle(el, "padding-right", true) || 0)
        );
      }
      if (prop === "height") {
        return Math.max(
          0,
          // #8377
          Math.min(el.offsetHeight, el.scrollHeight) - (customGetStyle(el, "padding-top", true) || 0) - (customGetStyle(el, "padding-bottom", true) || 0)
        );
      }
      if (!win$g.getComputedStyle) {
        error$a(27, true);
      }
      var css2 = win$g.getComputedStyle(el, void 0);
      if (css2) {
        style = css2.getPropertyValue(prop);
        if (pick$1B(toInt, prop !== "opacity")) {
          style = pInt$a(style);
        }
      }
      return style;
    }
    function inArray(item2, arr, fromIndex) {
      error$a(32, false, void 0, { "Highcharts.inArray": "use Array.indexOf" });
      return arr.indexOf(item2, fromIndex);
    }
    var find$j = Array.prototype.find ? function(arr, callback) {
      return arr.find(callback);
    } : (
      // Legacy implementation. PhantomJS, IE <= 11 etc. #7223.
      function(arr, callback) {
        var i;
        var length = arr.length;
        for (i = 0; i < length; i++) {
          if (callback(arr[i], i)) {
            return arr[i];
          }
        }
      }
    );
    function keys(obj) {
      error$a(32, false, void 0, { "Highcharts.keys": "use Object.keys" });
      return Object.keys(obj);
    }
    function offset$1(el) {
      var docElem = doc$m.documentElement, box = el.parentElement || el.parentNode ? el.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 };
      return {
        top: box.top + (win$g.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
        left: box.left + (win$g.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),
        width: box.width,
        height: box.height
      };
    }
    function objectEach$B(obj, fn, ctx) {
      for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) {
          fn.call(ctx || obj[key], obj[key], key, obj);
        }
      }
    }
    objectEach$B({
      map: "map",
      each: "forEach",
      grep: "filter",
      reduce: "reduce",
      some: "some"
    }, function(val, key) {
      H[key] = function(arr) {
        var _a2;
        error$a(32, false, void 0, (_a2 = {}, _a2["Highcharts." + key] = "use Array." + val, _a2));
        return Array.prototype[val].apply(arr, [].slice.call(arguments, 1));
      };
    });
    function addEvent$12(el, type, fn, options) {
      if (options === void 0) {
        options = {};
      }
      var owner = typeof el === "function" && el.prototype || el;
      if (!Object.hasOwnProperty.call(owner, "hcEvents")) {
        owner.hcEvents = {};
      }
      var events = owner.hcEvents;
      if (H.Point && // without H a dependency loop occurs
      el instanceof H.Point && el.series && el.series.chart) {
        el.series.chart.runTrackerClick = true;
      }
      var addEventListener = el.addEventListener || H.addEventListenerPolyfill;
      if (addEventListener) {
        addEventListener.call(el, type, fn, H.supportsPassiveEvents ? {
          passive: options.passive === void 0 ? type.indexOf("touch") !== -1 : options.passive,
          capture: false
        } : false);
      }
      if (!events[type]) {
        events[type] = [];
      }
      var eventObject = {
        fn,
        order: typeof options.order === "number" ? options.order : Infinity
      };
      events[type].push(eventObject);
      events[type].sort(function(a, b) {
        return a.order - b.order;
      });
      return function() {
        removeEvent$c(el, type, fn);
      };
    }
    function removeEvent$c(el, type, fn) {
      function removeOneEvent(type2, fn2) {
        var removeEventListener = el.removeEventListener || H.removeEventListenerPolyfill;
        if (removeEventListener) {
          removeEventListener.call(el, type2, fn2, false);
        }
      }
      function removeAllEvents(eventCollection) {
        var types, len;
        if (!el.nodeName) {
          return;
        }
        if (type) {
          types = {};
          types[type] = true;
        } else {
          types = eventCollection;
        }
        objectEach$B(types, function(_val, n) {
          if (eventCollection[n]) {
            len = eventCollection[n].length;
            while (len--) {
              removeOneEvent(n, eventCollection[n][len].fn);
            }
          }
        });
      }
      var owner = typeof el === "function" && el.prototype || el;
      if (Object.hasOwnProperty.call(owner, "hcEvents")) {
        var events = owner.hcEvents;
        if (type) {
          var typeEvents = events[type] || [];
          if (fn) {
            events[type] = typeEvents.filter(function(obj) {
              return fn !== obj.fn;
            });
            removeOneEvent(type, fn);
          } else {
            removeAllEvents(events);
            events[type] = [];
          }
        } else {
          removeAllEvents(events);
          delete owner.hcEvents;
        }
      }
    }
    function fireEvent$B(el, type, eventArguments, defaultFunction) {
      var e2;
      eventArguments = eventArguments || {};
      if (doc$m.createEvent && (el.dispatchEvent || el.fireEvent && // Enable firing events on Highcharts instance.
      el !== H)) {
        e2 = doc$m.createEvent("Events");
        e2.initEvent(type, true, true);
        eventArguments = extend$1q(e2, eventArguments);
        if (el.dispatchEvent) {
          el.dispatchEvent(eventArguments);
        } else {
          el.fireEvent(type, eventArguments);
        }
      } else if (el.hcEvents) {
        if (!eventArguments.target) {
          extend$1q(eventArguments, {
            // Attach a simple preventDefault function to skip
            // default handler if called. The built-in
            // defaultPrevented property is not overwritable (#5112)
            preventDefault: function() {
              eventArguments.defaultPrevented = true;
            },
            // Setting target to native events fails with clicking
            // the zoom-out button in Chrome.
            target: el,
            // If the type is not set, we're running a custom event
            // (#2297). If it is set, we're running a browser event,
            // and setting it will cause en error in IE8 (#2465).
            type
          });
        }
        var events = [];
        var object = el;
        var multilevel = false;
        while (object.hcEvents) {
          if (Object.hasOwnProperty.call(object, "hcEvents") && object.hcEvents[type]) {
            if (events.length) {
              multilevel = true;
            }
            events.unshift.apply(events, object.hcEvents[type]);
          }
          object = Object.getPrototypeOf(object);
        }
        if (multilevel) {
          events.sort(function(a, b) {
            return a.order - b.order;
          });
        }
        events.forEach(function(obj) {
          if (obj.fn.call(el, eventArguments) === false) {
            eventArguments.preventDefault();
          }
        });
      }
      if (defaultFunction && !eventArguments.defaultPrevented) {
        defaultFunction.call(el, eventArguments);
      }
    }
    var serialMode;
    var uniqueKey$8 = function() {
      var hash = Math.random().toString(36).substring(2, 9) + "-";
      var id = 0;
      return function() {
        return "highcharts-" + (serialMode ? "" : hash) + id++;
      };
    }();
    function useSerialIds(mode) {
      return serialMode = pick$1B(mode, serialMode);
    }
    function isFunction$5(obj) {
      return typeof obj === "function";
    }
    if (win$g.jQuery) {
      win$g.jQuery.fn.highcharts = function() {
        var args = [].slice.call(arguments);
        if (this[0]) {
          if (args[0]) {
            new H[
              // eslint-disable-line computed-property-spacing, no-new
              // Constructor defaults to Chart
              isString$c(args[0]) ? args.shift() : "Chart"
            ](this[0], args[0], args[1]);
            return this;
          }
          return charts$5[attr$8(this[0], "data-highcharts-chart")];
        }
      };
    }
    var Utilities = {
      addEvent: addEvent$12,
      arrayMax: arrayMax$a,
      arrayMin: arrayMin$9,
      attr: attr$8,
      clamp: clamp$j,
      cleanRecursively: cleanRecursively$2,
      clearTimeout: internalClearTimeout,
      correctFloat: correctFloat$d,
      createElement: createElement$b,
      css: css$d,
      defined: defined$W,
      destroyObjectProperties: destroyObjectProperties$a,
      discardElement: discardElement$7,
      erase: erase$9,
      error: error$a,
      extend: extend$1q,
      extendClass: extendClass$2,
      find: find$j,
      fireEvent: fireEvent$B,
      getMagnitude: getMagnitude$3,
      getNestedProperty: getNestedProperty$3,
      getStyle: getStyle$2,
      inArray,
      isArray: isArray$n,
      isClass,
      isDOMElement,
      isFunction: isFunction$5,
      isNumber: isNumber$R,
      isObject: isObject$f,
      isString: isString$c,
      keys,
      merge: merge$1p,
      normalizeTickInterval: normalizeTickInterval$3,
      objectEach: objectEach$B,
      offset: offset$1,
      pad: pad$2,
      pick: pick$1B,
      pInt: pInt$a,
      relativeLength: relativeLength$a,
      removeEvent: removeEvent$c,
      splat: splat$j,
      stableSort: stableSort$7,
      syncTimeout: syncTimeout$9,
      timeUnits: timeUnits$3,
      uniqueKey: uniqueKey$8,
      useSerialIds,
      wrap: wrap$d
    };
    var palette = {
      /**
       * Colors for data series and points.
       */
      colors: [
        "#7cb5ec",
        "#434348",
        "#90ed7d",
        "#f7a35c",
        "#8085e9",
        "#f15c80",
        "#e4d354",
        "#2b908f",
        "#f45b5b",
        "#91e8e1"
      ],
      /**
       * Chart background, point stroke for markers and columns etc
       */
      backgroundColor: "#ffffff",
      /**
       * Strong text.
       */
      neutralColor100: "#000000",
      /**
       * Main text and some strokes.
       */
      neutralColor80: "#333333",
      /**
       * Axis labels, axis title, connector fallback.
       */
      neutralColor60: "#666666",
      /**
       * Credits text, export menu stroke.
       */
      neutralColor40: "#999999",
      /**
       * Disabled texts, button strokes, crosshair etc.
       */
      neutralColor20: "#cccccc",
      /**
       * Grid lines etc.
       */
      neutralColor10: "#e6e6e6",
      /**
       * Minor grid lines etc.
       */
      neutralColor5: "#f2f2f2",
      /**
       * Tooltip backgroud, button fills, map null points.
       */
      neutralColor3: "#f7f7f7",
      /**
       * Drilldown clickable labels, color axis max color.
       */
      highlightColor100: "#003399",
      /**
       * Selection marker, menu hover, button hover, chart border, navigator series.
       */
      highlightColor80: "#335cad",
      /**
       * Navigator mask fill.
       */
      highlightColor60: "#6685c2",
      /**
       * Ticks and axis line.
       */
      highlightColor20: "#ccd6eb",
      /**
       * Pressed button, color axis min color.
       */
      highlightColor10: "#e6ebf5",
      /**
       * Positive indicator color
       */
      positiveColor: "#06b535",
      /**
       * Negative indicator color
       */
      negativeColor: "#f21313"
    };
    var ChartDefaults = {
      /**
       * Default `mapData` for all series. If set to a string, it functions
       * as an index into the `Highcharts.maps` array. Otherwise it is
       * interpreted as map data.
       *
       * @see [mapData](#series.map.mapData)
       *
       * @sample    maps/demo/geojson
       *            Loading geoJSON data
       * @sample    maps/chart/topojson
       *            Loading topoJSON converted to geoJSON
       *
       * @type      {string|Array<*>|Highcharts.GeoJSON}
       * @since     5.0.0
       * @product   highmaps
       * @apioption chart.map
       */
      /**
       * Set lat/lon transformation definitions for the chart. If not defined,
       * these are extracted from the map data.
       *
       * @type      {*}
       * @since     5.0.0
       * @product   highmaps
       * @apioption chart.mapTransforms
       */
      /**
       * When using multiple axis, the ticks of two or more opposite axes
       * will automatically be aligned by adding ticks to the axis or axes
       * with the least ticks, as if `tickAmount` were specified.
       *
       * This can be prevented by setting `alignTicks` to false. If the grid
       * lines look messy, it's a good idea to hide them for the secondary
       * axis by setting `gridLineWidth` to 0.
       *
       * If `startOnTick` or `endOnTick` in an Axis options are set to false,
       * then the `alignTicks ` will be disabled for the Axis.
       *
       * Disabled for logarithmic axes.
       *
       * @sample {highcharts} highcharts/chart/alignticks-true/
       *         True by default
       * @sample {highcharts} highcharts/chart/alignticks-false/
       *         False
       * @sample {highstock} stock/chart/alignticks-true/
       *         True by default
       * @sample {highstock} stock/chart/alignticks-false/
       *         False
       *
       * @type      {boolean}
       * @default   true
       * @product   highcharts highstock gantt
       * @apioption chart.alignTicks
       */
      /**
       * Set the overall animation for all chart updating. Animation can be
       * disabled throughout the chart by setting it to false here. It can
       * be overridden for each individual API method as a function parameter.
       * The only animation not affected by this option is the initial series
       * animation, see [plotOptions.series.animation](
       * #plotOptions.series.animation).
       *
       * The animation can either be set as a boolean or a configuration
       * object. If `true`, it will use the 'swing' jQuery easing and a
       * duration of 500 ms. If used as a configuration object, the following
       * properties are supported:
       *
       * - `defer`: The animation delay time in milliseconds.
       *
       * - `duration`: The duration of the animation in milliseconds.
       *
       * - `easing`: A string reference to an easing function set on the
       *   `Math` object. See
       *   [the easing demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).
       *
       * When zooming on a series with less than 100 points, the chart redraw
       * will be done with animation, but in case of more data points, it is
       * necessary to set this option to ensure animation on zoom.
       *
       * @sample {highcharts} highcharts/chart/animation-none/
       *         Updating with no animation
       * @sample {highcharts} highcharts/chart/animation-duration/
       *         With a longer duration
       * @sample {highcharts} highcharts/chart/animation-easing/
       *         With a jQuery UI easing
       * @sample {highmaps} maps/chart/animation-none/
       *         Updating with no animation
       * @sample {highmaps} maps/chart/animation-duration/
       *         With a longer duration
       *
       * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
       * @default   undefined
       * @apioption chart.animation
       */
      /**
       * A CSS class name to apply to the charts container `div`, allowing
       * unique CSS styling for each chart.
       *
       * @type      {string}
       * @apioption chart.className
       */
      /**
       * Event listeners for the chart.
       *
       * @apioption chart.events
       */
      /**
       * Fires when a series is added to the chart after load time, using the
       * `addSeries` method. One parameter, `event`, is passed to the
       * function, containing common event information. Through
       * `event.options` you can access the series options that were passed to
       * the `addSeries` method. Returning false prevents the series from
       * being added.
       *
       * @sample {highcharts} highcharts/chart/events-addseries/
       *         Alert on add series
       * @sample {highstock} stock/chart/events-addseries/
       *         Alert on add series
       *
       * @type      {Highcharts.ChartAddSeriesCallbackFunction}
       * @since     1.2.0
       * @context   Highcharts.Chart
       * @apioption chart.events.addSeries
       */
      /**
       * Fires when clicking on the plot background. One parameter, `event`,
       * is passed to the function, containing common event information.
       *
       * Information on the clicked spot can be found through `event.xAxis`
       * and `event.yAxis`, which are arrays containing the axes of each
       * dimension and each axis' value at the clicked spot. The primary axes
       * are `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
       * datetime axis is milliseconds since 1970-01-01 00:00:00.
       *
       * ```js
       * click: function(e) {
       *     console.log(
       *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', e.xAxis[0].value),
       *         e.yAxis[0].value
       *     )
       * }
       * ```
       *
       * @sample {highcharts} highcharts/chart/events-click/
       *         Alert coordinates on click
       * @sample {highcharts} highcharts/chart/events-container/
       *         Alternatively, attach event to container
       * @sample {highstock} stock/chart/events-click/
       *         Alert coordinates on click
       * @sample {highstock} highcharts/chart/events-container/
       *         Alternatively, attach event to container
       * @sample {highmaps} maps/chart/events-click/
       *         Record coordinates on click
       * @sample {highmaps} highcharts/chart/events-container/
       *         Alternatively, attach event to container
       *
       * @type      {Highcharts.ChartClickCallbackFunction}
       * @since     1.2.0
       * @context   Highcharts.Chart
       * @apioption chart.events.click
       */
      /**
       * Fires when the chart is finished loading. Since v4.2.2, it also waits
       * for images to be loaded, for example from point markers. One
       * parameter, `event`, is passed to the function, containing common
       * event information.
       *
       * There is also a second parameter to the chart constructor where a
       * callback function can be passed to be executed on chart.load.
       *
       * @sample {highcharts} highcharts/chart/events-load/
       *         Alert on chart load
       * @sample {highstock} stock/chart/events-load/
       *         Alert on chart load
       * @sample {highmaps} maps/chart/events-load/
       *         Add series on chart load
       *
       * @type      {Highcharts.ChartLoadCallbackFunction}
       * @context   Highcharts.Chart
       * @apioption chart.events.load
       */
      /**
       * Fires when the chart is redrawn, either after a call to
       * `chart.redraw()` or after an axis, series or point is modified with
       * the `redraw` option set to `true`. One parameter, `event`, is passed
       * to the function, containing common event information.
       *
       * @sample {highcharts} highcharts/chart/events-redraw/
       *         Alert on chart redraw
       * @sample {highstock} stock/chart/events-redraw/
       *         Alert on chart redraw when adding a series or moving the
       *         zoomed range
       * @sample {highmaps} maps/chart/events-redraw/
       *         Set subtitle on chart redraw
       *
       * @type      {Highcharts.ChartRedrawCallbackFunction}
       * @since     1.2.0
       * @context   Highcharts.Chart
       * @apioption chart.events.redraw
       */
      /**
       * Fires after initial load of the chart (directly after the `load`
       * event), and after each redraw (directly after the `redraw` event).
       *
       * @type      {Highcharts.ChartRenderCallbackFunction}
       * @since     5.0.7
       * @context   Highcharts.Chart
       * @apioption chart.events.render
       */
      /**
       * Fires when an area of the chart has been selected. Selection is
       * enabled by setting the chart's zoomType. One parameter, `event`, is
       * passed to the function, containing common event information. The
       * default action for the selection event is to zoom the chart to the
       * selected area. It can be prevented by calling
       * `event.preventDefault()` or return false.
       *
       * Information on the selected area can be found through `event.xAxis`
       * and `event.yAxis`, which are arrays containing the axes of each
       * dimension and each axis' min and max values. The primary axes are
       * `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
       * datetime axis is milliseconds since 1970-01-01 00:00:00.
       *
       * ```js
       * selection: function(event) {
       *     // log the min and max of the primary, datetime x-axis
       *     console.log(
       *         Highcharts.dateFormat(
       *             '%Y-%m-%d %H:%M:%S',
       *             event.xAxis[0].min
       *         ),
       *         Highcharts.dateFormat(
       *             '%Y-%m-%d %H:%M:%S',
       *             event.xAxis[0].max
       *         )
       *     );
       *     // log the min and max of the y axis
       *     console.log(event.yAxis[0].min, event.yAxis[0].max);
       * }
       * ```
       *
       * @sample {highcharts} highcharts/chart/events-selection/
       *         Report on selection and reset
       * @sample {highcharts} highcharts/chart/events-selection-points/
       *         Select a range of points through a drag selection
       * @sample {highstock} stock/chart/events-selection/
       *         Report on selection and reset
       * @sample {highstock} highcharts/chart/events-selection-points/
       *         Select a range of points through a drag selection
       *         (Highcharts)
       *
       * @type      {Highcharts.ChartSelectionCallbackFunction}
       * @apioption chart.events.selection
       */
      /**
       * The margin between the outer edge of the chart and the plot area.
       * The numbers in the array designate top, right, bottom and left
       * respectively. Use the options `marginTop`, `marginRight`,
       * `marginBottom` and `marginLeft` for shorthand setting of one option.
       *
       * By default there is no margin. The actual space is dynamically
       * calculated from the offset of axis labels, axis title, title,
       * subtitle and legend in addition to the `spacingTop`, `spacingRight`,
       * `spacingBottom` and `spacingLeft` options.
       *
       * @sample {highcharts} highcharts/chart/margins-zero/
       *         Zero margins
       * @sample {highstock} stock/chart/margin-zero/
       *         Zero margins
       *
       * @type      {number|Array<number>}
       * @apioption chart.margin
       */
      /**
       * The margin between the bottom outer edge of the chart and the plot
       * area. Use this to set a fixed pixel value for the margin as opposed
       * to the default dynamic margin. See also `spacingBottom`.
       *
       * @sample {highcharts} highcharts/chart/marginbottom/
       *         100px bottom margin
       * @sample {highstock} stock/chart/marginbottom/
       *         100px bottom margin
       * @sample {highmaps} maps/chart/margin/
       *         100px margins
       *
       * @type      {number}
       * @since     2.0
       * @apioption chart.marginBottom
       */
      /**
       * The margin between the left outer edge of the chart and the plot
       * area. Use this to set a fixed pixel value for the margin as opposed
       * to the default dynamic margin. See also `spacingLeft`.
       *
       * @sample {highcharts} highcharts/chart/marginleft/
       *         150px left margin
       * @sample {highstock} stock/chart/marginleft/
       *         150px left margin
       * @sample {highmaps} maps/chart/margin/
       *         100px margins
       *
       * @type      {number}
       * @since     2.0
       * @apioption chart.marginLeft
       */
      /**
       * The margin between the right outer edge of the chart and the plot
       * area. Use this to set a fixed pixel value for the margin as opposed
       * to the default dynamic margin. See also `spacingRight`.
       *
       * @sample {highcharts} highcharts/chart/marginright/
       *         100px right margin
       * @sample {highstock} stock/chart/marginright/
       *         100px right margin
       * @sample {highmaps} maps/chart/margin/
       *         100px margins
       *
       * @type      {number}
       * @since     2.0
       * @apioption chart.marginRight
       */
      /**
       * The margin between the top outer edge of the chart and the plot area.
       * Use this to set a fixed pixel value for the margin as opposed to
       * the default dynamic margin. See also `spacingTop`.
       *
       * @sample {highcharts} highcharts/chart/margintop/ 100px top margin
       * @sample {highstock} stock/chart/margintop/
       *         100px top margin
       * @sample {highmaps} maps/chart/margin/
       *         100px margins
       *
       * @type      {number}
       * @since     2.0
       * @apioption chart.marginTop
       */
      /**
       * Callback function to override the default function that formats all
       * the numbers in the chart. Returns a string with the formatted number.
       *
       * @sample highcharts/members/highcharts-numberformat
       *      Arabic digits in Highcharts
       * @type {Highcharts.NumberFormatterCallbackFunction}
       * @since 8.0.0
       * @apioption chart.numberFormatter
       */
      /**
       * Allows setting a key to switch between zooming and panning. Can be
       * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows
       * key on Windows) or `shift`. The keys are mapped directly to the key
       * properties of the click event argument (`event.altKey`,
       * `event.ctrlKey`, `event.metaKey` and `event.shiftKey`).
       *
       * @type       {string}
       * @since      4.0.3
       * @product    highcharts gantt
       * @validvalue ["alt", "ctrl", "meta", "shift"]
       * @apioption  chart.panKey
       */
      /**
       * Allow panning in a chart. Best used with [panKey](#chart.panKey)
       * to combine zooming and panning.
       *
       * On touch devices, when the [tooltip.followTouchMove](
       * #tooltip.followTouchMove) option is `true` (default), panning
       * requires two fingers. To allow panning with one finger, set
       * `followTouchMove` to `false`.
       *
       * @sample  {highcharts} highcharts/chart/pankey/ Zooming and panning
       * @sample  {highstock} stock/chart/panning/ Zooming and xy panning
       */
      panning: {
        /**
         * Enable or disable chart panning.
         *
         * @type      {boolean}
         * @default   {highcharts} false
         * @default   {highstock|highmaps} true
         */
        enabled: false,
        /**
         * Decides in what dimensions the user can pan the chart. Can be
         * one of `x`, `y`, or `xy`.
         *
         * @sample {highcharts} highcharts/chart/panning-type
         *         Zooming and xy panning
         *
         * @type       {string}
         * @validvalue ["x", "y", "xy"]
         * @default    {highcharts|highstock} x
         * @default    {highmaps} xy
         */
        type: "x"
      },
      /**
       * Equivalent to [zoomType](#chart.zoomType), but for multitouch
       * gestures only. By default, the `pinchType` is the same as the
       * `zoomType` setting. However, pinching can be enabled separately in
       * some cases, for example in stock charts where a mouse drag pans the
       * chart, while pinching is enabled. When [tooltip.followTouchMove](
       * #tooltip.followTouchMove) is true, pinchType only applies to
       * two-finger touches.
       *
       * @type       {string}
       * @default    {highcharts} undefined
       * @default    {highstock} x
       * @since      3.0
       * @product    highcharts highstock gantt
       * @validvalue ["x", "y", "xy"]
       * @apioption  chart.pinchType
       */
      /**
       * Whether to apply styled mode. When in styled mode, no presentational
       * attributes or CSS are applied to the chart SVG. Instead, CSS rules
       * are required to style the chart. The default style sheet is
       * available from `https://code.highcharts.com/css/highcharts.css`.
       *
       * @type       {boolean}
       * @default    false
       * @since      7.0
       * @apioption  chart.styledMode
       */
      styledMode: false,
      /**
       * The corner radius of the outer chart border.
       *
       * @sample {highcharts} highcharts/chart/borderradius/
       *         20px radius
       * @sample {highstock} stock/chart/border/
       *         10px radius
       * @sample {highmaps} maps/chart/border/
       *         Border options
       *
       */
      borderRadius: 0,
      /**
       * In styled mode, this sets how many colors the class names
       * should rotate between. With ten colors, series (or points) are
       * given class names like `highcharts-color-0`, `highcharts-color-0`
       * [...] `highcharts-color-9`. The equivalent in non-styled mode
       * is to set colors using the [colors](#colors) setting.
       *
       * @since      5.0.0
       */
      colorCount: 10,
      /**
       * Alias of `type`.
       *
       * @sample {highcharts} highcharts/chart/defaultseriestype/
       *         Bar
       *
       * @deprecated
       *
       * @product highcharts
       */
      defaultSeriesType: "line",
      /**
       * If true, the axes will scale to the remaining visible series once
       * one series is hidden. If false, hiding and showing a series will
       * not affect the axes or the other series. For stacks, once one series
       * within the stack is hidden, the rest of the stack will close in
       * around it even if the axis is not affected.
       *
       * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/
       *         True by default
       * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/
       *         False
       * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/
       *         True with stack
       * @sample {highstock} stock/chart/ignorehiddenseries-true/
       *         True by default
       * @sample {highstock} stock/chart/ignorehiddenseries-false/
       *         False
       *
       * @since   1.2.0
       * @product highcharts highstock gantt
       */
      ignoreHiddenSeries: true,
      /**
       * Whether to invert the axes so that the x axis is vertical and y axis
       * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)
       * by default.
       *
       * @productdesc {highcharts}
       * If a bar series is present in the chart, it will be inverted
       * automatically. Inverting the chart doesn't have an effect if there
       * are no cartesian series in the chart, or if the chart is
       * [polar](#chart.polar).
       *
       * @sample {highcharts} highcharts/chart/inverted/
       *         Inverted line
       * @sample {highstock} stock/navigator/inverted/
       *         Inverted stock chart
       *
       * @type      {boolean}
       * @default   false
       * @product   highcharts highstock gantt
       * @apioption chart.inverted
       */
      /**
       * The distance between the outer edge of the chart and the content,
       * like title or legend, or axis title and labels if present. The
       * numbers in the array designate top, right, bottom and left
       * respectively. Use the options spacingTop, spacingRight, spacingBottom
       * and spacingLeft options for shorthand setting of one option.
       *
       * @type    {Array<number>}
       * @see     [chart.margin](#chart.margin)
       * @default [10, 10, 15, 10]
       * @since   3.0.6
       */
      spacing: [10, 10, 15, 10],
      /**
       * The button that appears after a selection zoom, allowing the user
       * to reset zoom.
       */
      resetZoomButton: {
        /**
         * What frame the button placement should be related to. Can be
         * either `plotBox` or `spacingBox`.
         *
         * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
         *         Relative to the chart
         * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
         *         Relative to the chart
         *
         * @type       {Highcharts.ButtonRelativeToValue}
         * @default    plot
         * @since      2.2
         * @apioption  chart.resetZoomButton.relativeTo
         */
        /**
         * A collection of attributes for the button. The object takes SVG
         * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
         * border radius. The theme also supports `style`, a collection of
         * CSS properties for the text. Equivalent attributes for the hover
         * state are given in `theme.states.hover`.
         *
         * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
         *         Theming the button
         * @sample {highstock} highcharts/chart/resetzoombutton-theme/
         *         Theming the button
         *
         * @type {Highcharts.SVGAttributes}
         * @since 2.2
         */
        theme: {
          /** @internal */
          zIndex: 6
        },
        /**
         * The position of the button.
         *
         * @sample {highcharts} highcharts/chart/resetzoombutton-position/
         *         Above the plot area
         * @sample {highstock} highcharts/chart/resetzoombutton-position/
         *         Above the plot area
         * @sample {highmaps} highcharts/chart/resetzoombutton-position/
         *         Above the plot area
         *
         * @type  {Highcharts.AlignObject}
         * @since 2.2
         */
        position: {
          /**
           * The horizontal alignment of the button.
           */
          align: "right",
          /**
           * The horizontal offset of the button.
           */
          x: -10,
          /**
           * The vertical alignment of the button.
           *
           * @type       {Highcharts.VerticalAlignValue}
           * @default    top
           * @apioption  chart.resetZoomButton.position.verticalAlign
           */
          /**
           * The vertical offset of the button.
           */
          y: 10
        }
      },
      /**
       * The pixel width of the plot area border.
       *
       * @sample {highcharts} highcharts/chart/plotborderwidth/
       *         1px border
       * @sample {highstock} stock/chart/plotborder/
       *         2px border
       * @sample {highmaps} maps/chart/plotborder/
       *         Plot border options
       *
       * @type      {number}
       * @default   0
       * @apioption chart.plotBorderWidth
       */
      /**
       * Whether to apply a drop shadow to the plot area. Requires that
       * plotBackgroundColor be set. The shadow can be an object configuration
       * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
       *
       * @sample {highcharts} highcharts/chart/plotshadow/
       *         Plot shadow
       * @sample {highstock} stock/chart/plotshadow/
       *         Plot shadow
       * @sample {highmaps} maps/chart/plotborder/
       *         Plot border options
       *
       * @type      {boolean|Highcharts.CSSObject}
       * @default   false
       * @apioption chart.plotShadow
       */
      /**
       * When true, cartesian charts like line, spline, area and column are
       * transformed into the polar coordinate system. This produces _polar
       * charts_, also known as _radar charts_.
       *
       * @sample {highcharts} highcharts/demo/polar/
       *         Polar chart
       * @sample {highcharts} highcharts/demo/polar-wind-rose/
       *         Wind rose, stacked polar column chart
       * @sample {highcharts} highcharts/demo/polar-spider/
       *         Spider web chart
       * @sample {highcharts} highcharts/parallel-coordinates/polar/
       *         Star plot, multivariate data in a polar chart
       *
       * @type      {boolean}
       * @default   false
       * @since     2.3.0
       * @product   highcharts
       * @requires  highcharts-more
       * @apioption chart.polar
       */
      /**
       * Whether to reflow the chart to fit the width of the container div
       * on resizing the window.
       *
       * @sample {highcharts} highcharts/chart/reflow-true/
       *         True by default
       * @sample {highcharts} highcharts/chart/reflow-false/
       *         False
       * @sample {highstock} stock/chart/reflow-true/
       *         True by default
       * @sample {highstock} stock/chart/reflow-false/
       *         False
       * @sample {highmaps} maps/chart/reflow-true/
       *         True by default
       * @sample {highmaps} maps/chart/reflow-false/
       *         False
       *
       * @type      {boolean}
       * @default   true
       * @since     2.1
       * @apioption chart.reflow
       */
      /**
       * The HTML element where the chart will be rendered. If it is a string,
       * the element by that id is used. The HTML element can also be passed
       * by direct reference, or as the first argument of the chart
       * constructor, in which case the option is not needed.
       *
       * @sample {highcharts} highcharts/chart/reflow-true/
       *         String
       * @sample {highcharts} highcharts/chart/renderto-object/
       *         Object reference
       * @sample {highstock} stock/chart/renderto-string/
       *         String
       * @sample {highstock} stock/chart/renderto-object/
       *         Object reference
       *
       * @type      {string|Highcharts.HTMLDOMElement}
       * @apioption chart.renderTo
       */
      /**
       * The background color of the marker square when selecting (zooming
       * in on) an area of the chart.
       *
       * @see In styled mode, the selection marker fill is set with the
       *      `.highcharts-selection-marker` class.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default   rgba(51,92,173,0.25)
       * @since     2.1.7
       * @apioption chart.selectionMarkerFill
       */
      /**
       * Whether to apply a drop shadow to the outer chart area. Requires
       * that backgroundColor be set. The shadow can be an object
       * configuration containing `color`, `offsetX`, `offsetY`, `opacity` and
       * `width`.
       *
       * @sample {highcharts} highcharts/chart/shadow/
       *         Shadow
       * @sample {highstock} stock/chart/shadow/
       *         Shadow
       * @sample {highmaps} maps/chart/border/
       *         Chart border and shadow
       *
       * @type      {boolean|Highcharts.CSSObject}
       * @default   false
       * @apioption chart.shadow
       */
      /**
       * Whether to show the axes initially. This only applies to empty charts
       * where series are added dynamically, as axes are automatically added
       * to cartesian series.
       *
       * @sample {highcharts} highcharts/chart/showaxes-false/
       *         False by default
       * @sample {highcharts} highcharts/chart/showaxes-true/
       *         True
       *
       * @type      {boolean}
       * @since     1.2.5
       * @product   highcharts gantt
       * @apioption chart.showAxes
       */
      /**
       * The space between the bottom edge of the chart and the content (plot
       * area, axis title and labels, title, subtitle or legend in top
       * position).
       *
       * @sample {highcharts} highcharts/chart/spacingbottom/
       *         Spacing bottom set to 100
       * @sample {highstock} stock/chart/spacingbottom/
       *         Spacing bottom set to 100
       * @sample {highmaps} maps/chart/spacing/
       *         Spacing 100 all around
       *
       * @type      {number}
       * @default   15
       * @since     2.1
       * @apioption chart.spacingBottom
       */
      /**
       * The space between the left edge of the chart and the content (plot
       * area, axis title and labels, title, subtitle or legend in top
       * position).
       *
       * @sample {highcharts} highcharts/chart/spacingleft/
       *         Spacing left set to 100
       * @sample {highstock} stock/chart/spacingleft/
       *         Spacing left set to 100
       * @sample {highmaps} maps/chart/spacing/
       *         Spacing 100 all around
       *
       * @type      {number}
       * @default   10
       * @since     2.1
       * @apioption chart.spacingLeft
       */
      /**
       * The space between the right edge of the chart and the content (plot
       * area, axis title and labels, title, subtitle or legend in top
       * position).
       *
       * @sample {highcharts} highcharts/chart/spacingright-100/
       *         Spacing set to 100
       * @sample {highcharts} highcharts/chart/spacingright-legend/
       *         Legend in right position with default spacing
       * @sample {highstock} stock/chart/spacingright/
       *         Spacing set to 100
       * @sample {highmaps} maps/chart/spacing/
       *         Spacing 100 all around
       *
       * @type      {number}
       * @default   10
       * @since     2.1
       * @apioption chart.spacingRight
       */
      /**
       * The space between the top edge of the chart and the content (plot
       * area, axis title and labels, title, subtitle or legend in top
       * position).
       *
       * @sample {highcharts} highcharts/chart/spacingtop-100/
       *         A top spacing of 100
       * @sample {highcharts} highcharts/chart/spacingtop-10/
       *         Floating chart title makes the plot area align to the default
       *         spacingTop of 10.
       * @sample {highstock} stock/chart/spacingtop/
       *         A top spacing of 100
       * @sample {highmaps} maps/chart/spacing/
       *         Spacing 100 all around
       *
       * @type      {number}
       * @default   10
       * @since     2.1
       * @apioption chart.spacingTop
       */
      /**
       * Additional CSS styles to apply inline to the container `div`. Note
       * that since the default font styles are applied in the renderer, it
       * is ignorant of the individual chart options and must be set globally.
       *
       * @see    In styled mode, general chart styles can be set with the
       *         `.highcharts-root` class.
       * @sample {highcharts} highcharts/chart/style-serif-font/
       *         Using a serif type font
       * @sample {highcharts} highcharts/css/em/
       *         Styled mode with relative font sizes
       * @sample {highstock} stock/chart/style/
       *         Using a serif type font
       * @sample {highmaps} maps/chart/style-serif-font/
       *         Using a serif type font
       *
       * @type      {Highcharts.CSSObject}
       * @default   {"fontFamily": "\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif","fontSize":"12px"}
       * @apioption chart.style
       */
      /**
       * The default series type for the chart. Can be any of the chart types
       * listed under [plotOptions](#plotOptions) and [series](#series) or can
       * be a series provided by an additional module.
       *
       * In TypeScript this option has no effect in sense of typing and
       * instead the `type` option must always be set in the series.
       *
       * @sample {highcharts} highcharts/chart/type-bar/
       *         Bar
       * @sample {highstock} stock/chart/type/
       *         Areaspline
       * @sample {highmaps} maps/chart/type-mapline/
       *         Mapline
       *
       * @type       {string}
       * @default    {highcharts} line
       * @default    {highstock} line
       * @default    {highmaps} map
       * @since      2.1.0
       * @apioption  chart.type
       */
      /**
       * Decides in what dimensions the user can zoom by dragging the mouse.
       * Can be one of `x`, `y` or `xy`.
       *
       * @see [panKey](#chart.panKey)
       *
       * @sample {highcharts} highcharts/chart/zoomtype-none/
       *         None by default
       * @sample {highcharts} highcharts/chart/zoomtype-x/
       *         X
       * @sample {highcharts} highcharts/chart/zoomtype-y/
       *         Y
       * @sample {highcharts} highcharts/chart/zoomtype-xy/
       *         Xy
       * @sample {highstock} stock/demo/basic-line/
       *         None by default
       * @sample {highstock} stock/chart/zoomtype-x/
       *         X
       * @sample {highstock} stock/chart/zoomtype-y/
       *         Y
       * @sample {highstock} stock/chart/zoomtype-xy/
       *         Xy
       *
       * @type       {string}
       * @product    highcharts highstock gantt
       * @validvalue ["x", "y", "xy"]
       * @apioption  chart.zoomType
       */
      /**
       * Enables zooming by a single touch, in combination with
       * [chart.zoomType](#chart.zoomType). When enabled, two-finger pinch
       * will still work as set up by [chart.pinchType](#chart.pinchType).
       * However, `zoomBySingleTouch` will interfere with touch-dragging the
       * chart to read the tooltip. And especially when vertical zooming is
       * enabled, it will make it hard to scroll vertically on the page.
       * @since 9.0.0
       * @sample     highcharts/chart/zoombysingletouch
       *             Zoom by single touch enabled, with buttons to toggle
       * @product    highcharts highstock gantt
       */
      zoomBySingleTouch: false,
      /**
       * An explicit width for the chart. By default (when `null`) the width
       * is calculated from the offset width of the containing element.
       *
       * @sample {highcharts} highcharts/chart/width/
       *         800px wide
       * @sample {highstock} stock/chart/width/
       *         800px wide
       * @sample {highmaps} maps/chart/size/
       *         Chart with explicit size
       *
       * @type {null|number|string}
       */
      width: null,
      /**
       * An explicit height for the chart. If a _number_, the height is
       * given in pixels. If given a _percentage string_ (for example
       * `'56%'`), the height is given as the percentage of the actual chart
       * width. This allows for preserving the aspect ratio across responsive
       * sizes.
       *
       * By default (when `null`) the height is calculated from the offset
       * height of the containing element, or 400 pixels if the containing
       * element's height is 0.
       *
       * @sample {highcharts} highcharts/chart/height/
       *         500px height
       * @sample {highstock} stock/chart/height/
       *         300px height
       * @sample {highmaps} maps/chart/size/
       *         Chart with explicit size
       * @sample highcharts/chart/height-percent/
       *         Highcharts with percentage height
       *
       * @type {null|number|string}
       */
      height: null,
      /**
       * The color of the outer chart border.
       *
       * @see In styled mode, the stroke is set with the
       *      `.highcharts-background` class.
       *
       * @sample {highcharts} highcharts/chart/bordercolor/
       *         Brown border
       * @sample {highstock} stock/chart/border/
       *         Brown border
       * @sample {highmaps} maps/chart/border/
       *         Border options
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      borderColor: palette.highlightColor80,
      /**
       * The pixel width of the outer chart border.
       *
       * @see In styled mode, the stroke is set with the
       *      `.highcharts-background` class.
       *
       * @sample {highcharts} highcharts/chart/borderwidth/
       *         5px border
       * @sample {highstock} stock/chart/border/
       *         2px border
       * @sample {highmaps} maps/chart/border/
       *         Border options
       *
       * @type      {number}
       * @default   0
       * @apioption chart.borderWidth
       */
      /**
       * The background color or gradient for the outer chart area.
       *
       * @see In styled mode, the background is set with the
       *      `.highcharts-background` class.
       *
       * @sample {highcharts} highcharts/chart/backgroundcolor-color/
       *         Color
       * @sample {highcharts} highcharts/chart/backgroundcolor-gradient/
       *         Gradient
       * @sample {highstock} stock/chart/backgroundcolor-color/
       *         Color
       * @sample {highstock} stock/chart/backgroundcolor-gradient/
       *         Gradient
       * @sample {highmaps} maps/chart/backgroundcolor-color/
       *         Color
       * @sample {highmaps} maps/chart/backgroundcolor-gradient/
       *         Gradient
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      backgroundColor: palette.backgroundColor,
      /**
       * The background color or gradient for the plot area.
       *
       * @see In styled mode, the plot background is set with the
       *      `.highcharts-plot-background` class.
       *
       * @sample {highcharts} highcharts/chart/plotbackgroundcolor-color/
       *         Color
       * @sample {highcharts} highcharts/chart/plotbackgroundcolor-gradient/
       *         Gradient
       * @sample {highstock} stock/chart/plotbackgroundcolor-color/
       *         Color
       * @sample {highstock} stock/chart/plotbackgroundcolor-gradient/
       *         Gradient
       * @sample {highmaps} maps/chart/plotbackgroundcolor-color/
       *         Color
       * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
       *         Gradient
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @apioption chart.plotBackgroundColor
       */
      /**
       * The URL for an image to use as the plot background. To set an image
       * as the background for the entire chart, set a CSS background image
       * to the container element. Note that for the image to be applied to
       * exported charts, its URL needs to be accessible by the export server.
       *
       * @see In styled mode, a plot background image can be set with the
       *      `.highcharts-plot-background` class and a [custom pattern](
       *      https://www.highcharts.com/docs/chart-design-and-style/
       *      gradients-shadows-and-patterns).
       *
       * @sample {highcharts} highcharts/chart/plotbackgroundimage/
       *         Skies
       * @sample {highstock} stock/chart/plotbackgroundimage/
       *         Skies
       *
       * @type      {string}
       * @apioption chart.plotBackgroundImage
       */
      /**
       * The color of the inner chart or plot area border.
       *
       * @see In styled mode, a plot border stroke can be set with the
       *      `.highcharts-plot-border` class.
       *
       * @sample {highcharts} highcharts/chart/plotbordercolor/
       *         Blue border
       * @sample {highstock} stock/chart/plotborder/
       *         Blue border
       * @sample {highmaps} maps/chart/plotborder/
       *         Plot border options
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      plotBorderColor: palette.neutralColor20
    };
    var isNumber$Q = Utilities.isNumber, merge$1o = Utilities.merge, pInt$9 = Utilities.pInt;
    var Color = (
      /** @class */
      function() {
        function Color2(input) {
          this.rgba = [NaN, NaN, NaN, NaN];
          this.input = input;
          var GlobalColor = H.Color;
          if (GlobalColor && GlobalColor !== Color2) {
            return new GlobalColor(input);
          }
          if (!(this instanceof Color2)) {
            return new Color2(input);
          }
          this.init(input);
        }
        Color2.parse = function(input) {
          return input ? new Color2(input) : Color2.None;
        };
        Color2.prototype.init = function(input) {
          var result2, rgba, i, parser;
          if (typeof input === "object" && typeof input.stops !== "undefined") {
            this.stops = input.stops.map(function(stop2) {
              return new Color2(stop2[1]);
            });
          } else if (typeof input === "string") {
            this.input = input = Color2.names[input.toLowerCase()] || input;
            if (input.charAt(0) === "#") {
              var len = input.length, col = parseInt(input.substr(1), 16);
              if (len === 7) {
                rgba = [
                  (col & 16711680) >> 16,
                  (col & 65280) >> 8,
                  col & 255,
                  1
                ];
              } else if (len === 4) {
                rgba = [
                  (col & 3840) >> 4 | (col & 3840) >> 8,
                  (col & 240) >> 4 | col & 240,
                  (col & 15) << 4 | col & 15,
                  1
                ];
              }
            }
            if (!rgba) {
              i = Color2.parsers.length;
              while (i-- && !rgba) {
                parser = Color2.parsers[i];
                result2 = parser.regex.exec(input);
                if (result2) {
                  rgba = parser.parse(result2);
                }
              }
            }
          }
          if (rgba) {
            this.rgba = rgba;
          }
        };
        Color2.prototype.get = function(format2) {
          var input = this.input, rgba = this.rgba;
          if (typeof input === "object" && typeof this.stops !== "undefined") {
            var ret_1 = merge$1o(input);
            ret_1.stops = [].slice.call(ret_1.stops);
            this.stops.forEach(function(stop2, i) {
              ret_1.stops[i] = [
                ret_1.stops[i][0],
                stop2.get(format2)
              ];
            });
            return ret_1;
          }
          if (rgba && isNumber$Q(rgba[0])) {
            if (format2 === "rgb" || !format2 && rgba[3] === 1) {
              return "rgb(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + ")";
            }
            if (format2 === "a") {
              return "" + rgba[3];
            }
            return "rgba(" + rgba.join(",") + ")";
          }
          return input;
        };
        Color2.prototype.brighten = function(alpha) {
          var rgba = this.rgba;
          if (this.stops) {
            this.stops.forEach(function(stop2) {
              stop2.brighten(alpha);
            });
          } else if (isNumber$Q(alpha) && alpha !== 0) {
            for (var i = 0; i < 3; i++) {
              rgba[i] += pInt$9(alpha * 255);
              if (rgba[i] < 0) {
                rgba[i] = 0;
              }
              if (rgba[i] > 255) {
                rgba[i] = 255;
              }
            }
          }
          return this;
        };
        Color2.prototype.setOpacity = function(alpha) {
          this.rgba[3] = alpha;
          return this;
        };
        Color2.prototype.tweenTo = function(to, pos) {
          var fromRgba = this.rgba, toRgba = to.rgba;
          if (!isNumber$Q(fromRgba[0]) || !isNumber$Q(toRgba[0])) {
            return to.input || "none";
          }
          var hasAlpha = toRgba[3] !== 1 || fromRgba[3] !== 1;
          return (hasAlpha ? "rgba(" : "rgb(") + Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) + "," + Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) + "," + Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) + (hasAlpha ? "," + (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos)) : "") + ")";
        };
        Color2.names = {
          white: "#ffffff",
          black: "#000000"
        };
        Color2.parsers = [{
          // RGBA color
          // eslint-disable-next-line max-len
          regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
          parse: function(result2) {
            return [
              pInt$9(result2[1]),
              pInt$9(result2[2]),
              pInt$9(result2[3]),
              parseFloat(result2[4], 10)
            ];
          }
        }, {
          // RGB color
          regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
          parse: function(result2) {
            return [pInt$9(result2[1]), pInt$9(result2[2]), pInt$9(result2[3]), 1];
          }
        }];
        Color2.None = new Color2("");
        return Color2;
      }()
    );
    var win$f = H.win;
    var defined$V = Utilities.defined, error$9 = Utilities.error, extend$1p = Utilities.extend, isObject$e = Utilities.isObject, merge$1n = Utilities.merge, objectEach$A = Utilities.objectEach, pad$1 = Utilities.pad, pick$1A = Utilities.pick, splat$i = Utilities.splat, timeUnits$2 = Utilities.timeUnits;
    var hasNewSafariBug = H.isSafari && win$f.Intl && win$f.Intl.DateTimeFormat.prototype.formatRange;
    var hasOldSafariBug = H.isSafari && win$f.Intl && !win$f.Intl.DateTimeFormat.prototype.formatRange;
    var Time = (
      /** @class */
      function() {
        function Time2(options) {
          this.options = {};
          this.useUTC = false;
          this.variableTimezone = false;
          this.Date = win$f.Date;
          this.getTimezoneOffset = this.timezoneOffsetFunction();
          this.update(options);
        }
        Time2.prototype.get = function(unit, date) {
          if (this.variableTimezone || this.timezoneOffset) {
            var realMs = date.getTime();
            var ms = realMs - this.getTimezoneOffset(date);
            date.setTime(ms);
            var ret = date["getUTC" + unit]();
            date.setTime(realMs);
            return ret;
          }
          if (this.useUTC) {
            return date["getUTC" + unit]();
          }
          return date["get" + unit]();
        };
        Time2.prototype.set = function(unit, date, value) {
          if (this.variableTimezone || this.timezoneOffset) {
            if (unit === "Milliseconds" || unit === "Seconds" || unit === "Minutes" && this.getTimezoneOffset(date) % 36e5 === 0) {
              return date["setUTC" + unit](value);
            }
            var offset2 = this.getTimezoneOffset(date);
            var ms = date.getTime() - offset2;
            date.setTime(ms);
            date["setUTC" + unit](value);
            var newOffset = this.getTimezoneOffset(date);
            ms = date.getTime() + newOffset;
            return date.setTime(ms);
          }
          if (this.useUTC || hasNewSafariBug && unit === "FullYear") {
            return date["setUTC" + unit](value);
          }
          return date["set" + unit](value);
        };
        Time2.prototype.update = function(options) {
          var useUTC = pick$1A(options && options.useUTC, true);
          this.options = options = merge$1n(true, this.options || {}, options);
          this.Date = options.Date || win$f.Date || Date;
          this.useUTC = useUTC;
          this.timezoneOffset = useUTC && options.timezoneOffset;
          this.getTimezoneOffset = this.timezoneOffsetFunction();
          this.variableTimezone = useUTC && !!(options.getTimezoneOffset || options.timezone);
        };
        Time2.prototype.makeTime = function(year, month, date, hours, minutes, seconds) {
          var d, offset2, newOffset;
          if (this.useUTC) {
            d = this.Date.UTC.apply(0, arguments);
            offset2 = this.getTimezoneOffset(d);
            d += offset2;
            newOffset = this.getTimezoneOffset(d);
            if (offset2 !== newOffset) {
              d += newOffset - offset2;
            } else if (offset2 - 36e5 === this.getTimezoneOffset(d - 36e5) && !hasOldSafariBug) {
              d -= 36e5;
            }
          } else {
            d = new this.Date(year, month, pick$1A(date, 1), pick$1A(hours, 0), pick$1A(minutes, 0), pick$1A(seconds, 0)).getTime();
          }
          return d;
        };
        Time2.prototype.timezoneOffsetFunction = function() {
          var time = this, options = this.options, moment = options.moment || win$f.moment;
          if (!this.useUTC) {
            return function(timestamp) {
              return new Date(timestamp.toString()).getTimezoneOffset() * 6e4;
            };
          }
          if (options.timezone) {
            if (!moment) {
              error$9(25);
            } else {
              return function(timestamp) {
                return -moment.tz(timestamp, options.timezone).utcOffset() * 6e4;
              };
            }
          }
          if (this.useUTC && options.getTimezoneOffset) {
            return function(timestamp) {
              return options.getTimezoneOffset(timestamp.valueOf()) * 6e4;
            };
          }
          return function() {
            return (time.timezoneOffset || 0) * 6e4;
          };
        };
        Time2.prototype.dateFormat = function(format2, timestamp, capitalize) {
          if (!defined$V(timestamp) || isNaN(timestamp)) {
            return H.defaultOptions.lang && H.defaultOptions.lang.invalidDate || "";
          }
          format2 = pick$1A(format2, "%Y-%m-%d %H:%M:%S");
          var time = this, date = new this.Date(timestamp), hours = this.get("Hours", date), day = this.get("Day", date), dayOfMonth = this.get("Date", date), month = this.get("Month", date), fullYear = this.get("FullYear", date), lang2 = H.defaultOptions.lang, langWeekdays = lang2 && lang2.weekdays, shortWeekdays = lang2 && lang2.shortWeekdays, replacements = extend$1p({
            // Day
            // Short weekday, like 'Mon'
            a: shortWeekdays ? shortWeekdays[day] : langWeekdays[day].substr(0, 3),
            // Long weekday, like 'Monday'
            A: langWeekdays[day],
            // Two digit day of the month, 01 to 31
            d: pad$1(dayOfMonth),
            // Day of the month, 1 through 31
            e: pad$1(dayOfMonth, 2, " "),
            // Day of the week, 0 through 6
            w: day,
            // Week (none implemented)
            // 'W': weekNumber(),
            // Month
            // Short month, like 'Jan'
            b: lang2.shortMonths[month],
            // Long month, like 'January'
            B: lang2.months[month],
            // Two digit month number, 01 through 12
            m: pad$1(month + 1),
            // Month number, 1 through 12 (#8150)
            o: month + 1,
            // Year
            // Two digits year, like 09 for 2009
            y: fullYear.toString().substr(2, 2),
            // Four digits year, like 2009
            Y: fullYear,
            // Time
            // Two digits hours in 24h format, 00 through 23
            H: pad$1(hours),
            // Hours in 24h format, 0 through 23
            k: hours,
            // Two digits hours in 12h format, 00 through 11
            I: pad$1(hours % 12 || 12),
            // Hours in 12h format, 1 through 12
            l: hours % 12 || 12,
            // Two digits minutes, 00 through 59
            M: pad$1(this.get("Minutes", date)),
            // Upper case AM or PM
            p: hours < 12 ? "AM" : "PM",
            // Lower case AM or PM
            P: hours < 12 ? "am" : "pm",
            // Two digits seconds, 00 through  59
            S: pad$1(date.getSeconds()),
            // Milliseconds (naming from Ruby)
            L: pad$1(Math.floor(timestamp % 1e3), 3)
          }, H.dateFormats);
          objectEach$A(replacements, function(val, key) {
            while (format2.indexOf("%" + key) !== -1) {
              format2 = format2.replace("%" + key, typeof val === "function" ? val.call(time, timestamp) : val);
            }
          });
          return capitalize ? format2.substr(0, 1).toUpperCase() + format2.substr(1) : format2;
        };
        Time2.prototype.resolveDTLFormat = function(f) {
          if (!isObject$e(f, true)) {
            f = splat$i(f);
            return {
              main: f[0],
              from: f[1],
              to: f[2]
            };
          }
          return f;
        };
        Time2.prototype.getTimeTicks = function(normalizedInterval, min, max, startOfWeek) {
          var time = this, Date2 = time.Date, tickPositions = [], higherRanks = {}, minDate = new Date2(min), interval = normalizedInterval.unitRange, count = normalizedInterval.count || 1;
          var i, minYear, variableDayLength, minDay;
          startOfWeek = pick$1A(startOfWeek, 1);
          if (defined$V(min)) {
            time.set("Milliseconds", minDate, interval >= timeUnits$2.second ? 0 : (
              // #3935
              count * Math.floor(time.get("Milliseconds", minDate) / count)
            ));
            if (interval >= timeUnits$2.second) {
              time.set("Seconds", minDate, interval >= timeUnits$2.minute ? 0 : (
                // #3935
                count * Math.floor(time.get("Seconds", minDate) / count)
              ));
            }
            if (interval >= timeUnits$2.minute) {
              time.set("Minutes", minDate, interval >= timeUnits$2.hour ? 0 : count * Math.floor(time.get("Minutes", minDate) / count));
            }
            if (interval >= timeUnits$2.hour) {
              time.set("Hours", minDate, interval >= timeUnits$2.day ? 0 : count * Math.floor(time.get("Hours", minDate) / count));
            }
            if (interval >= timeUnits$2.day) {
              time.set("Date", minDate, interval >= timeUnits$2.month ? 1 : Math.max(1, count * Math.floor(time.get("Date", minDate) / count)));
            }
            if (interval >= timeUnits$2.month) {
              time.set("Month", minDate, interval >= timeUnits$2.year ? 0 : count * Math.floor(time.get("Month", minDate) / count));
              minYear = time.get("FullYear", minDate);
            }
            if (interval >= timeUnits$2.year) {
              minYear -= minYear % count;
              time.set("FullYear", minDate, minYear);
            }
            if (interval === timeUnits$2.week) {
              minDay = time.get("Day", minDate);
              time.set("Date", minDate, time.get("Date", minDate) - minDay + startOfWeek + // We don't want to skip days that are before
              // startOfWeek (#7051)
              (minDay < startOfWeek ? -7 : 0));
            }
            minYear = time.get("FullYear", minDate);
            var minMonth = time.get("Month", minDate), minDateDate = time.get("Date", minDate), minHours = time.get("Hours", minDate);
            min = minDate.getTime();
            if ((time.variableTimezone || !time.useUTC) && defined$V(max)) {
              variableDayLength = // Long range, assume we're crossing over.
              max - min > 4 * timeUnits$2.month || // Short range, check if min and max are in different time
              // zones.
              time.getTimezoneOffset(min) !== time.getTimezoneOffset(max);
            }
            var t = minDate.getTime();
            i = 1;
            while (t < max) {
              tickPositions.push(t);
              if (interval === timeUnits$2.year) {
                t = time.makeTime(minYear + i * count, 0);
              } else if (interval === timeUnits$2.month) {
                t = time.makeTime(minYear, minMonth + i * count);
              } else if (variableDayLength && (interval === timeUnits$2.day || interval === timeUnits$2.week)) {
                t = time.makeTime(minYear, minMonth, minDateDate + i * count * (interval === timeUnits$2.day ? 1 : 7));
              } else if (variableDayLength && interval === timeUnits$2.hour && count > 1) {
                t = time.makeTime(minYear, minMonth, minDateDate, minHours + i * count);
              } else {
                t += interval * count;
              }
              i++;
            }
            tickPositions.push(t);
            if (interval <= timeUnits$2.hour && tickPositions.length < 1e4) {
              tickPositions.forEach(function(t2) {
                if (
                  // Speed optimization, no need to run dateFormat unless
                  // we're on a full or half hour
                  t2 % 18e5 === 0 && // Check for local or global midnight
                  time.dateFormat("%H%M%S%L", t2) === "000000000"
                ) {
                  higherRanks[t2] = "day";
                }
              });
            }
          }
          tickPositions.info = extend$1p(normalizedInterval, {
            higherRanks,
            totalRange: interval * count
          });
          return tickPositions;
        };
        Time2.prototype.getDateFormat = function(range, timestamp, startOfWeek, dateTimeLabelFormats) {
          var dateStr = this.dateFormat("%m-%d %H:%M:%S.%L", timestamp), blank = "01-01 00:00:00.000", strpos = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
          };
          var format2, n, lastN = "millisecond";
          for (n in timeUnits$2) {
            if (range === timeUnits$2.week && +this.dateFormat("%w", timestamp) === startOfWeek && dateStr.substr(6) === blank.substr(6)) {
              n = "week";
              break;
            }
            if (timeUnits$2[n] > range) {
              n = lastN;
              break;
            }
            if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
              break;
            }
            if (n !== "week") {
              lastN = n;
            }
          }
          if (n) {
            format2 = this.resolveDTLFormat(dateTimeLabelFormats[n]).main;
          }
          return format2;
        };
        return Time2;
      }()
    );
    var color$g = Color.parse;
    var isTouchDevice$4 = H.isTouchDevice, svg$5 = H.svg;
    var merge$1m = Utilities.merge;
    var defaultOptions$g = {
      /**
       * An array containing the default colors for the chart's series. When
       * all colors are used, new colors are pulled from the start again.
       *
       * Default colors can also be set on a series or series.type basis,
       * see [column.colors](#plotOptions.column.colors),
       * [pie.colors](#plotOptions.pie.colors).
       *
       * In styled mode, the colors option doesn't exist. Instead, colors
       * are defined in CSS and applied either through series or point class
       * names, or through the [chart.colorCount](#chart.colorCount) option.
       *
       *
       * ### Legacy
       *
       * In Highcharts 3.x, the default colors were:
       * ```js
       * colors: ['#2f7ed8', '#0d233a', '#8bbc21', '#910000', '#1aadce',
       *         '#492970', '#f28f43', '#77a1e5', '#c42525', '#a6c96a']
       * ```
       *
       * In Highcharts 2.x, the default colors were:
       * ```js
       * colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
       *         '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92']
       * ```
       *
       * @sample {highcharts} highcharts/chart/colors/
       *         Assign a global color theme
       *
       * @type    {Array<Highcharts.ColorString>}
       * @default ["#7cb5ec", "#434348", "#90ed7d", "#f7a35c", "#8085e9",
       *          "#f15c80", "#e4d354", "#2b908f", "#f45b5b", "#91e8e1"]
       */
      colors: palette.colors,
      /**
       * Styled mode only. Configuration object for adding SVG definitions for
       * reusable elements. See [gradients, shadows and
       * patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns)
       * for more information and code examples.
       *
       * @type      {*}
       * @since     5.0.0
       * @apioption defs
       */
      /**
       * @ignore-option
       */
      symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
      /**
       * The language object is global and it can't be set on each chart
       * initialization. Instead, use `Highcharts.setOptions` to set it before any
       * chart is initialized.
       *
       * ```js
       * Highcharts.setOptions({
       *     lang: {
       *         months: [
       *             'Janvier', 'Fvrier', 'Mars', 'Avril',
       *             'Mai', 'Juin', 'Juillet', 'Aot',
       *             'Septembre', 'Octobre', 'Novembre', 'Dcembre'
       *         ],
       *         weekdays: [
       *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',
       *             'Jeudi', 'Vendredi', 'Samedi'
       *         ]
       *     }
       * });
       * ```
       */
      lang: {
        /**
         * The loading text that appears when the chart is set into the loading
         * state following a call to `chart.showLoading`.
         */
        loading: "Loading...",
        /**
         * An array containing the months names. Corresponds to the `%B` format
         * in `Highcharts.dateFormat()`.
         *
         * @type    {Array<string>}
         * @default ["January", "February", "March", "April", "May", "June",
         *          "July", "August", "September", "October", "November",
         *          "December"]
         */
        months: [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ],
        /**
         * An array containing the months names in abbreviated form. Corresponds
         * to the `%b` format in `Highcharts.dateFormat()`.
         *
         * @type    {Array<string>}
         * @default ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
         *          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
         */
        shortMonths: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ],
        /**
         * An array containing the weekday names.
         *
         * @type    {Array<string>}
         * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
         *          "Friday", "Saturday"]
         */
        weekdays: [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday"
        ],
        /**
         * Short week days, starting Sunday. If not specified, Highcharts uses
         * the first three letters of the `lang.weekdays` option.
         *
         * @sample highcharts/lang/shortweekdays/
         *         Finnish two-letter abbreviations
         *
         * @type      {Array<string>}
         * @since     4.2.4
         * @apioption lang.shortWeekdays
         */
        /**
         * What to show in a date field for invalid dates. Defaults to an empty
         * string.
         *
         * @type      {string}
         * @since     4.1.8
         * @product   highcharts highstock
         * @apioption lang.invalidDate
         */
        /**
         * The title appearing on hovering the zoom in button. The text itself
         * defaults to "+" and can be changed in the button options.
         *
         * @type      {string}
         * @default   Zoom in
         * @product   highmaps
         * @apioption lang.zoomIn
         */
        /**
         * The title appearing on hovering the zoom out button. The text itself
         * defaults to "-" and can be changed in the button options.
         *
         * @type      {string}
         * @default   Zoom out
         * @product   highmaps
         * @apioption lang.zoomOut
         */
        /**
         * The default decimal point used in the `Highcharts.numberFormat`
         * method unless otherwise specified in the function arguments.
         *
         * @since 1.2.2
         */
        decimalPoint: ".",
        /**
         * [Metric prefixes](https://en.wikipedia.org/wiki/Metric_prefix) used
         * to shorten high numbers in axis labels. Replacing any of the
         * positions with `null` causes the full number to be written. Setting
         * `numericSymbols` to `null` disables shortening altogether.
         *
         * @sample {highcharts} highcharts/lang/numericsymbols/
         *         Replacing the symbols with text
         * @sample {highstock} highcharts/lang/numericsymbols/
         *         Replacing the symbols with text
         *
         * @type    {Array<string>}
         * @default ["k", "M", "G", "T", "P", "E"]
         * @since   2.3.0
         */
        numericSymbols: ["k", "M", "G", "T", "P", "E"],
        /**
         * The magnitude of [numericSymbols](#lang.numericSymbol) replacements.
         * Use 10000 for Japanese, Korean and various Chinese locales, which
         * use symbols for 10^4, 10^8 and 10^12.
         *
         * @sample highcharts/lang/numericsymbolmagnitude/
         *         10000 magnitude for Japanese
         *
         * @type      {number}
         * @default   1000
         * @since     5.0.3
         * @apioption lang.numericSymbolMagnitude
         */
        /**
         * The text for the label appearing when a chart is zoomed.
         *
         * @since 1.2.4
         */
        resetZoom: "Reset zoom",
        /**
         * The tooltip title for the label appearing when a chart is zoomed.
         *
         * @since 1.2.4
         */
        resetZoomTitle: "Reset zoom level 1:1",
        /**
         * The default thousands separator used in the `Highcharts.numberFormat`
         * method unless otherwise specified in the function arguments. Defaults
         * to a single space character, which is recommended in
         * [ISO 31-0](https://en.wikipedia.org/wiki/ISO_31-0#Numbers) and works
         * across Anglo-American and continental European languages.
         *
         * @default \u0020
         * @since   1.2.2
         */
        thousandsSep: " "
      },
      /**
       * Global options that don't apply to each chart. These options, like
       * the `lang` options, must be set using the `Highcharts.setOptions`
       * method.
       *
       * ```js
       * Highcharts.setOptions({
       *     global: {
       *         useUTC: false
       *     }
       * });
       * ```
       */
      /**
       * _Canvg rendering for Android 2.x is removed as of Highcharts 5.0\.
       * Use the [libURL](#exporting.libURL) option to configure exporting._
       *
       * The URL to the additional file to lazy load for Android 2.x devices.
       * These devices don't support SVG, so we download a helper file that
       * contains [canvg](https://github.com/canvg/canvg), its dependency
       * rbcolor, and our own CanVG Renderer class. To avoid hotlinking to
       * our site, you can install canvas-tools.js on your own server and
       * change this option accordingly.
       *
       * @deprecated
       *
       * @type      {string}
       * @default   https://code.highcharts.com/{version}/modules/canvas-tools.js
       * @product   highcharts highmaps
       * @apioption global.canvasToolsURL
       */
      /**
       * This option is deprecated since v6.0.5. Instead, use
       * [time.useUTC](#time.useUTC) that supports individual time settings
       * per chart.
       *
       * @deprecated
       *
       * @type      {boolean}
       * @apioption global.useUTC
       */
      /**
       * This option is deprecated since v6.0.5. Instead, use
       * [time.Date](#time.Date) that supports individual time settings
       * per chart.
       *
       * @deprecated
       *
       * @type      {Function}
       * @product   highcharts highstock
       * @apioption global.Date
       */
      /**
       * This option is deprecated since v6.0.5. Instead, use
       * [time.getTimezoneOffset](#time.getTimezoneOffset) that supports
       * individual time settings per chart.
       *
       * @deprecated
       *
       * @type      {Function}
       * @product   highcharts highstock
       * @apioption global.getTimezoneOffset
       */
      /**
       * This option is deprecated since v6.0.5. Instead, use
       * [time.timezone](#time.timezone) that supports individual time
       * settings per chart.
       *
       * @deprecated
       *
       * @type      {string}
       * @product   highcharts highstock
       * @apioption global.timezone
       */
      /**
       * This option is deprecated since v6.0.5. Instead, use
       * [time.timezoneOffset](#time.timezoneOffset) that supports individual
       * time settings per chart.
       *
       * @deprecated
       *
       * @type      {number}
       * @product   highcharts highstock
       * @apioption global.timezoneOffset
       */
      global: {},
      /**
       * Time options that can apply globally or to individual charts. These
       * settings affect how `datetime` axes are laid out, how tooltips are
       * formatted, how series
       * [pointIntervalUnit](#plotOptions.series.pointIntervalUnit) works and how
       * the Highcharts Stock range selector handles time.
       *
       * The common use case is that all charts in the same Highcharts object
       * share the same time settings, in which case the global settings are set
       * using `setOptions`.
       *
       * ```js
       * // Apply time settings globally
       * Highcharts.setOptions({
       *     time: {
       *         timezone: 'Europe/London'
       *     }
       * });
       * // Apply time settings by instance
       * let chart = Highcharts.chart('container', {
       *     time: {
       *         timezone: 'America/New_York'
       *     },
       *     series: [{
       *         data: [1, 4, 3, 5]
       *     }]
       * });
       *
       * // Use the Time object
       * console.log(
       *        'Current time in New York',
       *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
       * );
       * ```
       *
       * Since v6.0.5, the time options were moved from the `global` obect to the
       * `time` object, and time options can be set on each individual chart.
       *
       * @sample {highcharts|highstock}
       *         highcharts/time/timezone/
       *         Set the timezone globally
       * @sample {highcharts}
       *         highcharts/time/individual/
       *         Set the timezone per chart instance
       * @sample {highstock}
       *         stock/time/individual/
       *         Set the timezone per chart instance
       *
       * @since     6.0.5
       * @optionparent time
       */
      time: {
        /**
         * A custom `Date` class for advanced date handling. For example,
         * [JDate](https://github.com/tahajahangir/jdate) can be hooked in to
         * handle Jalali dates.
         *
         * @type      {*}
         * @since     4.0.4
         * @product   highcharts highstock gantt
         */
        Date: void 0,
        /**
         * A callback to return the time zone offset for a given datetime. It
         * takes the timestamp in terms of milliseconds since January 1 1970,
         * and returns the timezone offset in minutes. This provides a hook
         * for drawing time based charts in specific time zones using their
         * local DST crossover dates, with the help of external libraries.
         *
         * @see [global.timezoneOffset](#global.timezoneOffset)
         *
         * @sample {highcharts|highstock} highcharts/time/gettimezoneoffset/
         *         Use moment.js to draw Oslo time regardless of browser locale
         *
         * @type      {Highcharts.TimezoneOffsetCallbackFunction}
         * @since     4.1.0
         * @product   highcharts highstock gantt
         */
        getTimezoneOffset: void 0,
        /**
         * Requires [moment.js](https://momentjs.com/). If the timezone option
         * is specified, it creates a default
         * [getTimezoneOffset](#time.getTimezoneOffset) function that looks
         * up the specified timezone in moment.js. If moment.js is not included,
         * this throws a Highcharts error in the console, but does not crash the
         * chart.
         *
         * @see [getTimezoneOffset](#time.getTimezoneOffset)
         *
         * @sample {highcharts|highstock} highcharts/time/timezone/
         *         Europe/Oslo
         *
         * @type      {string}
         * @since     5.0.7
         * @product   highcharts highstock gantt
         */
        timezone: void 0,
        /**
         * The timezone offset in minutes. Positive values are west, negative
         * values are east of UTC, as in the ECMAScript
         * [getTimezoneOffset](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)
         * method. Use this to display UTC based data in a predefined time zone.
         *
         * @see [time.getTimezoneOffset](#time.getTimezoneOffset)
         *
         * @sample {highcharts|highstock} highcharts/time/timezoneoffset/
         *         Timezone offset
         *
         * @since     3.0.8
         * @product   highcharts highstock gantt
         */
        timezoneOffset: 0,
        /**
         * Whether to use UTC time for axis scaling, tickmark placement and
         * time display in `Highcharts.dateFormat`. Advantages of using UTC
         * is that the time displays equally regardless of the user agent's
         * time zone settings. Local time can be used when the data is loaded
         * in real time or when correct Daylight Saving Time transitions are
         * required.
         *
         * @sample {highcharts} highcharts/time/useutc-true/
         *         True by default
         * @sample {highcharts} highcharts/time/useutc-false/
         *         False
         */
        useUTC: true
      },
      chart: ChartDefaults,
      /**
       * The chart's main title.
       *
       * @sample {highmaps} maps/title/title/
       *         Title options demonstrated
       */
      title: {
        /**
         * When the title is floating, the plot area will not move to make space
         * for it.
         *
         * @sample {highcharts} highcharts/chart/zoomtype-none/
         *         False by default
         * @sample {highcharts} highcharts/title/floating/
         *         True - title on top of the plot area
         * @sample {highstock} stock/chart/title-floating/
         *         True - title on top of the plot area
         *
         * @type      {boolean}
         * @default   false
         * @since     2.1
         * @apioption title.floating
         */
        /**
         * CSS styles for the title. Use this for font styling, but use `align`,
         * `x` and `y` for text alignment.
         *
         * In styled mode, the title style is given in the `.highcharts-title`
         * class.
         *
         * @sample {highcharts} highcharts/title/style/
         *         Custom color and weight
         * @sample {highstock} stock/chart/title-style/
         *         Custom color and weight
         * @sample highcharts/css/titles/
         *         Styled mode
         *
         * @type      {Highcharts.CSSObject}
         * @default   {highcharts|highmaps} { "color": "#333333", "fontSize": "18px" }
         * @default   {highstock} { "color": "#333333", "fontSize": "16px" }
         * @apioption title.style
         */
        /**
         * Whether to
         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
         * to render the text.
         *
         * @type      {boolean}
         * @default   false
         * @apioption title.useHTML
         */
        /**
         * The vertical alignment of the title. Can be one of `"top"`,
         * `"middle"` and `"bottom"`. When a value is given, the title behaves
         * as if [floating](#title.floating) were `true`.
         *
         * @sample {highcharts} highcharts/title/verticalalign/
         *         Chart title in bottom right corner
         * @sample {highstock} stock/chart/title-verticalalign/
         *         Chart title in bottom right corner
         *
         * @type      {Highcharts.VerticalAlignValue}
         * @since     2.1
         * @apioption title.verticalAlign
         */
        /**
         * The x position of the title relative to the alignment within
         * `chart.spacingLeft` and `chart.spacingRight`.
         *
         * @sample {highcharts} highcharts/title/align/
         *         Aligned to the plot area (x = 70px = margin left - spacing
         *         left)
         * @sample {highstock} stock/chart/title-align/
         *         Aligned to the plot area (x = 50px = margin left - spacing
         *         left)
         *
         * @type      {number}
         * @default   0
         * @since     2.0
         * @apioption title.x
         */
        /**
         * The y position of the title relative to the alignment within
         * [chart.spacingTop](#chart.spacingTop) and [chart.spacingBottom](
         * #chart.spacingBottom). By default it depends on the font size.
         *
         * @sample {highcharts} highcharts/title/y/
         *         Title inside the plot area
         * @sample {highstock} stock/chart/title-verticalalign/
         *         Chart title in bottom right corner
         *
         * @type      {number}
         * @since     2.0
         * @apioption title.y
         */
        /**
         * The title of the chart. To disable the title, set the `text` to
         * `undefined`.
         *
         * @sample {highcharts} highcharts/title/text/
         *         Custom title
         * @sample {highstock} stock/chart/title-text/
         *         Custom title
         *
         * @default {highcharts|highmaps} Chart title
         * @default {highstock} undefined
         */
        text: "Chart title",
        /**
         * The horizontal alignment of the title. Can be one of "left", "center"
         * and "right".
         *
         * @sample {highcharts} highcharts/title/align/
         *         Aligned to the plot area (x = 70px = margin left - spacing
         *         left)
         * @sample {highstock} stock/chart/title-align/
         *         Aligned to the plot area (x = 50px = margin left - spacing
         *         left)
         *
         * @type  {Highcharts.AlignValue}
         * @since 2.0
         */
        align: "center",
        /**
         * The margin between the title and the plot area, or if a subtitle
         * is present, the margin between the subtitle and the plot area.
         *
         * @sample {highcharts} highcharts/title/margin-50/
         *         A chart title margin of 50
         * @sample {highcharts} highcharts/title/margin-subtitle/
         *         The same margin applied with a subtitle
         * @sample {highstock} stock/chart/title-margin/
         *         A chart title margin of 50
         *
         * @since 2.1
         */
        margin: 15,
        /**
         * Adjustment made to the title width, normally to reserve space for
         * the exporting burger menu.
         *
         * @sample highcharts/title/widthadjust/
         *         Wider menu, greater padding
         *
         * @since 4.2.5
         */
        widthAdjust: -44
      },
      /**
       * The chart's subtitle. This can be used both to display a subtitle below
       * the main title, and to display random text anywhere in the chart. The
       * subtitle can be updated after chart initialization through the
       * `Chart.setTitle` method.
       *
       * @sample {highmaps} maps/title/subtitle/
       *         Subtitle options demonstrated
       */
      subtitle: {
        /**
         * When the subtitle is floating, the plot area will not move to make
         * space for it.
         *
         * @sample {highcharts} highcharts/subtitle/floating/
         *         Floating title and subtitle
         * @sample {highstock} stock/chart/subtitle-footnote
         *         Footnote floating at bottom right of plot area
         *
         * @type      {boolean}
         * @default   false
         * @since     2.1
         * @apioption subtitle.floating
         */
        /**
         * CSS styles for the title.
         *
         * In styled mode, the subtitle style is given in the
         * `.highcharts-subtitle` class.
         *
         * @sample {highcharts} highcharts/subtitle/style/
         *         Custom color and weight
         * @sample {highcharts} highcharts/css/titles/
         *         Styled mode
         * @sample {highstock} stock/chart/subtitle-style
         *         Custom color and weight
         * @sample {highstock} highcharts/css/titles/
         *         Styled mode
         * @sample {highmaps} highcharts/css/titles/
         *         Styled mode
         *
         * @type      {Highcharts.CSSObject}
         * @default   {"color": "#666666"}
         * @apioption subtitle.style
         */
        /**
         * Whether to
         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
         * to render the text.
         *
         * @type      {boolean}
         * @default   false
         * @apioption subtitle.useHTML
         */
        /**
         * The vertical alignment of the title. Can be one of `"top"`,
         * `"middle"` and `"bottom"`. When middle, the subtitle behaves as
         * floating.
         *
         * @sample {highcharts} highcharts/subtitle/verticalalign/
         *         Footnote at the bottom right of plot area
         * @sample {highstock} stock/chart/subtitle-footnote
         *         Footnote at the bottom right of plot area
         *
         * @type      {Highcharts.VerticalAlignValue}
         * @since     2.1
         * @apioption subtitle.verticalAlign
         */
        /**
         * The x position of the subtitle relative to the alignment within
         * `chart.spacingLeft` and `chart.spacingRight`.
         *
         * @sample {highcharts} highcharts/subtitle/align/
         *         Footnote at right of plot area
         * @sample {highstock} stock/chart/subtitle-footnote
         *         Footnote at the bottom right of plot area
         *
         * @type      {number}
         * @default   0
         * @since     2.0
         * @apioption subtitle.x
         */
        /**
         * The y position of the subtitle relative to the alignment within
         * `chart.spacingTop` and `chart.spacingBottom`. By default the subtitle
         * is laid out below the title unless the title is floating.
         *
         * @sample {highcharts} highcharts/subtitle/verticalalign/
         *         Footnote at the bottom right of plot area
         * @sample {highstock} stock/chart/subtitle-footnote
         *         Footnote at the bottom right of plot area
         *
         * @type      {number}
         * @since     2.0
         * @apioption subtitle.y
         */
        /**
         * The subtitle of the chart.
         *
         * @sample {highcharts|highstock} highcharts/subtitle/text/
         *         Custom subtitle
         * @sample {highcharts|highstock} highcharts/subtitle/text-formatted/
         *         Formatted and linked text.
         */
        text: "",
        /**
         * The horizontal alignment of the subtitle. Can be one of "left",
         *  "center" and "right".
         *
         * @sample {highcharts} highcharts/subtitle/align/
         *         Footnote at right of plot area
         * @sample {highstock} stock/chart/subtitle-footnote
         *         Footnote at bottom right of plot area
         *
         * @type  {Highcharts.AlignValue}
         * @since 2.0
         */
        align: "center",
        /**
         * Adjustment made to the subtitle width, normally to reserve space
         * for the exporting burger menu.
         *
         * @see [title.widthAdjust](#title.widthAdjust)
         *
         * @sample highcharts/title/widthadjust/
         *         Wider menu, greater padding
         *
         * @since 4.2.5
         */
        widthAdjust: -44
      },
      /**
       * The chart's caption, which will render below the chart and will be part
       * of exported charts. The caption can be updated after chart initialization
       * through the `Chart.update` or `Chart.caption.update` methods.
       *
       * @sample highcharts/caption/text/
       *         A chart with a caption
       * @since  7.2.0
       */
      caption: {
        /**
         * When the caption is floating, the plot area will not move to make
         * space for it.
         *
         * @type      {boolean}
         * @default   false
         * @apioption caption.floating
         */
        /**
         * The margin between the caption and the plot area.
         */
        margin: 15,
        /**
         * CSS styles for the caption.
         *
         * In styled mode, the caption style is given in the
         * `.highcharts-caption` class.
         *
         * @sample {highcharts} highcharts/css/titles/
         *         Styled mode
         *
         * @type      {Highcharts.CSSObject}
         * @default   {"color": "#666666"}
         * @apioption caption.style
         */
        /**
         * Whether to
         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
         * to render the text.
         *
         * @type      {boolean}
         * @default   false
         * @apioption caption.useHTML
         */
        /**
         * The x position of the caption relative to the alignment within
         * `chart.spacingLeft` and `chart.spacingRight`.
         *
         * @type      {number}
         * @default   0
         * @apioption caption.x
         */
        /**
         * The y position of the caption relative to the alignment within
         * `chart.spacingTop` and `chart.spacingBottom`.
         *
         * @type      {number}
         * @apioption caption.y
         */
        /**
         * The caption text of the chart.
         *
         * @sample {highcharts} highcharts/caption/text/
         *         Custom caption
         */
        text: "",
        /**
         * The horizontal alignment of the caption. Can be one of "left",
         *  "center" and "right".
         *
         * @type  {Highcharts.AlignValue}
         */
        align: "left",
        /**
         * The vertical alignment of the caption. Can be one of `"top"`,
         * `"middle"` and `"bottom"`. When middle, the caption behaves as
         * floating.
         *
         * @type      {Highcharts.VerticalAlignValue}
         */
        verticalAlign: "bottom"
      },
      /**
       * The plotOptions is a wrapper object for config objects for each series
       * type. The config objects for each series can also be overridden for
       * each series item as given in the series array.
       *
       * Configuration options for the series are given in three levels. Options
       * for all series in a chart are given in the [plotOptions.series](
       * #plotOptions.series) object. Then options for all series of a specific
       * type are given in the plotOptions of that type, for example
       * `plotOptions.line`. Next, options for one single series are given in
       * [the series array](#series).
       */
      plotOptions: {},
      /**
       * HTML labels that can be positioned anywhere in the chart area.
       *
       * This option is deprecated since v7.1.2. Instead, use
       * [annotations](#annotations) that support labels.
       *
       * @deprecated
       * @product   highcharts highstock
       */
      labels: {
        /**
         * An HTML label that can be positioned anywhere in the chart area.
         *
         * @deprecated
         * @type      {Array<*>}
         * @apioption labels.items
         */
        /**
         * Inner HTML or text for the label.
         *
         * @deprecated
         * @type      {string}
         * @apioption labels.items.html
         */
        /**
         * CSS styles for each label. To position the label, use left and top
         * like this:
         * ```js
         * style: {
         *     left: '100px',
         *     top: '100px'
         * }
         * ```
         *
         * @deprecated
         * @type      {Highcharts.CSSObject}
         * @apioption labels.items.style
         */
        /**
         * Shared CSS styles for all labels.
         *
         * @deprecated
         * @type    {Highcharts.CSSObject}
         * @default {"color": "#333333", "position": "absolute"}
         */
        style: {
          /**
           * @ignore-option
           */
          position: "absolute",
          /**
           * @ignore-option
           */
          color: palette.neutralColor80
        }
      },
      /**
       * The legend is a box containing a symbol and name for each series
       * item or point item in the chart. Each series (or points in case
       * of pie charts) is represented by a symbol and its name in the legend.
       *
       * It is possible to override the symbol creator function and create
       * [custom legend symbols](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-custom-symbol/).
       *
       * @productdesc {highmaps}
       * A Highmaps legend by default contains one legend item per series, but if
       * a `colorAxis` is defined, the axis will be displayed in the legend.
       * Either as a gradient, or as multiple legend items for `dataClasses`.
       */
      legend: {
        /**
         * The background color of the legend.
         *
         * @see In styled mode, the legend background fill can be applied with
         *      the `.highcharts-legend-box` class.
         *
         * @sample {highcharts} highcharts/legend/backgroundcolor/
         *         Yellowish background
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/border-background/
         *         Border and background options
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption legend.backgroundColor
         */
        /**
         * The width of the drawn border around the legend.
         *
         * @see In styled mode, the legend border stroke width can be applied
         *      with the `.highcharts-legend-box` class.
         *
         * @sample {highcharts} highcharts/legend/borderwidth/
         *         2px border width
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/border-background/
         *         Border and background options
         *
         * @type      {number}
         * @default   0
         * @apioption legend.borderWidth
         */
        /**
         * Enable or disable the legend. There is also a series-specific option,
         * [showInLegend](#plotOptions.series.showInLegend), that can hide the
         * series from the legend. In some series types this is `false` by
         * default, so it must set to `true` in order to show the legend for the
         * series.
         *
         * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled
         * @sample {highstock} stock/legend/align/ Various legend options
         * @sample {highmaps} maps/legend/enabled-false/ Legend disabled
         *
         * @default {highstock} false
         * @default {highmaps} true
         * @default {gantt} false
         */
        enabled: true,
        /**
         * The horizontal alignment of the legend box within the chart area.
         * Valid values are `left`, `center` and `right`.
         *
         * In the case that the legend is aligned in a corner position, the
         * `layout` option will determine whether to place it above/below
         * or on the side of the plot area.
         *
         * @sample {highcharts} highcharts/legend/align/
         *         Legend at the right of the chart
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/alignment/
         *         Legend alignment
         *
         * @type  {Highcharts.AlignValue}
         * @since 2.0
         */
        align: "center",
        /**
         * If the [layout](legend.layout) is `horizontal` and the legend items
         * span over two lines or more, whether to align the items into vertical
         * columns. Setting this to `false` makes room for more items, but will
         * look more messy.
         *
         * @since 6.1.0
         */
        alignColumns: true,
        /**
         * A CSS class name to apply to the legend group.
         */
        className: "highcharts-no-tooltip",
        /**
         * When the legend is floating, the plot area ignores it and is allowed
         * to be placed below it.
         *
         * @sample {highcharts} highcharts/legend/floating-false/
         *         False by default
         * @sample {highcharts} highcharts/legend/floating-true/
         *         True
         * @sample {highmaps} maps/legend/alignment/
         *         Floating legend
         *
         * @type      {boolean}
         * @default   false
         * @since     2.1
         * @apioption legend.floating
         */
        /**
         * The layout of the legend items. Can be one of `horizontal` or
         * `vertical` or `proximate`. When `proximate`, the legend items will be
         * placed as close as possible to the graphs they're representing,
         * except in inverted charts or when the legend position doesn't allow
         * it.
         *
         * @sample {highcharts} highcharts/legend/layout-horizontal/
         *         Horizontal by default
         * @sample {highcharts} highcharts/legend/layout-vertical/
         *         Vertical
         * @sample highcharts/legend/layout-proximate
         *         Labels proximate to the data
         * @sample {highstock} stock/legend/layout-horizontal/
         *         Horizontal by default
         * @sample {highmaps} maps/legend/padding-itemmargin/
         *         Vertical with data classes
         * @sample {highmaps} maps/legend/layout-vertical/
         *         Vertical with color axis gradient
         *
         * @validvalue ["horizontal", "vertical", "proximate"]
         */
        layout: "horizontal",
        /**
         * In a legend with horizontal layout, the itemDistance defines the
         * pixel distance between each item.
         *
         * @sample {highcharts} highcharts/legend/layout-horizontal/
         *         50px item distance
         * @sample {highstock} highcharts/legend/layout-horizontal/
         *         50px item distance
         *
         * @type      {number}
         * @default   {highcharts} 20
         * @default   {highstock} 20
         * @default   {highmaps} 8
         * @since     3.0.3
         * @apioption legend.itemDistance
         */
        /**
         * The pixel bottom margin for each legend item.
         *
         * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         * @sample {highmaps} maps/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         *
         * @type      {number}
         * @default   0
         * @since     2.2.0
         * @apioption legend.itemMarginBottom
         */
        /**
         * The pixel top margin for each legend item.
         *
         * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         * @sample {highmaps} maps/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         *
         * @type      {number}
         * @default   0
         * @since     2.2.0
         * @apioption legend.itemMarginTop
         */
        /**
         * The width for each legend item. By default the items are laid out
         * successively. In a [horizontal layout](legend.layout), if the items
         * are laid out across two rows or more, they will be vertically aligned
         * depending on the [legend.alignColumns](legend.alignColumns) option.
         *
         * @sample {highcharts} highcharts/legend/itemwidth-default/
         *         Undefined by default
         * @sample {highcharts} highcharts/legend/itemwidth-80/
         *         80 for aligned legend items
         *
         * @type      {number}
         * @since     2.0
         * @apioption legend.itemWidth
         */
        /**
         * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
         * for each legend label. Available variables relates to properties on
         * the series, or the point in case of pies.
         *
         * @type      {string}
         * @default   {name}
         * @since     1.3
         * @apioption legend.labelFormat
         */
        /* eslint-disable valid-jsdoc */
        /**
         * Callback function to format each of the series' labels. The `this`
         * keyword refers to the series object, or the point object in case of
         * pie charts. By default the series or point name is printed.
         *
         * @productdesc {highmaps}
         * In Highmaps the context can also be a data class in case of a
         * `colorAxis`.
         *
         * @sample {highcharts} highcharts/legend/labelformatter/
         *         Add text
         * @sample {highmaps} maps/legend/labelformatter/
         *         Data classes with label formatter
         *
         * @type {Highcharts.FormatterCallbackFunction<Point|Series>}
         */
        labelFormatter: function() {
          return this.name;
        },
        /**
         * Line height for the legend items. Deprecated as of 2.1\. Instead,
         * the line height for each item can be set using
         * `itemStyle.lineHeight`, and the padding between items using
         * `itemMarginTop` and `itemMarginBottom`.
         *
         * @sample {highcharts} highcharts/legend/lineheight/
         *         Setting padding
         *
         * @deprecated
         *
         * @type      {number}
         * @default   16
         * @since     2.0
         * @product   highcharts gantt
         * @apioption legend.lineHeight
         */
        /**
         * If the plot area sized is calculated automatically and the legend is
         * not floating, the legend margin is the space between the legend and
         * the axis labels or plot area.
         *
         * @sample {highcharts} highcharts/legend/margin-default/
         *         12 pixels by default
         * @sample {highcharts} highcharts/legend/margin-30/
         *         30 pixels
         *
         * @type      {number}
         * @default   12
         * @since     2.1
         * @apioption legend.margin
         */
        /**
         * Maximum pixel height for the legend. When the maximum height is
         * extended, navigation will show.
         *
         * @type      {number}
         * @since     2.3.0
         * @apioption legend.maxHeight
         */
        /**
         * The color of the drawn border around the legend.
         *
         * @see In styled mode, the legend border stroke can be applied with the
         *      `.highcharts-legend-box` class.
         *
         * @sample {highcharts} highcharts/legend/bordercolor/
         *         Brown border
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/border-background/
         *         Border and background options
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        borderColor: palette.neutralColor40,
        /**
         * The border corner radius of the legend.
         *
         * @sample {highcharts} highcharts/legend/borderradius-default/
         *         Square by default
         * @sample {highcharts} highcharts/legend/borderradius-round/
         *         5px rounded
         * @sample {highmaps} maps/legend/border-background/
         *         Border and background options
         */
        borderRadius: 0,
        /**
         * Options for the paging or navigation appearing when the legend is
         * overflown. Navigation works well on screen, but not in static
         * exported images. One way of working around that is to
         * [increase the chart height in
         * export](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-enabled-false/).
         */
        navigation: {
          /**
           * How to animate the pages when navigating up or down. A value of
           * `true` applies the default navigation given in the
           * `chart.animation` option. Additional options can be given as an
           * object containing values for easing and duration.
           *
           * @sample {highcharts} highcharts/legend/navigation/
           *         Legend page navigation demonstrated
           * @sample {highstock} highcharts/legend/navigation/
           *         Legend page navigation demonstrated
           *
           * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
           * @default   true
           * @since     2.2.4
           * @apioption legend.navigation.animation
           */
          /**
           * The pixel size of the up and down arrows in the legend paging
           * navigation.
           *
           * @sample {highcharts} highcharts/legend/navigation/
           *         Legend page navigation demonstrated
           * @sample {highstock} highcharts/legend/navigation/
           *         Legend page navigation demonstrated
           *
           * @type      {number}
           * @default   12
           * @since     2.2.4
           * @apioption legend.navigation.arrowSize
           */
          /**
           * Whether to enable the legend navigation. In most cases, disabling
           * the navigation results in an unwanted overflow.
           *
           * See also the [adapt chart to legend](
           * https://www.highcharts.com/products/plugin-registry/single/8/Adapt-Chart-To-Legend)
           * plugin for a solution to extend the chart height to make room for
           * the legend, optionally in exported charts only.
           *
           * @type      {boolean}
           * @default   true
           * @since     4.2.4
           * @apioption legend.navigation.enabled
           */
          /**
           * Text styles for the legend page navigation.
           *
           * @see In styled mode, the navigation items are styled with the
           *      `.highcharts-legend-navigation` class.
           *
           * @sample {highcharts} highcharts/legend/navigation/
           *         Legend page navigation demonstrated
           * @sample {highstock} highcharts/legend/navigation/
           *         Legend page navigation demonstrated
           *
           * @type      {Highcharts.CSSObject}
           * @since     2.2.4
           * @apioption legend.navigation.style
           */
          /**
           * The color for the active up or down arrow in the legend page
           * navigation.
           *
           * @see In styled mode, the active arrow be styled with the
           *      `.highcharts-legend-nav-active` class.
           *
           * @sample  {highcharts} highcharts/legend/navigation/
           *          Legend page navigation demonstrated
           * @sample  {highstock} highcharts/legend/navigation/
           *          Legend page navigation demonstrated
           *
           * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @since 2.2.4
           */
          activeColor: palette.highlightColor100,
          /**
           * The color of the inactive up or down arrow in the legend page
           * navigation. .
           *
           * @see In styled mode, the inactive arrow be styled with the
           *      `.highcharts-legend-nav-inactive` class.
           *
           * @sample {highcharts} highcharts/legend/navigation/
           *         Legend page navigation demonstrated
           * @sample {highstock} highcharts/legend/navigation/
           *         Legend page navigation demonstrated
           *
           * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @since 2.2.4
           */
          inactiveColor: palette.neutralColor20
        },
        /**
         * The inner padding of the legend box.
         *
         * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         * @sample {highmaps} maps/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         *
         * @type      {number}
         * @default   8
         * @since     2.2.0
         * @apioption legend.padding
         */
        /**
         * Whether to reverse the order of the legend items compared to the
         * order of the series or points as defined in the configuration object.
         *
         * @see [yAxis.reversedStacks](#yAxis.reversedStacks),
         *      [series.legendIndex](#series.legendIndex)
         *
         * @sample {highcharts} highcharts/legend/reversed/
         *         Stacked bar with reversed legend
         *
         * @type      {boolean}
         * @default   false
         * @since     1.2.5
         * @apioption legend.reversed
         */
        /**
         * Whether to show the symbol on the right side of the text rather than
         * the left side. This is common in Arabic and Hebrew.
         *
         * @sample {highcharts} highcharts/legend/rtl/
         *         Symbol to the right
         *
         * @type      {boolean}
         * @default   false
         * @since     2.2
         * @apioption legend.rtl
         */
        /**
         * CSS styles for the legend area. In the 1.x versions the position
         * of the legend area was determined by CSS. In 2.x, the position is
         * determined by properties like `align`, `verticalAlign`, `x` and `y`,
         * but the styles are still parsed for backwards compatibility.
         *
         * @deprecated
         *
         * @type      {Highcharts.CSSObject}
         * @product   highcharts highstock
         * @apioption legend.style
         */
        /**
         * CSS styles for each legend item. Only a subset of CSS is supported,
         * notably those options related to text. The default `textOverflow`
         * property makes long texts truncate. Set it to `undefined` to wrap
         * text instead. A `width` property can be added to control the text
         * width.
         *
         * @see In styled mode, the legend items can be styled with the
         *      `.highcharts-legend-item` class.
         *
         * @sample {highcharts} highcharts/legend/itemstyle/
         *         Bold black text
         * @sample {highmaps} maps/legend/itemstyle/
         *         Item text styles
         *
         * @type    {Highcharts.CSSObject}
         * @default {"color": "#333333", "cursor": "pointer", "fontSize": "12px", "fontWeight": "bold", "textOverflow": "ellipsis"}
         */
        itemStyle: {
          /**
           * @ignore
           */
          color: palette.neutralColor80,
          /**
           * @ignore
           */
          cursor: "pointer",
          /**
           * @ignore
           */
          fontSize: "12px",
          /**
           * @ignore
           */
          fontWeight: "bold",
          /**
           * @ignore
           */
          textOverflow: "ellipsis"
        },
        /**
         * CSS styles for each legend item in hover mode. Only a subset of
         * CSS is supported, notably those options related to text. Properties
         * are inherited from `style` unless overridden here.
         *
         * @see In styled mode, the hovered legend items can be styled with
         *      the `.highcharts-legend-item:hover` pesudo-class.
         *
         * @sample {highcharts} highcharts/legend/itemhoverstyle/
         *         Red on hover
         * @sample {highmaps} maps/legend/itemstyle/
         *         Item text styles
         *
         * @type    {Highcharts.CSSObject}
         * @default {"color": "#000000"}
         */
        itemHoverStyle: {
          /**
           * @ignore
           */
          color: palette.neutralColor100
        },
        /**
         * CSS styles for each legend item when the corresponding series or
         * point is hidden. Only a subset of CSS is supported, notably those
         * options related to text. Properties are inherited from `style`
         * unless overridden here.
         *
         * @see In styled mode, the hidden legend items can be styled with
         *      the `.highcharts-legend-item-hidden` class.
         *
         * @sample {highcharts} highcharts/legend/itemhiddenstyle/
         *         Darker gray color
         *
         * @type    {Highcharts.CSSObject}
         * @default {"color": "#cccccc"}
         */
        itemHiddenStyle: {
          /**
           * @ignore
           */
          color: palette.neutralColor20
        },
        /**
         * Whether to apply a drop shadow to the legend. A `backgroundColor`
         * also needs to be applied for this to take effect. The shadow can be
         * an object configuration containing `color`, `offsetX`, `offsetY`,
         * `opacity` and `width`.
         *
         * @sample {highcharts} highcharts/legend/shadow/
         *         White background and drop shadow
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/border-background/
         *         Border and background options
         *
         * @type {boolean|Highcharts.CSSObject}
         */
        shadow: false,
        /**
         * Default styling for the checkbox next to a legend item when
         * `showCheckbox` is true.
         *
         * @type {Highcharts.CSSObject}
         * @default {"width": "13px", "height": "13px", "position":"absolute"}
         */
        itemCheckboxStyle: {
          /**
           * @ignore
           */
          position: "absolute",
          /**
           * @ignore
           */
          width: "13px",
          /**
           * @ignore
           */
          height: "13px"
        },
        // itemWidth: undefined,
        /**
         * When this is true, the legend symbol width will be the same as
         * the symbol height, which in turn defaults to the font size of the
         * legend items.
         *
         * @since 5.0.0
         */
        squareSymbol: true,
        /**
         * The pixel height of the symbol for series types that use a rectangle
         * in the legend. Defaults to the font size of legend items.
         *
         * @productdesc {highmaps}
         * In Highmaps, when the symbol is the gradient of a vertical color
         * axis, the height defaults to 200.
         *
         * @sample {highmaps} maps/legend/layout-vertical-sized/
         *         Sized vertical gradient
         * @sample {highmaps} maps/legend/padding-itemmargin/
         *         No distance between data classes
         *
         * @type      {number}
         * @since     3.0.8
         * @apioption legend.symbolHeight
         */
        /**
         * The border radius of the symbol for series types that use a rectangle
         * in the legend. Defaults to half the `symbolHeight`.
         *
         * @sample {highcharts} highcharts/legend/symbolradius/
         *         Round symbols
         * @sample {highstock} highcharts/legend/symbolradius/
         *         Round symbols
         * @sample {highmaps} highcharts/legend/symbolradius/
         *         Round symbols
         *
         * @type      {number}
         * @since     3.0.8
         * @apioption legend.symbolRadius
         */
        /**
         * The pixel width of the legend item symbol. When the `squareSymbol`
         * option is set, this defaults to the `symbolHeight`, otherwise 16.
         *
         * @productdesc {highmaps}
         * In Highmaps, when the symbol is the gradient of a horizontal color
         * axis, the width defaults to 200.
         *
         * @sample {highcharts} highcharts/legend/symbolwidth/
         *         Greater symbol width and padding
         * @sample {highmaps} maps/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         * @sample {highmaps} maps/legend/layout-vertical-sized/
         *         Sized vertical gradient
         *
         * @type      {number}
         * @apioption legend.symbolWidth
         */
        /**
         * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
         * to render the legend item texts.
         *
         * Prior to 4.1.7, when using HTML, [legend.navigation](
         * #legend.navigation) was disabled.
         *
         * @type      {boolean}
         * @default   false
         * @apioption legend.useHTML
         */
        /**
         * The width of the legend box. If a number is set, it translates to
         * pixels. Since v7.0.2 it allows setting a percent string of the full
         * chart width, for example `40%`.
         *
         * Defaults to the full chart width for legends below or above the
         * chart, half the chart width for legends to the left and right.
         *
         * @sample {highcharts} highcharts/legend/width/
         *         Aligned to the plot area
         * @sample {highcharts} highcharts/legend/width-percent/
         *         A percent of the chart width
         *
         * @type      {number|string}
         * @since     2.0
         * @apioption legend.width
         */
        /**
         * The pixel padding between the legend item symbol and the legend
         * item text.
         *
         * @sample {highcharts} highcharts/legend/symbolpadding/
         *         Greater symbol width and padding
         */
        symbolPadding: 5,
        /**
         * The vertical alignment of the legend box. Can be one of `top`,
         * `middle` or `bottom`. Vertical position can be further determined
         * by the `y` option.
         *
         * In the case that the legend is aligned in a corner position, the
         * `layout` option will determine whether to place it above/below
         * or on the side of the plot area.
         *
         * When the [layout](#legend.layout) option is `proximate`, the
         * `verticalAlign` option doesn't apply.
         *
         * @sample {highcharts} highcharts/legend/verticalalign/
         *         Legend 100px from the top of the chart
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/alignment/
         *         Legend alignment
         *
         * @type  {Highcharts.VerticalAlignValue}
         * @since 2.0
         */
        verticalAlign: "bottom",
        // width: undefined,
        /**
         * The x offset of the legend relative to its horizontal alignment
         * `align` within chart.spacingLeft and chart.spacingRight. Negative
         * x moves it to the left, positive x moves it to the right.
         *
         * @sample {highcharts} highcharts/legend/width/
         *         Aligned to the plot area
         *
         * @since 2.0
         */
        x: 0,
        /**
         * The vertical offset of the legend relative to it's vertical alignment
         * `verticalAlign` within chart.spacingTop and chart.spacingBottom.
         *  Negative y moves it up, positive y moves it down.
         *
         * @sample {highcharts} highcharts/legend/verticalalign/
         *         Legend 100px from the top of the chart
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/alignment/
         *         Legend alignment
         *
         * @since 2.0
         */
        y: 0,
        /**
         * A title to be added on top of the legend.
         *
         * @sample {highcharts} highcharts/legend/title/
         *         Legend title
         * @sample {highmaps} maps/legend/alignment/
         *         Legend with title
         *
         * @since 3.0
         */
        title: {
          /**
           * A text or HTML string for the title.
           *
           * @type      {string}
           * @since     3.0
           * @apioption legend.title.text
           */
          /**
           * Generic CSS styles for the legend title.
           *
           * @see In styled mode, the legend title is styled with the
           *      `.highcharts-legend-title` class.
           *
           * @type    {Highcharts.CSSObject}
           * @default {"fontWeight": "bold"}
           * @since   3.0
           */
          style: {
            /**
             * @ignore
             */
            fontWeight: "bold"
          }
        }
      },
      /**
       * The loading options control the appearance of the loading screen
       * that covers the plot area on chart operations. This screen only
       * appears after an explicit call to `chart.showLoading()`. It is a
       * utility for developers to communicate to the end user that something
       * is going on, for example while retrieving new data via an XHR connection.
       * The "Loading..." text itself is not part of this configuration
       * object, but part of the `lang` object.
       */
      loading: {
        /**
         * The duration in milliseconds of the fade out effect.
         *
         * @sample highcharts/loading/hideduration/
         *         Fade in and out over a second
         *
         * @type      {number}
         * @default   100
         * @since     1.2.0
         * @apioption loading.hideDuration
         */
        /**
         * The duration in milliseconds of the fade in effect.
         *
         * @sample highcharts/loading/hideduration/
         *         Fade in and out over a second
         *
         * @type      {number}
         * @default   100
         * @since     1.2.0
         * @apioption loading.showDuration
         */
        /**
         * CSS styles for the loading label `span`.
         *
         * @see In styled mode, the loading label is styled with the
         *      `.highcharts-loading-inner` class.
         *
         * @sample {highcharts|highmaps} highcharts/loading/labelstyle/
         *         Vertically centered
         * @sample {highstock} stock/loading/general/
         *         Label styles
         *
         * @type    {Highcharts.CSSObject}
         * @default {"fontWeight": "bold", "position": "relative", "top": "45%"}
         * @since   1.2.0
         */
        labelStyle: {
          /**
           * @ignore
           */
          fontWeight: "bold",
          /**
           * @ignore
           */
          position: "relative",
          /**
           * @ignore
           */
          top: "45%"
        },
        /**
         * CSS styles for the loading screen that covers the plot area.
         *
         * In styled mode, the loading label is styled with the
         * `.highcharts-loading` class.
         *
         * @sample  {highcharts|highmaps} highcharts/loading/style/
         *          Gray plot area, white text
         * @sample  {highstock} stock/loading/general/
         *          Gray plot area, white text
         *
         * @type    {Highcharts.CSSObject}
         * @default {"position": "absolute", "backgroundColor": "#ffffff", "opacity": 0.5, "textAlign": "center"}
         * @since   1.2.0
         */
        style: {
          /**
           * @ignore
           */
          position: "absolute",
          /**
           * @ignore
           */
          backgroundColor: palette.backgroundColor,
          /**
           * @ignore
           */
          opacity: 0.5,
          /**
           * @ignore
           */
          textAlign: "center"
        }
      },
      /**
       * Options for the tooltip that appears when the user hovers over a
       * series or point.
       *
       * @declare Highcharts.TooltipOptions
       */
      tooltip: {
        /**
         * The color of the tooltip border. When `undefined`, the border takes
         * the color of the corresponding series or point.
         *
         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
         *         Follow series by default
         * @sample {highcharts} highcharts/tooltip/bordercolor-black/
         *         Black border
         * @sample {highstock} stock/tooltip/general/
         *         Styled tooltip
         * @sample {highmaps} maps/tooltip/background-border/
         *         Background and border demo
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption tooltip.borderColor
         */
        /**
         * A CSS class name to apply to the tooltip's container div,
         * allowing unique CSS styling for each chart.
         *
         * @type      {string}
         * @apioption tooltip.className
         */
        /**
         * Since 4.1, the crosshair definitions are moved to the Axis object
         * in order for a better separation from the tooltip. See
         * [xAxis.crosshair](#xAxis.crosshair).
         *
         * @sample {highcharts} highcharts/tooltip/crosshairs-x/
         *         Enable a crosshair for the x value
         *
         * @deprecated
         *
         * @type      {*}
         * @default   true
         * @apioption tooltip.crosshairs
         */
        /**
         * Distance from point to tooltip in pixels.
         *
         * @type      {number}
         * @default   16
         * @apioption tooltip.distance
         */
        /**
         * Whether the tooltip should follow the mouse as it moves across
         * columns, pie slices and other point types with an extent.
         * By default it behaves this way for pie, polygon, map, sankey
         * and wordcloud series by override in the `plotOptions`
         * for those series types.
         *
         * Does not apply if [split](#tooltip.split) is `true`.
         *
         * For touch moves to behave the same way, [followTouchMove](
         * #tooltip.followTouchMove) must be `true` also.
         *
         * @type      {boolean}
         * @default   {highcharts} false
         * @default   {highstock} false
         * @default   {highmaps} true
         * @since     3.0
         * @apioption tooltip.followPointer
         */
        /**
         * Whether the tooltip should update as the finger moves on a touch
         * device. If this is `true` and [chart.panning](#chart.panning) is
         * set,`followTouchMove` will take over one-finger touches, so the user
         * needs to use two fingers for zooming and panning.
         *
         * Note the difference to [followPointer](#tooltip.followPointer) that
         * only defines the _position_ of the tooltip. If `followPointer` is
         * false in for example a column series, the tooltip will show above or
         * below the column, but as `followTouchMove` is true, the tooltip will
         * jump from column to column as the user swipes across the plot area.
         *
         * @type      {boolean}
         * @default   {highcharts} true
         * @default   {highstock} true
         * @default   {highmaps} false
         * @since     3.0.1
         * @apioption tooltip.followTouchMove
         */
        /**
         * Callback function to format the text of the tooltip from scratch. In
         * case of single or [shared](#tooltip.shared) tooltips, a string should
         * be returned. In case of [split](#tooltip.split) tooltips, it should
         * return an array where the first item is the header, and subsequent
         * items are mapped to the points. Return `false` to disable tooltip for
         * a specific point on series.
         *
         * A subset of HTML is supported. Unless `useHTML` is true, the HTML of
         * the tooltip is parsed and converted to SVG, therefore this isn't a
         * complete HTML renderer. The following HTML tags are supported: `b`,
         * `br`, `em`, `i`, `span`, `strong`. Spans can be styled with a `style`
         * attribute, but only text-related CSS, that is shared with SVG, is
         * handled.
         *
         * The available data in the formatter differ a bit depending on whether
         * the tooltip is shared or split, or belongs to a single point. In a
         * shared/split tooltip, all properties except `x`, which is common for
         * all points, are kept in an array, `this.points`.
         *
         * Available data are:
         *
         * - **this.percentage (not shared) /**
         *   **this.points[i].percentage (shared)**:
         *   Stacked series and pies only. The point's percentage of the total.
         *
         * - **this.point (not shared) / this.points[i].point (shared)**:
         *   The point object. The point name, if defined, is available through
         *   `this.point.name`.
         *
         * - **this.points**:
         *   In a shared tooltip, this is an array containing all other
         *   properties for each point.
         *
         * - **this.series (not shared) / this.points[i].series (shared)**:
         *   The series object. The series name is available through
         *   `this.series.name`.
         *
         * - **this.total (not shared) / this.points[i].total (shared)**:
         *   Stacked series only. The total value at this point's x value.
         *
         * - **this.x**:
         *   The x value. This property is the same regardless of the tooltip
         *   being shared or not.
         *
         * - **this.y (not shared) / this.points[i].y (shared)**:
         *   The y value.
         *
         * @sample {highcharts} highcharts/tooltip/formatter-simple/
         *         Simple string formatting
         * @sample {highcharts} highcharts/tooltip/formatter-shared/
         *         Formatting with shared tooltip
         * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
         *         Formatting with split tooltip
         * @sample highcharts/tooltip/formatter-conditional-default/
         *         Extending default formatter
         * @sample {highstock} stock/tooltip/formatter/
         *         Formatting with shared tooltip
         * @sample {highmaps} maps/tooltip/formatter/
         *         String formatting
         *
         * @type      {Highcharts.TooltipFormatterCallbackFunction}
         * @apioption tooltip.formatter
         */
        /**
         * Callback function to format the text of the tooltip for
         * visible null points.
         * Works analogously to [formatter](#tooltip.formatter).
         *
         * @sample highcharts/plotoptions/series-nullformat
         *         Format data label and tooltip for null point.
         *
         * @type      {Highcharts.TooltipFormatterCallbackFunction}
         * @apioption tooltip.nullFormatter
         */
        /**
         * Whether to allow the tooltip to render outside the chart's SVG
         * element box. By default (`false`), the tooltip is rendered within the
         * chart's SVG element, which results in the tooltip being aligned
         * inside the chart area. For small charts, this may result in clipping
         * or overlapping. When `true`, a separate SVG element is created and
         * overlaid on the page, allowing the tooltip to be aligned inside the
         * page itself.
         *
         * Defaults to `true` if `chart.scrollablePlotArea` is activated,
         * otherwise `false`.
         *
         * @sample highcharts/tooltip/outside
         *         Small charts with tooltips outside
         *
         * @type      {boolean|undefined}
         * @default   undefined
         * @since     6.1.1
         * @apioption tooltip.outside
         */
        /**
         * A callback function for formatting the HTML output for a single point
         * in the tooltip. Like the `pointFormat` string, but with more
         * flexibility.
         *
         * @type      {Highcharts.FormatterCallbackFunction<Highcharts.Point>}
         * @since     4.1.0
         * @context   Highcharts.Point
         * @apioption tooltip.pointFormatter
         */
        /**
         * A callback function to place the tooltip in a default position. The
         * callback receives three parameters: `labelWidth`, `labelHeight` and
         * `point`, where point contains values for `plotX` and `plotY` telling
         * where the reference point is in the plot area. Add `chart.plotLeft`
         * and `chart.plotTop` to get the full coordinates.
         *
         * Since v7, when [tooltip.split](#tooltip.split) option is enabled,
         * positioner is called for each of the boxes separately, including
         * xAxis header. xAxis header is not a point, instead `point` argument
         * contains info:
         * `{ plotX: Number, plotY: Number, isHeader: Boolean }`
         *
         *
         * The return should be an object containing x and y values, for example
         * `{ x: 100, y: 100 }`.
         *
         * @sample {highcharts} highcharts/tooltip/positioner/
         *         A fixed tooltip position
         * @sample {highstock} stock/tooltip/positioner/
         *         A fixed tooltip position on top of the chart
         * @sample {highmaps} maps/tooltip/positioner/
         *         A fixed tooltip position
         * @sample {highstock} stock/tooltip/split-positioner/
         *         Split tooltip with fixed positions
         * @sample {highstock} stock/tooltip/positioner-scrollable-plotarea/
         *         Scrollable plot area combined with tooltip positioner
         *
         * @type      {Highcharts.TooltipPositionerCallbackFunction}
         * @since     2.2.4
         * @apioption tooltip.positioner
         */
        /**
         * Split the tooltip into one label per series, with the header close
         * to the axis. This is recommended over [shared](#tooltip.shared)
         * tooltips for charts with multiple line series, generally making them
         * easier to read. This option takes precedence over `tooltip.shared`.
         *
         * @productdesc {highstock} In Highcharts Stock, tooltips are split
         * by default since v6.0.0. Stock charts typically contain
         * multi-dimension points and multiple panes, making split tooltips
         * the preferred layout over
         * the previous `shared` tooltip.
         *
         * @sample highcharts/tooltip/split/
         *         Split tooltip
         * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
         *         Split tooltip and custom formatter callback
         *
         * @type      {boolean}
         * @default   {highcharts} false
         * @default   {highstock} true
         * @since     5.0.0
         * @product   highcharts highstock
         * @apioption tooltip.split
         */
        /**
         * Prevents the tooltip from switching or closing, when touched or
         * pointed.
         *
         * @sample highcharts/tooltip/stickoncontact/
         *         Tooltip sticks on pointer contact
         *
         * @type      {boolean}
         * @since     8.0.1
         * @apioption tooltip.stickOnContact
         */
        /**
         * Use HTML to render the contents of the tooltip instead of SVG. Using
         * HTML allows advanced formatting like tables and images in the
         * tooltip. It is also recommended for rtl languages as it works around
         * rtl bugs in early Firefox.
         *
         * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
         *         A table for value alignment
         * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
         *         Full HTML tooltip
         * @sample {highmaps} maps/tooltip/usehtml/
         *         Pure HTML tooltip
         *
         * @type      {boolean}
         * @default   false
         * @since     2.2
         * @apioption tooltip.useHTML
         */
        /**
         * How many decimals to show in each series' y value. This is
         * overridable in each series' tooltip options object. The default is to
         * preserve all decimals.
         *
         * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
         *         Set decimals, prefix and suffix for the value
         * @sample {highmaps} maps/tooltip/valuedecimals/
         *         Set decimals, prefix and suffix for the value
         *
         * @type      {number|undefined}
         * @since     2.2
         * @apioption tooltip.valueDecimals
         */
        /**
         * A string to prepend to each series' y value. Overridable in each
         * series' tooltip options object.
         *
         * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
         *         Set decimals, prefix and suffix for the value
         * @sample {highmaps} maps/tooltip/valuedecimals/
         *         Set decimals, prefix and suffix for the value
         *
         * @type      {string}
         * @since     2.2
         * @apioption tooltip.valuePrefix
         */
        /**
         * A string to append to each series' y value. Overridable in each
         * series' tooltip options object.
         *
         * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
         *         Set decimals, prefix and suffix for the value
         * @sample {highmaps} maps/tooltip/valuedecimals/
         *         Set decimals, prefix and suffix for the value
         *
         * @type      {string}
         * @since     2.2
         * @apioption tooltip.valueSuffix
         */
        /**
         * The format for the date in the tooltip header if the X axis is a
         * datetime axis. The default is a best guess based on the smallest
         * distance between points in the chart.
         *
         * @sample {highcharts} highcharts/tooltip/xdateformat/
         *         A different format
         *
         * @type      {string}
         * @product   highcharts highstock gantt
         * @apioption tooltip.xDateFormat
         */
        /**
         * How many decimals to show for the `point.change` value when the
         * `series.compare` option is set. This is overridable in each series'
         * tooltip options object. The default is to preserve all decimals.
         *
         * @type      {number}
         * @since     1.0.1
         * @product   highstock
         * @apioption tooltip.changeDecimals
         */
        /**
         * Enable or disable the tooltip.
         *
         * @sample {highcharts} highcharts/tooltip/enabled/
         *         Disabled
         * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
         *         Disable tooltip and show values on chart instead
         */
        enabled: true,
        /**
         * Enable or disable animation of the tooltip.
         *
         * @type       {boolean}
         * @default    true
         * @since      2.3.0
         */
        animation: svg$5,
        /**
         * The radius of the rounded border corners.
         *
         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
         *         5px by default
         * @sample {highcharts} highcharts/tooltip/borderradius-0/
         *         Square borders
         * @sample {highmaps} maps/tooltip/background-border/
         *         Background and border demo
         */
        borderRadius: 3,
        /**
         * For series on datetime axes, the date format in the tooltip's
         * header will by default be guessed based on the closest data points.
         * This member gives the default string representations used for
         * each unit. For an overview of the replacement codes, see
         * [dateFormat](/class-reference/Highcharts#.dateFormat).
         *
         * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)
         *
         * @type    {Highcharts.Dictionary<string>}
         * @product highcharts highstock gantt
         */
        dateTimeLabelFormats: {
          /** @internal */
          millisecond: "%A, %b %e, %H:%M:%S.%L",
          /** @internal */
          second: "%A, %b %e, %H:%M:%S",
          /** @internal */
          minute: "%A, %b %e, %H:%M",
          /** @internal */
          hour: "%A, %b %e, %H:%M",
          /** @internal */
          day: "%A, %b %e, %Y",
          /** @internal */
          week: "Week from %A, %b %e, %Y",
          /** @internal */
          month: "%B %Y",
          /** @internal */
          year: "%Y"
        },
        /**
         * A string to append to the tooltip format.
         *
         * @sample {highcharts} highcharts/tooltip/footerformat/
         *         A table for value alignment
         * @sample {highmaps} maps/tooltip/format/
         *         Format demo
         *
         * @since 2.2
         */
        footerFormat: "",
        /**
         * The name of a symbol to use for the border around the tooltip
         * header. Applies only when [tooltip.split](#tooltip.split) is
         * enabled.
         *
         * Custom callbacks for symbol path generation can also be added to
         * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
         * [series.marker.symbol](plotOptions.line.marker.symbol).
         *
         * @see [tooltip.shape](#tooltip.shape)
         *
         * @sample {highstock} stock/tooltip/split-positioner/
         *         Different shapes for header and split boxes
         *
         * @type       {Highcharts.TooltipShapeValue}
         * @validvalue ["callout", "square"]
         * @since      7.0
         */
        headerShape: "callout",
        /**
         * The number of milliseconds to wait until the tooltip is hidden when
         * mouse out from a point or chart.
         *
         * @since     3.0
         */
        hideDelay: 500,
        /**
         * Padding inside the tooltip, in pixels.
         *
         * @since      5.0.0
         */
        padding: 8,
        /**
         * The name of a symbol to use for the border around the tooltip. Can
         * be one of: `"callout"`, `"circle"` or `"rect"`. When
         * [tooltip.split](#tooltip.split)
         * option is enabled, shape is applied to all boxes except header, which
         * is controlled by
         * [tooltip.headerShape](#tooltip.headerShape).
         *
         * Custom callbacks for symbol path generation can also be added to
         * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
         * [series.marker.symbol](plotOptions.line.marker.symbol).
         *
         * @type      {Highcharts.TooltipShapeValue}
         * @since     4.0
         */
        shape: "callout",
        /**
         * When the tooltip is shared, the entire plot area will capture mouse
         * movement or touch events. Tooltip texts for series types with ordered
         * data (not pie, scatter, flags etc) will be shown in a single bubble.
         * This is recommended for single series charts and for tablet/mobile
         * optimized charts.
         *
         * See also [tooltip.split](#tooltip.split), that is better suited for
         * charts with many series, especially line-type series. The
         * `tooltip.split` option takes precedence over `tooltip.shared`.
         *
         * @sample {highcharts} highcharts/tooltip/shared-false/
         *         False by default
         * @sample {highcharts} highcharts/tooltip/shared-true/
         *         True
         * @sample {highcharts} highcharts/tooltip/shared-x-crosshair/
         *         True with x axis crosshair
         * @sample {highcharts} highcharts/tooltip/shared-true-mixed-types/
         *         True with mixed series types
         *
         * @since     2.1
         * @product   highcharts highstock
         */
        shared: false,
        /**
         * Proximity snap for graphs or single points. It defaults to 10 for
         * mouse-powered devices and 25 for touch devices.
         *
         * Note that in most cases the whole plot area captures the mouse
         * movement, and in these cases `tooltip.snap` doesn't make sense. This
         * applies when [stickyTracking](#plotOptions.series.stickyTracking)
         * is `true` (default) and when the tooltip is [shared](#tooltip.shared)
         * or [split](#tooltip.split).
         *
         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
         *         10 px by default
         * @sample {highcharts} highcharts/tooltip/snap-50/
         *         50 px on graph
         *
         * @type    {number}
         * @default 10/25
         * @since   1.2.0
         * @product highcharts highstock
         */
        snap: isTouchDevice$4 ? 25 : 10,
        /**
         * The HTML of the tooltip header line. Variables are enclosed by
         * curly brackets. Available variables are `point.key`, `series.name`,
         * `series.color` and other members from the `point` and `series`
         * objects. The `point.key` variable contains the category name, x
         * value or datetime string depending on the type of axis. For datetime
         * axes, the `point.key` date format can be set using
         * `tooltip.xDateFormat`.
         *
         * @sample {highcharts} highcharts/tooltip/footerformat/
         *         An HTML table in the tooltip
         * @sample {highstock} highcharts/tooltip/footerformat/
         *         An HTML table in the tooltip
         * @sample {highmaps} maps/tooltip/format/
         *         Format demo
         *
         * @type       {string}
         * @apioption  tooltip.headerFormat
         */
        headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
        /**
         * The HTML of the null point's line in the tooltip. Works analogously
         * to [pointFormat](#tooltip.pointFormat).
         *
         * @sample {highcharts} highcharts/plotoptions/series-nullformat
         *         Format data label and tooltip for null point.
         *
         * @type      {string}
         * @apioption tooltip.nullFormat
         */
        /**
         * The HTML of the point's line in the tooltip. Variables are enclosed
         * by curly brackets. Available variables are `point.x`, `point.y`,
         * `series.name` and `series.color` and other properties on the same
         * form. Furthermore, `point.y` can be extended by the
         * `tooltip.valuePrefix` and `tooltip.valueSuffix` variables. This can
         * also be overridden for each series, which makes it a good hook for
         * displaying units.
         *
         * In styled mode, the dot is colored by a class name rather
         * than the point color.
         *
         * @sample {highcharts} highcharts/tooltip/pointformat/
         *         A different point format with value suffix
         * @sample {highmaps} maps/tooltip/format/
         *         Format demo
         *
         * @type       {string}
         * @since      2.2
         * @apioption  tooltip.pointFormat
         */
        pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.y}</b><br/>',
        /**
         * The background color or gradient for the tooltip.
         *
         * In styled mode, the stroke width is set in the
         * `.highcharts-tooltip-box` class.
         *
         * @sample {highcharts} highcharts/tooltip/backgroundcolor-solid/
         *         Yellowish background
         * @sample {highcharts} highcharts/tooltip/backgroundcolor-gradient/
         *         Gradient
         * @sample {highcharts} highcharts/css/tooltip-border-background/
         *         Tooltip in styled mode
         * @sample {highstock} stock/tooltip/general/
         *         Custom tooltip
         * @sample {highstock} highcharts/css/tooltip-border-background/
         *         Tooltip in styled mode
         * @sample {highmaps} maps/tooltip/background-border/
         *         Background and border demo
         * @sample {highmaps} highcharts/css/tooltip-border-background/
         *         Tooltip in styled mode
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        backgroundColor: color$g(palette.neutralColor3).setOpacity(0.85).get(),
        /**
         * The pixel width of the tooltip border.
         *
         * In styled mode, the stroke width is set in the
         * `.highcharts-tooltip-box` class.
         *
         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
         *         2px by default
         * @sample {highcharts} highcharts/tooltip/borderwidth/
         *         No border (shadow only)
         * @sample {highcharts} highcharts/css/tooltip-border-background/
         *         Tooltip in styled mode
         * @sample {highstock} stock/tooltip/general/
         *         Custom tooltip
         * @sample {highstock} highcharts/css/tooltip-border-background/
         *         Tooltip in styled mode
         * @sample {highmaps} maps/tooltip/background-border/
         *         Background and border demo
         * @sample {highmaps} highcharts/css/tooltip-border-background/
         *         Tooltip in styled mode
         */
        borderWidth: 1,
        /**
         * Whether to apply a drop shadow to the tooltip.
         *
         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
         *         True by default
         * @sample {highcharts} highcharts/tooltip/shadow/
         *         False
         * @sample {highmaps} maps/tooltip/positioner/
         *         Fixed tooltip position, border and shadow disabled
         *
         * @type {boolean|Highcharts.ShadowOptionsObject}
         */
        shadow: true,
        /**
         * Prevents the tooltip from switching or closing when touched or
         * pointed.
         *
         * @sample highcharts/tooltip/stickoncontact/
         *         Tooltip sticks on pointer contact
         *
         * @since     8.0.1
         */
        stickOnContact: false,
        /**
         * CSS styles for the tooltip. The tooltip can also be styled through
         * the CSS class `.highcharts-tooltip`.
         *
         * Note that the default `pointerEvents` style makes the tooltip ignore
         * mouse events, so in order to use clickable tooltips, this value must
         * be set to `auto`.
         *
         * @sample {highcharts} highcharts/tooltip/style/
         *         Greater padding, bold text
         *
         * @type {Highcharts.CSSObject}
         */
        style: {
          /** @internal */
          color: palette.neutralColor80,
          /** @internal */
          cursor: "default",
          /** @internal */
          fontSize: "12px",
          /** @internal */
          whiteSpace: "nowrap"
        },
        /**
         * Use HTML to render the contents of the tooltip instead of SVG. Using
         * HTML allows advanced formatting like tables and images in the
         * tooltip. It is also recommended for rtl languages as it works around
         * rtl bugs in early Firefox.
         *
         * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
         *         A table for value alignment
         * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
         *         Full HTML tooltip
         * @sample {highmaps} maps/tooltip/usehtml/
         *         Pure HTML tooltip
         *
         * @since     2.2
         */
        useHTML: false
      },
      /**
       * Highchart by default puts a credits label in the lower right corner
       * of the chart. This can be changed using these options.
       */
      credits: {
        /**
         * Credits for map source to be concatenated with conventional credit
         * text. By default this is a format string that collects copyright
         * information from the map if available.
         *
         * @see [mapTextFull](#credits.mapTextFull)
         * @see [text](#credits.text)
         *
         * @type      {string}
         * @default   \u00a9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>
         * @since     4.2.2
         * @product   highmaps
         * @apioption credits.mapText
         */
        /**
         * Detailed credits for map source to be displayed on hover of credits
         * text. By default this is a format string that collects copyright
         * information from the map if available.
         *
         * @see [mapText](#credits.mapText)
         * @see [text](#credits.text)
         *
         * @type      {string}
         * @default   {geojson.copyright}
         * @since     4.2.2
         * @product   highmaps
         * @apioption credits.mapTextFull
         */
        /**
         * Whether to show the credits text.
         *
         * @sample {highcharts} highcharts/credits/enabled-false/
         *         Credits disabled
         * @sample {highstock} stock/credits/enabled/
         *         Credits disabled
         * @sample {highmaps} maps/credits/enabled-false/
         *         Credits disabled
         */
        enabled: true,
        /**
         * The URL for the credits label.
         *
         * @sample {highcharts} highcharts/credits/href/
         *         Custom URL and text
         * @sample {highmaps} maps/credits/customized/
         *         Custom URL and text
         */
        href: "https://www.highcharts.com?credits",
        /**
         * Position configuration for the credits label.
         *
         * @sample {highcharts} highcharts/credits/position-left/
         *         Left aligned
         * @sample {highcharts} highcharts/credits/position-left/
         *         Left aligned
         * @sample {highmaps} maps/credits/customized/
         *         Left aligned
         * @sample {highmaps} maps/credits/customized/
         *         Left aligned
         *
         * @type    {Highcharts.AlignObject}
         * @since   2.1
         */
        position: {
          /** @internal */
          align: "right",
          /** @internal */
          x: -10,
          /** @internal */
          verticalAlign: "bottom",
          /** @internal */
          y: -5
        },
        /**
         * CSS styles for the credits label.
         *
         * @see In styled mode, credits styles can be set with the
         *      `.highcharts-credits` class.
         *
         * @type {Highcharts.CSSObject}
         */
        style: {
          /** @internal */
          cursor: "pointer",
          /** @internal */
          color: palette.neutralColor40,
          /** @internal */
          fontSize: "9px"
        },
        /**
         * The text for the credits label.
         *
         * @productdesc {highmaps}
         * If a map is loaded as GeoJSON, the text defaults to
         * `Highcharts @ {map-credits}`. Otherwise, it defaults to
         * `Highcharts.com`.
         *
         * @sample {highcharts} highcharts/credits/href/
         *         Custom URL and text
         * @sample {highmaps} maps/credits/customized/
         *         Custom URL and text
         */
        text: "Highcharts.com"
      }
    };
    defaultOptions$g.chart.styledMode = false;
    var defaultTime$2 = new Time(merge$1m(defaultOptions$g.global, defaultOptions$g.time));
    function getOptions$3() {
      return defaultOptions$g;
    }
    function setOptions$2(options) {
      merge$1m(true, defaultOptions$g, options);
      if (options.time || options.global) {
        if (H.time) {
          H.time.update(merge$1m(defaultOptions$g.global, defaultOptions$g.time, options.global, options.time));
        } else {
          H.time = defaultTime$2;
        }
      }
      return defaultOptions$g;
    }
    var DefaultOptions = {
      defaultOptions: defaultOptions$g,
      defaultTime: defaultTime$2,
      getOptions: getOptions$3,
      setOptions: setOptions$2
    };
    var color$f = Color.parse;
    var win$e = H.win;
    var isNumber$P = Utilities.isNumber, objectEach$z = Utilities.objectEach;
    var Fx = (
      /** @class */
      function() {
        function Fx2(elem, options, prop) {
          this.pos = NaN;
          this.options = options;
          this.elem = elem;
          this.prop = prop;
        }
        Fx2.prototype.dSetter = function() {
          var paths = this.paths, start = paths && paths[0], end = paths && paths[1], now = this.now || 0;
          var path = [];
          if (now === 1 || !start || !end) {
            path = this.toD || [];
          } else if (start.length === end.length && now < 1) {
            for (var i = 0; i < end.length; i++) {
              var startSeg = start[i];
              var endSeg = end[i];
              var tweenSeg = [];
              for (var j = 0; j < endSeg.length; j++) {
                var startItem = startSeg[j];
                var endItem = endSeg[j];
                if (isNumber$P(startItem) && isNumber$P(endItem) && // Arc boolean flags
                !(endSeg[0] === "A" && (j === 4 || j === 5))) {
                  tweenSeg[j] = startItem + now * (endItem - startItem);
                } else {
                  tweenSeg[j] = endItem;
                }
              }
              path.push(tweenSeg);
            }
          } else {
            path = end;
          }
          this.elem.attr("d", path, void 0, true);
        };
        Fx2.prototype.update = function() {
          var elem = this.elem, prop = this.prop, now = this.now, step = this.options.step;
          if (this[prop + "Setter"]) {
            this[prop + "Setter"]();
          } else if (elem.attr) {
            if (elem.element) {
              elem.attr(prop, now, null, true);
            }
          } else {
            elem.style[prop] = now + this.unit;
          }
          if (step) {
            step.call(elem, now, this);
          }
        };
        Fx2.prototype.run = function(from, to, unit) {
          var self = this, options = self.options, timer = function(gotoEnd) {
            return timer.stopped ? false : self.step(gotoEnd);
          }, requestAnimationFrame2 = win$e.requestAnimationFrame || function(step2) {
            setTimeout(step2, 13);
          }, step = function() {
            for (var i = 0; i < Fx2.timers.length; i++) {
              if (!Fx2.timers[i]()) {
                Fx2.timers.splice(i--, 1);
              }
            }
            if (Fx2.timers.length) {
              requestAnimationFrame2(step);
            }
          };
          if (from === to && !this.elem["forceAnimate:" + this.prop]) {
            delete options.curAnim[this.prop];
            if (options.complete && Object.keys(options.curAnim).length === 0) {
              options.complete.call(this.elem);
            }
          } else {
            this.startTime = +/* @__PURE__ */ new Date();
            this.start = from;
            this.end = to;
            this.unit = unit;
            this.now = this.start;
            this.pos = 0;
            timer.elem = this.elem;
            timer.prop = this.prop;
            if (timer() && Fx2.timers.push(timer) === 1) {
              requestAnimationFrame2(step);
            }
          }
        };
        Fx2.prototype.step = function(gotoEnd) {
          var t = +/* @__PURE__ */ new Date(), options = this.options, elem = this.elem, complete = options.complete, duration = options.duration, curAnim = options.curAnim;
          var ret, done;
          if (elem.attr && !elem.element) {
            ret = false;
          } else if (gotoEnd || t >= duration + this.startTime) {
            this.now = this.end;
            this.pos = 1;
            this.update();
            curAnim[this.prop] = true;
            done = true;
            objectEach$z(curAnim, function(val) {
              if (val !== true) {
                done = false;
              }
            });
            if (done && complete) {
              complete.call(elem);
            }
            ret = false;
          } else {
            this.pos = options.easing((t - this.startTime) / duration);
            this.now = this.start + (this.end - this.start) * this.pos;
            this.update();
            ret = true;
          }
          return ret;
        };
        Fx2.prototype.initPath = function(elem, fromD, toD) {
          var startX = elem.startX, endX = elem.endX, end = toD.slice(), isArea = elem.isArea, positionFactor = isArea ? 2 : 1;
          var shift, fullLength, i, reverse, start = fromD && fromD.slice();
          if (!start) {
            return [end, end];
          }
          function prepend(arr, other) {
            while (arr.length < fullLength) {
              var moveSegment = arr[0], otherSegment = other[fullLength - arr.length];
              if (otherSegment && moveSegment[0] === "M") {
                if (otherSegment[0] === "C") {
                  arr[0] = [
                    "C",
                    moveSegment[1],
                    moveSegment[2],
                    moveSegment[1],
                    moveSegment[2],
                    moveSegment[1],
                    moveSegment[2]
                  ];
                } else {
                  arr[0] = ["L", moveSegment[1], moveSegment[2]];
                }
              }
              arr.unshift(moveSegment);
              if (isArea) {
                var z = arr.pop();
                arr.push(arr[arr.length - 1], z);
              }
            }
          }
          function append(arr, other) {
            while (arr.length < fullLength) {
              var segmentToAdd = arr[Math.floor(arr.length / positionFactor) - 1].slice();
              if (segmentToAdd[0] === "C") {
                segmentToAdd[1] = segmentToAdd[5];
                segmentToAdd[2] = segmentToAdd[6];
              }
              if (!isArea) {
                arr.push(segmentToAdd);
              } else {
                var lowerSegmentToAdd = arr[Math.floor(arr.length / positionFactor)].slice();
                arr.splice(arr.length / 2, 0, segmentToAdd, lowerSegmentToAdd);
              }
            }
          }
          if (startX && endX && endX.length) {
            for (i = 0; i < startX.length; i++) {
              if (startX[i] === endX[0]) {
                shift = i;
                break;
              } else if (startX[0] === endX[endX.length - startX.length + i]) {
                shift = i;
                reverse = true;
                break;
              } else if (startX[startX.length - 1] === endX[endX.length - startX.length + i]) {
                shift = startX.length - i;
                break;
              }
            }
            if (typeof shift === "undefined") {
              start = [];
            }
          }
          if (start.length && isNumber$P(shift)) {
            fullLength = end.length + shift * positionFactor;
            if (!reverse) {
              prepend(end, start);
              append(start);
            } else {
              prepend(start, end);
              append(end);
            }
          }
          return [start, end];
        };
        Fx2.prototype.fillSetter = function() {
          Fx2.prototype.strokeSetter.apply(this, arguments);
        };
        Fx2.prototype.strokeSetter = function() {
          this.elem.attr(this.prop, color$f(this.start).tweenTo(color$f(this.end), this.pos), null, true);
        };
        Fx2.timers = [];
        return Fx2;
      }()
    );
    var defined$U = Utilities.defined, getStyle$1 = Utilities.getStyle, isArray$m = Utilities.isArray, isNumber$O = Utilities.isNumber, isObject$d = Utilities.isObject, merge$1l = Utilities.merge, objectEach$y = Utilities.objectEach, pick$1z = Utilities.pick;
    function setAnimation$5(animation, chart) {
      chart.renderer.globalAnimation = pick$1z(animation, chart.options.chart.animation, true);
    }
    function animObject$c(animation) {
      return isObject$d(animation) ? merge$1l({ duration: 500, defer: 0 }, animation) : { duration: animation ? 500 : 0, defer: 0 };
    }
    function getDeferredAnimation$3(chart, animation, series) {
      var labelAnimation = animObject$c(animation), s = series ? [series] : chart.series;
      var defer = 0, duration = 0;
      s.forEach(function(series2) {
        var seriesAnim = animObject$c(series2.options.animation);
        defer = animation && defined$U(animation.defer) ? labelAnimation.defer : Math.max(defer, seriesAnim.duration + seriesAnim.defer);
        duration = Math.min(labelAnimation.duration, seriesAnim.duration);
      });
      if (chart.renderer.forExport) {
        defer = 0;
      }
      var anim = {
        defer: Math.max(0, defer - duration),
        duration: Math.min(defer, duration)
      };
      return anim;
    }
    function animate$2(el, params, opt) {
      var start, unit = "", end, fx, args;
      if (!isObject$d(opt)) {
        args = arguments;
        opt = {
          duration: args[2],
          easing: args[3],
          complete: args[4]
        };
      }
      if (!isNumber$O(opt.duration)) {
        opt.duration = 400;
      }
      opt.easing = typeof opt.easing === "function" ? opt.easing : Math[opt.easing] || Math.easeInOutSine;
      opt.curAnim = merge$1l(params);
      objectEach$y(params, function(val, prop) {
        stop$2(el, prop);
        fx = new Fx(el, opt, prop);
        end = void 0;
        if (prop === "d" && isArray$m(params.d)) {
          fx.paths = fx.initPath(el, el.pathArray, params.d);
          fx.toD = params.d;
          start = 0;
          end = 1;
        } else if (el.attr) {
          start = el.attr(prop);
        } else {
          start = parseFloat(getStyle$1(el, prop)) || 0;
          if (prop !== "opacity") {
            unit = "px";
          }
        }
        if (!end) {
          end = val;
        }
        if (typeof end === "string" && end.match("px")) {
          end = end.replace(/px/g, "");
        }
        fx.run(start, end, unit);
      });
    }
    function stop$2(el, prop) {
      var i = Fx.timers.length;
      while (i--) {
        if (Fx.timers[i].elem === el && (!prop || prop === Fx.timers[i].prop)) {
          Fx.timers[i].stopped = true;
        }
      }
    }
    var animationExports = {
      animate: animate$2,
      animObject: animObject$c,
      getDeferredAnimation: getDeferredAnimation$3,
      setAnimation: setAnimation$5,
      stop: stop$2
    };
    var SVG_NS$3 = H.SVG_NS;
    var attr$7 = Utilities.attr, createElement$a = Utilities.createElement, discardElement$6 = Utilities.discardElement, error$8 = Utilities.error, isString$b = Utilities.isString, objectEach$x = Utilities.objectEach, splat$h = Utilities.splat;
    var hasValidDOMParser = function() {
      try {
        return Boolean(new DOMParser().parseFromString("", "text/html"));
      } catch (e2) {
        return false;
      }
    }();
    var AST = (
      /** @class */
      function() {
        function AST2(source) {
          this.nodes = typeof source === "string" ? this.parseMarkup(source) : source;
        }
        AST2.filterUserAttributes = function(attributes) {
          objectEach$x(attributes, function(val, key) {
            var valid = true;
            if (AST2.allowedAttributes.indexOf(key) === -1) {
              valid = false;
            }
            if (["background", "dynsrc", "href", "lowsrc", "src"].indexOf(key) !== -1) {
              valid = isString$b(val) && AST2.allowedReferences.some(function(ref) {
                return val.indexOf(ref) === 0;
              });
            }
            if (!valid) {
              error$8("Highcharts warning: Invalid attribute '" + key + "' in config");
              delete attributes[key];
            }
          });
          return attributes;
        };
        AST2.setElementHTML = function(el, html2) {
          el.innerHTML = "";
          if (html2) {
            var ast = new AST2(html2);
            ast.addToDOM(el);
          }
        };
        AST2.prototype.addToDOM = function(parent) {
          function recurse(subtree, subParent) {
            var ret;
            splat$h(subtree).forEach(function(item2) {
              var tagName = item2.tagName;
              var textNode = item2.textContent ? H.doc.createTextNode(item2.textContent) : void 0;
              var node;
              if (tagName) {
                if (tagName === "#text") {
                  node = textNode;
                } else if (AST2.allowedTags.indexOf(tagName) !== -1) {
                  var NS = tagName === "svg" ? SVG_NS$3 : subParent.namespaceURI || SVG_NS$3;
                  var element = H.doc.createElementNS(NS, tagName);
                  var attributes_1 = item2.attributes || {};
                  objectEach$x(item2, function(val, key) {
                    if (key !== "tagName" && key !== "attributes" && key !== "children" && key !== "textContent") {
                      attributes_1[key] = val;
                    }
                  });
                  attr$7(element, AST2.filterUserAttributes(attributes_1));
                  if (textNode) {
                    element.appendChild(textNode);
                  }
                  recurse(item2.children || [], element);
                  node = element;
                } else {
                  error$8("Highcharts warning: Invalid tagName '" + tagName + "' in config");
                }
              }
              if (node) {
                subParent.appendChild(node);
              }
              ret = node;
            });
            return ret;
          }
          return recurse(this.nodes, parent);
        };
        AST2.prototype.parseMarkup = function(markup) {
          var nodes = [];
          markup = markup.trim();
          var doc2;
          var body;
          if (hasValidDOMParser) {
            doc2 = new DOMParser().parseFromString(markup, "text/html");
          } else {
            body = createElement$a("div");
            body.innerHTML = markup;
            doc2 = { body };
          }
          var appendChildNodes = function(node, addTo) {
            var tagName = node.nodeName.toLowerCase();
            var astNode = {
              tagName
            };
            if (tagName === "#text") {
              astNode.textContent = node.textContent || "";
            }
            var parsedAttributes = node.attributes;
            if (parsedAttributes) {
              var attributes_2 = {};
              [].forEach.call(parsedAttributes, function(attrib) {
                attributes_2[attrib.name] = attrib.value;
              });
              astNode.attributes = attributes_2;
            }
            if (node.childNodes.length) {
              var children_1 = [];
              [].forEach.call(node.childNodes, function(childNode) {
                appendChildNodes(childNode, children_1);
              });
              if (children_1.length) {
                astNode.children = children_1;
              }
            }
            addTo.push(astNode);
          };
          [].forEach.call(doc2.body.childNodes, function(childNode) {
            return appendChildNodes(childNode, nodes);
          });
          if (body) {
            discardElement$6(body);
          }
          return nodes;
        };
        AST2.allowedAttributes = [
          "aria-controls",
          "aria-describedby",
          "aria-expanded",
          "aria-haspopup",
          "aria-hidden",
          "aria-label",
          "aria-labelledby",
          "aria-live",
          "aria-pressed",
          "aria-readonly",
          "aria-roledescription",
          "aria-selected",
          "class",
          "clip-path",
          "color",
          "colspan",
          "cx",
          "cy",
          "d",
          "dx",
          "dy",
          "disabled",
          "fill",
          "height",
          "href",
          "id",
          "in",
          "markerHeight",
          "markerWidth",
          "offset",
          "opacity",
          "orient",
          "padding",
          "paddingLeft",
          "paddingRight",
          "patternUnits",
          "r",
          "refX",
          "refY",
          "role",
          "scope",
          "slope",
          "src",
          "startOffset",
          "stdDeviation",
          "stroke",
          "stroke-linecap",
          "stroke-width",
          "style",
          "tableValues",
          "result",
          "rowspan",
          "summary",
          "target",
          "tabindex",
          "text-align",
          "textAnchor",
          "textLength",
          "type",
          "valign",
          "width",
          "x",
          "x1",
          "x2",
          "y",
          "y1",
          "y2",
          "zIndex"
        ];
        AST2.allowedReferences = [
          "https://",
          "http://",
          "mailto:",
          "/",
          "../",
          "./",
          "#"
        ];
        AST2.allowedTags = [
          "a",
          "b",
          "br",
          "button",
          "caption",
          "circle",
          "clipPath",
          "code",
          "dd",
          "defs",
          "div",
          "dl",
          "dt",
          "em",
          "feComponentTransfer",
          "feFuncA",
          "feFuncB",
          "feFuncG",
          "feFuncR",
          "feGaussianBlur",
          "feOffset",
          "feMerge",
          "feMergeNode",
          "filter",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "hr",
          "i",
          "img",
          "li",
          "linearGradient",
          "marker",
          "ol",
          "p",
          "path",
          "pattern",
          "pre",
          "rect",
          "small",
          "span",
          "stop",
          "strong",
          "style",
          "sub",
          "sup",
          "svg",
          "table",
          "text",
          "thead",
          "tbody",
          "tspan",
          "td",
          "th",
          "tr",
          "u",
          "ul",
          "#text"
        ];
        return AST2;
      }()
    );
    var defaultOptions$f = DefaultOptions.defaultOptions, defaultTime$1 = DefaultOptions.defaultTime;
    var getNestedProperty$2 = Utilities.getNestedProperty, isNumber$N = Utilities.isNumber, pick$1y = Utilities.pick, pInt$8 = Utilities.pInt;
    function dateFormat(format2, timestamp, capitalize) {
      return defaultTime$1.dateFormat(format2, timestamp, capitalize);
    }
    function format$e(str, ctx, chart) {
      var splitter = "{", isInside = false, segment, valueAndFormat, val, index;
      var floatRegex = /f$/;
      var decRegex = /\.([0-9])/;
      var lang2 = defaultOptions$f.lang;
      var time = chart && chart.time || defaultTime$1;
      var numberFormatter = chart && chart.numberFormatter || numberFormat$2;
      var ret = [];
      while (str) {
        index = str.indexOf(splitter);
        if (index === -1) {
          break;
        }
        segment = str.slice(0, index);
        if (isInside) {
          valueAndFormat = segment.split(":");
          val = getNestedProperty$2(valueAndFormat.shift() || "", ctx);
          if (valueAndFormat.length && typeof val === "number") {
            segment = valueAndFormat.join(":");
            if (floatRegex.test(segment)) {
              var decimals = parseInt((segment.match(decRegex) || ["", "-1"])[1], 10);
              if (val !== null) {
                val = numberFormatter(val, decimals, lang2.decimalPoint, segment.indexOf(",") > -1 ? lang2.thousandsSep : "");
              }
            } else {
              val = time.dateFormat(segment, val);
            }
          }
          ret.push(val);
        } else {
          ret.push(segment);
        }
        str = str.slice(index + 1);
        isInside = !isInside;
        splitter = isInside ? "}" : "{";
      }
      ret.push(str);
      return ret.join("");
    }
    function numberFormat$2(number, decimals, decimalPoint, thousandsSep) {
      number = +number || 0;
      decimals = +decimals;
      var ret, fractionDigits;
      var lang2 = defaultOptions$f.lang, origDec = (number.toString().split(".")[1] || "").split("e")[0].length, exponent = number.toString().split("e"), firstDecimals = decimals;
      if (decimals === -1) {
        decimals = Math.min(origDec, 20);
      } else if (!isNumber$N(decimals)) {
        decimals = 2;
      } else if (decimals && exponent[1] && exponent[1] < 0) {
        fractionDigits = decimals + +exponent[1];
        if (fractionDigits >= 0) {
          exponent[0] = (+exponent[0]).toExponential(fractionDigits).split("e")[0];
          decimals = fractionDigits;
        } else {
          exponent[0] = exponent[0].split(".")[0] || 0;
          if (decimals < 20) {
            number = (exponent[0] * Math.pow(10, exponent[1])).toFixed(decimals);
          } else {
            number = 0;
          }
          exponent[1] = 0;
        }
      }
      var roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) + Math.pow(10, -Math.max(decimals, origDec) - 1)).toFixed(decimals);
      var strinteger = String(pInt$8(roundedNumber));
      var thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;
      decimalPoint = pick$1y(decimalPoint, lang2.decimalPoint);
      thousandsSep = pick$1y(thousandsSep, lang2.thousandsSep);
      ret = number < 0 ? "-" : "";
      ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : "";
      if (+exponent[1] < 0 && !firstDecimals) {
        ret = "0";
      } else {
        ret += strinteger.substr(thousands).replace(/(\d{3})(?=\d)/g, "$1" + thousandsSep);
      }
      if (decimals) {
        ret += decimalPoint + roundedNumber.slice(-decimals);
      }
      if (exponent[1] && +ret !== 0) {
        ret += "e" + exponent[1];
      }
      return ret;
    }
    var FormatUtilities = {
      dateFormat,
      format: format$e,
      numberFormat: numberFormat$2
    };
    var clamp$i = Utilities.clamp, pick$1x = Utilities.pick, stableSort$6 = Utilities.stableSort;
    var RendererUtilities;
    (function(RendererUtilities2) {
      function distribute2(boxes, len, maxDistance) {
        var origBoxes = boxes, reducedLen = origBoxes.reducedLen || len, sortByRank = function(a, b) {
          return (b.rank || 0) - (a.rank || 0);
        }, sortByTarget = function(a, b) {
          return a.target - b.target;
        };
        var i, overlapping = true, restBoxes = [], box, target, total = 0;
        i = boxes.length;
        while (i--) {
          total += boxes[i].size;
        }
        if (total > reducedLen) {
          stableSort$6(boxes, sortByRank);
          i = 0;
          total = 0;
          while (total <= reducedLen) {
            total += boxes[i].size;
            i++;
          }
          restBoxes = boxes.splice(i - 1, boxes.length);
        }
        stableSort$6(boxes, sortByTarget);
        boxes = boxes.map(function(box2) {
          return {
            size: box2.size,
            targets: [box2.target],
            align: pick$1x(box2.align, 0.5)
          };
        });
        while (overlapping) {
          i = boxes.length;
          while (i--) {
            box = boxes[i];
            target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;
            box.pos = clamp$i(target - box.size * box.align, 0, len - box.size);
          }
          i = boxes.length;
          overlapping = false;
          while (i--) {
            if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {
              boxes[i - 1].size += boxes[i].size;
              boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);
              boxes[i - 1].align = 0.5;
              if (boxes[i - 1].pos + boxes[i - 1].size > len) {
                boxes[i - 1].pos = len - boxes[i - 1].size;
              }
              boxes.splice(i, 1);
              overlapping = true;
            }
          }
        }
        origBoxes.push.apply(origBoxes, restBoxes);
        i = 0;
        boxes.some(function(box2) {
          var posInCompositeBox = 0;
          return (box2.targets || []).some(function() {
            origBoxes[i].pos = box2.pos + posInCompositeBox;
            if (typeof maxDistance !== "undefined" && Math.abs(origBoxes[i].pos - origBoxes[i].target) > maxDistance) {
              origBoxes.slice(0, i + 1).forEach(function(box3) {
                return delete box3.pos;
              });
              origBoxes.reducedLen = (origBoxes.reducedLen || len) - len * 0.1;
              if (origBoxes.reducedLen > len * 0.1) {
                distribute2(origBoxes, len, maxDistance);
              }
              return true;
            }
            posInCompositeBox += origBoxes[i].size;
            i++;
            return false;
          });
        });
        stableSort$6(origBoxes, sortByTarget);
        return origBoxes;
      }
      RendererUtilities2.distribute = distribute2;
    })(RendererUtilities || (RendererUtilities = {}));
    const R = RendererUtilities;
    var animate$1 = animationExports.animate, animObject$b = animationExports.animObject, stop$1 = animationExports.stop;
    var deg2rad$8 = H.deg2rad, doc$l = H.doc, noop$l = H.noop, svg$4 = H.svg, SVG_NS$2 = H.SVG_NS, win$d = H.win;
    var addEvent$11 = Utilities.addEvent, attr$6 = Utilities.attr, createElement$9 = Utilities.createElement, css$c = Utilities.css, defined$T = Utilities.defined, erase$8 = Utilities.erase, extend$1o = Utilities.extend, fireEvent$A = Utilities.fireEvent, isArray$l = Utilities.isArray, isFunction$4 = Utilities.isFunction, isNumber$M = Utilities.isNumber, isString$a = Utilities.isString, merge$1k = Utilities.merge, objectEach$w = Utilities.objectEach, pick$1w = Utilities.pick, pInt$7 = Utilities.pInt, syncTimeout$8 = Utilities.syncTimeout, uniqueKey$7 = Utilities.uniqueKey;
    var SVGElement = (
      /** @class */
      function() {
        function SVGElement2() {
          this.element = void 0;
          this.onEvents = {};
          this.opacity = 1;
          this.renderer = void 0;
          this.SVG_NS = SVG_NS$2;
          this.symbolCustomAttribs = [
            "x",
            "y",
            "width",
            "height",
            "r",
            "start",
            "end",
            "innerR",
            "anchorX",
            "anchorY",
            "rounded"
          ];
        }
        SVGElement2.prototype._defaultGetter = function(key) {
          var ret = pick$1w(
            this[key + "Value"],
            // align getter
            this[key],
            this.element ? this.element.getAttribute(key) : null,
            0
          );
          if (/^[\-0-9\.]+$/.test(ret)) {
            ret = parseFloat(ret);
          }
          return ret;
        };
        SVGElement2.prototype._defaultSetter = function(value, key, element) {
          element.setAttribute(key, value);
        };
        SVGElement2.prototype.add = function(parent) {
          var renderer = this.renderer, element = this.element;
          var inserted;
          if (parent) {
            this.parentGroup = parent;
          }
          this.parentInverted = parent && parent.inverted;
          if (typeof this.textStr !== "undefined" && this.element.nodeName === "text") {
            renderer.buildText(this);
          }
          this.added = true;
          if (!parent || parent.handleZ || this.zIndex) {
            inserted = this.zIndexSetter();
          }
          if (!inserted) {
            (parent ? parent.element : renderer.box).appendChild(element);
          }
          if (this.onAdd) {
            this.onAdd();
          }
          return this;
        };
        SVGElement2.prototype.addClass = function(className, replace) {
          var currentClassName = replace ? "" : this.attr("class") || "";
          className = (className || "").split(/ /g).reduce(function(newClassName, name) {
            if (currentClassName.indexOf(name) === -1) {
              newClassName.push(name);
            }
            return newClassName;
          }, currentClassName ? [currentClassName] : []).join(" ");
          if (className !== currentClassName) {
            this.attr("class", className);
          }
          return this;
        };
        SVGElement2.prototype.afterSetters = function() {
          if (this.doTransform) {
            this.updateTransform();
            this.doTransform = false;
          }
        };
        SVGElement2.prototype.align = function(alignOptions, alignByTranslate, box) {
          var attribs = {}, renderer = this.renderer, alignedObjects = renderer.alignedObjects;
          var x, y, alignTo, alignFactor, vAlignFactor;
          if (alignOptions) {
            this.alignOptions = alignOptions;
            this.alignByTranslate = alignByTranslate;
            if (!box || isString$a(box)) {
              this.alignTo = alignTo = box || "renderer";
              erase$8(alignedObjects, this);
              alignedObjects.push(this);
              box = void 0;
            }
          } else {
            alignOptions = this.alignOptions;
            alignByTranslate = this.alignByTranslate;
            alignTo = this.alignTo;
          }
          box = pick$1w(box, renderer[alignTo], alignTo === "scrollablePlotBox" ? renderer.plotBox : void 0, renderer);
          var align = alignOptions.align, vAlign = alignOptions.verticalAlign;
          x = (box.x || 0) + (alignOptions.x || 0);
          y = (box.y || 0) + (alignOptions.y || 0);
          if (align === "right") {
            alignFactor = 1;
          } else if (align === "center") {
            alignFactor = 2;
          }
          if (alignFactor) {
            x += (box.width - (alignOptions.width || 0)) / alignFactor;
          }
          attribs[alignByTranslate ? "translateX" : "x"] = Math.round(x);
          if (vAlign === "bottom") {
            vAlignFactor = 1;
          } else if (vAlign === "middle") {
            vAlignFactor = 2;
          }
          if (vAlignFactor) {
            y += (box.height - (alignOptions.height || 0)) / vAlignFactor;
          }
          attribs[alignByTranslate ? "translateY" : "y"] = Math.round(y);
          this[this.placed ? "animate" : "attr"](attribs);
          this.placed = true;
          this.alignAttr = attribs;
          return this;
        };
        SVGElement2.prototype.alignSetter = function(value) {
          var convert = {
            left: "start",
            center: "middle",
            right: "end"
          };
          if (convert[value]) {
            this.alignValue = value;
            this.element.setAttribute("text-anchor", convert[value]);
          }
        };
        SVGElement2.prototype.animate = function(params, options, complete) {
          var _this = this;
          var animOptions = animObject$b(pick$1w(options, this.renderer.globalAnimation, true)), deferTime = animOptions.defer;
          if (pick$1w(doc$l.hidden, doc$l.msHidden, doc$l.webkitHidden, false)) {
            animOptions.duration = 0;
          }
          if (animOptions.duration !== 0) {
            if (complete) {
              animOptions.complete = complete;
            }
            syncTimeout$8(function() {
              if (_this.element) {
                animate$1(_this, params, animOptions);
              }
            }, deferTime);
          } else {
            this.attr(params, void 0, complete);
            objectEach$w(params, function(val, prop) {
              if (animOptions.step) {
                animOptions.step.call(this, val, { prop, pos: 1, elem: this });
              }
            }, this);
          }
          return this;
        };
        SVGElement2.prototype.applyTextOutline = function(textOutline) {
          var elem = this.element, hasContrast = textOutline.indexOf("contrast") !== -1;
          if (hasContrast) {
            textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
          }
          var parts = textOutline.split(" ");
          var color2 = parts[parts.length - 1];
          var strokeWidth = parts[0];
          if (strokeWidth && strokeWidth !== "none" && H.svg) {
            this.fakeTS = true;
            this.ySetter = this.xSetter;
            strokeWidth = strokeWidth.replace(/(^[\d\.]+)(.*?)$/g, function(match2, digit, unit) {
              return 2 * Number(digit) + unit;
            });
            this.removeTextOutline();
            var outline_1 = doc$l.createElementNS(SVG_NS$2, "tspan");
            attr$6(outline_1, {
              "class": "highcharts-text-outline",
              fill: color2,
              stroke: color2,
              "stroke-width": strokeWidth,
              "stroke-linejoin": "round"
            });
            [].forEach.call(elem.childNodes, function(childNode) {
              var clone = childNode.cloneNode(true);
              if (clone.removeAttribute) {
                ["fill", "stroke", "stroke-width", "stroke"].forEach(function(prop) {
                  return clone.removeAttribute(prop);
                });
              }
              outline_1.appendChild(clone);
            });
            var br_1 = doc$l.createElementNS(SVG_NS$2, "tspan");
            br_1.textContent = "";
            ["x", "y"].forEach(function(key) {
              var value = elem.getAttribute(key);
              if (value) {
                br_1.setAttribute(key, value);
              }
            });
            outline_1.appendChild(br_1);
            elem.insertBefore(outline_1, elem.firstChild);
          }
        };
        SVGElement2.prototype.attr = function(hash, val, complete, continueAnimation) {
          var element = this.element, symbolCustomAttribs = this.symbolCustomAttribs;
          var key, hasSetSymbolSize, ret = this, skipAttr, setter;
          if (typeof hash === "string" && typeof val !== "undefined") {
            key = hash;
            hash = {};
            hash[key] = val;
          }
          if (typeof hash === "string") {
            ret = (this[hash + "Getter"] || this._defaultGetter).call(this, hash, element);
          } else {
            objectEach$w(hash, function eachAttribute(val2, key2) {
              skipAttr = false;
              if (!continueAnimation) {
                stop$1(this, key2);
              }
              if (this.symbolName && symbolCustomAttribs.indexOf(key2) !== -1) {
                if (!hasSetSymbolSize) {
                  this.symbolAttr(hash);
                  hasSetSymbolSize = true;
                }
                skipAttr = true;
              }
              if (this.rotation && (key2 === "x" || key2 === "y")) {
                this.doTransform = true;
              }
              if (!skipAttr) {
                setter = this[key2 + "Setter"] || this._defaultSetter;
                setter.call(this, val2, key2, element);
                if (!this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key2)) {
                  this.updateShadows(key2, val2, setter);
                }
              }
            }, this);
            this.afterSetters();
          }
          if (complete) {
            complete.call(this);
          }
          return ret;
        };
        SVGElement2.prototype.clip = function(clipRect) {
          return this.attr("clip-path", clipRect ? "url(" + this.renderer.url + "#" + clipRect.id + ")" : "none");
        };
        SVGElement2.prototype.crisp = function(rect2, strokeWidth) {
          var wrapper = this;
          strokeWidth = strokeWidth || rect2.strokeWidth || 0;
          var normalizer = Math.round(strokeWidth) % 2 / 2;
          rect2.x = Math.floor(rect2.x || wrapper.x || 0) + normalizer;
          rect2.y = Math.floor(rect2.y || wrapper.y || 0) + normalizer;
          rect2.width = Math.floor((rect2.width || wrapper.width || 0) - 2 * normalizer);
          rect2.height = Math.floor((rect2.height || wrapper.height || 0) - 2 * normalizer);
          if (defined$T(rect2.strokeWidth)) {
            rect2.strokeWidth = strokeWidth;
          }
          return rect2;
        };
        SVGElement2.prototype.complexColor = function(colorOptions, prop, elem) {
          var renderer = this.renderer;
          var colorObject, gradName, gradAttr, radAttr, gradients, stops, stopColor, stopOpacity, radialReference, id, key = [], value;
          fireEvent$A(this.renderer, "complexColor", {
            args: arguments
          }, function() {
            if (colorOptions.radialGradient) {
              gradName = "radialGradient";
            } else if (colorOptions.linearGradient) {
              gradName = "linearGradient";
            }
            if (gradName) {
              gradAttr = colorOptions[gradName];
              gradients = renderer.gradients;
              stops = colorOptions.stops;
              radialReference = elem.radialReference;
              if (isArray$l(gradAttr)) {
                colorOptions[gradName] = gradAttr = {
                  x1: gradAttr[0],
                  y1: gradAttr[1],
                  x2: gradAttr[2],
                  y2: gradAttr[3],
                  gradientUnits: "userSpaceOnUse"
                };
              }
              if (gradName === "radialGradient" && radialReference && !defined$T(gradAttr.gradientUnits)) {
                radAttr = gradAttr;
                gradAttr = merge$1k(gradAttr, renderer.getRadialAttr(radialReference, radAttr), { gradientUnits: "userSpaceOnUse" });
              }
              objectEach$w(gradAttr, function(value2, n) {
                if (n !== "id") {
                  key.push(n, value2);
                }
              });
              objectEach$w(stops, function(val) {
                key.push(val);
              });
              key = key.join(",");
              if (gradients[key]) {
                id = gradients[key].attr("id");
              } else {
                gradAttr.id = id = uniqueKey$7();
                var gradientObject_1 = gradients[key] = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);
                gradientObject_1.radAttr = radAttr;
                gradientObject_1.stops = [];
                stops.forEach(function(stop2) {
                  if (stop2[1].indexOf("rgba") === 0) {
                    colorObject = Color.parse(stop2[1]);
                    stopColor = colorObject.get("rgb");
                    stopOpacity = colorObject.get("a");
                  } else {
                    stopColor = stop2[1];
                    stopOpacity = 1;
                  }
                  var stopObject = renderer.createElement("stop").attr({
                    offset: stop2[0],
                    "stop-color": stopColor,
                    "stop-opacity": stopOpacity
                  }).add(gradientObject_1);
                  gradientObject_1.stops.push(stopObject);
                });
              }
              value = "url(" + renderer.url + "#" + id + ")";
              elem.setAttribute(prop, value);
              elem.gradient = key;
              colorOptions.toString = function() {
                return value;
              };
            }
          });
        };
        SVGElement2.prototype.css = function(styles) {
          var oldStyles = this.styles, newStyles = {}, elem = this.element, svgPseudoProps = ["textOutline", "textOverflow", "width"];
          var textWidth, serializedCss = "", hyphenate, hasNew = !oldStyles;
          if (styles && styles.color) {
            styles.fill = styles.color;
          }
          if (oldStyles) {
            objectEach$w(styles, function(style, n) {
              if (oldStyles && oldStyles[n] !== style) {
                newStyles[n] = style;
                hasNew = true;
              }
            });
          }
          if (hasNew) {
            if (oldStyles) {
              styles = extend$1o(oldStyles, newStyles);
            }
            if (styles) {
              if (styles.width === null || styles.width === "auto") {
                delete this.textWidth;
              } else if (elem.nodeName.toLowerCase() === "text" && styles.width) {
                textWidth = this.textWidth = pInt$7(styles.width);
              }
            }
            this.styles = styles;
            if (textWidth && (!svg$4 && this.renderer.forExport)) {
              delete styles.width;
            }
            if (elem.namespaceURI === this.SVG_NS) {
              hyphenate = function(a, b) {
                return "-" + b.toLowerCase();
              };
              objectEach$w(styles, function(style, n) {
                if (svgPseudoProps.indexOf(n) === -1) {
                  serializedCss += n.replace(/([A-Z])/g, hyphenate) + ":" + style + ";";
                }
              });
              if (serializedCss) {
                attr$6(elem, "style", serializedCss);
              }
            } else {
              css$c(elem, styles);
            }
            if (this.added) {
              if (this.element.nodeName === "text") {
                this.renderer.buildText(this);
              }
              if (styles && styles.textOutline) {
                this.applyTextOutline(styles.textOutline);
              }
            }
          }
          return this;
        };
        SVGElement2.prototype.dashstyleSetter = function(value) {
          var i, strokeWidth = this["stroke-width"];
          if (strokeWidth === "inherit") {
            strokeWidth = 1;
          }
          value = value && value.toLowerCase();
          if (value) {
            var v = value.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
            i = v.length;
            while (i--) {
              v[i] = "" + pInt$7(v[i]) * pick$1w(strokeWidth, NaN);
            }
            value = v.join(",").replace(/NaN/g, "none");
            this.element.setAttribute("stroke-dasharray", value);
          }
        };
        SVGElement2.prototype.destroy = function() {
          var wrapper = this, element = wrapper.element || {}, renderer = wrapper.renderer, ownerSVGElement = element.ownerSVGElement;
          var parentToClean = renderer.isSVG && element.nodeName === "SPAN" && wrapper.parentGroup || void 0, grandParent, i;
          element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
          stop$1(wrapper);
          if (wrapper.clipPath && ownerSVGElement) {
            var clipPath_1 = wrapper.clipPath;
            [].forEach.call(ownerSVGElement.querySelectorAll("[clip-path],[CLIP-PATH]"), function(el) {
              if (el.getAttribute("clip-path").indexOf(clipPath_1.element.id) > -1) {
                el.removeAttribute("clip-path");
              }
            });
            wrapper.clipPath = clipPath_1.destroy();
          }
          if (wrapper.stops) {
            for (i = 0; i < wrapper.stops.length; i++) {
              wrapper.stops[i].destroy();
            }
            wrapper.stops.length = 0;
            wrapper.stops = void 0;
          }
          wrapper.safeRemoveChild(element);
          if (!renderer.styledMode) {
            wrapper.destroyShadows();
          }
          while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
            grandParent = parentToClean.parentGroup;
            wrapper.safeRemoveChild(parentToClean.div);
            delete parentToClean.div;
            parentToClean = grandParent;
          }
          if (wrapper.alignTo) {
            erase$8(renderer.alignedObjects, wrapper);
          }
          objectEach$w(wrapper, function(val, key) {
            if (wrapper[key] && wrapper[key].parentGroup === wrapper && wrapper[key].destroy) {
              wrapper[key].destroy();
            }
            delete wrapper[key];
          });
          return;
        };
        SVGElement2.prototype.destroyShadows = function() {
          (this.shadows || []).forEach(function(shadow) {
            this.safeRemoveChild(shadow);
          }, this);
          this.shadows = void 0;
        };
        SVGElement2.prototype.destroyTextPath = function(elem, path) {
          var textElement = elem.getElementsByTagName("text")[0];
          var childNodes;
          if (textElement) {
            textElement.removeAttribute("dx");
            textElement.removeAttribute("dy");
            path.element.setAttribute("id", "");
            if (this.textPathWrapper && textElement.getElementsByTagName("textPath").length) {
              childNodes = this.textPathWrapper.element.childNodes;
              while (childNodes.length) {
                textElement.appendChild(childNodes[0]);
              }
              textElement.removeChild(this.textPathWrapper.element);
            }
          } else if (elem.getAttribute("dx") || elem.getAttribute("dy")) {
            elem.removeAttribute("dx");
            elem.removeAttribute("dy");
          }
          if (this.textPathWrapper) {
            this.textPathWrapper = this.textPathWrapper.destroy();
          }
        };
        SVGElement2.prototype.dSetter = function(value, key, element) {
          if (isArray$l(value)) {
            if (typeof value[0] === "string") {
              value = this.renderer.pathToSegments(value);
            }
            this.pathArray = value;
            value = value.reduce(function(acc, seg, i) {
              if (!seg || !seg.join) {
                return (seg || "").toString();
              }
              return (i ? acc + " " : "") + seg.join(" ");
            }, "");
          }
          if (/(NaN| {2}|^$)/.test(value)) {
            value = "M 0 0";
          }
          if (this[key] !== value) {
            element.setAttribute(key, value);
            this[key] = value;
          }
        };
        SVGElement2.prototype.fadeOut = function(duration) {
          var elemWrapper = this;
          elemWrapper.animate({
            opacity: 0
          }, {
            duration: pick$1w(duration, 150),
            complete: function() {
              elemWrapper.attr({ y: -9999 }).hide();
            }
          });
        };
        SVGElement2.prototype.fillSetter = function(value, key, element) {
          if (typeof value === "string") {
            element.setAttribute(key, value);
          } else if (value) {
            this.complexColor(value, key, element);
          }
        };
        SVGElement2.prototype.getBBox = function(reload, rot) {
          var wrapper = this, renderer = wrapper.renderer, element = wrapper.element, styles = wrapper.styles, textStr = wrapper.textStr, cache = renderer.cache, cacheKeys = renderer.cacheKeys, isSVG = element.namespaceURI === wrapper.SVG_NS, rotation = pick$1w(rot, wrapper.rotation, 0), fontSize = renderer.styledMode ? element && SVGElement2.prototype.getStyle.call(element, "font-size") : styles && styles.fontSize;
          var bBox, width, height, toggleTextShadowShim, cacheKey;
          if (defined$T(textStr)) {
            cacheKey = textStr.toString();
            if (cacheKey.indexOf("<") === -1) {
              cacheKey = cacheKey.replace(/[0-9]/g, "0");
            }
            cacheKey += [
              "",
              rotation,
              fontSize,
              wrapper.textWidth,
              styles && styles.textOverflow,
              styles && styles.fontWeight
              // #12163
            ].join(",");
          }
          if (cacheKey && !reload) {
            bBox = cache[cacheKey];
          }
          if (!bBox) {
            if (isSVG || renderer.forExport) {
              try {
                toggleTextShadowShim = this.fakeTS && function(display) {
                  var outline = element.querySelector(".highcharts-text-outline");
                  if (outline) {
                    css$c(outline, { display });
                  }
                };
                if (isFunction$4(toggleTextShadowShim)) {
                  toggleTextShadowShim("none");
                }
                bBox = element.getBBox ? (
                  // SVG: use extend because IE9 is not allowed to change
                  // width and height in case of rotation (below)
                  extend$1o({}, element.getBBox())
                ) : {
                  // Legacy IE in export mode
                  width: element.offsetWidth,
                  height: element.offsetHeight
                };
                if (isFunction$4(toggleTextShadowShim)) {
                  toggleTextShadowShim("");
                }
              } catch (e2) {
              }
              if (!bBox || bBox.width < 0) {
                bBox = { width: 0, height: 0 };
              }
            } else {
              bBox = wrapper.htmlGetBBox();
            }
            if (renderer.isSVG) {
              width = bBox.width;
              height = bBox.height;
              if (isSVG) {
                bBox.height = height = {
                  "11px,17": 14,
                  "13px,20": 16
                }[styles && styles.fontSize + "," + Math.round(height)] || height;
              }
              if (rotation) {
                var rad = rotation * deg2rad$8;
                bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));
                bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));
              }
            }
            if (cacheKey && (textStr === "" || bBox.height > 0)) {
              while (cacheKeys.length > 250) {
                delete cache[cacheKeys.shift()];
              }
              if (!cache[cacheKey]) {
                cacheKeys.push(cacheKey);
              }
              cache[cacheKey] = bBox;
            }
          }
          return bBox;
        };
        SVGElement2.prototype.getStyle = function(prop) {
          return win$d.getComputedStyle(this.element || this, "").getPropertyValue(prop);
        };
        SVGElement2.prototype.hasClass = function(className) {
          return ("" + this.attr("class")).split(" ").indexOf(className) !== -1;
        };
        SVGElement2.prototype.hide = function(hideByTranslation) {
          if (hideByTranslation) {
            this.attr({ y: -9999 });
          } else {
            this.attr({ visibility: "hidden" });
          }
          return this;
        };
        SVGElement2.prototype.htmlGetBBox = function() {
          return { height: 0, width: 0, x: 0, y: 0 };
        };
        SVGElement2.prototype.init = function(renderer, nodeName) {
          this.element = nodeName === "span" ? createElement$9(nodeName) : doc$l.createElementNS(this.SVG_NS, nodeName);
          this.renderer = renderer;
          fireEvent$A(this, "afterInit");
        };
        SVGElement2.prototype.invert = function(inverted) {
          this.inverted = inverted;
          this.updateTransform();
          return this;
        };
        SVGElement2.prototype.on = function(eventType, handler) {
          var onEvents = this.onEvents;
          if (onEvents[eventType]) {
            onEvents[eventType]();
          }
          onEvents[eventType] = addEvent$11(this.element, eventType, handler);
          return this;
        };
        SVGElement2.prototype.opacitySetter = function(value, key, element) {
          var opacity = Number(Number(value).toFixed(3));
          this.opacity = opacity;
          element.setAttribute(key, opacity);
        };
        SVGElement2.prototype.removeClass = function(className) {
          return this.attr("class", ("" + this.attr("class")).replace(isString$a(className) ? new RegExp("(^| )" + className + "( |$)") : (
            // #12064, #13590
            className
          ), " ").replace(/ +/g, " ").trim());
        };
        SVGElement2.prototype.removeTextOutline = function() {
          var outline = this.element.querySelector("tspan.highcharts-text-outline");
          if (outline) {
            this.safeRemoveChild(outline);
          }
        };
        SVGElement2.prototype.safeRemoveChild = function(element) {
          var parentNode = element.parentNode;
          if (parentNode) {
            parentNode.removeChild(element);
          }
        };
        SVGElement2.prototype.setRadialReference = function(coordinates) {
          var existingGradient = this.element.gradient && this.renderer.gradients[this.element.gradient];
          this.element.radialReference = coordinates;
          if (existingGradient && existingGradient.radAttr) {
            existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));
          }
          return this;
        };
        SVGElement2.prototype.setTextPath = function(path, textPathOptions) {
          var elem = this.element, textNode = this.text ? this.text.element : elem, attribsMap = {
            textAnchor: "text-anchor"
          };
          var adder = false, textPathElement, textPathId, textPathWrapper = this.textPathWrapper, firstTime = !textPathWrapper;
          textPathOptions = merge$1k(true, {
            enabled: true,
            attributes: {
              dy: -5,
              startOffset: "50%",
              textAnchor: "middle"
            }
          }, textPathOptions);
          var attrs = AST.filterUserAttributes(textPathOptions.attributes);
          if (path && textPathOptions && textPathOptions.enabled) {
            if (textPathWrapper && textPathWrapper.element.parentNode === null) {
              firstTime = true;
              textPathWrapper = textPathWrapper.destroy();
            } else if (textPathWrapper) {
              this.removeTextOutline.call(textPathWrapper.parentGroup);
            }
            if (this.options && this.options.padding) {
              attrs.dx = -this.options.padding;
            }
            if (!textPathWrapper) {
              this.textPathWrapper = textPathWrapper = this.renderer.createElement("textPath");
              adder = true;
            }
            textPathElement = textPathWrapper.element;
            textPathId = path.element.getAttribute("id");
            if (!textPathId) {
              path.element.setAttribute("id", textPathId = uniqueKey$7());
            }
            if (firstTime) {
              textNode.setAttribute("y", 0);
              if (isNumber$M(attrs.dx)) {
                textNode.setAttribute("x", -attrs.dx);
              }
              var childNodes = [].slice.call(textNode.childNodes);
              for (var i = 0; i < childNodes.length; i++) {
                var childNode = childNodes[i];
                if (childNode.nodeType === Node.TEXT_NODE || childNode.nodeName === "tspan") {
                  textPathElement.appendChild(childNode);
                }
              }
            }
            if (adder && textPathWrapper) {
              textPathWrapper.add({ element: textNode });
            }
            textPathElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + textPathId);
            if (defined$T(attrs.dy)) {
              textPathElement.parentNode.setAttribute("dy", attrs.dy);
              delete attrs.dy;
            }
            if (defined$T(attrs.dx)) {
              textPathElement.parentNode.setAttribute("dx", attrs.dx);
              delete attrs.dx;
            }
            objectEach$w(attrs, function(val, key) {
              textPathElement.setAttribute(attribsMap[key] || key, val);
            });
            elem.removeAttribute("transform");
            this.removeTextOutline.call(textPathWrapper);
            if (this.text && !this.renderer.styledMode) {
              this.attr({
                fill: "none",
                "stroke-width": 0
              });
            }
            this.updateTransform = noop$l;
            this.applyTextOutline = noop$l;
          } else if (textPathWrapper) {
            delete this.updateTransform;
            delete this.applyTextOutline;
            this.destroyTextPath(elem, path);
            this.updateTransform();
            if (this.options && this.options.rotation) {
              this.applyTextOutline(this.options.style.textOutline);
            }
          }
          return this;
        };
        SVGElement2.prototype.shadow = function(shadowOptions, group, cutOff) {
          var shadows = [], element = this.element, oldShadowOptions = this.oldShadowOptions, defaultShadowOptions = {
            color: palette.neutralColor100,
            offsetX: this.parentInverted ? -1 : 1,
            offsetY: this.parentInverted ? -1 : 1,
            opacity: 0.15,
            width: 3
          };
          var i, shadow, strokeWidth, shadowElementOpacity, update = false, transform, options;
          if (shadowOptions === true) {
            options = defaultShadowOptions;
          } else if (typeof shadowOptions === "object") {
            options = extend$1o(defaultShadowOptions, shadowOptions);
          }
          if (options) {
            if (options && oldShadowOptions) {
              objectEach$w(options, function(value, key) {
                if (value !== oldShadowOptions[key]) {
                  update = true;
                }
              });
            }
            if (update) {
              this.destroyShadows();
            }
            this.oldShadowOptions = options;
          }
          if (!options) {
            this.destroyShadows();
          } else if (!this.shadows) {
            shadowElementOpacity = options.opacity / options.width;
            transform = this.parentInverted ? "translate(" + options.offsetY + ", " + options.offsetX + ")" : "translate(" + options.offsetX + ", " + options.offsetY + ")";
            for (i = 1; i <= options.width; i++) {
              shadow = element.cloneNode(false);
              strokeWidth = options.width * 2 + 1 - 2 * i;
              attr$6(shadow, {
                stroke: shadowOptions.color || palette.neutralColor100,
                "stroke-opacity": shadowElementOpacity * i,
                "stroke-width": strokeWidth,
                transform,
                fill: "none"
              });
              shadow.setAttribute("class", (shadow.getAttribute("class") || "") + " highcharts-shadow");
              if (cutOff) {
                attr$6(shadow, "height", Math.max(attr$6(shadow, "height") - strokeWidth, 0));
                shadow.cutHeight = strokeWidth;
              }
              if (group) {
                group.element.appendChild(shadow);
              } else if (element.parentNode) {
                element.parentNode.insertBefore(shadow, element);
              }
              shadows.push(shadow);
            }
            this.shadows = shadows;
          }
          return this;
        };
        SVGElement2.prototype.show = function(inherit) {
          return this.attr({ visibility: inherit ? "inherit" : "visible" });
        };
        SVGElement2.prototype.strokeSetter = function(value, key, element) {
          this[key] = value;
          if (this.stroke && this["stroke-width"]) {
            SVGElement2.prototype.fillSetter.call(this, this.stroke, "stroke", element);
            element.setAttribute("stroke-width", this["stroke-width"]);
            this.hasStroke = true;
          } else if (key === "stroke-width" && value === 0 && this.hasStroke) {
            element.removeAttribute("stroke");
            this.hasStroke = false;
          } else if (this.renderer.styledMode && this["stroke-width"]) {
            element.setAttribute("stroke-width", this["stroke-width"]);
            this.hasStroke = true;
          }
        };
        SVGElement2.prototype.strokeWidth = function() {
          if (!this.renderer.styledMode) {
            return this["stroke-width"] || 0;
          }
          var val = this.getStyle("stroke-width");
          var ret = 0, dummy;
          if (val.indexOf("px") === val.length - 2) {
            ret = pInt$7(val);
          } else if (val !== "") {
            dummy = doc$l.createElementNS(SVG_NS$2, "rect");
            attr$6(dummy, {
              width: val,
              "stroke-width": 0
            });
            this.element.parentNode.appendChild(dummy);
            ret = dummy.getBBox().width;
            dummy.parentNode.removeChild(dummy);
          }
          return ret;
        };
        SVGElement2.prototype.symbolAttr = function(hash) {
          var wrapper = this;
          [
            "x",
            "y",
            "r",
            "start",
            "end",
            "width",
            "height",
            "innerR",
            "anchorX",
            "anchorY",
            "clockwise"
          ].forEach(function(key) {
            wrapper[key] = pick$1w(hash[key], wrapper[key]);
          });
          wrapper.attr({
            d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
          });
        };
        SVGElement2.prototype.textSetter = function(value) {
          if (value !== this.textStr) {
            delete this.textPxLength;
            this.textStr = value;
            if (this.added) {
              this.renderer.buildText(this);
            }
          }
        };
        SVGElement2.prototype.titleSetter = function(value) {
          var el = this.element;
          var titleNode = el.getElementsByTagName("title")[0] || doc$l.createElementNS(this.SVG_NS, "title");
          if (el.insertBefore) {
            el.insertBefore(titleNode, el.firstChild);
          } else {
            el.appendChild(titleNode);
          }
          titleNode.textContent = // #3276, #3895
          String(pick$1w(value, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
        };
        SVGElement2.prototype.toFront = function() {
          var element = this.element;
          element.parentNode.appendChild(element);
          return this;
        };
        SVGElement2.prototype.translate = function(x, y) {
          return this.attr({
            translateX: x,
            translateY: y
          });
        };
        SVGElement2.prototype.updateShadows = function(key, value, setter) {
          var shadows = this.shadows;
          if (shadows) {
            var i = shadows.length;
            while (i--) {
              setter.call(shadows[i], key === "height" ? Math.max(value - (shadows[i].cutHeight || 0), 0) : key === "d" ? this.d : value, key, shadows[i]);
            }
          }
        };
        SVGElement2.prototype.updateTransform = function() {
          var wrapper = this, scaleX = wrapper.scaleX, scaleY = wrapper.scaleY, inverted = wrapper.inverted, rotation = wrapper.rotation, matrix = wrapper.matrix, element = wrapper.element;
          var translateX = wrapper.translateX || 0, translateY = wrapper.translateY || 0;
          if (inverted) {
            translateX += wrapper.width;
            translateY += wrapper.height;
          }
          var transform = ["translate(" + translateX + "," + translateY + ")"];
          if (defined$T(matrix)) {
            transform.push("matrix(" + matrix.join(",") + ")");
          }
          if (inverted) {
            transform.push("rotate(90) scale(-1,1)");
          } else if (rotation) {
            transform.push("rotate(" + rotation + " " + pick$1w(this.rotationOriginX, element.getAttribute("x"), 0) + " " + pick$1w(this.rotationOriginY, element.getAttribute("y") || 0) + ")");
          }
          if (defined$T(scaleX) || defined$T(scaleY)) {
            transform.push("scale(" + pick$1w(scaleX, 1) + " " + pick$1w(scaleY, 1) + ")");
          }
          if (transform.length) {
            element.setAttribute("transform", transform.join(" "));
          }
        };
        SVGElement2.prototype.visibilitySetter = function(value, key, element) {
          if (value === "inherit") {
            element.removeAttribute(key);
          } else if (this[key] !== value) {
            element.setAttribute(key, value);
          }
          this[key] = value;
        };
        SVGElement2.prototype.xGetter = function(key) {
          if (this.element.nodeName === "circle") {
            if (key === "x") {
              key = "cx";
            } else if (key === "y") {
              key = "cy";
            }
          }
          return this._defaultGetter(key);
        };
        SVGElement2.prototype.zIndexSetter = function(value, key) {
          var renderer = this.renderer, parentGroup = this.parentGroup, parentWrapper = parentGroup || renderer, parentNode = parentWrapper.element || renderer.box, element = this.element, svgParent = parentNode === renderer.box;
          var childNodes, otherElement, otherZIndex, inserted = false, undefinedOtherZIndex, run = this.added, i;
          if (defined$T(value)) {
            element.setAttribute("data-z-index", value);
            value = +value;
            if (this[key] === value) {
              run = false;
            }
          } else if (defined$T(this[key])) {
            element.removeAttribute("data-z-index");
          }
          this[key] = value;
          if (run) {
            value = this.zIndex;
            if (value && parentGroup) {
              parentGroup.handleZ = true;
            }
            childNodes = parentNode.childNodes;
            for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {
              otherElement = childNodes[i];
              otherZIndex = otherElement.getAttribute("data-z-index");
              undefinedOtherZIndex = !defined$T(otherZIndex);
              if (otherElement !== element) {
                if (
                  // Negative zIndex versus no zIndex:
                  // On all levels except the highest. If the parent is
                  // <svg>, then we don't want to put items before <desc>
                  // or <defs>
                  value < 0 && undefinedOtherZIndex && !svgParent && !i
                ) {
                  parentNode.insertBefore(element, childNodes[i]);
                  inserted = true;
                } else if (
                  // Insert after the first element with a lower zIndex
                  pInt$7(otherZIndex) <= value || // If negative zIndex, add this before first undefined
                  // zIndex element
                  undefinedOtherZIndex && (!defined$T(value) || value >= 0)
                ) {
                  parentNode.insertBefore(
                    element,
                    childNodes[i + 1] || null
                    // null for oldIE export
                  );
                  inserted = true;
                }
              }
            }
            if (!inserted) {
              parentNode.insertBefore(
                element,
                childNodes[svgParent ? 3 : 0] || null
                // null for oldIE
              );
              inserted = true;
            }
          }
          return inserted;
        };
        return SVGElement2;
      }()
    );
    SVGElement.prototype["stroke-widthSetter"] = SVGElement.prototype.strokeSetter;
    SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
    SVGElement.prototype.matrixSetter = SVGElement.prototype.rotationOriginXSetter = SVGElement.prototype.rotationOriginYSetter = SVGElement.prototype.rotationSetter = SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = SVGElement.prototype.verticalAlignSetter = function(value, key) {
      this[key] = value;
      this.doTransform = true;
    };
    var RendererRegistry;
    (function(RendererRegistry2) {
      RendererRegistry2.rendererTypes = {};
      var defaultRenderer;
      function getRendererType(rendererType) {
        if (rendererType === void 0) {
          rendererType = defaultRenderer;
        }
        return RendererRegistry2.rendererTypes[rendererType] || RendererRegistry2.rendererTypes[defaultRenderer];
      }
      RendererRegistry2.getRendererType = getRendererType;
      function registerRendererType(rendererType, rendererClass, setAsDefault) {
        RendererRegistry2.rendererTypes[rendererType] = rendererClass;
        if (!defaultRenderer || setAsDefault) {
          defaultRenderer = rendererType;
          H.Renderer = rendererClass;
        }
      }
      RendererRegistry2.registerRendererType = registerRendererType;
    })(RendererRegistry || (RendererRegistry = {}));
    const RendererRegistry$1 = RendererRegistry;
    var __extends$Y = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var defined$S = Utilities.defined, extend$1n = Utilities.extend, isNumber$L = Utilities.isNumber, merge$1j = Utilities.merge, pick$1v = Utilities.pick, removeEvent$b = Utilities.removeEvent;
    var SVGLabel = (
      /** @class */
      function(_super) {
        __extends$Y(SVGLabel2, _super);
        function SVGLabel2(renderer, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
          var _this = _super.call(this) || this;
          _this.paddingLeftSetter = _this.paddingSetter;
          _this.paddingRightSetter = _this.paddingSetter;
          _this.init(renderer, "g");
          _this.textStr = str;
          _this.x = x;
          _this.y = y;
          _this.anchorX = anchorX;
          _this.anchorY = anchorY;
          _this.baseline = baseline;
          _this.className = className;
          _this.addClass(className === "button" ? "highcharts-no-tooltip" : "highcharts-label");
          if (className) {
            _this.addClass("highcharts-" + className);
          }
          _this.text = renderer.text(void 0, 0, 0, useHTML).attr({ zIndex: 1 });
          var hasBGImage;
          if (typeof shape === "string") {
            hasBGImage = /^url\((.*?)\)$/.test(shape);
            if (hasBGImage || _this.renderer.symbols[shape]) {
              _this.symbolKey = shape;
            }
          }
          _this.bBox = SVGLabel2.emptyBBox;
          _this.padding = 3;
          _this.baselineOffset = 0;
          _this.needsBox = renderer.styledMode || hasBGImage;
          _this.deferredAttr = {};
          _this.alignFactor = 0;
          return _this;
        }
        SVGLabel2.prototype.alignSetter = function(value) {
          var alignFactor = {
            left: 0,
            center: 0.5,
            right: 1
          }[value];
          if (alignFactor !== this.alignFactor) {
            this.alignFactor = alignFactor;
            if (this.bBox && isNumber$L(this.xSetting)) {
              this.attr({ x: this.xSetting });
            }
          }
        };
        SVGLabel2.prototype.anchorXSetter = function(value, key) {
          this.anchorX = value;
          this.boxAttr(key, Math.round(value) - this.getCrispAdjust() - this.xSetting);
        };
        SVGLabel2.prototype.anchorYSetter = function(value, key) {
          this.anchorY = value;
          this.boxAttr(key, value - this.ySetting);
        };
        SVGLabel2.prototype.boxAttr = function(key, value) {
          if (this.box) {
            this.box.attr(key, value);
          } else {
            this.deferredAttr[key] = value;
          }
        };
        SVGLabel2.prototype.css = function(styles) {
          if (styles) {
            var textStyles_1 = {};
            styles = merge$1j(styles);
            SVGLabel2.textProps.forEach(function(prop) {
              if (typeof styles[prop] !== "undefined") {
                textStyles_1[prop] = styles[prop];
                delete styles[prop];
              }
            });
            this.text.css(textStyles_1);
            var isWidth = "width" in textStyles_1, isFontStyle = "fontSize" in textStyles_1 || "fontWeight" in textStyles_1;
            if (isFontStyle) {
              this.updateTextPadding();
            } else if (isWidth) {
              this.updateBoxSize();
            }
          }
          return SVGElement.prototype.css.call(this, styles);
        };
        SVGLabel2.prototype.destroy = function() {
          removeEvent$b(this.element, "mouseenter");
          removeEvent$b(this.element, "mouseleave");
          if (this.text) {
            this.text.destroy();
          }
          if (this.box) {
            this.box = this.box.destroy();
          }
          SVGElement.prototype.destroy.call(this);
          return void 0;
        };
        SVGLabel2.prototype.fillSetter = function(value, key) {
          if (value) {
            this.needsBox = true;
          }
          this.fill = value;
          this.boxAttr(key, value);
        };
        SVGLabel2.prototype.getBBox = function() {
          if (this.textStr && this.bBox.width === 0 && this.bBox.height === 0) {
            this.updateBoxSize();
          }
          var padding = this.padding;
          var paddingLeft = pick$1v(this.paddingLeft, padding);
          return {
            width: this.width,
            height: this.height,
            x: this.bBox.x - paddingLeft,
            y: this.bBox.y - padding
          };
        };
        SVGLabel2.prototype.getCrispAdjust = function() {
          return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
        };
        SVGLabel2.prototype.heightSetter = function(value) {
          this.heightSetting = value;
        };
        SVGLabel2.prototype.onAdd = function() {
          var str = this.textStr;
          this.text.add(this);
          this.attr({
            // Alignment is available now  (#3295, 0 not rendered if given
            // as a value)
            text: defined$S(str) ? str : "",
            x: this.x,
            y: this.y
          });
          if (this.box && defined$S(this.anchorX)) {
            this.attr({
              anchorX: this.anchorX,
              anchorY: this.anchorY
            });
          }
        };
        SVGLabel2.prototype.paddingSetter = function(value, key) {
          if (!isNumber$L(value)) {
            this[key] = void 0;
          } else if (value !== this[key]) {
            this[key] = value;
            this.updateTextPadding();
          }
        };
        SVGLabel2.prototype.rSetter = function(value, key) {
          this.boxAttr(key, value);
        };
        SVGLabel2.prototype.shadow = function(b) {
          if (b && !this.renderer.styledMode) {
            this.updateBoxSize();
            if (this.box) {
              this.box.shadow(b);
            }
          }
          return this;
        };
        SVGLabel2.prototype.strokeSetter = function(value, key) {
          this.stroke = value;
          this.boxAttr(key, value);
        };
        SVGLabel2.prototype["stroke-widthSetter"] = function(value, key) {
          if (value) {
            this.needsBox = true;
          }
          this["stroke-width"] = value;
          this.boxAttr(key, value);
        };
        SVGLabel2.prototype["text-alignSetter"] = function(value) {
          this.textAlign = value;
        };
        SVGLabel2.prototype.textSetter = function(text) {
          if (typeof text !== "undefined") {
            this.text.attr({ text });
          }
          this.updateTextPadding();
        };
        SVGLabel2.prototype.updateBoxSize = function() {
          var style = this.text.element.style, attribs = {}, padding = this.padding, bBox = this.bBox = (!isNumber$L(this.widthSetting) || !isNumber$L(this.heightSetting) || this.textAlign) && defined$S(this.text.textStr) ? this.text.getBBox() : SVGLabel2.emptyBBox;
          var crispAdjust;
          this.width = this.getPaddedWidth();
          this.height = (this.heightSetting || bBox.height || 0) + 2 * padding;
          var metrics = this.renderer.fontMetrics(style && style.fontSize, this.text);
          this.baselineOffset = padding + Math.min(
            // When applicable, use the font size of the first line (#15707)
            (this.text.firstLineMetrics || metrics).b,
            // When the height is 0, there is no bBox, so go with the font
            // metrics. Highmaps CSS demos.
            bBox.height || Infinity
          );
          if (this.heightSetting) {
            this.baselineOffset += (this.heightSetting - metrics.h) / 2;
          }
          if (this.needsBox) {
            if (!this.box) {
              var box = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
              box.addClass(
                // Don't use label className for buttons
                (this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")
              );
              box.add(this);
            }
            crispAdjust = this.getCrispAdjust();
            attribs.x = crispAdjust;
            attribs.y = (this.baseline ? -this.baselineOffset : 0) + crispAdjust;
            attribs.width = Math.round(this.width);
            attribs.height = Math.round(this.height);
            this.box.attr(extend$1n(attribs, this.deferredAttr));
            this.deferredAttr = {};
          }
        };
        SVGLabel2.prototype.updateTextPadding = function() {
          var text = this.text;
          this.updateBoxSize();
          var textY = this.baseline ? 0 : this.baselineOffset;
          var textX = pick$1v(this.paddingLeft, this.padding);
          if (defined$S(this.widthSetting) && this.bBox && (this.textAlign === "center" || this.textAlign === "right")) {
            textX += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width);
          }
          if (textX !== text.x || textY !== text.y) {
            text.attr("x", textX);
            if (text.hasBoxWidthChanged) {
              this.bBox = text.getBBox(true);
            }
            if (typeof textY !== "undefined") {
              text.attr("y", textY);
            }
          }
          text.x = textX;
          text.y = textY;
        };
        SVGLabel2.prototype.widthSetter = function(value) {
          this.widthSetting = isNumber$L(value) ? value : void 0;
        };
        SVGLabel2.prototype.getPaddedWidth = function() {
          var padding = this.padding;
          var paddingLeft = pick$1v(this.paddingLeft, padding);
          var paddingRight = pick$1v(this.paddingRight, padding);
          return (this.widthSetting || this.bBox.width || 0) + paddingLeft + paddingRight;
        };
        SVGLabel2.prototype.xSetter = function(value) {
          this.x = value;
          if (this.alignFactor) {
            value -= this.alignFactor * this.getPaddedWidth();
            this["forceAnimate:x"] = true;
          }
          this.xSetting = Math.round(value);
          this.attr("translateX", this.xSetting);
        };
        SVGLabel2.prototype.ySetter = function(value) {
          this.ySetting = this.y = Math.round(value);
          this.attr("translateY", this.ySetting);
        };
        SVGLabel2.emptyBBox = { width: 0, height: 0, x: 0, y: 0 };
        SVGLabel2.textProps = [
          "color",
          "direction",
          "fontFamily",
          "fontSize",
          "fontStyle",
          "fontWeight",
          "lineHeight",
          "textAlign",
          "textDecoration",
          "textOutline",
          "textOverflow",
          "width"
        ];
        return SVGLabel2;
      }(SVGElement)
    );
    var defined$R = Utilities.defined, isNumber$K = Utilities.isNumber, pick$1u = Utilities.pick;
    function arc$1(x, y, w2, h, options) {
      var arc2 = [];
      if (options) {
        var start = options.start || 0, rx = pick$1u(options.r, w2), ry = pick$1u(options.r, h || w2), proximity = 1e-3, fullCircle = Math.abs((options.end || 0) - start - 2 * Math.PI) < proximity, end = (options.end || 0) - proximity, innerRadius = options.innerR, open_1 = pick$1u(options.open, fullCircle), cosStart = Math.cos(start), sinStart = Math.sin(start), cosEnd = Math.cos(end), sinEnd = Math.sin(end), longArc = pick$1u(options.longArc, end - start - Math.PI < proximity ? 0 : 1);
        arc2.push([
          "M",
          x + rx * cosStart,
          y + ry * sinStart
        ], [
          "A",
          rx,
          ry,
          0,
          longArc,
          pick$1u(options.clockwise, 1),
          x + rx * cosEnd,
          y + ry * sinEnd
        ]);
        if (defined$R(innerRadius)) {
          arc2.push(open_1 ? [
            "M",
            x + innerRadius * cosEnd,
            y + innerRadius * sinEnd
          ] : [
            "L",
            x + innerRadius * cosEnd,
            y + innerRadius * sinEnd
          ], [
            "A",
            innerRadius,
            innerRadius,
            0,
            longArc,
            // Clockwise - opposite to the outer arc clockwise
            defined$R(options.clockwise) ? 1 - options.clockwise : 0,
            x + innerRadius * cosStart,
            y + innerRadius * sinStart
          ]);
        }
        if (!open_1) {
          arc2.push(["Z"]);
        }
      }
      return arc2;
    }
    function callout(x, y, w2, h, options) {
      var arrowLength = 6, halfDistance = 6, r = Math.min(options && options.r || 0, w2, h), safeDistance = r + halfDistance, anchorX = options && options.anchorX, anchorY = options && options.anchorY || 0;
      var path = roundedRect(x, y, w2, h, { r });
      if (!isNumber$K(anchorX)) {
        return path;
      }
      if (x + anchorX >= w2) {
        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
          path.splice(3, 1, ["L", x + w2, anchorY - halfDistance], ["L", x + w2 + arrowLength, anchorY], ["L", x + w2, anchorY + halfDistance], ["L", x + w2, y + h - r]);
        } else {
          path.splice(3, 1, ["L", x + w2, h / 2], ["L", anchorX, anchorY], ["L", x + w2, h / 2], ["L", x + w2, y + h - r]);
        }
      } else if (x + anchorX <= 0) {
        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
          path.splice(7, 1, ["L", x, anchorY + halfDistance], ["L", x - arrowLength, anchorY], ["L", x, anchorY - halfDistance], ["L", x, y + r]);
        } else {
          path.splice(7, 1, ["L", x, h / 2], ["L", anchorX, anchorY], ["L", x, h / 2], ["L", x, y + r]);
        }
      } else if (
        // replace bottom
        anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w2 - safeDistance
      ) {
        path.splice(5, 1, ["L", anchorX + halfDistance, y + h], ["L", anchorX, y + h + arrowLength], ["L", anchorX - halfDistance, y + h], ["L", x + r, y + h]);
      } else if (
        // replace top
        anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w2 - safeDistance
      ) {
        path.splice(1, 1, ["L", anchorX - halfDistance, y], ["L", anchorX, y - arrowLength], ["L", anchorX + halfDistance, y], ["L", w2 - r, y]);
      }
      return path;
    }
    function circle(x, y, w2, h) {
      return arc$1(x + w2 / 2, y + h / 2, w2 / 2, h / 2, {
        start: Math.PI * 0.5,
        end: Math.PI * 2.5,
        open: false
      });
    }
    function diamond(x, y, w2, h) {
      return [
        ["M", x + w2 / 2, y],
        ["L", x + w2, y + h / 2],
        ["L", x + w2 / 2, y + h],
        ["L", x, y + h / 2],
        ["Z"]
      ];
    }
    function rect(x, y, w2, h, options) {
      if (options && options.r) {
        return roundedRect(x, y, w2, h, options);
      }
      return [
        ["M", x, y],
        ["L", x + w2, y],
        ["L", x + w2, y + h],
        ["L", x, y + h],
        ["Z"]
      ];
    }
    function roundedRect(x, y, w2, h, options) {
      var r = options && options.r || 0;
      return [
        ["M", x + r, y],
        ["L", x + w2 - r, y],
        ["C", x + w2, y, x + w2, y, x + w2, y + r],
        ["L", x + w2, y + h - r],
        ["C", x + w2, y + h, x + w2, y + h, x + w2 - r, y + h],
        ["L", x + r, y + h],
        ["C", x, y + h, x, y + h, x, y + h - r],
        ["L", x, y + r],
        ["C", x, y, x, y, x + r, y]
        // top-left corner
      ];
    }
    function triangle(x, y, w2, h) {
      return [
        ["M", x + w2 / 2, y],
        ["L", x + w2, y + h],
        ["L", x, y + h],
        ["Z"]
      ];
    }
    function triangleDown(x, y, w2, h) {
      return [
        ["M", x, y],
        ["L", x + w2, y],
        ["L", x + w2 / 2, y + h],
        ["Z"]
      ];
    }
    var Symbols = {
      arc: arc$1,
      callout,
      circle,
      diamond,
      rect,
      roundedRect,
      square: rect,
      triangle,
      "triangle-down": triangleDown
    };
    var doc$k = H.doc, SVG_NS$1 = H.SVG_NS;
    var attr$5 = Utilities.attr, isString$9 = Utilities.isString, objectEach$v = Utilities.objectEach, pick$1t = Utilities.pick;
    var TextBuilder = (
      /** @class */
      function() {
        function TextBuilder2(svgElement) {
          var textStyles = svgElement.styles;
          this.renderer = svgElement.renderer;
          this.svgElement = svgElement;
          this.width = svgElement.textWidth;
          this.textLineHeight = textStyles && textStyles.lineHeight;
          this.textOutline = textStyles && textStyles.textOutline;
          this.ellipsis = Boolean(textStyles && textStyles.textOverflow === "ellipsis");
          this.noWrap = Boolean(textStyles && textStyles.whiteSpace === "nowrap");
          this.fontSize = textStyles && textStyles.fontSize;
        }
        TextBuilder2.prototype.buildSVG = function() {
          var wrapper = this.svgElement, textNode = wrapper.element, renderer = wrapper.renderer, textStr = pick$1t(wrapper.textStr, "").toString(), hasMarkup = textStr.indexOf("<") !== -1, childNodes = textNode.childNodes, tempParent = this.width && !wrapper.added && renderer.box, regexMatchBreaks = /<br.*?>/g, textCache = [
            textStr,
            this.ellipsis,
            this.noWrap,
            this.textLineHeight,
            this.textOutline,
            this.fontSize,
            this.width
          ].join(",");
          if (textCache === wrapper.textCache) {
            return;
          }
          wrapper.textCache = textCache;
          delete wrapper.actualWidth;
          for (var i = childNodes.length; i--; ) {
            textNode.removeChild(childNodes[i]);
          }
          if (!hasMarkup && !this.ellipsis && !this.width && (textStr.indexOf(" ") === -1 || this.noWrap && !regexMatchBreaks.test(textStr))) {
            textNode.appendChild(doc$k.createTextNode(this.unescapeEntities(textStr)));
          } else if (textStr !== "") {
            if (tempParent) {
              tempParent.appendChild(textNode);
            }
            var ast = new AST(textStr);
            this.modifyTree(ast.nodes);
            ast.addToDOM(wrapper.element);
            this.modifyDOM();
            if (this.ellipsis && (textNode.textContent || "").indexOf("") !== -1) {
              wrapper.attr(
                "title",
                this.unescapeEntities(wrapper.textStr || "", ["&lt;", "&gt;"])
                // #7179
              );
            }
            if (tempParent) {
              tempParent.removeChild(textNode);
            }
          }
          if (isString$9(this.textOutline) && wrapper.applyTextOutline) {
            wrapper.applyTextOutline(this.textOutline);
          }
        };
        TextBuilder2.prototype.modifyDOM = function() {
          var _this = this;
          var wrapper = this.svgElement;
          var x = attr$5(wrapper.element, "x");
          wrapper.firstLineMetrics = void 0;
          var firstChild;
          while (firstChild = wrapper.element.firstChild) {
            if (/^[\s\u200B]*$/.test(firstChild.textContent || " ")) {
              wrapper.element.removeChild(firstChild);
            } else {
              break;
            }
          }
          [].forEach.call(wrapper.element.querySelectorAll("tspan.highcharts-br"), function(br, i) {
            if (br.nextSibling && br.previousSibling) {
              if (i === 0 && br.previousSibling.nodeType === 1) {
                wrapper.firstLineMetrics = wrapper.renderer.fontMetrics(void 0, br.previousSibling);
              }
              attr$5(br, {
                // Since the break is inserted in front of the next
                // line, we need to use the next sibling for the line
                // height
                dy: _this.getLineHeight(br.nextSibling),
                x
              });
            }
          });
          var width = this.width || 0;
          if (!width) {
            return;
          }
          var modifyTextNode = function(textNode, parentElement) {
            var text = textNode.textContent || "";
            var words = text.replace(/([^\^])-/g, "$1- ").split(" ");
            var hasWhiteSpace = !_this.noWrap && (words.length > 1 || wrapper.element.childNodes.length > 1);
            var dy = _this.getLineHeight(parentElement);
            var lineNo = 0;
            var startAt = wrapper.actualWidth;
            if (_this.ellipsis) {
              if (text) {
                _this.truncate(
                  textNode,
                  text,
                  void 0,
                  0,
                  // Target width
                  Math.max(
                    0,
                    // Substract the font face to make room for the
                    // ellipsis itself
                    width - parseInt(_this.fontSize || 12, 10)
                  ),
                  // Build the text to test for
                  function(text2, currentIndex) {
                    return text2.substring(0, currentIndex) + "";
                  }
                );
              }
            } else if (hasWhiteSpace) {
              var lines = [];
              var precedingSiblings = [];
              while (parentElement.firstChild && parentElement.firstChild !== textNode) {
                precedingSiblings.push(parentElement.firstChild);
                parentElement.removeChild(parentElement.firstChild);
              }
              while (words.length) {
                if (words.length && !_this.noWrap && lineNo > 0) {
                  lines.push(textNode.textContent || "");
                  textNode.textContent = words.join(" ").replace(/- /g, "-");
                }
                _this.truncate(
                  textNode,
                  void 0,
                  words,
                  lineNo === 0 ? startAt || 0 : 0,
                  width,
                  // Build the text to test for
                  function(t, currentIndex) {
                    return words.slice(0, currentIndex).join(" ").replace(/- /g, "-");
                  }
                );
                startAt = wrapper.actualWidth;
                lineNo++;
              }
              precedingSiblings.forEach(function(childNode) {
                parentElement.insertBefore(childNode, textNode);
              });
              lines.forEach(function(line) {
                parentElement.insertBefore(doc$k.createTextNode(line), textNode);
                var br = doc$k.createElementNS(SVG_NS$1, "tspan");
                br.textContent = "";
                attr$5(br, { dy, x });
                parentElement.insertBefore(br, textNode);
              });
            }
          };
          var modifyChildren = function(node) {
            var childNodes = [].slice.call(node.childNodes);
            childNodes.forEach(function(childNode) {
              if (childNode.nodeType === Node.TEXT_NODE) {
                modifyTextNode(childNode, node);
              } else {
                if (childNode.className.baseVal.indexOf("highcharts-br") !== -1) {
                  wrapper.actualWidth = 0;
                }
                modifyChildren(childNode);
              }
            });
          };
          modifyChildren(wrapper.element);
        };
        TextBuilder2.prototype.getLineHeight = function(node) {
          var fontSizeStyle;
          var element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
          if (!this.renderer.styledMode) {
            fontSizeStyle = element && /(px|em)$/.test(element.style.fontSize) ? element.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12;
          }
          return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(fontSizeStyle, element || this.svgElement.element).h;
        };
        TextBuilder2.prototype.modifyTree = function(nodes) {
          var _this = this;
          var modifyChild = function(node, i) {
            var tagName = node.tagName;
            var styledMode = _this.renderer.styledMode;
            var attributes = node.attributes || {};
            if (tagName === "b" || tagName === "strong") {
              if (styledMode) {
                attributes["class"] = "highcharts-strong";
              } else {
                attributes.style = "font-weight:bold;" + (attributes.style || "");
              }
            } else if (tagName === "i" || tagName === "em") {
              if (styledMode) {
                attributes["class"] = "highcharts-emphasized";
              } else {
                attributes.style = "font-style:italic;" + (attributes.style || "");
              }
            }
            if (isString$9(attributes.style)) {
              attributes.style = attributes.style.replace(/(;| |^)color([ :])/, "$1fill$2");
            }
            if (tagName === "br") {
              attributes["class"] = "highcharts-br";
              node.textContent = "";
              var nextNode = nodes[i + 1];
              if (nextNode && nextNode.textContent) {
                nextNode.textContent = nextNode.textContent.replace(/^ +/gm, "");
              }
            }
            if (tagName !== "#text" && tagName !== "a") {
              node.tagName = "tspan";
            }
            node.attributes = attributes;
            if (node.children) {
              node.children.filter(function(c) {
                return c.tagName !== "#text";
              }).forEach(modifyChild);
            }
          };
          nodes.forEach(modifyChild);
        };
        TextBuilder2.prototype.truncate = function(textNode, text, words, startAt, width, getString) {
          var svgElement = this.svgElement;
          var renderer = svgElement.renderer, rotation = svgElement.rotation;
          var lengths = [];
          var minIndex = words ? 1 : 0;
          var maxIndex = (text || words || "").length;
          var currentIndex = maxIndex;
          var str;
          var actualWidth;
          var getSubStringLength = function(charEnd, concatenatedEnd) {
            var end = concatenatedEnd || charEnd;
            var parentNode = textNode.parentNode;
            if (parentNode && typeof lengths[end] === "undefined") {
              if (parentNode.getSubStringLength) {
                try {
                  lengths[end] = startAt + parentNode.getSubStringLength(0, words ? end + 1 : end);
                } catch (e2) {
                }
              } else if (renderer.getSpanWidth) {
                textNode.textContent = getString(text || words, charEnd);
                lengths[end] = startAt + renderer.getSpanWidth(svgElement, textNode);
              }
            }
            return lengths[end];
          };
          svgElement.rotation = 0;
          actualWidth = getSubStringLength(textNode.textContent.length);
          if (startAt + actualWidth > width) {
            while (minIndex <= maxIndex) {
              currentIndex = Math.ceil((minIndex + maxIndex) / 2);
              if (words) {
                str = getString(words, currentIndex);
              }
              actualWidth = getSubStringLength(currentIndex, str && str.length - 1);
              if (minIndex === maxIndex) {
                minIndex = maxIndex + 1;
              } else if (actualWidth > width) {
                maxIndex = currentIndex - 1;
              } else {
                minIndex = currentIndex;
              }
            }
            if (maxIndex === 0) {
              textNode.textContent = "";
            } else if (!(text && maxIndex === text.length - 1)) {
              textNode.textContent = str || getString(text || words, currentIndex);
            }
          }
          if (words) {
            words.splice(0, currentIndex);
          }
          svgElement.actualWidth = actualWidth;
          svgElement.rotation = rotation;
        };
        TextBuilder2.prototype.unescapeEntities = function(inputStr, except) {
          objectEach$v(this.renderer.escapes, function(value, key) {
            if (!except || except.indexOf(value) === -1) {
              inputStr = inputStr.toString().replace(new RegExp(value, "g"), key);
            }
          });
          return inputStr;
        };
        return TextBuilder2;
      }()
    );
    var charts$4 = H.charts, deg2rad$7 = H.deg2rad, doc$j = H.doc, isFirefox$3 = H.isFirefox, isMS$2 = H.isMS, isWebKit$1 = H.isWebKit, noop$k = H.noop, SVG_NS = H.SVG_NS, symbolSizes = H.symbolSizes, win$c = H.win;
    var addEvent$10 = Utilities.addEvent, attr$4 = Utilities.attr, createElement$8 = Utilities.createElement, css$b = Utilities.css, defined$Q = Utilities.defined, destroyObjectProperties$9 = Utilities.destroyObjectProperties, extend$1m = Utilities.extend, isArray$k = Utilities.isArray, isNumber$J = Utilities.isNumber, isObject$c = Utilities.isObject, isString$8 = Utilities.isString, merge$1i = Utilities.merge, pick$1s = Utilities.pick, pInt$6 = Utilities.pInt, uniqueKey$6 = Utilities.uniqueKey;
    var hasInternalReferenceBug;
    var SVGRenderer = (
      /** @class */
      function() {
        function SVGRenderer2(container, width, height, style, forExport, allowHTML, styledMode) {
          this.alignedObjects = void 0;
          this.box = void 0;
          this.boxWrapper = void 0;
          this.cache = void 0;
          this.cacheKeys = void 0;
          this.chartIndex = void 0;
          this.defs = void 0;
          this.globalAnimation = void 0;
          this.gradients = void 0;
          this.height = void 0;
          this.imgCount = void 0;
          this.isSVG = void 0;
          this.style = void 0;
          this.url = void 0;
          this.width = void 0;
          this.init(container, width, height, style, forExport, allowHTML, styledMode);
        }
        SVGRenderer2.prototype.init = function(container, width, height, style, forExport, allowHTML, styledMode) {
          var renderer = this, boxWrapper = renderer.createElement("svg").attr({
            version: "1.1",
            "class": "highcharts-root"
          }), element = boxWrapper.element;
          if (!styledMode) {
            boxWrapper.css(this.getStyle(style));
          }
          container.appendChild(element);
          attr$4(container, "dir", "ltr");
          if (container.innerHTML.indexOf("xmlns") === -1) {
            attr$4(element, "xmlns", this.SVG_NS);
          }
          renderer.isSVG = true;
          this.box = element;
          this.boxWrapper = boxWrapper;
          renderer.alignedObjects = [];
          this.url = this.getReferenceURL();
          var desc = this.createElement("desc").add();
          desc.element.appendChild(doc$j.createTextNode("Created with Highcharts 9.2.2"));
          renderer.defs = this.createElement("defs").add();
          renderer.allowHTML = allowHTML;
          renderer.forExport = forExport;
          renderer.styledMode = styledMode;
          renderer.gradients = {};
          renderer.cache = {};
          renderer.cacheKeys = [];
          renderer.imgCount = 0;
          renderer.setSize(width, height, false);
          var subPixelFix, rect2;
          if (isFirefox$3 && container.getBoundingClientRect) {
            subPixelFix = function() {
              css$b(container, { left: 0, top: 0 });
              rect2 = container.getBoundingClientRect();
              css$b(container, {
                left: Math.ceil(rect2.left) - rect2.left + "px",
                top: Math.ceil(rect2.top) - rect2.top + "px"
              });
            };
            subPixelFix();
            renderer.unSubPixelFix = addEvent$10(win$c, "resize", subPixelFix);
          }
        };
        SVGRenderer2.prototype.definition = function(def) {
          var ast = new AST([def]);
          return ast.addToDOM(this.defs.element);
        };
        SVGRenderer2.prototype.getReferenceURL = function() {
          if ((isFirefox$3 || isWebKit$1) && doc$j.getElementsByTagName("base").length) {
            if (!defined$Q(hasInternalReferenceBug)) {
              var id = uniqueKey$6();
              var ast = new AST([{
                tagName: "svg",
                attributes: {
                  width: 8,
                  height: 8
                },
                children: [{
                  tagName: "defs",
                  children: [{
                    tagName: "clipPath",
                    attributes: {
                      id
                    },
                    children: [{
                      tagName: "rect",
                      attributes: {
                        width: 4,
                        height: 4
                      }
                    }]
                  }]
                }, {
                  tagName: "rect",
                  attributes: {
                    id: "hitme",
                    width: 8,
                    height: 8,
                    "clip-path": "url(#" + id + ")",
                    fill: "rgba(0,0,0,0.001)"
                  }
                }]
              }]);
              var svg2 = ast.addToDOM(doc$j.body);
              css$b(svg2, {
                position: "fixed",
                top: 0,
                left: 0,
                zIndex: 9e5
              });
              var hitElement = doc$j.elementFromPoint(6, 6);
              hasInternalReferenceBug = (hitElement && hitElement.id) === "hitme";
              doc$j.body.removeChild(svg2);
            }
            if (hasInternalReferenceBug) {
              return win$c.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
            }
          }
          return "";
        };
        SVGRenderer2.prototype.getStyle = function(style) {
          this.style = extend$1m({
            fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
            fontSize: "12px"
          }, style);
          return this.style;
        };
        SVGRenderer2.prototype.setStyle = function(style) {
          this.boxWrapper.css(this.getStyle(style));
        };
        SVGRenderer2.prototype.isHidden = function() {
          return !this.boxWrapper.getBBox().width;
        };
        SVGRenderer2.prototype.destroy = function() {
          var renderer = this, rendererDefs = renderer.defs;
          renderer.box = null;
          renderer.boxWrapper = renderer.boxWrapper.destroy();
          destroyObjectProperties$9(renderer.gradients || {});
          renderer.gradients = null;
          if (rendererDefs) {
            renderer.defs = rendererDefs.destroy();
          }
          if (renderer.unSubPixelFix) {
            renderer.unSubPixelFix();
          }
          renderer.alignedObjects = null;
          return null;
        };
        SVGRenderer2.prototype.createElement = function(nodeName) {
          var wrapper = new this.Element();
          wrapper.init(this, nodeName);
          return wrapper;
        };
        SVGRenderer2.prototype.getRadialAttr = function(radialReference, gradAttr) {
          return {
            cx: radialReference[0] - radialReference[2] / 2 + (gradAttr.cx || 0) * radialReference[2],
            cy: radialReference[1] - radialReference[2] / 2 + (gradAttr.cy || 0) * radialReference[2],
            r: (gradAttr.r || 0) * radialReference[2]
          };
        };
        SVGRenderer2.prototype.buildText = function(wrapper) {
          new TextBuilder(wrapper).buildSVG();
        };
        SVGRenderer2.prototype.getContrast = function(rgba) {
          rgba = Color.parse(rgba).rgba;
          rgba[0] *= 1;
          rgba[1] *= 1.2;
          rgba[2] *= 0.5;
          return rgba[0] + rgba[1] + rgba[2] > 1.8 * 255 ? "#000000" : "#FFFFFF";
        };
        SVGRenderer2.prototype.button = function(text, x, y, callback, theme2, hoverState, pressedState, disabledState, shape, useHTML) {
          var label = this.label(text, x, y, shape, void 0, void 0, useHTML, void 0, "button"), styledMode = this.styledMode;
          var curState = 0, normalState = theme2 ? merge$1i(theme2) : {};
          var userNormalStyle = normalState && normalState.style || {};
          normalState = AST.filterUserAttributes(normalState);
          label.attr(merge$1i({ padding: 8, r: 2 }, normalState));
          var normalStyle, hoverStyle, pressedStyle, disabledStyle;
          if (!styledMode) {
            normalState = merge$1i({
              fill: palette.neutralColor3,
              stroke: palette.neutralColor20,
              "stroke-width": 1,
              style: {
                color: palette.neutralColor80,
                cursor: "pointer",
                fontWeight: "normal"
              }
            }, {
              style: userNormalStyle
            }, normalState);
            normalStyle = normalState.style;
            delete normalState.style;
            hoverState = merge$1i(normalState, {
              fill: palette.neutralColor10
            }, AST.filterUserAttributes(hoverState || {}));
            hoverStyle = hoverState.style;
            delete hoverState.style;
            pressedState = merge$1i(normalState, {
              fill: palette.highlightColor10,
              style: {
                color: palette.neutralColor100,
                fontWeight: "bold"
              }
            }, AST.filterUserAttributes(pressedState || {}));
            pressedStyle = pressedState.style;
            delete pressedState.style;
            disabledState = merge$1i(normalState, {
              style: {
                color: palette.neutralColor20
              }
            }, AST.filterUserAttributes(disabledState || {}));
            disabledStyle = disabledState.style;
            delete disabledState.style;
          }
          addEvent$10(label.element, isMS$2 ? "mouseover" : "mouseenter", function() {
            if (curState !== 3) {
              label.setState(1);
            }
          });
          addEvent$10(label.element, isMS$2 ? "mouseout" : "mouseleave", function() {
            if (curState !== 3) {
              label.setState(curState);
            }
          });
          label.setState = function(state) {
            if (state !== 1) {
              label.state = curState = state;
            }
            label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][state || 0]);
            if (!styledMode) {
              label.attr([
                normalState,
                hoverState,
                pressedState,
                disabledState
              ][state || 0]).css([
                normalStyle,
                hoverStyle,
                pressedStyle,
                disabledStyle
              ][state || 0]);
            }
          };
          if (!styledMode) {
            label.attr(normalState).css(extend$1m({ cursor: "default" }, normalStyle));
          }
          return label.on("touchstart", function(e2) {
            return e2.stopPropagation();
          }).on("click", function(e2) {
            if (curState !== 3) {
              callback.call(label, e2);
            }
          });
        };
        SVGRenderer2.prototype.crispLine = function(points, width, roundingFunction) {
          if (roundingFunction === void 0) {
            roundingFunction = "round";
          }
          var start = points[0];
          var end = points[1];
          if (defined$Q(start[1]) && start[1] === end[1]) {
            start[1] = end[1] = Math[roundingFunction](start[1]) - width % 2 / 2;
          }
          if (defined$Q(start[2]) && start[2] === end[2]) {
            start[2] = end[2] = Math[roundingFunction](start[2]) + width % 2 / 2;
          }
          return points;
        };
        SVGRenderer2.prototype.path = function(path) {
          var attribs = this.styledMode ? {} : {
            fill: "none"
          };
          if (isArray$k(path)) {
            attribs.d = path;
          } else if (isObject$c(path)) {
            extend$1m(attribs, path);
          }
          return this.createElement("path").attr(attribs);
        };
        SVGRenderer2.prototype.circle = function(x, y, r) {
          var attribs = isObject$c(x) ? x : typeof x === "undefined" ? {} : { x, y, r }, wrapper = this.createElement("circle");
          wrapper.xSetter = wrapper.ySetter = function(value, key, element) {
            element.setAttribute("c" + key, value);
          };
          return wrapper.attr(attribs);
        };
        SVGRenderer2.prototype.arc = function(x, y, r, innerR, start, end) {
          var options;
          if (isObject$c(x)) {
            options = x;
            y = options.y;
            r = options.r;
            innerR = options.innerR;
            start = options.start;
            end = options.end;
            x = options.x;
          } else {
            options = { innerR, start, end };
          }
          var arc2 = this.symbol("arc", x, y, r, r, options);
          arc2.r = r;
          return arc2;
        };
        SVGRenderer2.prototype.rect = function(x, y, width, height, r, strokeWidth) {
          r = isObject$c(x) ? x.r : r;
          var wrapper = this.createElement("rect");
          var attribs = isObject$c(x) ? x : typeof x === "undefined" ? {} : {
            x,
            y,
            width: Math.max(width, 0),
            height: Math.max(height, 0)
          };
          if (!this.styledMode) {
            if (typeof strokeWidth !== "undefined") {
              attribs["stroke-width"] = strokeWidth;
              attribs = wrapper.crisp(attribs);
            }
            attribs.fill = "none";
          }
          if (r) {
            attribs.r = r;
          }
          wrapper.rSetter = function(value, _key, element) {
            wrapper.r = value;
            attr$4(element, {
              rx: value,
              ry: value
            });
          };
          wrapper.rGetter = function() {
            return wrapper.r || 0;
          };
          return wrapper.attr(attribs);
        };
        SVGRenderer2.prototype.setSize = function(width, height, animate2) {
          var renderer = this;
          renderer.width = width;
          renderer.height = height;
          renderer.boxWrapper.animate({
            width,
            height
          }, {
            step: function() {
              this.attr({
                viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
              });
            },
            duration: pick$1s(animate2, true) ? void 0 : 0
          });
          renderer.alignElements();
        };
        SVGRenderer2.prototype.g = function(name) {
          var elem = this.createElement("g");
          return name ? elem.attr({ "class": "highcharts-" + name }) : elem;
        };
        SVGRenderer2.prototype.image = function(src, x, y, width, height, onload) {
          var attribs = { preserveAspectRatio: "none" }, setSVGImageSource = function(el, src2) {
            if (el.setAttributeNS) {
              el.setAttributeNS("http://www.w3.org/1999/xlink", "href", src2);
            } else {
              el.setAttribute("hc-svg-href", src2);
            }
          };
          if (arguments.length > 1) {
            extend$1m(attribs, {
              x,
              y,
              width,
              height
            });
          }
          var elemWrapper = this.createElement("image").attr(attribs), onDummyLoad = function(e2) {
            setSVGImageSource(elemWrapper.element, src);
            onload.call(elemWrapper, e2);
          };
          if (onload) {
            setSVGImageSource(
              elemWrapper.element,
              "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
              /* eslint-disable-line */
            );
            var dummy = new win$c.Image();
            addEvent$10(dummy, "load", onDummyLoad);
            dummy.src = src;
            if (dummy.complete) {
              onDummyLoad({});
            }
          } else {
            setSVGImageSource(elemWrapper.element, src);
          }
          return elemWrapper;
        };
        SVGRenderer2.prototype.symbol = function(symbol, x, y, width, height, options) {
          var ren = this, imageRegex = /^url\((.*?)\)$/, isImage = imageRegex.test(symbol), sym = !isImage && (this.symbols[symbol] ? symbol : "circle"), symbolFn = sym && this.symbols[sym];
          var obj, path, imageSrc, centerImage;
          if (symbolFn) {
            if (typeof x === "number") {
              path = symbolFn.call(this.symbols, Math.round(x || 0), Math.round(y || 0), width || 0, height || 0, options);
            }
            obj = this.path(path);
            if (!ren.styledMode) {
              obj.attr("fill", "none");
            }
            extend$1m(obj, {
              symbolName: sym || void 0,
              x,
              y,
              width,
              height
            });
            if (options) {
              extend$1m(obj, options);
            }
          } else if (isImage) {
            imageSrc = symbol.match(imageRegex)[1];
            var img_1 = obj = this.image(imageSrc);
            img_1.imgwidth = pick$1s(symbolSizes[imageSrc] && symbolSizes[imageSrc].width, options && options.width);
            img_1.imgheight = pick$1s(symbolSizes[imageSrc] && symbolSizes[imageSrc].height, options && options.height);
            centerImage = function(obj2) {
              return obj2.attr({
                width: obj2.width,
                height: obj2.height
              });
            };
            ["width", "height"].forEach(function(key) {
              img_1[key + "Setter"] = function(value, key2) {
                var imgSize = this["img" + key2];
                this[key2] = value;
                if (defined$Q(imgSize)) {
                  if (options && options.backgroundSize === "within" && this.width && this.height) {
                    imgSize = Math.round(imgSize * Math.min(this.width / this.imgwidth, this.height / this.imgheight));
                  }
                  if (this.element) {
                    this.element.setAttribute(key2, imgSize);
                  }
                  if (!this.alignByTranslate) {
                    var translate2 = ((this[key2] || 0) - imgSize) / 2;
                    var attribs = key2 === "width" ? { translateX: translate2 } : { translateY: translate2 };
                    this.attr(attribs);
                  }
                }
              };
            });
            if (defined$Q(x)) {
              img_1.attr({
                x,
                y
              });
            }
            img_1.isImg = true;
            if (defined$Q(img_1.imgwidth) && defined$Q(img_1.imgheight)) {
              centerImage(img_1);
            } else {
              img_1.attr({ width: 0, height: 0 });
              createElement$8("img", {
                onload: function() {
                  var chart = charts$4[ren.chartIndex];
                  if (this.width === 0) {
                    css$b(this, {
                      position: "absolute",
                      top: "-999em"
                    });
                    doc$j.body.appendChild(this);
                  }
                  symbolSizes[imageSrc] = {
                    width: this.width,
                    height: this.height
                  };
                  img_1.imgwidth = this.width;
                  img_1.imgheight = this.height;
                  if (img_1.element) {
                    centerImage(img_1);
                  }
                  if (this.parentNode) {
                    this.parentNode.removeChild(this);
                  }
                  ren.imgCount--;
                  if (!ren.imgCount && chart && !chart.hasLoaded) {
                    chart.onload();
                  }
                },
                src: imageSrc
              });
              this.imgCount++;
            }
          }
          return obj;
        };
        SVGRenderer2.prototype.clipRect = function(x, y, width, height) {
          var id = uniqueKey$6() + "-", clipPath = this.createElement("clipPath").attr({
            id
          }).add(this.defs), wrapper = this.rect(x, y, width, height, 0).add(clipPath);
          wrapper.id = id;
          wrapper.clipPath = clipPath;
          wrapper.count = 0;
          return wrapper;
        };
        SVGRenderer2.prototype.text = function(str, x, y, useHTML) {
          var renderer = this, attribs = {};
          if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
            return renderer.html(str, x, y);
          }
          attribs.x = Math.round(x || 0);
          if (y) {
            attribs.y = Math.round(y);
          }
          if (defined$Q(str)) {
            attribs.text = str;
          }
          var wrapper = renderer.createElement("text").attr(attribs);
          if (!useHTML || renderer.forExport && !renderer.allowHTML) {
            wrapper.xSetter = function(value, key, element) {
              var tspans = element.getElementsByTagName("tspan"), parentVal = element.getAttribute(key);
              for (var i = 0, tspan = void 0; i < tspans.length; i++) {
                tspan = tspans[i];
                if (tspan.getAttribute(key) === parentVal) {
                  tspan.setAttribute(key, value);
                }
              }
              element.setAttribute(key, value);
            };
          }
          return wrapper;
        };
        SVGRenderer2.prototype.fontMetrics = function(fontSize, elem) {
          if ((this.styledMode || !/px/.test(fontSize)) && win$c.getComputedStyle) {
            fontSize = elem && SVGElement.prototype.getStyle.call(elem, "font-size");
          } else {
            fontSize = fontSize || // When the elem is a DOM element (#5932)
            elem && elem.style && elem.style.fontSize || // Fall back on the renderer style default
            this.style && this.style.fontSize;
          }
          if (/px/.test(fontSize)) {
            fontSize = pInt$6(fontSize);
          } else {
            fontSize = 12;
          }
          var lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2), baseline = Math.round(lineHeight * 0.8);
          return {
            h: lineHeight,
            b: baseline,
            f: fontSize
          };
        };
        SVGRenderer2.prototype.rotCorr = function(baseline, rotation, alterY) {
          var y = baseline;
          if (rotation && alterY) {
            y = Math.max(y * Math.cos(rotation * deg2rad$7), 4);
          }
          return {
            x: -baseline / 3 * Math.sin(rotation * deg2rad$7),
            y
          };
        };
        SVGRenderer2.prototype.pathToSegments = function(path) {
          var ret = [];
          var segment = [];
          var commandLength = {
            A: 8,
            C: 7,
            H: 2,
            L: 3,
            M: 3,
            Q: 5,
            S: 5,
            T: 3,
            V: 2
          };
          for (var i = 0; i < path.length; i++) {
            if (isString$8(segment[0]) && isNumber$J(path[i]) && segment.length === commandLength[segment[0].toUpperCase()]) {
              path.splice(i, 0, segment[0].replace("M", "L").replace("m", "l"));
            }
            if (typeof path[i] === "string") {
              if (segment.length) {
                ret.push(segment.slice(0));
              }
              segment.length = 0;
            }
            segment.push(path[i]);
          }
          ret.push(segment.slice(0));
          return ret;
        };
        SVGRenderer2.prototype.label = function(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
          return new SVGLabel(this, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className);
        };
        SVGRenderer2.prototype.alignElements = function() {
          this.alignedObjects.forEach(function(el) {
            return el.align();
          });
        };
        return SVGRenderer2;
      }()
    );
    extend$1m(SVGRenderer.prototype, {
      /**
       * A pointer to the renderer's associated Element class. The VMLRenderer
       * will have a pointer to VMLElement here.
       *
       * @name Highcharts.SVGRenderer#Element
       * @type {Highcharts.SVGElement}
       */
      Element: SVGElement,
      SVG_NS,
      /**
       * A collection of characters mapped to HTML entities. When `useHTML` on an
       * element is true, these entities will be rendered correctly by HTML. In
       * the SVG pseudo-HTML, they need to be unescaped back to simple characters,
       * so for example `&lt;` will render as `<`.
       *
       * @example
       * // Add support for unescaping quotes
       * Highcharts.SVGRenderer.prototype.escapes['"'] = '&quot;';
       *
       * @name Highcharts.SVGRenderer#escapes
       * @type {Highcharts.Dictionary<string>}
       */
      escapes: {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;"
      },
      /**
       * An extendable collection of functions for defining symbol paths.
       *
       * @name Highcharts.SVGRenderer#symbols
       * @type {Highcharts.SymbolDictionary}
       */
      symbols: Symbols,
      /**
       * Dummy function for plugins, called every time the renderer is updated.
       * Prior to Highcharts 5, this was used for the canvg renderer.
       *
       * @deprecated
       * @function Highcharts.SVGRenderer#draw
       */
      draw: noop$k
    });
    RendererRegistry$1.registerRendererType("svg", SVGRenderer, true);
    var __extends$X = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var isFirefox$2 = H.isFirefox, isMS$1 = H.isMS, isWebKit = H.isWebKit, win$b = H.win;
    var css$a = Utilities.css, defined$P = Utilities.defined, extend$1l = Utilities.extend, pick$1r = Utilities.pick, pInt$5 = Utilities.pInt;
    var HTMLElement$1 = (
      /** @class */
      function(_super) {
        __extends$X(HTMLElement2, _super);
        function HTMLElement2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        HTMLElement2.compose = function(SVGElementClass) {
          if (HTMLElement2.composedClasses.indexOf(SVGElementClass) === -1) {
            HTMLElement2.composedClasses.push(SVGElementClass);
            var htmlElementProto = HTMLElement2.prototype, svgElementProto = SVGElementClass.prototype;
            svgElementProto.getSpanCorrection = htmlElementProto.getSpanCorrection;
            svgElementProto.htmlCss = htmlElementProto.htmlCss;
            svgElementProto.htmlGetBBox = htmlElementProto.htmlGetBBox;
            svgElementProto.htmlUpdateTransform = htmlElementProto.htmlUpdateTransform;
            svgElementProto.setSpanRotation = htmlElementProto.setSpanRotation;
          }
          return SVGElementClass;
        };
        HTMLElement2.prototype.getSpanCorrection = function(width, baseline, alignCorrection) {
          this.xCorr = -width * alignCorrection;
          this.yCorr = -baseline;
        };
        HTMLElement2.prototype.htmlCss = function(styles) {
          var wrapper = this, element = wrapper.element, isSettingWidth = element.tagName === "SPAN" && styles && "width" in styles, textWidth = pick$1r(isSettingWidth && styles.width, void 0);
          var doTransform;
          if (isSettingWidth) {
            delete styles.width;
            wrapper.textWidth = textWidth;
            doTransform = true;
          }
          if (styles && styles.textOverflow === "ellipsis") {
            styles.whiteSpace = "nowrap";
            styles.overflow = "hidden";
          }
          wrapper.styles = extend$1l(wrapper.styles, styles);
          css$a(wrapper.element, styles);
          if (doTransform) {
            wrapper.htmlUpdateTransform();
          }
          return wrapper;
        };
        HTMLElement2.prototype.htmlGetBBox = function() {
          var wrapper = this, element = wrapper.element;
          return {
            x: element.offsetLeft,
            y: element.offsetTop,
            width: element.offsetWidth,
            height: element.offsetHeight
          };
        };
        HTMLElement2.prototype.htmlUpdateTransform = function() {
          if (!this.added) {
            this.alignOnAdd = true;
            return;
          }
          var wrapper = this, renderer = wrapper.renderer, elem = wrapper.element, translateX = wrapper.translateX || 0, translateY = wrapper.translateY || 0, x = wrapper.x || 0, y = wrapper.y || 0, align = wrapper.textAlign || "left", alignCorrection = {
            left: 0,
            center: 0.5,
            right: 1
          }[align], styles = wrapper.styles, whiteSpace = styles && styles.whiteSpace;
          function getTextPxLength() {
            css$a(elem, {
              width: "",
              whiteSpace: whiteSpace || "nowrap"
            });
            return elem.offsetWidth;
          }
          css$a(elem, {
            marginLeft: translateX,
            marginTop: translateY
          });
          if (!renderer.styledMode && wrapper.shadows) {
            wrapper.shadows.forEach(function(shadow) {
              css$a(shadow, {
                marginLeft: translateX + 1,
                marginTop: translateY + 1
              });
            });
          }
          if (wrapper.inverted) {
            [].forEach.call(elem.childNodes, function(child) {
              renderer.invertChild(child, elem);
            });
          }
          if (elem.tagName === "SPAN") {
            var rotation = wrapper.rotation, textWidth = wrapper.textWidth && pInt$5(wrapper.textWidth), currentTextTransform = [
              rotation,
              align,
              elem.innerHTML,
              wrapper.textWidth,
              wrapper.textAlign
            ].join(",");
            var baseline = void 0;
            if (textWidth !== wrapper.oldTextWidth && (textWidth > wrapper.oldTextWidth || (wrapper.textPxLength || getTextPxLength()) > textWidth) && // Only set the width if the text is able to word-wrap, or
            // text-overflow is ellipsis (#9537)
            (/[ \-]/.test(elem.textContent || elem.innerText) || elem.style.textOverflow === "ellipsis")) {
              css$a(elem, {
                width: textWidth + "px",
                display: "block",
                whiteSpace: whiteSpace || "normal"
                // #3331
              });
              wrapper.oldTextWidth = textWidth;
              wrapper.hasBoxWidthChanged = true;
            } else {
              wrapper.hasBoxWidthChanged = false;
            }
            if (currentTextTransform !== wrapper.cTT) {
              baseline = renderer.fontMetrics(elem.style.fontSize, elem).b;
              if (defined$P(rotation) && (rotation !== (wrapper.oldRotation || 0) || align !== wrapper.oldAlign)) {
                wrapper.setSpanRotation(rotation, alignCorrection, baseline);
              }
              wrapper.getSpanCorrection(
                // Avoid elem.offsetWidth if we can, it affects rendering
                // time heavily (#7656)
                !defined$P(rotation) && wrapper.textPxLength || // #7920
                elem.offsetWidth,
                baseline,
                alignCorrection,
                rotation,
                align
              );
            }
            css$a(elem, {
              left: x + (wrapper.xCorr || 0) + "px",
              top: y + (wrapper.yCorr || 0) + "px"
            });
            wrapper.cTT = currentTextTransform;
            wrapper.oldRotation = rotation;
            wrapper.oldAlign = align;
          }
        };
        HTMLElement2.prototype.setSpanRotation = function(rotation, alignCorrection, baseline) {
          var getTransformKey = function() {
            return isMS$1 && !/Edge/.test(win$b.navigator.userAgent) ? "-ms-transform" : isWebKit ? "-webkit-transform" : isFirefox$2 ? "MozTransform" : win$b.opera ? "-o-transform" : void 0;
          };
          var rotationStyle = {}, cssTransformKey = getTransformKey();
          if (cssTransformKey) {
            rotationStyle[cssTransformKey] = rotationStyle.transform = "rotate(" + rotation + "deg)";
            rotationStyle[cssTransformKey + (isFirefox$2 ? "Origin" : "-origin")] = rotationStyle.transformOrigin = alignCorrection * 100 + "% " + baseline + "px";
            css$a(this.element, rotationStyle);
          }
        };
        HTMLElement2.composedClasses = [];
        return HTMLElement2;
      }(SVGElement)
    );
    var __extends$W = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var attr$3 = Utilities.attr, createElement$7 = Utilities.createElement, extend$1k = Utilities.extend, pick$1q = Utilities.pick;
    var HTMLRenderer = (
      /** @class */
      function(_super) {
        __extends$W(HTMLRenderer2, _super);
        function HTMLRenderer2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        HTMLRenderer2.compose = function(SVGRendererClass) {
          if (HTMLRenderer2.composedClasses.indexOf(SVGRendererClass) === -1) {
            HTMLRenderer2.composedClasses.push(SVGRendererClass);
            var htmlRendererProto = HTMLRenderer2.prototype, svgRendererProto = SVGRendererClass.prototype;
            svgRendererProto.html = htmlRendererProto.html;
          }
          return SVGRendererClass;
        };
        HTMLRenderer2.prototype.html = function(str, x, y) {
          var wrapper = this.createElement("span"), element = wrapper.element, renderer = wrapper.renderer, isSVG = renderer.isSVG, addSetters = function(gWrapper, style) {
            ["opacity", "visibility"].forEach(function(prop) {
              gWrapper[prop + "Setter"] = function(value, key, elem) {
                var styleObject = gWrapper.div ? gWrapper.div.style : style;
                SVGElement.prototype[prop + "Setter"].call(this, value, key, elem);
                if (styleObject) {
                  styleObject[key] = value;
                }
              };
            });
            gWrapper.addedSetters = true;
          };
          wrapper.textSetter = function(value) {
            if (value !== this.textStr) {
              delete this.bBox;
              delete this.oldTextWidth;
              AST.setElementHTML(this.element, pick$1q(value, ""));
              this.textStr = value;
              wrapper.doTransform = true;
            }
          };
          if (isSVG) {
            addSetters(wrapper, wrapper.element.style);
          }
          wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function(value, key) {
            if (key === "align") {
              wrapper.alignValue = wrapper.textAlign = value;
            } else {
              wrapper[key] = value;
            }
            wrapper.doTransform = true;
          };
          wrapper.afterSetters = function() {
            if (this.doTransform) {
              this.htmlUpdateTransform();
              this.doTransform = false;
            }
          };
          wrapper.attr({
            text: str,
            x: Math.round(x),
            y: Math.round(y)
          }).css({
            position: "absolute"
          });
          if (!renderer.styledMode) {
            wrapper.css({
              fontFamily: this.style.fontFamily,
              fontSize: this.style.fontSize
            });
          }
          element.style.whiteSpace = "nowrap";
          wrapper.css = wrapper.htmlCss;
          if (isSVG) {
            wrapper.add = function(svgGroupWrapper) {
              var container = renderer.box.parentNode, parents = [];
              var htmlGroup, parentGroup;
              this.parentGroup = svgGroupWrapper;
              if (svgGroupWrapper) {
                htmlGroup = svgGroupWrapper.div;
                if (!htmlGroup) {
                  parentGroup = svgGroupWrapper;
                  while (parentGroup) {
                    parents.push(parentGroup);
                    parentGroup = parentGroup.parentGroup;
                  }
                  parents.reverse().forEach(function(parentGroup2) {
                    var cls = attr$3(parentGroup2.element, "class");
                    function translateSetter(value, key) {
                      parentGroup2[key] = value;
                      if (key === "translateX") {
                        htmlGroupStyle.left = value + "px";
                      } else {
                        htmlGroupStyle.top = value + "px";
                      }
                      parentGroup2.doTransform = true;
                    }
                    var parentGroupStyles = parentGroup2.styles || {};
                    htmlGroup = parentGroup2.div = parentGroup2.div || createElement$7("div", cls ? { className: cls } : void 0, {
                      position: "absolute",
                      left: (parentGroup2.translateX || 0) + "px",
                      top: (parentGroup2.translateY || 0) + "px",
                      display: parentGroup2.display,
                      opacity: parentGroup2.opacity,
                      cursor: parentGroupStyles.cursor,
                      pointerEvents: parentGroupStyles.pointerEvents,
                      visibility: parentGroup2.visibility
                      // the top group is appended to container
                    }, htmlGroup || container);
                    var htmlGroupStyle = htmlGroup.style;
                    extend$1k(parentGroup2, {
                      // (#7287) Pass htmlGroup to use
                      // the related group
                      classSetter: /* @__PURE__ */ function(htmlGroup2) {
                        return function(value) {
                          this.element.setAttribute("class", value);
                          htmlGroup2.className = value;
                        };
                      }(htmlGroup),
                      on: function() {
                        if (parents[0].div) {
                          wrapper.on.apply({
                            element: parents[0].div,
                            onEvents: parentGroup2.onEvents
                          }, arguments);
                        }
                        return parentGroup2;
                      },
                      translateXSetter: translateSetter,
                      translateYSetter: translateSetter
                    });
                    if (!parentGroup2.addedSetters) {
                      addSetters(parentGroup2);
                    }
                  });
                }
              } else {
                htmlGroup = container;
              }
              htmlGroup.appendChild(element);
              wrapper.added = true;
              if (wrapper.alignOnAdd) {
                wrapper.htmlUpdateTransform();
              }
              return wrapper;
            };
          }
          return wrapper;
        };
        HTMLRenderer2.composedClasses = [];
        return HTMLRenderer2;
      }(SVGRenderer)
    );
    var AxisDefaults;
    (function(AxisDefaults2) {
      AxisDefaults2.defaultXAxisOptions = {
        /**
         * When using multiple axis, the ticks of two or more opposite axes
         * will automatically be aligned by adding ticks to the axis or axes
         * with the least ticks, as if `tickAmount` were specified.
         *
         * This can be prevented by setting `alignTicks` to false. If the grid
         * lines look messy, it's a good idea to hide them for the secondary
         * axis by setting `gridLineWidth` to 0.
         *
         * If `startOnTick` or `endOnTick` in an Axis options are set to false,
         * then the `alignTicks ` will be disabled for the Axis.
         *
         * Disabled for logarithmic axes.
         *
         * @product   highcharts highstock gantt
         */
        alignTicks: true,
        /**
         * Whether to allow decimals in this axis' ticks. When counting
         * integers, like persons or hits on a web page, decimals should
         * be avoided in the labels. By default, decimals are allowed on small
         * scale axes.
         *
         * @see [minTickInterval](#xAxis.minTickInterval)
         *
         * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-true/
         *         True by default
         * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-false/
         *         False
         *
         * @type      {boolean|undefined}
         * @default   undefined
         * @since     2.0
         */
        allowDecimals: void 0,
        /**
         * When using an alternate grid color, a band is painted across the
         * plot area between every other grid line.
         *
         * @sample {highcharts} highcharts/yaxis/alternategridcolor/
         *         Alternate grid color on the Y axis
         * @sample {highstock} stock/xaxis/alternategridcolor/
         *         Alternate grid color on the Y axis
         *
         * @type      {Highcharts.ColorType}
         * @apioption xAxis.alternateGridColor
         */
        /**
         * An array defining breaks in the axis, the sections defined will be
         * left out and all the points shifted closer to each other.
         *
         * @productdesc {highcharts}
         * Requires that the broken-axis.js module is loaded.
         *
         * @sample {highcharts} highcharts/axisbreak/break-simple/
         *         Simple break
         * @sample {highcharts|highstock} highcharts/axisbreak/break-visualized/
         *         Advanced with callback
         * @sample {highstock} stock/demo/intraday-breaks/
         *         Break on nights and weekends
         *
         * @type      {Array<*>}
         * @since     4.1.0
         * @product   highcharts highstock gantt
         * @apioption xAxis.breaks
         */
        /**
         * A number indicating how much space should be left between the start
         * and the end of the break. The break size is given in axis units,
         * so for instance on a `datetime` axis, a break size of 3600000 would
         * indicate the equivalent of an hour.
         *
         * @type      {number}
         * @default   0
         * @since     4.1.0
         * @product   highcharts highstock gantt
         * @apioption xAxis.breaks.breakSize
         */
        /**
         * The point where the break starts.
         *
         * @type      {number}
         * @since     4.1.0
         * @product   highcharts highstock gantt
         * @apioption xAxis.breaks.from
         */
        /**
         * Defines an interval after which the break appears again. By default
         * the breaks do not repeat.
         *
         * @type      {number}
         * @default   0
         * @since     4.1.0
         * @product   highcharts highstock gantt
         * @apioption xAxis.breaks.repeat
         */
        /**
         * The point where the break ends.
         *
         * @type      {number}
         * @since     4.1.0
         * @product   highcharts highstock gantt
         * @apioption xAxis.breaks.to
         */
        /**
         * If categories are present for the xAxis, names are used instead of
         * numbers for that axis.
         *
         * Since Highcharts 3.0, categories can also
         * be extracted by giving each point a [name](#series.data) and setting
         * axis [type](#xAxis.type) to `category`. However, if you have multiple
         * series, best practice remains defining the `categories` array.
         *
         * Example: `categories: ['Apples', 'Bananas', 'Oranges']`
         *
         * @sample {highcharts} highcharts/demo/line-labels/
         *         With
         * @sample {highcharts} highcharts/xaxis/categories/
         *         Without
         *
         * @type      {Array<string>}
         * @product   highcharts gantt
         * @apioption xAxis.categories
         */
        /**
         * The highest allowed value for automatically computed axis extremes.
         *
         * @see [floor](#xAxis.floor)
         *
         * @sample {highcharts|highstock} highcharts/yaxis/floor-ceiling/
         *         Floor and ceiling
         *
         * @type       {number}
         * @since      4.0
         * @product    highcharts highstock gantt
         * @apioption  xAxis.ceiling
         */
        /**
         * A class name that opens for styling the axis by CSS, especially in
         * Highcharts styled mode. The class name is applied to group elements
         * for the grid, axis elements and labels.
         *
         * @sample {highcharts|highstock|highmaps} highcharts/css/axis/
         *         Multiple axes with separate styling
         *
         * @type      {string}
         * @since     5.0.0
         * @apioption xAxis.className
         */
        /**
         * Configure a crosshair that follows either the mouse pointer or the
         * hovered point.
         *
         * In styled mode, the crosshairs are styled in the
         * `.highcharts-crosshair`, `.highcharts-crosshair-thin` or
         * `.highcharts-xaxis-category` classes.
         *
         * @productdesc {highstock}
         * In Highcharts stock, by default, the crosshair is enabled on the
         * X axis and disabled on the Y axis.
         *
         * @sample {highcharts} highcharts/xaxis/crosshair-both/
         *         Crosshair on both axes
         * @sample {highstock} stock/xaxis/crosshairs-xy/
         *         Crosshair on both axes
         * @sample {highmaps} highcharts/xaxis/crosshair-both/
         *         Crosshair on both axes
         *
         * @declare   Highcharts.AxisCrosshairOptions
         * @type      {boolean|*}
         * @default   false
         * @since     4.1
         * @apioption xAxis.crosshair
         */
        /**
         * A class name for the crosshair, especially as a hook for styling.
         *
         * @type      {string}
         * @since     5.0.0
         * @apioption xAxis.crosshair.className
         */
        /**
         * The color of the crosshair. Defaults to `#cccccc` for numeric and
         * datetime axes, and `rgba(204,214,235,0.25)` for category axes, where
         * the crosshair by default highlights the whole category.
         *
         * @sample {highcharts|highstock|highmaps} highcharts/xaxis/crosshair-customized/
         *         Customized crosshairs
         *
         * @type      {Highcharts.ColorType}
         * @default   #cccccc
         * @since     4.1
         * @apioption xAxis.crosshair.color
         */
        /**
         * The dash style for the crosshair. See
         * [plotOptions.series.dashStyle](#plotOptions.series.dashStyle)
         * for possible values.
         *
         * @sample {highcharts|highmaps} highcharts/xaxis/crosshair-dotted/
         *         Dotted crosshair
         * @sample {highstock} stock/xaxis/crosshair-dashed/
         *         Dashed X axis crosshair
         *
         * @type      {Highcharts.DashStyleValue}
         * @default   Solid
         * @since     4.1
         * @apioption xAxis.crosshair.dashStyle
         */
        /**
         * A label on the axis next to the crosshair.
         *
         * In styled mode, the label is styled with the
         * `.highcharts-crosshair-label` class.
         *
         * @sample {highstock} stock/xaxis/crosshair-label/
         *         Crosshair labels
         * @sample {highstock} highcharts/css/crosshair-label/
         *         Style mode
         *
         * @declare   Highcharts.AxisCrosshairLabelOptions
         * @since     2.1
         * @product   highstock
         * @apioption xAxis.crosshair.label
         */
        /**
         * Alignment of the label compared to the axis. Defaults to `"left"` for
         * right-side axes, `"right"` for left-side axes and `"center"` for
         * horizontal axes.
         *
         * @type      {Highcharts.AlignValue}
         * @since     2.1
         * @product   highstock
         * @apioption xAxis.crosshair.label.align
         */
        /**
         * The background color for the label. Defaults to the related series
         * color, or `#666666` if that is not available.
         *
         * @type      {Highcharts.ColorType}
         * @since     2.1
         * @product   highstock
         * @apioption xAxis.crosshair.label.backgroundColor
         */
        /**
         * The border color for the crosshair label
         *
         * @type      {Highcharts.ColorType}
         * @since     2.1
         * @product   highstock
         * @apioption xAxis.crosshair.label.borderColor
         */
        /**
         * The border corner radius of the crosshair label.
         *
         * @type      {number}
         * @default   3
         * @since     2.1.10
         * @product   highstock
         * @apioption xAxis.crosshair.label.borderRadius
         */
        /**
         * The border width for the crosshair label.
         *
         * @type      {number}
         * @default   0
         * @since     2.1
         * @product   highstock
         * @apioption xAxis.crosshair.label.borderWidth
         */
        /**
         * Flag to enable crosshair's label.
         *
         * @sample {highstock} stock/xaxis/crosshairs-xy/
         *         Enabled label for yAxis' crosshair
         *
         * @type      {boolean}
         * @default   false
         * @since     2.1
         * @product   highstock
         * @apioption xAxis.crosshair.label.enabled
         */
        /**
         * A format string for the crosshair label. Defaults to `{value}` for
         * numeric axes and `{value:%b %d, %Y}` for datetime axes.
         *
         * @type      {string}
         * @since     2.1
         * @product   highstock
         * @apioption xAxis.crosshair.label.format
         */
        /**
         * Formatter function for the label text.
         *
         * @type      {Highcharts.XAxisCrosshairLabelFormatterCallbackFunction}
         * @since     2.1
         * @product   highstock
         * @apioption xAxis.crosshair.label.formatter
         */
        /**
         * Padding inside the crosshair label.
         *
         * @type      {number}
         * @default   8
         * @since     2.1
         * @product   highstock
         * @apioption xAxis.crosshair.label.padding
         */
        /**
         * The shape to use for the label box.
         *
         * @type      {string}
         * @default   callout
         * @since     2.1
         * @product   highstock
         * @apioption xAxis.crosshair.label.shape
         */
        /**
         * Text styles for the crosshair label.
         *
         * @type      {Highcharts.CSSObject}
         * @default   {"color": "white", "fontWeight": "normal", "fontSize": "11px", "textAlign": "center"}
         * @since     2.1
         * @product   highstock
         * @apioption xAxis.crosshair.label.style
         */
        /**
         * Whether the crosshair should snap to the point or follow the pointer
         * independent of points.
         *
         * @sample {highcharts|highstock} highcharts/xaxis/crosshair-snap-false/
         *         True by default
         * @sample {highmaps} maps/demo/latlon-advanced/
         *         Snap is false
         *
         * @type      {boolean}
         * @default   true
         * @since     4.1
         * @apioption xAxis.crosshair.snap
         */
        /**
         * The pixel width of the crosshair. Defaults to 1 for numeric or
         * datetime axes, and for one category width for category axes.
         *
         * @sample {highcharts} highcharts/xaxis/crosshair-customized/
         *         Customized crosshairs
         * @sample {highstock} highcharts/xaxis/crosshair-customized/
         *         Customized crosshairs
         * @sample {highmaps} highcharts/xaxis/crosshair-customized/
         *         Customized crosshairs
         *
         * @type      {number}
         * @default   1
         * @since     4.1
         * @apioption xAxis.crosshair.width
         */
        /**
         * The Z index of the crosshair. Higher Z indices allow drawing the
         * crosshair on top of the series or behind the grid lines.
         *
         * @type      {number}
         * @default   2
         * @since     4.1
         * @apioption xAxis.crosshair.zIndex
         */
        /**
         * Whether to pan axis. If `chart.panning` is enabled, the option
         * allows to disable panning on an individual axis.
         */
        panningEnabled: true,
        /**
         * The Z index for the axis group.
         */
        zIndex: 2,
        /**
         * Whether to zoom axis. If `chart.zoomType` is set, the option allows
         * to disable zooming on an individual axis.
         *
         * @sample {highcharts} highcharts/xaxis/zoomenabled/
         *         Zoom enabled is false
         */
        zoomEnabled: true,
        /**
         * For a datetime axis, the scale will automatically adjust to the
         * appropriate unit. This member gives the default string
         * representations used for each unit. For intermediate values,
         * different units may be used, for example the `day` unit can be used
         * on midnight and `hour` unit be used for intermediate values on the
         * same axis.
         *
         * For an overview of the replacement codes, see
         * [dateFormat](/class-reference/Highcharts#.dateFormat).
         *
         * Defaults to:
         * ```js
         * {
         *     millisecond: '%H:%M:%S.%L',
         *     second: '%H:%M:%S',
         *     minute: '%H:%M',
         *     hour: '%H:%M',
         *     day: '%e. %b',
         *     week: '%e. %b',
         *     month: '%b \'%y',
         *     year: '%Y'
         * }
         * ```
         *
         * @sample {highcharts} highcharts/xaxis/datetimelabelformats/
         *         Different day format on X axis
         * @sample {highstock} stock/xaxis/datetimelabelformats/
         *         More information in x axis labels
         *
         * @declare Highcharts.AxisDateTimeLabelFormatsOptions
         * @product highcharts highstock gantt
         */
        dateTimeLabelFormats: {
          /**
           * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
           * @type {string|*}
           */
          millisecond: {
            main: "%H:%M:%S.%L",
            range: false
          },
          /**
           * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
           * @type {string|*}
           */
          second: {
            main: "%H:%M:%S",
            range: false
          },
          /**
           * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
           * @type {string|*}
           */
          minute: {
            main: "%H:%M",
            range: false
          },
          /**
           * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
           * @type {string|*}
           */
          hour: {
            main: "%H:%M",
            range: false
          },
          /**
           * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
           * @type {string|*}
           */
          day: {
            main: "%e. %b"
          },
          /**
           * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
           * @type {string|*}
           */
          week: {
            main: "%e. %b"
          },
          /**
           * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
           * @type {string|*}
           */
          month: {
            main: "%b '%y"
          },
          /**
           * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
           * @type {string|*}
           */
          year: {
            main: "%Y"
          }
        },
        /**
         * Whether to force the axis to end on a tick. Use this option with
         * the `maxPadding` option to control the axis end.
         *
         * @productdesc {highstock}
         * In Highcharts Stock, `endOnTick` is always `false` when the navigator
         * is enabled, to prevent jumpy scrolling.
         *
         * @sample {highcharts} highcharts/chart/reflow-true/
         *         True by default
         * @sample {highcharts} highcharts/yaxis/endontick/
         *         False
         * @sample {highstock} stock/demo/basic-line/
         *         True by default
         * @sample {highstock} stock/xaxis/endontick/
         *         False
         *
         * @since 1.2.0
         */
        endOnTick: false,
        /**
         * Event handlers for the axis.
         *
         * @type      {*}
         * @apioption xAxis.events
         */
        /**
         * An event fired after the breaks have rendered.
         *
         * @see [breaks](#xAxis.breaks)
         *
         * @sample {highcharts} highcharts/axisbreak/break-event/
         *         AfterBreak Event
         *
         * @type      {Highcharts.AxisEventCallbackFunction}
         * @since     4.1.0
         * @product   highcharts gantt
         * @apioption xAxis.events.afterBreaks
         */
        /**
         * As opposed to the `setExtremes` event, this event fires after the
         * final min and max values are computed and corrected for `minRange`.
         *
         * Fires when the minimum and maximum is set for the axis, either by
         * calling the `.setExtremes()` method or by selecting an area in the
         * chart. One parameter, `event`, is passed to the function, containing
         * common event information.
         *
         * The new user set minimum and maximum values can be found by
         * `event.min` and `event.max`. These reflect the axis minimum and
         * maximum in axis values. The actual data extremes are found in
         * `event.dataMin` and `event.dataMax`.
         *
         * @type      {Highcharts.AxisSetExtremesEventCallbackFunction}
         * @since     2.3
         * @context   Highcharts.Axis
         * @apioption xAxis.events.afterSetExtremes
         */
        /**
         * An event fired when a break from this axis occurs on a point.
         *
         * @see [breaks](#xAxis.breaks)
         *
         * @sample {highcharts} highcharts/axisbreak/break-visualized/
         *         Visualization of a Break
         *
         * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
         * @since     4.1.0
         * @product   highcharts gantt
         * @context   Highcharts.Axis
         * @apioption xAxis.events.pointBreak
         */
        /**
         * An event fired when a point falls inside a break from this axis.
         *
         * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
         * @product   highcharts highstock gantt
         * @context   Highcharts.Axis
         * @apioption xAxis.events.pointInBreak
         */
        /**
         * Fires when the minimum and maximum is set for the axis, either by
         * calling the `.setExtremes()` method or by selecting an area in the
         * chart. One parameter, `event`, is passed to the function,
         * containing common event information.
         *
         * The new user set minimum and maximum values can be found by
         * `event.min` and `event.max`. These reflect the axis minimum and
         * maximum in data values. When an axis is zoomed all the way out from
         * the "Reset zoom" button, `event.min` and `event.max` are null, and
         * the new extremes are set based on `this.dataMin` and `this.dataMax`.
         *
         * @sample {highstock} stock/xaxis/events-setextremes/
         *         Log new extremes on x axis
         *
         * @type      {Highcharts.AxisSetExtremesEventCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Axis
         * @apioption xAxis.events.setExtremes
         */
        /**
         * The lowest allowed value for automatically computed axis extremes.
         *
         * @see [ceiling](#yAxis.ceiling)
         *
         * @sample {highcharts} highcharts/yaxis/floor-ceiling/
         *         Floor and ceiling
         * @sample {highstock} stock/demo/lazy-loading/
         *         Prevent negative stock price on Y axis
         *
         * @type      {number}
         * @since     4.0
         * @product   highcharts highstock gantt
         * @apioption xAxis.floor
         */
        /**
         * The dash or dot style of the grid lines. For possible values, see
         * [this demonstration](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/).
         *
         * @sample {highcharts} highcharts/yaxis/gridlinedashstyle/
         *         Long dashes
         * @sample {highstock} stock/xaxis/gridlinedashstyle/
         *         Long dashes
         *
         * @type      {Highcharts.DashStyleValue}
         * @since     1.2
         */
        gridLineDashStyle: "Solid",
        /**
         * The Z index of the grid lines.
         *
         * @sample {highcharts|highstock} highcharts/xaxis/gridzindex/
         *         A Z index of 4 renders the grid above the graph
         *
         * @product   highcharts highstock gantt
         */
        gridZIndex: 1,
        /**
         * An id for the axis. This can be used after render time to get
         * a pointer to the axis object through `chart.get()`.
         *
         * @sample {highcharts} highcharts/xaxis/id/
         *         Get the object
         * @sample {highstock} stock/xaxis/id/
         *         Get the object
         *
         * @type      {string}
         * @since     1.2.0
         * @apioption xAxis.id
         */
        /**
         * The axis labels show the number or category for each tick.
         *
         * Since v8.0.0: Labels are animated in categorized x-axis with
         * updating data if `tickInterval` and `step` is set to 1.
         *
         * @productdesc {highmaps}
         * X and Y axis labels are by default disabled in Highmaps, but the
         * functionality is inherited from Highcharts and used on `colorAxis`,
         * and can be enabled on X and Y axes too.
         */
        labels: {
          /**
           * What part of the string the given position is anchored to.
           * If `left`, the left side of the string is at the axis position.
           * Can be one of `"left"`, `"center"` or `"right"`. Defaults to
           * an intelligent guess based on which side of the chart the axis
           * is on and the rotation of the label.
           *
           * @see [reserveSpace](#xAxis.labels.reserveSpace)
           *
           * @sample {highcharts} highcharts/xaxis/labels-align-left/
           *         Left
           * @sample {highcharts} highcharts/xaxis/labels-align-right/
           *         Right
           * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
           *         Left-aligned labels on a vertical category axis
           *
           * @type       {Highcharts.AlignValue}
           * @apioption  xAxis.labels.align
           */
          /**
           * Whether to allow the axis labels to overlap.
           * When false, overlapping labels are hidden.
           *
           * @sample {highcharts} highcharts/xaxis/labels-allowoverlap-true/
           *         X axis labels overlap enabled
           *
           * @type {boolean}
           * @default false
           * @apioption xAxis.labels.allowOverlap
           *
           */
          /**
           * For horizontal axes, the allowed degrees of label rotation
           * to prevent overlapping labels. If there is enough space,
           * labels are not rotated. As the chart gets narrower, it
           * will start rotating the labels -45 degrees, then remove
           * every second label and try again with rotations 0 and -45 etc.
           * Set it to `undefined` to disable rotation, which will
           * cause the labels to word-wrap if possible. Defaults to `[-45]``
           * on bottom and top axes, `undefined` on left and right axes.
           *
           * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-default/
           *         Default auto rotation of 0 or -45
           * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-0-90/
           *         Custom graded auto rotation
           *
           * @type      {Array<number>}
           * @default   undefined
           * @since     4.1.0
           * @product   highcharts highstock gantt
           * @apioption xAxis.labels.autoRotation
           */
          autoRotation: void 0,
          /**
           * When each category width is more than this many pixels, we don't
           * apply auto rotation. Instead, we lay out the axis label with word
           * wrap. A lower limit makes sense when the label contains multiple
           * short words that don't extend the available horizontal space for
           * each label.
           *
           * @sample {highcharts} highcharts/xaxis/labels-autorotationlimit/
           *         Lower limit
           *
           * @since     4.1.5
           * @product   highcharts gantt
           */
          autoRotationLimit: 80,
          /**
           * Polar charts only. The label's pixel distance from the perimeter
           * of the plot area.
           *
           * @type      {number}
           * @default   undefined
           * @product   highcharts gantt
           */
          distance: void 0,
          /**
           * Enable or disable the axis labels.
           *
           * @sample {highcharts} highcharts/xaxis/labels-enabled/
           *         X axis labels disabled
           * @sample {highstock} stock/xaxis/labels-enabled/
           *         X axis labels disabled
           *
           * @default {highcharts|highstock|gantt} true
           * @default {highmaps} false
           */
          enabled: true,
          /**
           * A format string for the axis label. The context is available as
           * format string variables. For example, you can use `{text}` to
           * insert the default formatted text. The recommended way of adding
           * units for the label is using `text`, for example `{text} km`.
           *
           * To add custom numeric or datetime formatting, use `{value}` with
           * formatting, for example `{value:.1f}` or `{value:%Y-%m-%d}`.
           *
           * See
           * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
           * for more examples of formatting.
           *
           * The default value is not specified due to the dynamic
           * nature of the default implementation.
           *
           * @sample {highcharts|highstock} highcharts/yaxis/labels-format/
           *         Add units to Y axis label
           * @sample {highcharts} highcharts/xaxis/labels-format-linked/
           *         Linked category names
           * @sample {highcharts} highcharts/xaxis/labels-format-custom/
           *         Custom number format
           *
           * @type      {string}
           * @since     3.0
           * @apioption xAxis.labels.format
           */
          /**
           * Callback JavaScript function to format the label. The value
           * is given by `this.value`. Additional properties for `this` are
           * `axis`, `chart`, `isFirst`, `isLast` and `text` which holds the
           * value of the default formatter.
           *
           * Defaults to a built in function returning a formatted string
           * depending on whether the axis is `category`, `datetime`,
           * `numeric` or other.
           *
           * @sample {highcharts} highcharts/xaxis/labels-formatter-linked/
           *         Linked category names
           * @sample {highcharts} highcharts/xaxis/labels-formatter-extended/
           *         Modified numeric labels
           * @sample {highstock} stock/xaxis/labels-formatter/
           *         Added units on Y axis
           *
           * @type      {Highcharts.AxisLabelsFormatterCallbackFunction}
           * @apioption xAxis.labels.formatter
           */
          /**
           * The number of pixels to indent the labels per level in a treegrid
           * axis.
           *
           * @sample gantt/treegrid-axis/demo
           *         Indentation 10px by default.
           * @sample gantt/treegrid-axis/indentation-0px
           *         Indentation set to 0px.
           *
           * @product gantt
           */
          indentation: 10,
          /**
           * Horizontal axis only. When `staggerLines` is not set,
           * `maxStaggerLines` defines how many lines the axis is allowed to
           * add to automatically avoid overlapping X labels. Set to `1` to
           * disable overlap detection.
           *
           * @deprecated
           * @type      {number}
           * @default   5
           * @since     1.3.3
           * @apioption xAxis.labels.maxStaggerLines
           */
          /**
           * How to handle overflowing labels on horizontal axis. If set to
           * `"allow"`, it will not be aligned at all. By default it
           * `"justify"` labels inside the chart area. If there is room to
           * move it, it will be aligned to the edge, else it will be removed.
           *
           * @since      2.2.5
           * @validvalue ["allow", "justify"]
           */
          overflow: "justify",
          /**
           * The pixel padding for axis labels, to ensure white space between
           * them.
           *
           * @product   highcharts gantt
           */
          padding: 5,
          /**
           * Whether to reserve space for the labels. By default, space is
           * reserved for the labels in these cases:
           *
           * * On all horizontal axes.
           * * On vertical axes if `label.align` is `right` on a left-side
           * axis or `left` on a right-side axis.
           * * On vertical axes if `label.align` is `center`.
           *
           * This can be turned off when for example the labels are rendered
           * inside the plot area instead of outside.
           *
           * @see [labels.align](#xAxis.labels.align)
           *
           * @sample {highcharts} highcharts/xaxis/labels-reservespace/
           *         No reserved space, labels inside plot
           * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
           *         Left-aligned labels on a vertical category axis
           *
           * @type      {boolean}
           * @since     4.1.10
           * @product   highcharts gantt
           * @apioption xAxis.labels.reserveSpace
           */
          reserveSpace: void 0,
          /**
           * Rotation of the labels in degrees. When `undefined`, the
           * `autoRotation` option takes precedence.
           *
           * @sample {highcharts} highcharts/xaxis/labels-rotation/
           *         X axis labels rotated 90
           *
           * @type      {number}
           * @default   0
           * @apioption xAxis.labels.rotation
           */
          rotation: void 0,
          /**
           * Horizontal axes only. The number of lines to spread the labels
           * over to make room or tighter labels. 0 disables staggering.
           *
           * @sample {highcharts} highcharts/xaxis/labels-staggerlines/
           *         Show labels over two lines
           * @sample {highstock} stock/xaxis/labels-staggerlines/
           *         Show labels over two lines
           *
           * @since     2.1
           */
          staggerLines: 0,
          /**
           * To show only every _n_'th label on the axis, set the step to _n_.
           * Setting the step to 2 shows every other label.
           *
           * By default, when 0, the step is calculated automatically to avoid
           * overlap. To prevent this, set it to 1\. This usually only
           * happens on a category axis, and is often a sign that you have
           * chosen the wrong axis type.
           *
           * Read more at
           * [Axis docs](https://www.highcharts.com/docs/chart-concepts/axes)
           * => What axis should I use?
           *
           * @sample {highcharts} highcharts/xaxis/labels-step/
           *         Showing only every other axis label on a categorized
           *         x-axis
           * @sample {highcharts} highcharts/xaxis/labels-step-auto/
           *         Auto steps on a category axis
           *
           * @since     2.1
           */
          step: 0,
          /**
           * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
           * to render the labels.
           */
          useHTML: false,
          /**
           * The x position offset of all labels relative to the tick
           * positions on the axis.
           *
           * @sample {highcharts} highcharts/xaxis/labels-x/
           *         Y axis labels placed on grid lines
           */
          x: 0,
          /**
           * The y position offset of all labels relative to the tick
           * positions on the axis. The default makes it adapt to the font
           * size of the bottom axis.
           *
           * @sample {highcharts} highcharts/xaxis/labels-x/
           *         Y axis labels placed on grid lines
           *
           * @type      {number}
           * @apioption xAxis.labels.y
           */
          /**
           * The Z index for the axis labels.
           */
          zIndex: 7,
          /**
           * CSS styles for the label. Use `whiteSpace: 'nowrap'` to prevent
           * wrapping of category labels. Use `textOverflow: 'none'` to
           * prevent ellipsis (dots).
           *
           * In styled mode, the labels are styled with the
           * `.highcharts-axis-labels` class.
           *
           * @sample {highcharts} highcharts/xaxis/labels-style/
           *         Red X axis labels
           *
           * @type      {Highcharts.CSSObject}
           */
          style: {
            /** @internal */
            color: palette.neutralColor60,
            /** @internal */
            cursor: "default",
            /** @internal */
            fontSize: "11px"
          }
        },
        /**
         * The left position as the horizontal axis. If it's a number, it is
         * interpreted as pixel position relative to the chart.
         *
         * Since Highcharts v5.0.13: If it's a percentage string, it is
         * interpreted as percentages of the plot width, offset from plot area
         * left.
         *
         * @type      {number|string}
         * @product   highcharts highstock
         * @apioption xAxis.left
         */
        /**
         * The top position as the vertical axis. If it's a number, it is
         * interpreted as pixel position relative to the chart.
         *
         * Since Highcharts 2: If it's a percentage string, it is interpreted
         * as percentages of the plot height, offset from plot area top.
         *
         * @type      {number|string}
         * @product   highcharts highstock
         * @apioption xAxis.top
         */
        /**
         * Index of another axis that this axis is linked to. When an axis is
         * linked to a master axis, it will take the same extremes as
         * the master, but as assigned by min or max or by setExtremes.
         * It can be used to show additional info, or to ease reading the
         * chart by duplicating the scales.
         *
         * @sample {highcharts} highcharts/xaxis/linkedto/
         *         Different string formats of the same date
         * @sample {highcharts} highcharts/yaxis/linkedto/
         *         Y values on both sides
         *
         * @type      {number}
         * @since     2.0.2
         * @product   highcharts highstock gantt
         * @apioption xAxis.linkedTo
         */
        /**
         * The maximum value of the axis. If `null`, the max value is
         * automatically calculated.
         *
         * If the [endOnTick](#yAxis.endOnTick) option is true, the `max` value
         * might be rounded up.
         *
         * If a [tickAmount](#yAxis.tickAmount) is set, the axis may be extended
         * beyond the set max in order to reach the given number of ticks. The
         * same may happen in a chart with multiple axes, determined by [chart.
         * alignTicks](#chart), where a `tickAmount` is applied internally.
         *
         * @sample {highcharts} highcharts/yaxis/max-200/
         *         Y axis max of 200
         * @sample {highcharts} highcharts/yaxis/max-logarithmic/
         *         Y axis max on logarithmic axis
         * @sample {highstock} stock/xaxis/min-max/
         *         Fixed min and max on X axis
         * @sample {highmaps} maps/axis/min-max/
         *         Pre-zoomed to a specific area
         *
         * @type      {number|null}
         * @apioption xAxis.max
         */
        /**
         * Padding of the max value relative to the length of the axis. A
         * padding of 0.05 will make a 100px axis 5px longer. This is useful
         * when you don't want the highest data value to appear on the edge
         * of the plot area. When the axis' `max` option is set or a max extreme
         * is set using `axis.setExtremes()`, the maxPadding will be ignored.
         *
         * @productdesc {highstock}
         * For an [ordinal](#xAxis.ordinal) axis, `minPadding` and `maxPadding`
         * are ignored. Use [overscroll](#xAxis.overscroll) instead.
         *
         * @sample {highcharts} highcharts/yaxis/maxpadding/
         *         Max padding of 0.25 on y axis
         * @sample {highstock} stock/xaxis/minpadding-maxpadding/
         *         Greater min- and maxPadding
         * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
         *         Add some padding
         *
         * @default   {highcharts} 0.01
         * @default   {highstock|highmaps} 0
         * @since     1.2.0
         */
        maxPadding: 0.01,
        /**
         * Deprecated. Use `minRange` instead.
         *
         * @deprecated
         * @type      {number}
         * @product   highcharts highstock
         * @apioption xAxis.maxZoom
         */
        /**
         * The minimum value of the axis. If `null` the min value is
         * automatically calculated.
         *
         * If the [startOnTick](#yAxis.startOnTick) option is true (default),
         * the `min` value might be rounded down.
         *
         * The automatically calculated minimum value is also affected by
         * [floor](#yAxis.floor), [softMin](#yAxis.softMin),
         * [minPadding](#yAxis.minPadding), [minRange](#yAxis.minRange)
         * as well as [series.threshold](#plotOptions.series.threshold)
         * and [series.softThreshold](#plotOptions.series.softThreshold).
         *
         * @sample {highcharts} highcharts/yaxis/min-startontick-false/
         *         -50 with startOnTick to false
         * @sample {highcharts} highcharts/yaxis/min-startontick-true/
         *         -50 with startOnTick true by default
         * @sample {highstock} stock/xaxis/min-max/
         *         Set min and max on X axis
         * @sample {highmaps} maps/axis/min-max/
         *         Pre-zoomed to a specific area
         *
         * @type      {number|null}
         * @apioption xAxis.min
         */
        /**
         * The dash or dot style of the minor grid lines. For possible values,
         * see [this demonstration](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/).
         *
         * @sample {highcharts} highcharts/yaxis/minorgridlinedashstyle/
         *         Long dashes on minor grid lines
         * @sample {highstock} stock/xaxis/minorgridlinedashstyle/
         *         Long dashes on minor grid lines
         *
         * @type      {Highcharts.DashStyleValue}
         * @since     1.2
         */
        minorGridLineDashStyle: "Solid",
        /**
         * Specific tick interval in axis units for the minor ticks. On a linear
         * axis, if `"auto"`, the minor tick interval is calculated as a fifth
         * of the tickInterval. If `null` or `undefined`, minor ticks are not
         * shown.
         *
         * On logarithmic axes, the unit is the power of the value. For example,
         * setting the minorTickInterval to 1 puts one tick on each of 0.1, 1,
         * 10, 100 etc. Setting the minorTickInterval to 0.1 produces 9 ticks
         * between 1 and 10, 10 and 100 etc.
         *
         * If user settings dictate minor ticks to become too dense, they don't
         * make sense, and will be ignored to prevent performance problems.
         *
         * @sample {highcharts} highcharts/yaxis/minortickinterval-null/
         *         Null by default
         * @sample {highcharts} highcharts/yaxis/minortickinterval-5/
         *         5 units
         * @sample {highcharts} highcharts/yaxis/minortickinterval-log-auto/
         *         "auto"
         * @sample {highcharts} highcharts/yaxis/minortickinterval-log/
         *         0.1
         * @sample {highstock} stock/demo/basic-line/
         *         Null by default
         * @sample {highstock} stock/xaxis/minortickinterval-auto/
         *         "auto"
         *
         * @type      {number|string|null}
         * @apioption xAxis.minorTickInterval
         */
        /**
         * The pixel length of the minor tick marks.
         *
         * @sample {highcharts} highcharts/yaxis/minorticklength/
         *         10px on Y axis
         * @sample {highstock} stock/xaxis/minorticks/
         *         10px on Y axis
         */
        minorTickLength: 2,
        /**
         * The position of the minor tick marks relative to the axis line.
         *  Can be one of `inside` and `outside`.
         *
         * @sample {highcharts} highcharts/yaxis/minortickposition-outside/
         *         Outside by default
         * @sample {highcharts} highcharts/yaxis/minortickposition-inside/
         *         Inside
         * @sample {highstock} stock/xaxis/minorticks/
         *         Inside
         *
         * @validvalue ["inside", "outside"]
         */
        minorTickPosition: "outside",
        /**
         * Enable or disable minor ticks. Unless
         * [minorTickInterval](#xAxis.minorTickInterval) is set, the tick
         * interval is calculated as a fifth of the `tickInterval`.
         *
         * On a logarithmic axis, minor ticks are laid out based on a best
         * guess, attempting to enter approximately 5 minor ticks between
         * each major tick.
         *
         * Prior to v6.0.0, ticks were unabled in auto layout by setting
         * `minorTickInterval` to `"auto"`.
         *
         * @productdesc {highcharts}
         * On axes using [categories](#xAxis.categories), minor ticks are not
         * supported.
         *
         * @sample {highcharts} highcharts/yaxis/minorticks-true/
         *         Enabled on linear Y axis
         *
         * @type      {boolean}
         * @default   false
         * @since     6.0.0
         * @apioption xAxis.minorTicks
         */
        /**
         * The pixel width of the minor tick mark.
         *
         * @sample {highcharts} highcharts/yaxis/minortickwidth/
         *         3px width
         * @sample {highstock} stock/xaxis/minorticks/
         *         1px width
         *
         * @type      {number}
         * @default   0
         * @apioption xAxis.minorTickWidth
         */
        /**
         * Padding of the min value relative to the length of the axis. A
         * padding of 0.05 will make a 100px axis 5px longer. This is useful
         * when you don't want the lowest data value to appear on the edge
         * of the plot area. When the axis' `min` option is set or a min extreme
         * is set using `axis.setExtremes()`, the minPadding will be ignored.
         *
         * @productdesc {highstock}
         * For an [ordinal](#xAxis.ordinal) axis, `minPadding` and `maxPadding`
         * are ignored. Use [overscroll](#xAxis.overscroll) instead.
         *
         * @sample {highcharts} highcharts/yaxis/minpadding/
         *         Min padding of 0.2
         * @sample {highstock} stock/xaxis/minpadding-maxpadding/
         *         Greater min- and maxPadding
         * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
         *         Add some padding
         *
         * @default    {highcharts} 0.01
         * @default    {highstock|highmaps} 0
         * @since      1.2.0
         * @product    highcharts highstock gantt
         */
        minPadding: 0.01,
        /**
         * The minimum range to display on this axis. The entire axis will not
         * be allowed to span over a smaller interval than this. For example,
         * for a datetime axis the main unit is milliseconds. If minRange is
         * set to 3600000, you can't zoom in more than to one hour.
         *
         * The default minRange for the x axis is five times the smallest
         * interval between any of the data points.
         *
         * On a logarithmic axis, the unit for the minimum range is the power.
         * So a minRange of 1 means that the axis can be zoomed to 10-100,
         * 100-1000, 1000-10000 etc.
         *
         * **Note**: The `minPadding`, `maxPadding`, `startOnTick` and
         * `endOnTick` settings also affect how the extremes of the axis
         * are computed.
         *
         * @sample {highcharts} highcharts/xaxis/minrange/
         *         Minimum range of 5
         * @sample {highstock} stock/xaxis/minrange/
         *         Max zoom of 6 months overrides user selections
         * @sample {highmaps} maps/axis/minrange/
         *         Minimum range of 1000
         *
         * @type      {number}
         * @apioption xAxis.minRange
         */
        /**
         * The minimum tick interval allowed in axis values. For example on
         * zooming in on an axis with daily data, this can be used to prevent
         * the axis from showing hours. Defaults to the closest distance between
         * two points on the axis.
         *
         * @type      {number}
         * @since     2.3.0
         * @apioption xAxis.minTickInterval
         */
        /**
         * The distance in pixels from the plot area to the axis line.
         * A positive offset moves the axis with it's line, labels and ticks
         * away from the plot area. This is typically used when two or more
         * axes are displayed on the same side of the plot. With multiple
         * axes the offset is dynamically adjusted to avoid collision, this
         * can be overridden by setting offset explicitly.
         *
         * @sample {highcharts} highcharts/yaxis/offset/
         *         Y axis offset of 70
         * @sample {highcharts} highcharts/yaxis/offset-centered/
         *         Axes positioned in the center of the plot
         * @sample {highstock} stock/xaxis/offset/
         *         Y axis offset by 70 px
         *
         * @type {number}
         */
        offset: void 0,
        /**
         * Whether to display the axis on the opposite side of the normal. The
         * normal is on the left side for vertical axes and bottom for
         * horizontal, so the opposite sides will be right and top respectively.
         * This is typically used with dual or multiple axes.
         *
         * @sample {highcharts} highcharts/yaxis/opposite/
         *         Secondary Y axis opposite
         * @sample {highstock} stock/xaxis/opposite/
         *         Y axis on left side
         *
         * @default   {highcharts|highstock|highmaps} false
         * @default   {gantt} true
         */
        opposite: false,
        /**
         * In an ordinal axis, the points are equally spaced in the chart
         * regardless of the actual time or x distance between them. This means
         * that missing data periods (e.g. nights or weekends for a stock chart)
         * will not take up space in the chart.
         * Having `ordinal: false` will show any gaps created by the `gapSize`
         * setting proportionate to their duration.
         *
         * In stock charts the X axis is ordinal by default, unless
         * the boost module is used and at least one of the series' data length
         * exceeds the [boostThreshold](#series.line.boostThreshold).
         *
         * For an ordinal axis, `minPadding` and `maxPadding` are ignored. Use
         * [overscroll](#xAxis.overscroll) instead.
         *
         * @sample {highstock} stock/xaxis/ordinal-true/
         *         True by default
         * @sample {highstock} stock/xaxis/ordinal-false/
         *         False
         *
         * @see [overscroll](#xAxis.overscroll)
         *
         * @type      {boolean}
         * @default   true
         * @since     1.1
         * @product   highstock
         * @apioption xAxis.ordinal
         */
        /**
         * Additional range on the right side of the xAxis. Works similar to
         * `xAxis.maxPadding`, but value is set in milliseconds. Can be set for
         * both main `xAxis` and the navigator's `xAxis`.
         *
         * @sample {highstock} stock/xaxis/overscroll/
         *         One minute overscroll with live data
         *
         * @type      {number}
         * @default   0
         * @since     6.0.0
         * @product   highstock
         * @apioption xAxis.overscroll
         */
        /**
         * Refers to the index in the [panes](#panes) array. Used for circular
         * gauges and polar charts. When the option is not set then first pane
         * will be used.
         *
         * @sample highcharts/demo/gauge-vu-meter
         *         Two gauges with different center
         *
         * @type      {number}
         * @product   highcharts
         * @apioption xAxis.pane
         */
        /**
         * The zoomed range to display when only defining one or none of `min`
         * or `max`. For example, to show the latest month, a range of one month
         * can be set.
         *
         * @sample {highstock} stock/xaxis/range/
         *         Setting a zoomed range when the rangeSelector is disabled
         *
         * @type      {number}
         * @product   highstock
         * @apioption xAxis.range
         */
        /**
         * Whether to reverse the axis so that the highest number is closest
         * to the origin. If the chart is inverted, the x axis is reversed by
         * default.
         *
         * @sample {highcharts} highcharts/yaxis/reversed/
         *         Reversed Y axis
         * @sample {highstock} stock/xaxis/reversed/
         *         Reversed Y axis
         *
         * @type      {boolean}
         * @default   undefined
         * @apioption xAxis.reversed
         */
        reversed: void 0,
        /**
         * This option determines how stacks should be ordered within a group.
         * For example reversed xAxis also reverses stacks, so first series
         * comes last in a group. To keep order like for non-reversed xAxis
         * enable this option.
         *
         * @sample {highcharts} highcharts/xaxis/reversedstacks/
         *         Reversed stacks comparison
         * @sample {highstock} highcharts/xaxis/reversedstacks/
         *         Reversed stacks comparison
         *
         * @since     6.1.1
         * @product   highcharts highstock
         */
        reversedStacks: false,
        /**
         * An optional scrollbar to display on the X axis in response to
         * limiting the minimum and maximum of the axis values.
         *
         * In styled mode, all the presentational options for the scrollbar are
         * replaced by the classes `.highcharts-scrollbar-thumb`,
         * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
         * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
         *
         * @sample {highstock} stock/yaxis/heatmap-scrollbars/
         *         Heatmap with both scrollbars
         *
         * @extends   scrollbar
         * @since     4.2.6
         * @product   highstock
         * @apioption xAxis.scrollbar
         */
        /**
         * Whether to show the axis line and title when the axis has no data.
         *
         * @sample {highcharts} highcharts/yaxis/showempty/
         *         When clicking the legend to hide series, one axis preserves
         *         line and title, the other doesn't
         * @sample {highstock} highcharts/yaxis/showempty/
         *         When clicking the legend to hide series, one axis preserves
         *         line and title, the other doesn't
         *
         * @since     1.1
         */
        showEmpty: true,
        /**
         * Whether to show the first tick label.
         *
         * @sample {highcharts} highcharts/xaxis/showfirstlabel-false/
         *         Set to false on X axis
         * @sample {highstock} stock/xaxis/showfirstlabel/
         *         Labels below plot lines on Y axis
         */
        showFirstLabel: true,
        /**
         * Whether to show the last tick label. Defaults to `true` on cartesian
         * charts, and `false` on polar charts.
         *
         * @sample {highcharts} highcharts/xaxis/showlastlabel-true/
         *         Set to true on X axis
         * @sample {highstock} stock/xaxis/showfirstlabel/
         *         Labels below plot lines on Y axis
         *
         * @product   highcharts highstock gantt
         */
        showLastLabel: true,
        /**
         * A soft maximum for the axis. If the series data maximum is less than
         * this, the axis will stay at this maximum, but if the series data
         * maximum is higher, the axis will flex to show all data.
         *
         * @sample highcharts/yaxis/softmin-softmax/
         *         Soft min and max
         *
         * @type      {number}
         * @since     5.0.1
         * @product   highcharts highstock gantt
         * @apioption xAxis.softMax
         */
        /**
         * A soft minimum for the axis. If the series data minimum is greater
         * than this, the axis will stay at this minimum, but if the series
         * data minimum is lower, the axis will flex to show all data.
         *
         * @sample highcharts/yaxis/softmin-softmax/
         *         Soft min and max
         *
         * @type      {number}
         * @since     5.0.1
         * @product   highcharts highstock gantt
         * @apioption xAxis.softMin
         */
        /**
         * For datetime axes, this decides where to put the tick between weeks.
         *  0 = Sunday, 1 = Monday.
         *
         * @sample {highcharts} highcharts/xaxis/startofweek-monday/
         *         Monday by default
         * @sample {highcharts} highcharts/xaxis/startofweek-sunday/
         *         Sunday
         * @sample {highstock} stock/xaxis/startofweek-1
         *         Monday by default
         * @sample {highstock} stock/xaxis/startofweek-0
         *         Sunday
         *
         * @product highcharts highstock gantt
         */
        startOfWeek: 1,
        /**
         * Whether to force the axis to start on a tick. Use this option with
         * the `minPadding` option to control the axis start.
         *
         * @productdesc {highstock}
         * In Highcharts Stock, `startOnTick` is always `false` when
         * the navigator is enabled, to prevent jumpy scrolling.
         *
         * @sample {highcharts} highcharts/xaxis/startontick-false/
         *         False by default
         * @sample {highcharts} highcharts/xaxis/startontick-true/
         *         True
         *
         * @since 1.2.0
         */
        startOnTick: false,
        /**
         * The amount of ticks to draw on the axis. This opens up for aligning
         * the ticks of multiple charts or panes within a chart. This option
         * overrides the `tickPixelInterval` option.
         *
         * This option only has an effect on linear axes. Datetime, logarithmic
         * or category axes are not affected.
         *
         * @sample {highcharts} highcharts/yaxis/tickamount/
         *         8 ticks on Y axis
         * @sample {highstock} highcharts/yaxis/tickamount/
         *         8 ticks on Y axis
         *
         * @type      {number}
         * @since     4.1.0
         * @product   highcharts highstock gantt
         * @apioption xAxis.tickAmount
         */
        /**
         * The interval of the tick marks in axis units. When `undefined`, the
         * tick interval is computed to approximately follow the
         * [tickPixelInterval](#xAxis.tickPixelInterval) on linear and datetime
         * axes. On categorized axes, a `undefined` tickInterval will default to
         * 1, one category. Note that datetime axes are based on milliseconds,
         * so for example an interval of one day is expressed as
         * `24 * 3600 * 1000`.
         *
         * On logarithmic axes, the tickInterval is based on powers, so a
         * tickInterval of 1 means one tick on each of 0.1, 1, 10, 100 etc. A
         * tickInterval of 2 means a tick of 0.1, 10, 1000 etc. A tickInterval
         * of 0.2 puts a tick on 0.1, 0.2, 0.4, 0.6, 0.8, 1, 2, 4, 6, 8, 10, 20,
         * 40 etc.
         *
         *
         * If the tickInterval is too dense for labels to be drawn, Highcharts
         * may remove ticks.
         *
         * If the chart has multiple axes, the [alignTicks](#chart.alignTicks)
         * option may interfere with the `tickInterval` setting.
         *
         * @see [tickPixelInterval](#xAxis.tickPixelInterval)
         * @see [tickPositions](#xAxis.tickPositions)
         * @see [tickPositioner](#xAxis.tickPositioner)
         *
         * @sample {highcharts} highcharts/xaxis/tickinterval-5/
         *         Tick interval of 5 on a linear axis
         * @sample {highstock} stock/xaxis/tickinterval/
         *         Tick interval of 0.01 on Y axis
         *
         * @type      {number}
         * @apioption xAxis.tickInterval
         */
        /**
         * The pixel length of the main tick marks.
         *
         * @sample {highcharts} highcharts/xaxis/ticklength/
         *         20 px tick length on the X axis
         * @sample {highstock} stock/xaxis/ticks/
         *         Formatted ticks on X axis
         */
        tickLength: 10,
        /**
         * If tickInterval is `null` this option sets the approximate pixel
         * interval of the tick marks. Not applicable to categorized axis.
         *
         * The tick interval is also influenced by the [minTickInterval](
         * #xAxis.minTickInterval) option, that, by default prevents ticks from
         * being denser than the data points.
         *
         * @see [tickInterval](#xAxis.tickInterval)
         * @see [tickPositioner](#xAxis.tickPositioner)
         * @see [tickPositions](#xAxis.tickPositions)
         *
         * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/
         *         50 px on X axis
         * @sample {highstock} stock/xaxis/tickpixelinterval/
         *         200 px on X axis
         */
        tickPixelInterval: 100,
        /**
         * For categorized axes only. If `on` the tick mark is placed in the
         * center of the category, if `between` the tick mark is placed between
         * categories. The default is `between` if the `tickInterval` is 1, else
         * `on`.
         *
         * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/
         *         "between" by default
         * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/
         *         "on"
         *
         * @product    highcharts gantt
         * @validvalue ["on", "between"]
         */
        tickmarkPlacement: "between",
        /**
         * The position of the major tick marks relative to the axis line.
         * Can be one of `inside` and `outside`.
         *
         * @sample {highcharts} highcharts/xaxis/tickposition-outside/
         *         "outside" by default
         * @sample {highcharts} highcharts/xaxis/tickposition-inside/
         *         "inside"
         * @sample {highstock} stock/xaxis/ticks/
         *         Formatted ticks on X axis
         *
         * @validvalue ["inside", "outside"]
         */
        tickPosition: "outside",
        /**
         * A callback function returning array defining where the ticks are
         * laid out on the axis. This overrides the default behaviour of
         * [tickPixelInterval](#xAxis.tickPixelInterval) and [tickInterval](
         * #xAxis.tickInterval). The automatic tick positions are accessible
         * through `this.tickPositions` and can be modified by the callback.
         *
         * @see [tickPositions](#xAxis.tickPositions)
         *
         * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
         *         Demo of tickPositions and tickPositioner
         * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
         *         Demo of tickPositions and tickPositioner
         *
         * @type      {Highcharts.AxisTickPositionerCallbackFunction}
         * @apioption xAxis.tickPositioner
         */
        /**
         * An array defining where the ticks are laid out on the axis. This
         * overrides the default behaviour of [tickPixelInterval](
         * #xAxis.tickPixelInterval) and [tickInterval](#xAxis.tickInterval).
         *
         * @see [tickPositioner](#xAxis.tickPositioner)
         *
         * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
         *         Demo of tickPositions and tickPositioner
         * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
         *         Demo of tickPositions and tickPositioner
         *
         * @type      {Array<number>}
         * @apioption xAxis.tickPositions
         */
        /**
         * The pixel width of the major tick marks. Defaults to 0 on category
         * axes, otherwise 1.
         *
         * In styled mode, the stroke width is given in the `.highcharts-tick`
         * class, but in order for the element to be generated on category axes,
         * the option must be explicitly set to 1.
         *
         * @sample {highcharts} highcharts/xaxis/tickwidth/
         *         10 px width
         * @sample {highcharts} highcharts/css/axis-grid/
         *         Styled mode
         * @sample {highstock} stock/xaxis/ticks/
         *         Formatted ticks on X axis
         * @sample {highstock} highcharts/css/axis-grid/
         *         Styled mode
         *
         * @type      {undefined|number}
         * @default   {highstock} 1
         * @default   {highmaps} 0
         * @apioption xAxis.tickWidth
         */
        /**
         * The axis title, showing next to the axis line.
         *
         * @productdesc {highmaps}
         * In Highmaps, the axis is hidden by default, but adding an axis title
         * is still possible. X axis and Y axis titles will appear at the bottom
         * and left by default.
         */
        title: {
          /**
           * Alignment of the title relative to the axis values. Possible
           * values are "low", "middle" or "high".
           *
           * @sample {highcharts} highcharts/xaxis/title-align-low/
           *         "low"
           * @sample {highcharts} highcharts/xaxis/title-align-center/
           *         "middle" by default
           * @sample {highcharts} highcharts/xaxis/title-align-high/
           *         "high"
           * @sample {highcharts} highcharts/yaxis/title-offset/
           *         Place the Y axis title on top of the axis
           * @sample {highstock} stock/xaxis/title-align/
           *         Aligned to "high" value
           *
           * @type {Highcharts.AxisTitleAlignValue}
           */
          align: "middle",
          /**
           * Deprecated. Set the `text` to `undefined` to disable the title.
           *
           * @deprecated
           * @type      {boolean}
           * @product   highcharts
           * @apioption xAxis.title.enabled
           */
          /**
           * The pixel distance between the axis labels or line and the title.
           * Defaults to 0 for horizontal axes, 10 for vertical
           *
           * @sample {highcharts} highcharts/xaxis/title-margin/
           *         Y axis title margin of 60
           *
           * @type      {number}
           * @apioption xAxis.title.margin
           */
          /**
           * The distance of the axis title from the axis line. By default,
           * this distance is computed from the offset width of the labels,
           * the labels' distance from the axis and the title's margin.
           * However when the offset option is set, it overrides all this.
           *
           * @sample {highcharts} highcharts/yaxis/title-offset/
           *         Place the axis title on top of the axis
           * @sample {highstock} highcharts/yaxis/title-offset/
           *         Place the axis title on top of the Y axis
           *
           * @type      {number}
           * @since     2.2.0
           * @apioption xAxis.title.offset
           */
          /**
           * Whether to reserve space for the title when laying out the axis.
           *
           * @type      {boolean}
           * @default   true
           * @since     5.0.11
           * @product   highcharts highstock gantt
           * @apioption xAxis.title.reserveSpace
           */
          /**
           * The rotation of the text in degrees. 0 is horizontal, 270 is
           * vertical reading from bottom to top.
           *
           * @sample {highcharts} highcharts/yaxis/title-offset/
           *         Horizontal
           */
          rotation: 0,
          /**
           * The actual text of the axis title. It can contain basic HTML tags
           * like `b`, `i` and `span` with style.
           *
           * @sample {highcharts} highcharts/xaxis/title-text/
           *         Custom HTML
           * @sample {highstock} stock/xaxis/title-text/
           *         Titles for both axes
           *
           * @type      {string|null}
           * @apioption xAxis.title.text
           */
          /**
           * Alignment of the text, can be `"left"`, `"right"` or `"center"`.
           * Default alignment depends on the
           * [title.align](xAxis.title.align):
           *
           * Horizontal axes:
           * - for `align` = `"low"`, `textAlign` is set to `left`
           * - for `align` = `"middle"`, `textAlign` is set to `center`
           * - for `align` = `"high"`, `textAlign` is set to `right`
           *
           * Vertical axes:
           * - for `align` = `"low"` and `opposite` = `true`, `textAlign` is
           *   set to `right`
           * - for `align` = `"low"` and `opposite` = `false`, `textAlign` is
           *   set to `left`
           * - for `align` = `"middle"`, `textAlign` is set to `center`
           * - for `align` = `"high"` and `opposite` = `true` `textAlign` is
           *   set to `left`
           * - for `align` = `"high"` and `opposite` = `false` `textAlign` is
           *   set to `right`
           *
           * @type      {Highcharts.AlignValue}
           * @apioption xAxis.title.textAlign
           */
          /**
           * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
           * to render the axis title.
           *
           * @product   highcharts highstock gantt
           */
          useHTML: false,
          /**
           * Horizontal pixel offset of the title position.
           *
           * @since     4.1.6
           * @product   highcharts highstock gantt
           */
          x: 0,
          /**
           * Vertical pixel offset of the title position.
           *
           * @product   highcharts highstock gantt
           */
          y: 0,
          /**
           * CSS styles for the title. If the title text is longer than the
           * axis length, it will wrap to multiple lines by default. This can
           * be customized by setting `textOverflow: 'ellipsis'`, by
           * setting a specific `width` or by setting `whiteSpace: 'nowrap'`.
           *
           * In styled mode, the stroke width is given in the
           * `.highcharts-axis-title` class.
           *
           * @sample {highcharts} highcharts/xaxis/title-style/
           *         Red
           * @sample {highcharts} highcharts/css/axis/
           *         Styled mode
           *
           * @type    {Highcharts.CSSObject}
           */
          style: {
            /** @internal */
            color: palette.neutralColor60
          }
        },
        /**
         * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`
         * or `category`. In a datetime axis, the numbers are given in
         * milliseconds, and tick marks are placed on appropriate values like
         * full hours or days. In a category axis, the
         * [point names](#series.line.data.name) of the chart's series are used
         * for categories, if not a [categories](#xAxis.categories) array is
         * defined.
         *
         * @sample {highcharts} highcharts/xaxis/type-linear/
         *         Linear
         * @sample {highcharts} highcharts/yaxis/type-log/
         *         Logarithmic
         * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
         *         Logarithmic with minor grid lines
         * @sample {highcharts} highcharts/xaxis/type-log-both/
         *         Logarithmic on two axes
         * @sample {highcharts} highcharts/yaxis/type-log-negative/
         *         Logarithmic with extension to emulate negative values
         *
         * @type    {Highcharts.AxisTypeValue}
         * @product highcharts gantt
         */
        type: "linear",
        /**
         * If there are multiple axes on the same side of the chart, the pixel
         * margin between the axes. Defaults to 0 on vertical axes, 15 on
         * horizontal axes.
         *
         * @type      {number}
         * @since     7.0.3
         * @apioption xAxis.margin
         */
        /**
         * Applies only when the axis `type` is `category`. When `uniqueNames`
         * is true, points are placed on the X axis according to their names.
         * If the same point name is repeated in the same or another series,
         * the point is placed on the same X position as other points of the
         * same name. When `uniqueNames` is false, the points are laid out in
         * increasing X positions regardless of their names, and the X axis
         * category will take the name of the last point in each position.
         *
         * @sample {highcharts} highcharts/xaxis/uniquenames-true/
         *         True by default
         * @sample {highcharts} highcharts/xaxis/uniquenames-false/
         *         False
         *
         * @since     4.2.7
         * @product   highcharts gantt
         */
        uniqueNames: true,
        /**
         * Datetime axis only. An array determining what time intervals the
         * ticks are allowed to fall on. Each array item is an array where the
         * first value is the time unit and the second value another array of
         * allowed multiples.
         *
         * Defaults to:
         * ```js
         * units: [[
         *     'millisecond', // unit name
         *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
         * ], [
         *     'second',
         *     [1, 2, 5, 10, 15, 30]
         * ], [
         *     'minute',
         *     [1, 2, 5, 10, 15, 30]
         * ], [
         *     'hour',
         *     [1, 2, 3, 4, 6, 8, 12]
         * ], [
         *     'day',
         *     [1, 2]
         * ], [
         *     'week',
         *     [1, 2]
         * ], [
         *     'month',
         *     [1, 2, 3, 4, 6]
         * ], [
         *     'year',
         *     null
         * ]]
         * ```
         *
         * @type      {Array<Array<string,(Array<number>|null)>>}
         * @product   highcharts highstock gantt
         * @apioption xAxis.units
         */
        /**
         * Whether axis, including axis title, line, ticks and labels, should
         * be visible.
         *
         * @since     4.1.9
         * @product   highcharts highstock gantt
         */
        visible: true,
        /**
         * Color of the minor, secondary grid lines.
         *
         * In styled mode, the stroke width is given in the
         * `.highcharts-minor-grid-line` class.
         *
         * @sample {highcharts} highcharts/yaxis/minorgridlinecolor/
         *         Bright grey lines from Y axis
         * @sample {highcharts|highstock} highcharts/css/axis-grid/
         *         Styled mode
         * @sample {highstock} stock/xaxis/minorgridlinecolor/
         *         Bright grey lines from Y axis
         *
         * @type    {Highcharts.ColorType}
         * @default #f2f2f2
         */
        minorGridLineColor: palette.neutralColor5,
        /**
         * Width of the minor, secondary grid lines.
         *
         * In styled mode, the stroke width is given in the
         * `.highcharts-grid-line` class.
         *
         * @sample {highcharts} highcharts/yaxis/minorgridlinewidth/
         *         2px lines from Y axis
         * @sample {highcharts|highstock} highcharts/css/axis-grid/
         *         Styled mode
         * @sample {highstock} stock/xaxis/minorgridlinewidth/
         *         2px lines from Y axis
         */
        minorGridLineWidth: 1,
        /**
         * Color for the minor tick marks.
         *
         * @sample {highcharts} highcharts/yaxis/minortickcolor/
         *         Black tick marks on Y axis
         * @sample {highstock} stock/xaxis/minorticks/
         *         Black tick marks on Y axis
         *
         * @type    {Highcharts.ColorType}
         * @default #999999
         */
        minorTickColor: palette.neutralColor40,
        /**
         * The color of the line marking the axis itself.
         *
         * In styled mode, the line stroke is given in the
         * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
         *
         * @productdesc {highmaps}
         * In Highmaps, the axis line is hidden by default, because the axis is
         * not visible by default.
         *
         * @sample {highcharts} highcharts/yaxis/linecolor/
         *         A red line on Y axis
         * @sample {highcharts|highstock} highcharts/css/axis/
         *         Axes in styled mode
         * @sample {highstock} stock/xaxis/linecolor/
         *         A red line on X axis
         *
         * @type    {Highcharts.ColorType}
         * @default #ccd6eb
         */
        lineColor: palette.highlightColor20,
        /**
         * The width of the line marking the axis itself.
         *
         * In styled mode, the stroke width is given in the
         * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
         *
         * @sample {highcharts} highcharts/yaxis/linecolor/
         *         A 1px line on Y axis
         * @sample {highcharts|highstock} highcharts/css/axis/
         *         Axes in styled mode
         * @sample {highstock} stock/xaxis/linewidth/
         *         A 2px line on X axis
         *
         * @default {highcharts|highstock} 1
         * @default {highmaps} 0
         */
        lineWidth: 1,
        /**
         * Color of the grid lines extending the ticks across the plot area.
         *
         * In styled mode, the stroke is given in the `.highcharts-grid-line`
         * class.
         *
         * @productdesc {highmaps}
         * In Highmaps, the grid lines are hidden by default.
         *
         * @sample {highcharts} highcharts/yaxis/gridlinecolor/
         *         Green lines
         * @sample {highcharts|highstock} highcharts/css/axis-grid/
         *         Styled mode
         * @sample {highstock} stock/xaxis/gridlinecolor/
         *         Green lines
         *
         * @type    {Highcharts.ColorType}
         * @default #e6e6e6
         */
        gridLineColor: palette.neutralColor10,
        /**
         * The width of the grid lines extending the ticks across the plot area.
         * Defaults to 1 on the Y axis and 0 on the X axis, except for 3d
         * charts.
         *
         * In styled mode, the stroke width is given in the
         * `.highcharts-grid-line` class.
         *
         * @sample {highcharts} highcharts/yaxis/gridlinewidth/
         *         2px lines
         * @sample {highcharts|highstock} highcharts/css/axis-grid/
         *         Styled mode
         * @sample {highstock} stock/xaxis/gridlinewidth/
         *         2px lines
         *
         * @type      {number}
         * @apioption xAxis.gridLineWidth
         */
        gridLineWidth: void 0,
        /**
         * The height as the vertical axis. If it's a number, it is
         * interpreted as pixels.
         *
         * Since Highcharts 2: If it's a percentage string, it is interpreted
         * as percentages of the total plot height.
         *
         * @type      {number|string}
         * @product   highcharts highstock
         * @apioption xAxis.height
         */
        /**
         * The width as the horizontal axis. If it's a number, it is interpreted
         * as pixels.
         *
         * Since Highcharts v5.0.13: If it's a percentage string, it is
         * interpreted as percentages of the total plot width.
         *
         * @type      {number|string}
         * @product   highcharts highstock
         * @apioption xAxis.width
         */
        /**
         * Color for the main tick marks.
         *
         * In styled mode, the stroke is given in the `.highcharts-tick`
         * class.
         *
         * @sample {highcharts} highcharts/xaxis/tickcolor/
         *         Red ticks on X axis
         * @sample {highcharts|highstock} highcharts/css/axis-grid/
         *         Styled mode
         * @sample {highstock} stock/xaxis/ticks/
         *         Formatted ticks on X axis
         *
         * @type    {Highcharts.ColorType}
         * @default #ccd6eb
         */
        tickColor: palette.highlightColor20
        // tickWidth: 1
      };
      AxisDefaults2.defaultYAxisOptions = {
        /**
         * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`,
         * `category` or `treegrid`. Defaults to `treegrid` for Gantt charts,
         * `linear` for other chart types.
         *
         * In a datetime axis, the numbers are given in milliseconds, and tick
         * marks are placed on appropriate values, like full hours or days. In a
         * category or treegrid axis, the [point names](#series.line.data.name)
         * of the chart's series are used for categories, if a
         * [categories](#xAxis.categories) array is not defined.
         *
         * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
         *         Logarithmic with minor grid lines
         * @sample {highcharts} highcharts/yaxis/type-log-negative/
         *         Logarithmic with extension to emulate negative values
         * @sample {gantt} gantt/treegrid-axis/demo
         *         Treegrid axis
         *
         * @type      {Highcharts.AxisTypeValue}
         * @default   {highcharts} linear
         * @default   {gantt} treegrid
         * @product   highcharts gantt
         * @apioption yAxis.type
         */
        /**
         * The height of the Y axis. If it's a number, it is interpreted as
         * pixels.
         *
         * Since Highcharts 2: If it's a percentage string, it is interpreted as
         * percentages of the total plot height.
         *
         * @see [yAxis.top](#yAxis.top)
         *
         * @sample {highstock} stock/demo/candlestick-and-volume/
         *         Percentage height panes
         *
         * @type      {number|string}
         * @product   highcharts highstock
         * @apioption yAxis.height
         */
        /**
         * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
         * to represent the maximum value of the Y axis.
         *
         * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
         *         Min and max colors
         *
         * @type      {Highcharts.ColorType}
         * @default   #003399
         * @since     4.0
         * @product   highcharts
         * @apioption yAxis.maxColor
         */
        /**
         * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
         * to represent the minimum value of the Y axis.
         *
         * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
         *         Min and max color
         *
         * @type      {Highcharts.ColorType}
         * @default   #e6ebf5
         * @since     4.0
         * @product   highcharts
         * @apioption yAxis.minColor
         */
        /**
         * Whether to reverse the axis so that the highest number is closest
         * to the origin.
         *
         * @sample {highcharts} highcharts/yaxis/reversed/
         *         Reversed Y axis
         * @sample {highstock} stock/xaxis/reversed/
         *         Reversed Y axis
         *
         * @type      {boolean}
         * @default   {highcharts} false
         * @default   {highstock} false
         * @default   {highmaps} true
         * @default   {gantt} true
         * @apioption yAxis.reversed
         */
        /**
         * If `true`, the first series in a stack will be drawn on top in a
         * positive, non-reversed Y axis. If `false`, the first series is in
         * the base of the stack.
         *
         * @sample {highcharts} highcharts/yaxis/reversedstacks-false/
         *         Non-reversed stacks
         * @sample {highstock} highcharts/yaxis/reversedstacks-false/
         *         Non-reversed stacks
         *
         * @type      {boolean}
         * @default   true
         * @since     3.0.10
         * @product   highcharts highstock
         * @apioption yAxis.reversedStacks
         */
        reversedStacks: true,
        /**
         * Solid gauge series only. Color stops for the solid gauge. Use this
         * in cases where a linear gradient between a `minColor` and `maxColor`
         * is not sufficient. The stops is an array of tuples, where the first
         * item is a float between 0 and 1 assigning the relative position in
         * the gradient, and the second item is the color.
         *
         * For solid gauges, the Y axis also inherits the concept of
         * [data classes](https://api.highcharts.com/highmaps#colorAxis.dataClasses)
         * from the Highmaps color axis.
         *
         * @see [minColor](#yAxis.minColor)
         * @see [maxColor](#yAxis.maxColor)
         *
         * @sample {highcharts} highcharts/demo/gauge-solid/
         *         True by default
         *
         * @type      {Array<Array<number,Highcharts.ColorType>>}
         * @since     4.0
         * @product   highcharts
         * @apioption yAxis.stops
         */
        /**
         * The pixel width of the major tick marks.
         *
         * @sample {highcharts} highcharts/xaxis/tickwidth/ 10 px width
         * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
         *
         * @type      {number}
         * @default   0
         * @product   highcharts highstock gantt
         * @apioption yAxis.tickWidth
         */
        /**
         * Whether to force the axis to end on a tick. Use this option with
         * the `maxPadding` option to control the axis end.
         *
         * This option is always disabled, when panning type is
         * either `y` or `xy`.
         *
         * @see [type](#chart.panning.type)
         *
         *
         * @sample {highcharts} highcharts/chart/reflow-true/
         *         True by default
         * @sample {highcharts} highcharts/yaxis/endontick/
         *         False
         * @sample {highstock} stock/demo/basic-line/
         *         True by default
         * @sample {highstock} stock/xaxis/endontick/
         *         False for Y axis
         *
         * @since 1.2.0
         */
        endOnTick: true,
        /**
         * Padding of the max value relative to the length of the axis. A
         * padding of 0.05 will make a 100px axis 5px longer. This is useful
         * when you don't want the highest data value to appear on the edge
         * of the plot area. When the axis' `max` option is set or a max extreme
         * is set using `axis.setExtremes()`, the maxPadding will be ignored.
         *
         * Also the `softThreshold` option takes precedence over `maxPadding`,
         * so if the data is tangent to the threshold, `maxPadding` may not
         * apply unless `softThreshold` is set to false.
         *
         * @sample {highcharts} highcharts/yaxis/maxpadding-02/
         *         Max padding of 0.2
         * @sample {highstock} stock/xaxis/minpadding-maxpadding/
         *         Greater min- and maxPadding
         *
         * @since   1.2.0
         * @product highcharts highstock gantt
         */
        maxPadding: 0.05,
        /**
         * Padding of the min value relative to the length of the axis. A
         * padding of 0.05 will make a 100px axis 5px longer. This is useful
         * when you don't want the lowest data value to appear on the edge
         * of the plot area. When the axis' `min` option is set or a max extreme
         * is set using `axis.setExtremes()`, the maxPadding will be ignored.
         *
         * Also the `softThreshold` option takes precedence over `minPadding`,
         * so if the data is tangent to the threshold, `minPadding` may not
         * apply unless `softThreshold` is set to false.
         *
         * @sample {highcharts} highcharts/yaxis/minpadding/
         *         Min padding of 0.2
         * @sample {highstock} stock/xaxis/minpadding-maxpadding/
         *         Greater min- and maxPadding
         *
         * @since   1.2.0
         * @product highcharts highstock gantt
         */
        minPadding: 0.05,
        /**
         * @productdesc {highstock}
         * In Highcharts Stock 1.x, the Y axis was placed
         * on the left side by default.
         *
         * @sample {highcharts} highcharts/yaxis/opposite/
         *         Secondary Y axis opposite
         * @sample {highstock} stock/xaxis/opposite/
         *         Y axis on left side
         *
         * @type      {boolean}
         * @default   {highstock} true
         * @default   {highcharts} false
         * @product   highstock highcharts gantt
         * @apioption yAxis.opposite
         */
        /**
         * @see [tickInterval](#xAxis.tickInterval)
         * @see [tickPositioner](#xAxis.tickPositioner)
         * @see [tickPositions](#xAxis.tickPositions)
         */
        tickPixelInterval: 72,
        showLastLabel: true,
        /**
         * @extends xAxis.labels
         */
        labels: {
          /**
           * Angular gauges and solid gauges only.
           * The label's pixel distance from the perimeter of the plot area.
           *
           * Since v7.1.2: If it's a percentage string, it is interpreted the
           * same as [series.radius](#plotOptions.gauge.radius), so label can be
           * aligned under the gauge's shape.
           *
           * @sample {highcharts} highcharts/yaxis/labels-distance/
           *         Labels centered under the arc
           *
           * @type      {number|string}
           * @default   -25
           * @product   highcharts
           * @apioption yAxis.labels.distance
           */
          /**
           * The y position offset of all labels relative to the tick
           * positions on the axis. For polar and radial axis consider the use
           * of the [distance](#yAxis.labels.distance) option.
           *
           * @sample {highcharts} highcharts/xaxis/labels-x/
           *         Y axis labels placed on grid lines
           *
           * @type      {number}
           * @default   {highcharts} 3
           * @default   {highstock} -2
           * @default   {highmaps} 3
           * @apioption yAxis.labels.y
           */
          /**
           * What part of the string the given position is anchored to. Can
           * be one of `"left"`, `"center"` or `"right"`. The exact position
           * also depends on the `labels.x` setting.
           *
           * Angular gauges and solid gauges defaults to `"center"`.
           * Solid gauges with two labels have additional option `"auto"`
           * for automatic horizontal and vertical alignment.
           *
           * @see [yAxis.labels.distance](#yAxis.labels.distance)
           *
           * @sample {highcharts} highcharts/yaxis/labels-align-left/
           *         Left
           * @sample {highcharts} highcharts/series-solidgauge/labels-auto-aligned/
           *         Solid gauge labels auto aligned
           *
           * @type       {Highcharts.AlignValue}
           * @default    {highcharts|highmaps} right
           * @default    {highstock} left
           * @apioption  yAxis.labels.align
           */
          /**
           * The x position offset of all labels relative to the tick
           * positions on the axis. Defaults to -15 for left axis, 15 for
           * right axis.
           *
           * @sample {highcharts} highcharts/xaxis/labels-x/
           *         Y axis labels placed on grid lines
           */
          x: -8
        },
        /**
         * @productdesc {highmaps}
         * In Highmaps, the axis line is hidden by default, because the axis is
         * not visible by default.
         *
         * @type      {Highcharts.ColorType}
         * @apioption yAxis.lineColor
         */
        /**
         * @sample {highcharts} highcharts/yaxis/max-200/
         *         Y axis max of 200
         * @sample {highcharts} highcharts/yaxis/max-logarithmic/
         *         Y axis max on logarithmic axis
         * @sample {highstock} stock/yaxis/min-max/
         *         Fixed min and max on Y axis
         * @sample {highmaps} maps/axis/min-max/
         *         Pre-zoomed to a specific area
         *
         * @apioption yAxis.max
         */
        /**
         * @sample {highcharts} highcharts/yaxis/min-startontick-false/
         *         -50 with startOnTick to false
         * @sample {highcharts} highcharts/yaxis/min-startontick-true/
         *         -50 with startOnTick true by default
         * @sample {highstock} stock/yaxis/min-max/
         *         Fixed min and max on Y axis
         * @sample {highmaps} maps/axis/min-max/
         *         Pre-zoomed to a specific area
         *
         * @apioption yAxis.min
         */
        /**
         * An optional scrollbar to display on the Y axis in response to
         * limiting the minimum an maximum of the axis values.
         *
         * In styled mode, all the presentational options for the scrollbar
         * are replaced by the classes `.highcharts-scrollbar-thumb`,
         * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
         * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
         *
         * @sample {highstock} stock/yaxis/scrollbar/
         *         Scrollbar on the Y axis
         *
         * @extends   scrollbar
         * @since     4.2.6
         * @product   highstock
         * @excluding height
         * @apioption yAxis.scrollbar
         */
        /**
         * Enable the scrollbar on the Y axis.
         *
         * @sample {highstock} stock/yaxis/scrollbar/
         *         Enabled on Y axis
         *
         * @type      {boolean}
         * @default   false
         * @since     4.2.6
         * @product   highstock
         * @apioption yAxis.scrollbar.enabled
         */
        /**
         * Pixel margin between the scrollbar and the axis elements.
         *
         * @type      {number}
         * @default   10
         * @since     4.2.6
         * @product   highstock
         * @apioption yAxis.scrollbar.margin
         */
        /**
         * Whether to show the scrollbar when it is fully zoomed out at max
         * range. Setting it to `false` on the Y axis makes the scrollbar stay
         * hidden until the user zooms in, like common in browsers.
         *
         * @type      {boolean}
         * @default   true
         * @since     4.2.6
         * @product   highstock
         * @apioption yAxis.scrollbar.showFull
         */
        /**
         * The width of a vertical scrollbar or height of a horizontal
         * scrollbar. Defaults to 20 on touch devices.
         *
         * @type      {number}
         * @default   14
         * @since     4.2.6
         * @product   highstock
         * @apioption yAxis.scrollbar.size
         */
        /**
         * Z index of the scrollbar elements.
         *
         * @type      {number}
         * @default   3
         * @since     4.2.6
         * @product   highstock
         * @apioption yAxis.scrollbar.zIndex
         */
        /**
         * A soft maximum for the axis. If the series data maximum is less
         * than this, the axis will stay at this maximum, but if the series
         * data maximum is higher, the axis will flex to show all data.
         *
         * **Note**: The [series.softThreshold](
         * #plotOptions.series.softThreshold) option takes precedence over this
         * option.
         *
         * @sample highcharts/yaxis/softmin-softmax/
         *         Soft min and max
         *
         * @type      {number}
         * @since     5.0.1
         * @product   highcharts highstock gantt
         * @apioption yAxis.softMax
         */
        /**
         * A soft minimum for the axis. If the series data minimum is greater
         * than this, the axis will stay at this minimum, but if the series
         * data minimum is lower, the axis will flex to show all data.
         *
         * **Note**: The [series.softThreshold](
         * #plotOptions.series.softThreshold) option takes precedence over this
         * option.
         *
         * @sample highcharts/yaxis/softmin-softmax/
         *         Soft min and max
         *
         * @type      {number}
         * @since     5.0.1
         * @product   highcharts highstock gantt
         * @apioption yAxis.softMin
         */
        /**
         * Defines the horizontal alignment of the stack total label. Can be one
         * of `"left"`, `"center"` or `"right"`. The default value is calculated
         * at runtime and depends on orientation and whether the stack is
         * positive or negative.
         *
         * @sample {highcharts} highcharts/yaxis/stacklabels-align-left/
         *         Aligned to the left
         * @sample {highcharts} highcharts/yaxis/stacklabels-align-center/
         *         Aligned in center
         * @sample {highcharts} highcharts/yaxis/stacklabels-align-right/
         *         Aligned to the right
         *
         * @type      {Highcharts.AlignValue}
         * @since     2.1.5
         * @product   highcharts
         * @apioption yAxis.stackLabels.align
         */
        /**
         * A format string for the data label. Available variables are the same
         * as for `formatter`.
         *
         * @type      {string}
         * @default   {total}
         * @since     3.0.2
         * @product   highcharts highstock
         * @apioption yAxis.stackLabels.format
         */
        /**
         * Rotation of the labels in degrees.
         *
         * @sample {highcharts} highcharts/yaxis/stacklabels-rotation/
         *         Labels rotated 45
         *
         * @type      {number}
         * @default   0
         * @since     2.1.5
         * @product   highcharts
         * @apioption yAxis.stackLabels.rotation
         */
        /**
         * The text alignment for the label. While `align` determines where the
         * texts anchor point is placed with regards to the stack, `textAlign`
         * determines how the text is aligned against its anchor point. Possible
         * values are `"left"`, `"center"` and `"right"`. The default value is
         * calculated at runtime and depends on orientation and whether the
         * stack is positive or negative.
         *
         * @sample {highcharts} highcharts/yaxis/stacklabels-textalign-left/
         *         Label in center position but text-aligned left
         *
         * @type      {Highcharts.AlignValue}
         * @since     2.1.5
         * @product   highcharts
         * @apioption yAxis.stackLabels.textAlign
         */
        /**
         * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
         * to render the labels.
         *
         * @type      {boolean}
         * @default   false
         * @since     3.0
         * @product   highcharts highstock
         * @apioption yAxis.stackLabels.useHTML
         */
        /**
         * Defines the vertical alignment of the stack total label. Can be one
         * of `"top"`, `"middle"` or `"bottom"`. The default value is calculated
         * at runtime and depends on orientation and whether the stack is
         * positive or negative.
         *
         * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-top/
         *         Vertically aligned top
         * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-middle/
         *         Vertically aligned middle
         * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-bottom/
         *         Vertically aligned bottom
         *
         * @type      {Highcharts.VerticalAlignValue}
         * @since     2.1.5
         * @product   highcharts
         * @apioption yAxis.stackLabels.verticalAlign
         */
        /**
         * The x position offset of the label relative to the left of the
         * stacked bar. The default value is calculated at runtime and depends
         * on orientation and whether the stack is positive or negative.
         *
         * @sample {highcharts} highcharts/yaxis/stacklabels-x/
         *         Stack total labels with x offset
         *
         * @type      {number}
         * @since     2.1.5
         * @product   highcharts
         * @apioption yAxis.stackLabels.x
         */
        /**
         * The y position offset of the label relative to the tick position
         * on the axis. The default value is calculated at runtime and depends
         * on orientation and whether the stack is positive or negative.
         *
         * @sample {highcharts} highcharts/yaxis/stacklabels-y/
         *         Stack total labels with y offset
         *
         * @type      {number}
         * @since     2.1.5
         * @product   highcharts
         * @apioption yAxis.stackLabels.y
         */
        /**
         * Whether to force the axis to start on a tick. Use this option with
         * the `maxPadding` option to control the axis start.
         *
         * This option is always disabled, when panning type is
         * either `y` or `xy`.
         *
         * @see [type](#chart.panning.type)
         *
         * @sample {highcharts} highcharts/xaxis/startontick-false/
         *         False by default
         * @sample {highcharts} highcharts/xaxis/startontick-true/
         *         True
         * @sample {highstock} stock/xaxis/endontick/
         *         False for Y axis
         *
         * @since   1.2.0
         * @product highcharts highstock gantt
         */
        startOnTick: true,
        title: {
          /**
           * The pixel distance between the axis labels and the title.
           * Positive values are outside the axis line, negative are inside.
           *
           * @sample {highcharts} highcharts/xaxis/title-margin/
           *         Y axis title margin of 60
           *
           * @type      {number}
           * @default   40
           * @apioption yAxis.title.margin
           */
          /**
           * The rotation of the text in degrees. 0 is horizontal, 270 is
           * vertical reading from bottom to top.
           *
           * @sample {highcharts} highcharts/yaxis/title-offset/
           *         Horizontal
           */
          rotation: 270,
          /**
           * The actual text of the axis title. Horizontal texts can contain
           * HTML, but rotated texts are painted using vector techniques and
           * must be clean text. The Y axis title is disabled by setting the
           * `text` option to `undefined`.
           *
           * @sample {highcharts} highcharts/xaxis/title-text/
           *         Custom HTML
           *
           * @type    {string|null}
           * @default {highcharts} Values
           * @default {highstock} undefined
           * @product highcharts highstock gantt
           */
          text: "Values"
        },
        /**
         * The top position of the Y axis. If it's a number, it is interpreted
         * as pixel position relative to the chart.
         *
         * Since Highcharts 2: If it's a percentage string, it is interpreted as
         * percentages of the plot height, offset from plot area top.
         *
         * @see [yAxis.height](#yAxis.height)
         *
         * @sample {highstock} stock/demo/candlestick-and-volume/
         *         Percentage height panes
         *
         * @type      {number|string}
         * @product   highcharts highstock
         * @apioption yAxis.top
         */
        /**
         * The stack labels show the total value for each bar in a stacked
         * column or bar chart. The label will be placed on top of positive
         * columns and below negative columns. In case of an inverted column
         * chart or a bar chart the label is placed to the right of positive
         * bars and to the left of negative bars.
         *
         * @product highcharts
         */
        stackLabels: {
          /**
           * Enable or disable the initial animation when a series is
           * displayed for the `stackLabels`. The animation can also be set as
           * a configuration object. Please note that this option only
           * applies to the initial animation.
           * For other animations, see [chart.animation](#chart.animation)
           * and the animation parameter under the API methods.
           * The following properties are supported:
           *
           * - `defer`: The animation delay time in milliseconds.
           *
           * @sample {highcharts} highcharts/plotoptions/animation-defer/
           *          Animation defer settings
           * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
           * @since 8.2.0
           * @apioption yAxis.stackLabels.animation
           */
          animation: {},
          /**
           * The animation delay time in milliseconds.
           * Set to `0` renders stackLabel immediately.
           * As `undefined` inherits defer time from the [series.animation.defer](#plotOptions.series.animation.defer).
           *
           * @type      {number}
           * @since 8.2.0
           * @apioption yAxis.stackLabels.animation.defer
           */
          /**
           * Allow the stack labels to overlap.
           *
           * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/
           *         Default false
           *
           * @since   5.0.13
           * @product highcharts
           */
          allowOverlap: false,
          /**
           * The background color or gradient for the stack label.
           *
           * @sample {highcharts} highcharts/yaxis/stacklabels-box/
           *          Stack labels box options
           * @type      {Highcharts.ColorType}
           * @since 8.1.0
           * @apioption yAxis.stackLabels.backgroundColor
           */
          /**
           * The border color for the stack label. Defaults to `undefined`.
           *
           * @sample {highcharts} highcharts/yaxis/stacklabels-box/
           *          Stack labels box options
           * @type      {Highcharts.ColorType}
           * @since 8.1.0
           * @apioption yAxis.stackLabels.borderColor
           */
          /**
           * The border radius in pixels for the stack label.
           *
           * @sample {highcharts} highcharts/yaxis/stacklabels-box/
           *          Stack labels box options
           * @type      {number}
           * @default   0
           * @since 8.1.0
           * @apioption yAxis.stackLabels.borderRadius
           */
          /**
           * The border width in pixels for the stack label.
           *
           * @sample {highcharts} highcharts/yaxis/stacklabels-box/
           *          Stack labels box options
           * @type      {number}
           * @default   0
           * @since 8.1.0
           * @apioption yAxis.stackLabels.borderWidth
           */
          /**
           * Enable or disable the stack total labels.
           *
           * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/
           *         Enabled stack total labels
           * @sample {highcharts} highcharts/yaxis/stacklabels-enabled-waterfall/
           *         Enabled stack labels in waterfall chart
           *
           * @since   2.1.5
           * @product highcharts
           */
          enabled: false,
          /**
           * Whether to hide stack labels that are outside the plot area.
           * By default, the stack label is moved
           * inside the plot area according to the
           * [overflow](/highcharts/#yAxis/stackLabels/overflow)
           * option.
           *
           * @type  {boolean}
           * @since 7.1.3
           */
          crop: true,
          /**
           * How to handle stack total labels that flow outside the plot area.
           * The default is set to `"justify"`,
           * which aligns them inside the plot area.
           * For columns and bars, this means it will be moved inside the bar.
           * To display stack labels outside the plot area,
           * set `crop` to `false` and `overflow` to `"allow"`.
           *
           * @sample highcharts/yaxis/stacklabels-overflow/
           *         Stack labels flows outside the plot area.
           *
           * @type  {Highcharts.DataLabelsOverflowValue}
           * @since 7.1.3
           */
          overflow: "justify",
          /* eslint-disable valid-jsdoc */
          /**
           * Callback JavaScript function to format the label. The value is
           * given by `this.total`.
           *
           * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/
           *         Added units to stack total value
           *
           * @type    {Highcharts.FormatterCallbackFunction<Highcharts.StackItemObject>}
           * @since   2.1.5
           * @product highcharts
           */
          formatter: function() {
            var numberFormatter = this.axis.chart.numberFormatter;
            return numberFormatter(this.total, -1);
          },
          /**
           * CSS styles for the label.
           *
           * In styled mode, the styles are set in the
           * `.highcharts-stack-label` class.
           *
           * @sample {highcharts} highcharts/yaxis/stacklabels-style/
           *         Red stack total labels
           *
           * @type    {Highcharts.CSSObject}
           * @since   2.1.5
           * @product highcharts
           */
          style: {
            /** @internal */
            color: palette.neutralColor100,
            /** @internal */
            fontSize: "11px",
            /** @internal */
            fontWeight: "bold",
            /** @internal */
            textOutline: "1px contrast"
          }
        },
        gridLineWidth: 1,
        lineWidth: 0
        // tickWidth: 0
      };
      AxisDefaults2.defaultLeftAxisOptions = {
        labels: {
          x: -15
        },
        title: {
          rotation: 270
        }
      };
      AxisDefaults2.defaultRightAxisOptions = {
        labels: {
          x: 15
        },
        title: {
          rotation: 90
        }
      };
      AxisDefaults2.defaultBottomAxisOptions = {
        labels: {
          autoRotation: [-45],
          x: 0
          // overflow: undefined,
          // staggerLines: null
        },
        margin: 15,
        title: {
          rotation: 0
        }
      };
      AxisDefaults2.defaultTopAxisOptions = {
        labels: {
          autoRotation: [-45],
          x: 0
          // overflow: undefined
          // staggerLines: null
        },
        margin: 15,
        title: {
          rotation: 0
        }
      };
    })(AxisDefaults || (AxisDefaults = {}));
    const AxisDefaults$1 = AxisDefaults;
    var addEvent$$ = Utilities.addEvent, isFunction$3 = Utilities.isFunction, objectEach$u = Utilities.objectEach, removeEvent$a = Utilities.removeEvent;
    var registerEventOptions$3 = function(component, options) {
      component.eventOptions = component.eventOptions || {};
      objectEach$u(options.events, function(event, eventType) {
        if (component.eventOptions[eventType] !== event) {
          if (component.eventOptions[eventType]) {
            removeEvent$a(component, eventType, component.eventOptions[eventType]);
            delete component.eventOptions[eventType];
          }
          if (isFunction$3(event)) {
            component.eventOptions[eventType] = event;
            addEvent$$(component, eventType, event);
          }
        }
      });
    };
    var exports$3 = {
      registerEventOptions: registerEventOptions$3
    };
    var deg2rad$6 = H.deg2rad;
    var clamp$h = Utilities.clamp, correctFloat$c = Utilities.correctFloat, defined$O = Utilities.defined, destroyObjectProperties$8 = Utilities.destroyObjectProperties, extend$1j = Utilities.extend, fireEvent$z = Utilities.fireEvent, isNumber$I = Utilities.isNumber, merge$1h = Utilities.merge, objectEach$t = Utilities.objectEach, pick$1p = Utilities.pick;
    var Tick = (
      /** @class */
      function() {
        function Tick2(axis, pos, type, noLabel, parameters) {
          this.isNew = true;
          this.isNewLabel = true;
          this.axis = axis;
          this.pos = pos;
          this.type = type || "";
          this.parameters = parameters || {};
          this.tickmarkOffset = this.parameters.tickmarkOffset;
          this.options = this.parameters.options;
          fireEvent$z(this, "init");
          if (!type && !noLabel) {
            this.addLabel();
          }
        }
        Tick2.prototype.addLabel = function() {
          var tick = this, axis = tick.axis, options = axis.options, chart = axis.chart, categories = axis.categories, log = axis.logarithmic, names = axis.names, pos = tick.pos, labelOptions = pick$1p(tick.options && tick.options.labels, options.labels), tickPositions = axis.tickPositions, isFirst = pos === tickPositions[0], isLast = pos === tickPositions[tickPositions.length - 1], animateLabels = (!labelOptions.step || labelOptions.step === 1) && axis.tickInterval === 1, tickPositionInfo = tickPositions.info;
          var label = tick.label, dateTimeLabelFormat, dateTimeLabelFormats, i;
          var value = this.parameters.category || (categories ? pick$1p(categories[pos], names[pos], pos) : pos);
          if (log && isNumber$I(value)) {
            value = correctFloat$c(log.lin2log(value));
          }
          if (axis.dateTime) {
            if (tickPositionInfo) {
              dateTimeLabelFormats = chart.time.resolveDTLFormat(options.dateTimeLabelFormats[!options.grid && tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName]);
              dateTimeLabelFormat = dateTimeLabelFormats.main;
            } else if (isNumber$I(value)) {
              dateTimeLabelFormat = axis.dateTime.getXDateFormat(value, options.dateTimeLabelFormats || {});
            }
          }
          tick.isFirst = isFirst;
          tick.isLast = isLast;
          var ctx = {
            axis,
            chart,
            dateTimeLabelFormat,
            isFirst,
            isLast,
            pos,
            tick,
            tickPositionInfo,
            value
          };
          fireEvent$z(this, "labelFormat", ctx);
          var labelFormatter = function(ctx2) {
            if (labelOptions.formatter) {
              return labelOptions.formatter.call(ctx2, ctx2);
            }
            if (labelOptions.format) {
              ctx2.text = axis.defaultLabelFormatter.call(ctx2);
              return FormatUtilities.format(labelOptions.format, ctx2, chart);
            }
            return axis.defaultLabelFormatter.call(ctx2, ctx2);
          };
          var str = labelFormatter.call(ctx, ctx);
          var list = dateTimeLabelFormats && dateTimeLabelFormats.list;
          if (list) {
            tick.shortenLabel = function() {
              for (i = 0; i < list.length; i++) {
                extend$1j(ctx, { dateTimeLabelFormat: list[i] });
                label.attr({
                  text: labelFormatter.call(ctx, ctx)
                });
                if (label.getBBox().width < axis.getSlotWidth(tick) - 2 * labelOptions.padding) {
                  return;
                }
              }
              label.attr({
                text: ""
              });
            };
          } else {
            tick.shortenLabel = void 0;
          }
          if (animateLabels && axis._addedPlotLB) {
            tick.moveLabel(str, labelOptions);
          }
          if (!defined$O(label) && !tick.movedLabel) {
            tick.label = label = tick.createLabel({ x: 0, y: 0 }, str, labelOptions);
            tick.rotation = 0;
          } else if (label && label.textStr !== str && !animateLabels) {
            if (label.textWidth && !labelOptions.style.width && !label.styles.width) {
              label.css({ width: null });
            }
            label.attr({ text: str });
            label.textPxLength = label.getBBox().width;
          }
        };
        Tick2.prototype.createLabel = function(xy, str, labelOptions) {
          var axis = this.axis, chart = axis.chart, label = defined$O(str) && labelOptions.enabled ? chart.renderer.text(str, xy.x, xy.y, labelOptions.useHTML).add(axis.labelGroup) : null;
          if (label) {
            if (!chart.styledMode) {
              label.css(merge$1h(labelOptions.style));
            }
            label.textPxLength = label.getBBox().width;
          }
          return label;
        };
        Tick2.prototype.destroy = function() {
          destroyObjectProperties$8(this, this.axis);
        };
        Tick2.prototype.getPosition = function(horiz, tickPos, tickmarkOffset, old) {
          var axis = this.axis, chart = axis.chart, cHeight = old && chart.oldChartHeight || chart.chartHeight, pos = {
            x: horiz ? correctFloat$c(axis.translate(tickPos + tickmarkOffset, null, null, old) + axis.transB) : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),
            y: horiz ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : correctFloat$c(cHeight - axis.translate(tickPos + tickmarkOffset, null, null, old) - axis.transB)
          };
          pos.y = clamp$h(pos.y, -1e5, 1e5);
          fireEvent$z(this, "afterGetPosition", { pos });
          return pos;
        };
        Tick2.prototype.getLabelPosition = function(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
          var axis = this.axis, transA = axis.transA, reversed = (
            // #7911
            axis.isLinked && axis.linkedParent ? axis.linkedParent.reversed : axis.reversed
          ), staggerLines = axis.staggerLines, rotCorr = axis.tickRotCorr || { x: 0, y: 0 }, labelOffsetCorrection = !horiz && !axis.reserveSpaceDefault ? -axis.labelOffset * (axis.labelAlign === "center" ? 0.5 : 1) : 0, pos = {};
          var yOffset = labelOptions.y, line;
          if (!defined$O(yOffset)) {
            if (axis.side === 0) {
              yOffset = label.rotation ? -8 : -label.getBBox().height;
            } else if (axis.side === 2) {
              yOffset = rotCorr.y + 8;
            } else {
              yOffset = Math.cos(label.rotation * deg2rad$6) * (rotCorr.y - label.getBBox(false, 0).height / 2);
            }
          }
          x = x + labelOptions.x + labelOffsetCorrection + rotCorr.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
          y = y + yOffset - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
          if (staggerLines) {
            line = index / (step || 1) % staggerLines;
            if (axis.opposite) {
              line = staggerLines - line - 1;
            }
            y += line * (axis.labelOffset / staggerLines);
          }
          pos.x = x;
          pos.y = Math.round(y);
          fireEvent$z(this, "afterGetLabelPosition", { pos, tickmarkOffset, index });
          return pos;
        };
        Tick2.prototype.getLabelSize = function() {
          return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
        };
        Tick2.prototype.getMarkPath = function(x, y, tickLength, tickWidth, horiz, renderer) {
          return renderer.crispLine([[
            "M",
            x,
            y
          ], [
            "L",
            x + (horiz ? 0 : -tickLength),
            y + (horiz ? tickLength : 0)
          ]], tickWidth);
        };
        Tick2.prototype.handleOverflow = function(xy) {
          var tick = this, axis = this.axis, labelOptions = axis.options.labels, pxPos = xy.x, chartWidth = axis.chart.chartWidth, spacing = axis.chart.spacing, leftBound = pick$1p(axis.labelLeft, Math.min(axis.pos, spacing[3])), rightBound = pick$1p(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1])), label = this.label, rotation = this.rotation, factor = {
            left: 0,
            center: 0.5,
            right: 1
          }[axis.labelAlign || label.attr("align")], labelWidth = label.getBBox().width, slotWidth = axis.getSlotWidth(tick), xCorrection = factor, css2 = {};
          var modifiedSlotWidth = slotWidth, goRight = 1, leftPos, rightPos, textWidth;
          if (!rotation && labelOptions.overflow === "justify") {
            leftPos = pxPos - factor * labelWidth;
            rightPos = pxPos + (1 - factor) * labelWidth;
            if (leftPos < leftBound) {
              modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
            } else if (rightPos > rightBound) {
              modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
              goRight = -1;
            }
            modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth);
            if (modifiedSlotWidth < slotWidth && axis.labelAlign === "center") {
              xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));
            }
            if (labelWidth > modifiedSlotWidth || axis.autoRotation && (label.styles || {}).width) {
              textWidth = modifiedSlotWidth;
            }
          } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
            textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad$6) - leftBound);
          } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
            textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad$6));
          }
          if (textWidth) {
            if (tick.shortenLabel) {
              tick.shortenLabel();
            } else {
              css2.width = Math.floor(textWidth) + "px";
              if (!(labelOptions.style || {}).textOverflow) {
                css2.textOverflow = "ellipsis";
              }
              label.css(css2);
            }
          }
        };
        Tick2.prototype.moveLabel = function(str, labelOptions) {
          var tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed;
          var moved = false, labelPos, xPos, yPos;
          if (label && label.textStr === str) {
            tick.movedLabel = label;
            moved = true;
            delete tick.label;
          } else {
            objectEach$t(axis.ticks, function(currentTick) {
              if (!moved && !currentTick.isNew && currentTick !== tick && currentTick.label && currentTick.label.textStr === str) {
                tick.movedLabel = currentTick.label;
                moved = true;
                currentTick.labelPos = tick.movedLabel.xy;
                delete currentTick.label;
              }
            });
          }
          if (!moved && (tick.labelPos || label)) {
            labelPos = tick.labelPos || label.xy;
            xPos = axis.horiz ? reversed ? 0 : axis.width + axis.left : labelPos.x;
            yPos = axis.horiz ? labelPos.y : reversed ? axis.width + axis.left : 0;
            tick.movedLabel = tick.createLabel({ x: xPos, y: yPos }, str, labelOptions);
            if (tick.movedLabel) {
              tick.movedLabel.attr({ opacity: 0 });
            }
          }
        };
        Tick2.prototype.render = function(index, old, opacity) {
          var tick = this, axis = tick.axis, horiz = axis.horiz, pos = tick.pos, tickmarkOffset = pick$1p(tick.tickmarkOffset, axis.tickmarkOffset), xy = tick.getPosition(horiz, pos, tickmarkOffset, old), x = xy.x, y = xy.y, reverseCrisp = horiz && x === axis.pos + axis.len || !horiz && y === axis.pos ? -1 : 1;
          var labelOpacity = pick$1p(
            opacity,
            tick.label && tick.label.newOpacity,
            // #15528
            1
          );
          opacity = pick$1p(opacity, 1);
          this.isActive = true;
          this.renderGridLine(old, opacity, reverseCrisp);
          this.renderMark(xy, opacity, reverseCrisp);
          this.renderLabel(xy, old, labelOpacity, index);
          tick.isNew = false;
          fireEvent$z(this, "afterRender");
        };
        Tick2.prototype.renderGridLine = function(old, opacity, reverseCrisp) {
          var tick = this, axis = tick.axis, options = axis.options, attribs = {}, pos = tick.pos, type = tick.type, tickmarkOffset = pick$1p(tick.tickmarkOffset, axis.tickmarkOffset), renderer = axis.chart.renderer;
          var gridLine = tick.gridLine, gridLinePath, gridLineWidth = options.gridLineWidth, gridLineColor = options.gridLineColor, dashStyle = options.gridLineDashStyle;
          if (tick.type === "minor") {
            gridLineWidth = options.minorGridLineWidth;
            gridLineColor = options.minorGridLineColor;
            dashStyle = options.minorGridLineDashStyle;
          }
          if (!gridLine) {
            if (!axis.chart.styledMode) {
              attribs.stroke = gridLineColor;
              attribs["stroke-width"] = gridLineWidth || 0;
              attribs.dashstyle = dashStyle;
            }
            if (!type) {
              attribs.zIndex = 1;
            }
            if (old) {
              opacity = 0;
            }
            tick.gridLine = gridLine = renderer.path().attr(attribs).addClass("highcharts-" + (type ? type + "-" : "") + "grid-line").add(axis.gridGroup);
          }
          if (gridLine) {
            gridLinePath = axis.getPlotLinePath({
              value: pos + tickmarkOffset,
              lineWidth: gridLine.strokeWidth() * reverseCrisp,
              force: "pass",
              old
            });
            if (gridLinePath) {
              gridLine[old || tick.isNew ? "attr" : "animate"]({
                d: gridLinePath,
                opacity
              });
            }
          }
        };
        Tick2.prototype.renderMark = function(xy, opacity, reverseCrisp) {
          var tick = this, axis = tick.axis, options = axis.options, renderer = axis.chart.renderer, type = tick.type, tickSize = axis.tickSize(type ? type + "Tick" : "tick"), x = xy.x, y = xy.y, tickWidth = pick$1p(options[type !== "minor" ? "tickWidth" : "minorTickWidth"], !type && axis.isXAxis ? 1 : 0), tickColor = options[type !== "minor" ? "tickColor" : "minorTickColor"];
          var mark = tick.mark;
          var isNewMark = !mark;
          if (tickSize) {
            if (axis.opposite) {
              tickSize[0] = -tickSize[0];
            }
            if (!mark) {
              tick.mark = mark = renderer.path().addClass("highcharts-" + (type ? type + "-" : "") + "tick").add(axis.axisGroup);
              if (!axis.chart.styledMode) {
                mark.attr({
                  stroke: tickColor,
                  "stroke-width": tickWidth
                });
              }
            }
            mark[isNewMark ? "attr" : "animate"]({
              d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, axis.horiz, renderer),
              opacity
            });
          }
        };
        Tick2.prototype.renderLabel = function(xy, old, opacity, index) {
          var tick = this, axis = tick.axis, horiz = axis.horiz, options = axis.options, label = tick.label, labelOptions = options.labels, step = labelOptions.step, tickmarkOffset = pick$1p(tick.tickmarkOffset, axis.tickmarkOffset), x = xy.x, y = xy.y;
          var show = true;
          if (label && isNumber$I(x)) {
            label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
            if (tick.isFirst && !tick.isLast && !options.showFirstLabel || tick.isLast && !tick.isFirst && !options.showLastLabel) {
              show = false;
            } else if (horiz && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
              tick.handleOverflow(xy);
            }
            if (step && index % step) {
              show = false;
            }
            if (show && isNumber$I(xy.y)) {
              xy.opacity = opacity;
              label[tick.isNewLabel ? "attr" : "animate"](xy);
              tick.isNewLabel = false;
            } else {
              label.attr("y", -9999);
              tick.isNewLabel = true;
            }
          }
        };
        Tick2.prototype.replaceMovedLabel = function() {
          var tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed;
          var x, y;
          if (label && !tick.isNew) {
            x = axis.horiz ? reversed ? axis.left : axis.width + axis.left : label.xy.x;
            y = axis.horiz ? label.xy.y : reversed ? axis.width + axis.top : axis.top;
            label.animate({ x, y, opacity: 0 }, void 0, label.destroy);
            delete tick.label;
          }
          axis.isDirty = true;
          tick.label = tick.movedLabel;
          delete tick.movedLabel;
        };
        return Tick2;
      }()
    );
    var animObject$a = animationExports.animObject;
    var defaultOptions$e = DefaultOptions.defaultOptions;
    var registerEventOptions$2 = exports$3.registerEventOptions;
    var deg2rad$5 = H.deg2rad;
    var arrayMax$9 = Utilities.arrayMax, arrayMin$8 = Utilities.arrayMin, clamp$g = Utilities.clamp, correctFloat$b = Utilities.correctFloat, defined$N = Utilities.defined, destroyObjectProperties$7 = Utilities.destroyObjectProperties, erase$7 = Utilities.erase, error$7 = Utilities.error, extend$1i = Utilities.extend, fireEvent$y = Utilities.fireEvent, getMagnitude$2 = Utilities.getMagnitude, isArray$j = Utilities.isArray, isNumber$H = Utilities.isNumber, isString$7 = Utilities.isString, merge$1g = Utilities.merge, normalizeTickInterval$2 = Utilities.normalizeTickInterval, objectEach$s = Utilities.objectEach, pick$1o = Utilities.pick, relativeLength$9 = Utilities.relativeLength, removeEvent$9 = Utilities.removeEvent, splat$g = Utilities.splat, syncTimeout$7 = Utilities.syncTimeout;
    var Axis = (
      /** @class */
      function() {
        function Axis2(chart, userOptions) {
          this.alternateBands = void 0;
          this.bottom = void 0;
          this.categories = void 0;
          this.chart = void 0;
          this.closestPointRange = void 0;
          this.coll = void 0;
          this.eventOptions = void 0;
          this.hasNames = void 0;
          this.hasVisibleSeries = void 0;
          this.height = void 0;
          this.isLinked = void 0;
          this.labelEdge = void 0;
          this.labelFormatter = void 0;
          this.left = void 0;
          this.len = void 0;
          this.max = void 0;
          this.maxLabelLength = void 0;
          this.min = void 0;
          this.minorTickInterval = void 0;
          this.minorTicks = void 0;
          this.minPixelPadding = void 0;
          this.names = void 0;
          this.offset = void 0;
          this.options = void 0;
          this.overlap = void 0;
          this.paddedTicks = void 0;
          this.plotLinesAndBands = void 0;
          this.plotLinesAndBandsGroups = void 0;
          this.pointRange = void 0;
          this.pointRangePadding = void 0;
          this.pos = void 0;
          this.positiveValuesOnly = void 0;
          this.right = void 0;
          this.series = void 0;
          this.side = void 0;
          this.tickAmount = void 0;
          this.tickInterval = void 0;
          this.tickmarkOffset = void 0;
          this.tickPositions = void 0;
          this.tickRotCorr = void 0;
          this.ticks = void 0;
          this.top = void 0;
          this.transA = void 0;
          this.transB = void 0;
          this.translationSlope = void 0;
          this.userOptions = void 0;
          this.visible = void 0;
          this.width = void 0;
          this.zoomEnabled = void 0;
          this.init(chart, userOptions);
        }
        Axis2.prototype.init = function(chart, userOptions) {
          var isXAxis = userOptions.isX, axis = this;
          axis.chart = chart;
          axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis;
          axis.isXAxis = isXAxis;
          axis.coll = axis.coll || (isXAxis ? "xAxis" : "yAxis");
          fireEvent$y(this, "init", { userOptions });
          axis.opposite = pick$1o(userOptions.opposite, axis.opposite);
          axis.side = pick$1o(
            userOptions.side,
            axis.side,
            axis.horiz ? axis.opposite ? 0 : 2 : (
              // top : bottom
              axis.opposite ? 1 : 3
            )
            // right : left
          );
          axis.setOptions(userOptions);
          var options = this.options, labelsOptions = options.labels, type = options.type;
          axis.userOptions = userOptions;
          axis.minPixelPadding = 0;
          axis.reversed = pick$1o(options.reversed, axis.reversed);
          axis.visible = options.visible;
          axis.zoomEnabled = options.zoomEnabled;
          axis.hasNames = type === "category" || options.categories === true;
          axis.categories = options.categories || axis.hasNames;
          if (!axis.names) {
            axis.names = [];
            axis.names.keys = {};
          }
          axis.plotLinesAndBandsGroups = {};
          axis.positiveValuesOnly = !!axis.logarithmic;
          axis.isLinked = defined$N(options.linkedTo);
          axis.ticks = {};
          axis.labelEdge = [];
          axis.minorTicks = {};
          axis.plotLinesAndBands = [];
          axis.alternateBands = {};
          axis.len = 0;
          axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
          axis.range = options.range;
          axis.offset = options.offset || 0;
          axis.max = null;
          axis.min = null;
          var crosshair = pick$1o(options.crosshair, splat$g(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1]);
          axis.crosshair = crosshair === true ? {} : crosshair;
          if (chart.axes.indexOf(axis) === -1) {
            if (isXAxis) {
              chart.axes.splice(chart.xAxis.length, 0, axis);
            } else {
              chart.axes.push(axis);
            }
            chart[axis.coll].push(axis);
          }
          axis.series = axis.series || [];
          if (chart.inverted && !axis.isZAxis && isXAxis && typeof axis.reversed === "undefined") {
            axis.reversed = true;
          }
          axis.labelRotation = isNumber$H(labelsOptions.rotation) ? labelsOptions.rotation : void 0;
          registerEventOptions$2(axis, options);
          fireEvent$y(this, "afterInit");
        };
        Axis2.prototype.setOptions = function(userOptions) {
          this.options = merge$1g(AxisDefaults$1.defaultXAxisOptions, this.coll === "yAxis" && AxisDefaults$1.defaultYAxisOptions, [
            AxisDefaults$1.defaultTopAxisOptions,
            AxisDefaults$1.defaultRightAxisOptions,
            AxisDefaults$1.defaultBottomAxisOptions,
            AxisDefaults$1.defaultLeftAxisOptions
          ][this.side], merge$1g(
            // if set in setOptions (#1053):
            defaultOptions$e[this.coll],
            userOptions
          ));
          fireEvent$y(this, "afterSetOptions", { userOptions });
        };
        Axis2.prototype.defaultLabelFormatter = function(ctx) {
          var axis = this.axis, chart = this.chart, numberFormatter = chart.numberFormatter, value = isNumber$H(this.value) ? this.value : NaN, time = axis.chart.time, categories = axis.categories, dateTimeLabelFormat = this.dateTimeLabelFormat, lang2 = defaultOptions$e.lang, numericSymbols = lang2.numericSymbols, numSymMagnitude = lang2.numericSymbolMagnitude || 1e3, numericSymbolDetector = axis.logarithmic ? Math.abs(value) : axis.tickInterval;
          var i = numericSymbols && numericSymbols.length, multi, ret;
          if (categories) {
            ret = "" + this.value;
          } else if (dateTimeLabelFormat) {
            ret = time.dateFormat(dateTimeLabelFormat, value);
          } else if (i && numericSymbolDetector >= 1e3) {
            while (i-- && typeof ret === "undefined") {
              multi = Math.pow(numSymMagnitude, i + 1);
              if (
                // Only accept a numeric symbol when the distance is more
                // than a full unit. So for example if the symbol is k, we
                // don't accept numbers like 0.5k.
                numericSymbolDetector >= multi && // Accept one decimal before the symbol. Accepts 0.5k but
                // not 0.25k. How does this work with the previous?
                value * 10 % multi === 0 && numericSymbols[i] !== null && value !== 0
              ) {
                ret = numberFormatter(value / multi, -1) + numericSymbols[i];
              }
            }
          }
          if (typeof ret === "undefined") {
            if (Math.abs(value) >= 1e4) {
              ret = numberFormatter(value, -1);
            } else {
              ret = numberFormatter(value, -1, void 0, "");
            }
          }
          return ret;
        };
        Axis2.prototype.getSeriesExtremes = function() {
          var axis = this, chart = axis.chart;
          var xExtremes;
          fireEvent$y(this, "getSeriesExtremes", null, function() {
            axis.hasVisibleSeries = false;
            axis.dataMin = axis.dataMax = axis.threshold = null;
            axis.softThreshold = !axis.isXAxis;
            if (axis.stacking) {
              axis.stacking.buildStacks();
            }
            axis.series.forEach(function(series) {
              if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
                var seriesOptions = series.options;
                var xData = void 0, threshold = seriesOptions.threshold, seriesDataMin = void 0, seriesDataMax = void 0;
                axis.hasVisibleSeries = true;
                if (axis.positiveValuesOnly && threshold <= 0) {
                  threshold = null;
                }
                if (axis.isXAxis) {
                  xData = series.xData;
                  if (xData.length) {
                    xData = axis.logarithmic ? xData.filter(axis.validatePositiveValue) : xData;
                    xExtremes = series.getXExtremes(xData);
                    seriesDataMin = xExtremes.min;
                    seriesDataMax = xExtremes.max;
                    if (!isNumber$H(seriesDataMin) && // #5010:
                    !(seriesDataMin instanceof Date)) {
                      xData = xData.filter(isNumber$H);
                      xExtremes = series.getXExtremes(xData);
                      seriesDataMin = xExtremes.min;
                      seriesDataMax = xExtremes.max;
                    }
                    if (xData.length) {
                      axis.dataMin = Math.min(pick$1o(axis.dataMin, seriesDataMin), seriesDataMin);
                      axis.dataMax = Math.max(pick$1o(axis.dataMax, seriesDataMax), seriesDataMax);
                    }
                  }
                } else {
                  var dataExtremes = series.applyExtremes();
                  if (isNumber$H(dataExtremes.dataMin)) {
                    seriesDataMin = dataExtremes.dataMin;
                    axis.dataMin = Math.min(pick$1o(axis.dataMin, seriesDataMin), seriesDataMin);
                  }
                  if (isNumber$H(dataExtremes.dataMax)) {
                    seriesDataMax = dataExtremes.dataMax;
                    axis.dataMax = Math.max(pick$1o(axis.dataMax, seriesDataMax), seriesDataMax);
                  }
                  if (defined$N(threshold)) {
                    axis.threshold = threshold;
                  }
                  if (!seriesOptions.softThreshold || axis.positiveValuesOnly) {
                    axis.softThreshold = false;
                  }
                }
              }
            });
          });
          fireEvent$y(this, "afterGetSeriesExtremes");
        };
        Axis2.prototype.translate = function(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
          var axis = this.linkedParent || this, localMin = old && axis.old ? axis.old.min : axis.min, minPixelPadding = axis.minPixelPadding, doPostTranslate = (axis.isOrdinal || axis.brokenAxis && axis.brokenAxis.hasBreaks || axis.logarithmic && handleLog) && axis.lin2val;
          var sign = 1, cvsOffset = 0, localA = old && axis.old ? axis.old.transA : axis.transA, returnValue = 0;
          if (!localA) {
            localA = axis.transA;
          }
          if (cvsCoord) {
            sign *= -1;
            cvsOffset = axis.len;
          }
          if (axis.reversed) {
            sign *= -1;
            cvsOffset -= sign * (axis.sector || axis.len);
          }
          if (backwards) {
            val = val * sign + cvsOffset;
            val -= minPixelPadding;
            returnValue = val / localA + localMin;
            if (doPostTranslate) {
              returnValue = axis.lin2val(returnValue);
            }
          } else {
            if (doPostTranslate) {
              val = axis.val2lin(val);
            }
            returnValue = isNumber$H(localMin) ? sign * (val - localMin) * localA + cvsOffset + sign * minPixelPadding + (isNumber$H(pointPlacement) ? localA * pointPlacement : 0) : void 0;
          }
          return returnValue;
        };
        Axis2.prototype.toPixels = function(value, paneCoordinates) {
          return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
        };
        Axis2.prototype.toValue = function(pixel, paneCoordinates) {
          return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
        };
        Axis2.prototype.getPlotLinePath = function(options) {
          var axis = this, chart = axis.chart, axisLeft = axis.left, axisTop = axis.top, old = options.old, value = options.value, lineWidth = options.lineWidth, cHeight = old && chart.oldChartHeight || chart.chartHeight, cWidth = old && chart.oldChartWidth || chart.chartWidth, transB = axis.transB;
          var translatedValue = options.translatedValue, force = options.force, x1, y1, x2, y2, skip;
          function between(x, a, b) {
            if (force !== "pass" && x < a || x > b) {
              if (force) {
                x = clamp$g(x, a, b);
              } else {
                skip = true;
              }
            }
            return x;
          }
          var evt = {
            value,
            lineWidth,
            old,
            force,
            acrossPanes: options.acrossPanes,
            translatedValue
          };
          fireEvent$y(this, "getPlotLinePath", evt, function(e2) {
            translatedValue = pick$1o(translatedValue, axis.translate(value, null, null, old));
            translatedValue = clamp$g(translatedValue, -1e5, 1e5);
            x1 = x2 = Math.round(translatedValue + transB);
            y1 = y2 = Math.round(cHeight - translatedValue - transB);
            if (!isNumber$H(translatedValue)) {
              skip = true;
              force = false;
            } else if (axis.horiz) {
              y1 = axisTop;
              y2 = cHeight - axis.bottom;
              x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
            } else {
              x1 = axisLeft;
              x2 = cWidth - axis.right;
              y1 = y2 = between(y1, axisTop, axisTop + axis.height);
            }
            e2.path = skip && !force ? null : chart.renderer.crispLine([["M", x1, y1], ["L", x2, y2]], lineWidth || 1);
          });
          return evt.path;
        };
        Axis2.prototype.getLinearTickPositions = function(tickInterval, min, max) {
          var roundedMin = correctFloat$b(Math.floor(min / tickInterval) * tickInterval), roundedMax = correctFloat$b(Math.ceil(max / tickInterval) * tickInterval), tickPositions = [];
          var pos, lastPos, precision;
          if (correctFloat$b(roundedMin + tickInterval) === roundedMin) {
            precision = 20;
          }
          if (this.single) {
            return [min];
          }
          pos = roundedMin;
          while (pos <= roundedMax) {
            tickPositions.push(pos);
            pos = correctFloat$b(pos + tickInterval, precision);
            if (pos === lastPos) {
              break;
            }
            lastPos = pos;
          }
          return tickPositions;
        };
        Axis2.prototype.getMinorTickInterval = function() {
          var options = this.options;
          if (options.minorTicks === true) {
            return pick$1o(options.minorTickInterval, "auto");
          }
          if (options.minorTicks === false) {
            return null;
          }
          return options.minorTickInterval;
        };
        Axis2.prototype.getMinorTickPositions = function() {
          var axis = this, options = axis.options, tickPositions = axis.tickPositions, minorTickInterval = axis.minorTickInterval, pointRangePadding = axis.pointRangePadding || 0, min = axis.min - pointRangePadding, max = axis.max + pointRangePadding, range = max - min;
          var minorTickPositions = [], pos;
          if (range && range / minorTickInterval < axis.len / 3) {
            var logarithmic_1 = axis.logarithmic;
            if (logarithmic_1) {
              this.paddedTicks.forEach(function(_pos, i, paddedTicks) {
                if (i) {
                  minorTickPositions.push.apply(minorTickPositions, logarithmic_1.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));
                }
              });
            } else if (axis.dateTime && this.getMinorTickInterval() === "auto") {
              minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval), min, max, options.startOfWeek));
            } else {
              for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
                if (pos === minorTickPositions[0]) {
                  break;
                }
                minorTickPositions.push(pos);
              }
            }
          }
          if (minorTickPositions.length !== 0) {
            axis.trimTicks(minorTickPositions);
          }
          return minorTickPositions;
        };
        Axis2.prototype.adjustForMinRange = function() {
          var axis = this, options = axis.options, log = axis.logarithmic;
          var min = axis.min, max = axis.max, zoomOffset, spaceAvailable, closestDataRange = 0, i, distance, xData, loopLength, minArgs, maxArgs, minRange;
          if (axis.isXAxis && typeof axis.minRange === "undefined" && !log) {
            if (defined$N(options.min) || defined$N(options.max)) {
              axis.minRange = null;
            } else {
              axis.series.forEach(function(series) {
                xData = series.xData;
                loopLength = series.xIncrement ? 1 : xData.length - 1;
                if (xData.length > 1) {
                  for (i = loopLength; i > 0; i--) {
                    distance = xData[i] - xData[i - 1];
                    if (!closestDataRange || distance < closestDataRange) {
                      closestDataRange = distance;
                    }
                  }
                }
              });
              axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);
            }
          }
          if (max - min < axis.minRange) {
            spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;
            minRange = axis.minRange;
            zoomOffset = (minRange - max + min) / 2;
            minArgs = [
              min - zoomOffset,
              pick$1o(options.min, min - zoomOffset)
            ];
            if (spaceAvailable) {
              minArgs[2] = axis.logarithmic ? axis.logarithmic.log2lin(axis.dataMin) : axis.dataMin;
            }
            min = arrayMax$9(minArgs);
            maxArgs = [
              min + minRange,
              pick$1o(options.max, min + minRange)
            ];
            if (spaceAvailable) {
              maxArgs[2] = log ? log.log2lin(axis.dataMax) : axis.dataMax;
            }
            max = arrayMin$8(maxArgs);
            if (max - min < minRange) {
              minArgs[0] = max - minRange;
              minArgs[1] = pick$1o(options.min, max - minRange);
              min = arrayMax$9(minArgs);
            }
          }
          axis.min = min;
          axis.max = max;
        };
        Axis2.prototype.getClosest = function() {
          var ret;
          if (this.categories) {
            ret = 1;
          } else {
            this.series.forEach(function(series) {
              var seriesClosest = series.closestPointRange, visible = series.visible || !series.chart.options.chart.ignoreHiddenSeries;
              if (!series.noSharedTooltip && defined$N(seriesClosest) && visible) {
                ret = defined$N(ret) ? Math.min(ret, seriesClosest) : seriesClosest;
              }
            });
          }
          return ret;
        };
        Axis2.prototype.nameToX = function(point) {
          var explicitCategories = isArray$j(this.categories), names = explicitCategories ? this.categories : this.names;
          var nameX = point.options.x, x;
          point.series.requireSorting = false;
          if (!defined$N(nameX)) {
            nameX = this.options.uniqueNames ? explicitCategories ? names.indexOf(point.name) : pick$1o(names.keys[point.name], -1) : point.series.autoIncrement();
          }
          if (nameX === -1) {
            if (!explicitCategories) {
              x = names.length;
            }
          } else {
            x = nameX;
          }
          if (typeof x !== "undefined") {
            this.names[x] = point.name;
            this.names.keys[point.name] = x;
          }
          return x;
        };
        Axis2.prototype.updateNames = function() {
          var axis = this, names = this.names, i = names.length;
          if (i > 0) {
            Object.keys(names.keys).forEach(function(key) {
              delete names.keys[key];
            });
            names.length = 0;
            this.minRange = this.userMinRange;
            (this.series || []).forEach(function(series) {
              series.xIncrement = null;
              if (!series.points || series.isDirtyData) {
                axis.max = Math.max(axis.max, series.xData.length - 1);
                series.processData();
                series.generatePoints();
              }
              series.data.forEach(function(point, i2) {
                var x;
                if (point && point.options && typeof point.name !== "undefined") {
                  x = axis.nameToX(point);
                  if (typeof x !== "undefined" && x !== point.x) {
                    point.x = x;
                    series.xData[i2] = x;
                  }
                }
              });
            });
          }
        };
        Axis2.prototype.setAxisTranslation = function() {
          var axis = this, range = axis.max - axis.min, linkedParent = axis.linkedParent, hasCategories = !!axis.categories, isXAxis = axis.isXAxis;
          var pointRange = axis.axisPointRange || 0, closestPointRange, minPointOffset = 0, pointRangePadding = 0, ordinalCorrection, transA = axis.transA;
          if (isXAxis || hasCategories || pointRange) {
            closestPointRange = axis.getClosest();
            if (linkedParent) {
              minPointOffset = linkedParent.minPointOffset;
              pointRangePadding = linkedParent.pointRangePadding;
            } else {
              axis.series.forEach(function(series) {
                var seriesPointRange = hasCategories ? 1 : isXAxis ? pick$1o(series.options.pointRange, closestPointRange, 0) : axis.axisPointRange || 0, pointPlacement = series.options.pointPlacement;
                pointRange = Math.max(pointRange, seriesPointRange);
                if (!axis.single || hasCategories) {
                  var isPointPlacementAxis = series.is("xrange") ? !isXAxis : isXAxis;
                  minPointOffset = Math.max(minPointOffset, isPointPlacementAxis && isString$7(pointPlacement) ? 0 : seriesPointRange / 2);
                  pointRangePadding = Math.max(pointRangePadding, isPointPlacementAxis && pointPlacement === "on" ? 0 : seriesPointRange);
                }
              });
            }
            ordinalCorrection = axis.ordinal && axis.ordinal.slope && closestPointRange ? axis.ordinal.slope / closestPointRange : 1;
            axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
            axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;
            axis.pointRange = Math.min(pointRange, axis.single && hasCategories ? 1 : range);
            if (isXAxis) {
              axis.closestPointRange = closestPointRange;
            }
          }
          axis.translationSlope = axis.transA = transA = axis.staticScale || axis.len / (range + pointRangePadding || 1);
          axis.transB = axis.horiz ? axis.left : axis.bottom;
          axis.minPixelPadding = transA * minPointOffset;
          fireEvent$y(this, "afterSetAxisTranslation");
        };
        Axis2.prototype.minFromRange = function() {
          var axis = this;
          return axis.max - axis.range;
        };
        Axis2.prototype.setTickInterval = function(secondPass) {
          var axis = this, chart = axis.chart, log = axis.logarithmic, options = axis.options, isXAxis = axis.isXAxis, isLinked = axis.isLinked, tickPixelIntervalOption = options.tickPixelInterval, categories = axis.categories, softThreshold = axis.softThreshold;
          var maxPadding = options.maxPadding, minPadding = options.minPadding, length, linkedParentExtremes, tickIntervalOption = options.tickInterval, threshold = isNumber$H(axis.threshold) ? axis.threshold : null, thresholdMin, thresholdMax, hardMin, hardMax;
          if (!axis.dateTime && !categories && !isLinked) {
            this.getTickAmount();
          }
          hardMin = pick$1o(axis.userMin, options.min);
          hardMax = pick$1o(axis.userMax, options.max);
          if (isLinked) {
            axis.linkedParent = chart[axis.coll][options.linkedTo];
            linkedParentExtremes = axis.linkedParent.getExtremes();
            axis.min = pick$1o(linkedParentExtremes.min, linkedParentExtremes.dataMin);
            axis.max = pick$1o(linkedParentExtremes.max, linkedParentExtremes.dataMax);
            if (options.type !== axis.linkedParent.options.type) {
              error$7(11, 1, chart);
            }
          } else {
            if (softThreshold && defined$N(threshold)) {
              if (axis.dataMin >= threshold) {
                thresholdMin = threshold;
                minPadding = 0;
              } else if (axis.dataMax <= threshold) {
                thresholdMax = threshold;
                maxPadding = 0;
              }
            }
            axis.min = pick$1o(hardMin, thresholdMin, axis.dataMin);
            axis.max = pick$1o(hardMax, thresholdMax, axis.dataMax);
          }
          if (log) {
            if (axis.positiveValuesOnly && !secondPass && Math.min(axis.min, pick$1o(axis.dataMin, axis.min)) <= 0) {
              error$7(10, 1, chart);
            }
            axis.min = correctFloat$b(log.log2lin(axis.min), 16);
            axis.max = correctFloat$b(log.log2lin(axis.max), 16);
          }
          if (axis.range && defined$N(axis.max)) {
            axis.userMin = axis.min = hardMin = Math.max(axis.dataMin, axis.minFromRange());
            axis.userMax = hardMax = axis.max;
            axis.range = null;
          }
          fireEvent$y(axis, "foundExtremes");
          if (axis.beforePadding) {
            axis.beforePadding();
          }
          axis.adjustForMinRange();
          if (!categories && !axis.axisPointRange && !(axis.stacking && axis.stacking.usePercentage) && !isLinked && defined$N(axis.min) && defined$N(axis.max)) {
            length = axis.max - axis.min;
            if (length) {
              if (!defined$N(hardMin) && minPadding) {
                axis.min -= length * minPadding;
              }
              if (!defined$N(hardMax) && maxPadding) {
                axis.max += length * maxPadding;
              }
            }
          }
          if (!isNumber$H(axis.userMin)) {
            if (isNumber$H(options.softMin) && options.softMin < axis.min) {
              axis.min = hardMin = options.softMin;
            }
            if (isNumber$H(options.floor)) {
              axis.min = Math.max(axis.min, options.floor);
            }
          }
          if (!isNumber$H(axis.userMax)) {
            if (isNumber$H(options.softMax) && options.softMax > axis.max) {
              axis.max = hardMax = options.softMax;
            }
            if (isNumber$H(options.ceiling)) {
              axis.max = Math.min(axis.max, options.ceiling);
            }
          }
          if (softThreshold && defined$N(axis.dataMin)) {
            threshold = threshold || 0;
            if (!defined$N(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {
              axis.min = axis.options.minRange ? Math.min(threshold, axis.max - axis.minRange) : threshold;
            } else if (!defined$N(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
              axis.max = axis.options.minRange ? Math.max(threshold, axis.min + axis.minRange) : threshold;
            }
          }
          if (isNumber$H(axis.min) && isNumber$H(axis.max) && !this.chart.polar && axis.min > axis.max) {
            if (defined$N(axis.options.min)) {
              axis.max = axis.min;
            } else if (defined$N(axis.options.max)) {
              axis.min = axis.max;
            }
          }
          if (axis.min === axis.max || typeof axis.min === "undefined" || typeof axis.max === "undefined") {
            axis.tickInterval = 1;
          } else if (isLinked && axis.linkedParent && !tickIntervalOption && tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
            axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
          } else {
            axis.tickInterval = pick$1o(
              tickIntervalOption,
              this.tickAmount ? (axis.max - axis.min) / Math.max(this.tickAmount - 1, 1) : void 0,
              // For categoried axis, 1 is default, for linear axis use
              // tickPix
              categories ? 1 : (
                // don't let it be more than the data range
                (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption)
              )
            );
          }
          if (isXAxis && !secondPass) {
            axis.series.forEach(function(series) {
              series.forceCrop = series.forceCropping && series.forceCropping();
              series.processData(axis.min !== (axis.old && axis.old.min) || axis.max !== (axis.old && axis.old.max));
            });
            fireEvent$y(this, "postProcessData");
          }
          axis.setAxisTranslation();
          fireEvent$y(this, "initialAxisTranslation");
          if (axis.pointRange && !tickIntervalOption) {
            axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
          }
          var minTickInterval = pick$1o(
            options.minTickInterval,
            // In datetime axes, don't go below the data interval, except when
            // there are scatter-like series involved (#13369).
            axis.dateTime && !axis.series.some(function(s) {
              return s.noSharedTooltip;
            }) ? axis.closestPointRange : 0
          );
          if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
            axis.tickInterval = minTickInterval;
          }
          if (!axis.dateTime && !axis.logarithmic && !tickIntervalOption) {
            axis.tickInterval = normalizeTickInterval$2(axis.tickInterval, void 0, getMagnitude$2(axis.tickInterval), pick$1o(
              options.allowDecimals,
              // If the tick interval is greather than 0.5, avoid
              // decimals, as linear axes are often used to render
              // discrete values. #3363. If a tick amount is set, allow
              // decimals by default, as it increases the chances for a
              // good fit.
              axis.tickInterval < 0.5 || this.tickAmount !== void 0
            ), !!this.tickAmount);
          }
          if (!this.tickAmount) {
            axis.tickInterval = axis.unsquish();
          }
          this.setTickPositions();
        };
        Axis2.prototype.setTickPositions = function() {
          var axis = this, options = this.options, tickPositionsOption = options.tickPositions, minorTickIntervalOption = this.getMinorTickInterval(), hasVerticalPanning = this.hasVerticalPanning(), isColorAxis = this.coll === "colorAxis", startOnTick = (isColorAxis || !hasVerticalPanning) && options.startOnTick, endOnTick = (isColorAxis || !hasVerticalPanning) && options.endOnTick;
          var tickPositions, tickPositioner = options.tickPositioner;
          this.tickmarkOffset = this.categories && options.tickmarkPlacement === "between" && this.tickInterval === 1 ? 0.5 : 0;
          this.minorTickInterval = minorTickIntervalOption === "auto" && this.tickInterval ? this.tickInterval / 5 : minorTickIntervalOption;
          this.single = this.min === this.max && defined$N(this.min) && !this.tickAmount && // Data is on integer (#6563)
          (parseInt(this.min, 10) === this.min || // Between integers and decimals are not allowed (#6274)
          options.allowDecimals !== false);
          this.tickPositions = // Find the tick positions. Work on a copy (#1565)
          tickPositions = tickPositionsOption && tickPositionsOption.slice();
          if (!tickPositions) {
            if ((!axis.ordinal || !axis.ordinal.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) {
              tickPositions = [this.min, this.max];
              error$7(19, false, this.chart);
            } else if (axis.dateTime) {
              tickPositions = axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, axis.ordinal && axis.ordinal.positions, this.closestPointRange, true);
            } else if (axis.logarithmic) {
              tickPositions = axis.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
            } else {
              tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
            }
            if (tickPositions.length > this.len) {
              tickPositions = [tickPositions[0], tickPositions.pop()];
              if (tickPositions[0] === tickPositions[1]) {
                tickPositions.length = 1;
              }
            }
            this.tickPositions = tickPositions;
            if (tickPositioner) {
              tickPositioner = tickPositioner.apply(axis, [this.min, this.max]);
              if (tickPositioner) {
                this.tickPositions = tickPositions = tickPositioner;
              }
            }
          }
          this.paddedTicks = tickPositions.slice(0);
          this.trimTicks(tickPositions, startOnTick, endOnTick);
          if (!this.isLinked) {
            if (this.single && tickPositions.length < 2 && !this.categories && !this.series.some(function(s) {
              return s.is("heatmap") && s.options.pointPlacement === "between";
            })) {
              this.min -= 0.5;
              this.max += 0.5;
            }
            if (!tickPositionsOption && !tickPositioner) {
              this.adjustTickAmount();
            }
          }
          fireEvent$y(this, "afterSetTickPositions");
        };
        Axis2.prototype.trimTicks = function(tickPositions, startOnTick, endOnTick) {
          var roundedMin = tickPositions[0], roundedMax = tickPositions[tickPositions.length - 1], minPointOffset = !this.isOrdinal && this.minPointOffset || 0;
          fireEvent$y(this, "trimTicks");
          if (!this.isLinked) {
            if (startOnTick && roundedMin !== -Infinity) {
              this.min = roundedMin;
            } else {
              while (this.min - minPointOffset > tickPositions[0]) {
                tickPositions.shift();
              }
            }
            if (endOnTick) {
              this.max = roundedMax;
            } else {
              while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
                tickPositions.pop();
              }
            }
            if (tickPositions.length === 0 && defined$N(roundedMin) && !this.options.tickPositions) {
              tickPositions.push((roundedMax + roundedMin) / 2);
            }
          }
        };
        Axis2.prototype.alignToOthers = function() {
          var axis = this, others = (
            // Whether there is another axis to pair with this one
            {}
          ), options = axis.options;
          var hasOther;
          if (
            // Only if alignTicks is true
            this.chart.options.chart.alignTicks !== false && options.alignTicks && // Disabled when startOnTick or endOnTick are false (#7604)
            options.startOnTick !== false && options.endOnTick !== false && // Don't try to align ticks on a log axis, they are not evenly
            // spaced (#6021)
            !axis.logarithmic
          ) {
            this.chart[this.coll].forEach(function(axis2) {
              var otherOptions = axis2.options, horiz = axis2.horiz, key = [
                horiz ? otherOptions.left : otherOptions.top,
                otherOptions.width,
                otherOptions.height,
                otherOptions.pane
              ].join(",");
              if (axis2.series.length) {
                if (others[key]) {
                  hasOther = true;
                } else {
                  others[key] = 1;
                }
              }
            });
          }
          return hasOther;
        };
        Axis2.prototype.getTickAmount = function() {
          var axis = this, options = this.options, tickPixelInterval = options.tickPixelInterval;
          var tickAmount = options.tickAmount;
          if (!defined$N(options.tickInterval) && !tickAmount && this.len < tickPixelInterval && !this.isRadial && !axis.logarithmic && options.startOnTick && options.endOnTick) {
            tickAmount = 2;
          }
          if (!tickAmount && this.alignToOthers()) {
            tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
          }
          if (tickAmount < 4) {
            this.finalTickAmt = tickAmount;
            tickAmount = 5;
          }
          this.tickAmount = tickAmount;
        };
        Axis2.prototype.adjustTickAmount = function() {
          var axis = this, axisOptions = axis.options, tickInterval = axis.tickInterval, tickPositions = axis.tickPositions, tickAmount = axis.tickAmount, finalTickAmt = axis.finalTickAmt, currentTickAmount = tickPositions && tickPositions.length, threshold = pick$1o(axis.threshold, axis.softThreshold ? 0 : null);
          var len, i;
          if (axis.hasData() && isNumber$H(axis.min) && isNumber$H(axis.max)) {
            if (currentTickAmount < tickAmount) {
              while (tickPositions.length < tickAmount) {
                if (tickPositions.length % 2 || axis.min === threshold) {
                  tickPositions.push(correctFloat$b(tickPositions[tickPositions.length - 1] + tickInterval));
                } else {
                  tickPositions.unshift(correctFloat$b(tickPositions[0] - tickInterval));
                }
              }
              axis.transA *= (currentTickAmount - 1) / (tickAmount - 1);
              axis.min = axisOptions.startOnTick ? tickPositions[0] : Math.min(axis.min, tickPositions[0]);
              axis.max = axisOptions.endOnTick ? tickPositions[tickPositions.length - 1] : Math.max(axis.max, tickPositions[tickPositions.length - 1]);
            } else if (currentTickAmount > tickAmount) {
              axis.tickInterval *= 2;
              axis.setTickPositions();
            }
            if (defined$N(finalTickAmt)) {
              i = len = tickPositions.length;
              while (i--) {
                if (
                  // Remove every other tick
                  finalTickAmt === 3 && i % 2 === 1 || // Remove all but first and last
                  finalTickAmt <= 2 && i > 0 && i < len - 1
                ) {
                  tickPositions.splice(i, 1);
                }
              }
              axis.finalTickAmt = void 0;
            }
          }
        };
        Axis2.prototype.setScale = function() {
          var axis = this;
          var isDirtyData = false, isXAxisDirty = false;
          axis.series.forEach(function(series) {
            isDirtyData = isDirtyData || series.isDirtyData || series.isDirty;
            isXAxisDirty = isXAxisDirty || series.xAxis && series.xAxis.isDirty || false;
          });
          axis.setAxisSize();
          var isDirtyAxisLength = axis.len !== (axis.old && axis.old.len);
          if (isDirtyAxisLength || isDirtyData || isXAxisDirty || axis.isLinked || axis.forceRedraw || axis.userMin !== (axis.old && axis.old.userMin) || axis.userMax !== (axis.old && axis.old.userMax) || axis.alignToOthers()) {
            if (axis.stacking) {
              axis.stacking.resetStacks();
            }
            axis.forceRedraw = false;
            axis.getSeriesExtremes();
            axis.setTickInterval();
            if (!axis.isDirty) {
              axis.isDirty = isDirtyAxisLength || axis.min !== (axis.old && axis.old.min) || axis.max !== (axis.old && axis.old.max);
            }
          } else if (axis.stacking) {
            axis.stacking.cleanStacks();
          }
          if (isDirtyData && axis.panningState) {
            axis.panningState.isDirty = true;
          }
          fireEvent$y(this, "afterSetScale");
        };
        Axis2.prototype.setExtremes = function(newMin, newMax, redraw, animation, eventArguments) {
          var axis = this, chart = axis.chart;
          redraw = pick$1o(redraw, true);
          axis.series.forEach(function(serie) {
            delete serie.kdTree;
          });
          eventArguments = extend$1i(eventArguments, {
            min: newMin,
            max: newMax
          });
          fireEvent$y(axis, "setExtremes", eventArguments, function() {
            axis.userMin = newMin;
            axis.userMax = newMax;
            axis.eventArgs = eventArguments;
            if (redraw) {
              chart.redraw(animation);
            }
          });
        };
        Axis2.prototype.zoom = function(newMin, newMax) {
          var axis = this, dataMin = this.dataMin, dataMax = this.dataMax, options = this.options, min = Math.min(dataMin, pick$1o(options.min, dataMin)), max = Math.max(dataMax, pick$1o(options.max, dataMax)), evt = {
            newMin,
            newMax
          };
          fireEvent$y(this, "zoom", evt, function(e2) {
            var newMin2 = e2.newMin, newMax2 = e2.newMax;
            if (newMin2 !== axis.min || newMax2 !== axis.max) {
              if (!axis.allowZoomOutside) {
                if (defined$N(dataMin)) {
                  if (newMin2 < min) {
                    newMin2 = min;
                  }
                  if (newMin2 > max) {
                    newMin2 = max;
                  }
                }
                if (defined$N(dataMax)) {
                  if (newMax2 < min) {
                    newMax2 = min;
                  }
                  if (newMax2 > max) {
                    newMax2 = max;
                  }
                }
              }
              axis.displayBtn = typeof newMin2 !== "undefined" || typeof newMax2 !== "undefined";
              axis.setExtremes(newMin2, newMax2, false, void 0, { trigger: "zoom" });
            }
            e2.zoomed = true;
          });
          return evt.zoomed;
        };
        Axis2.prototype.setAxisSize = function() {
          var chart = this.chart, options = this.options, offsets = options.offsets || [0, 0, 0, 0], horiz = this.horiz, width = this.width = Math.round(relativeLength$9(pick$1o(options.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth)), height = this.height = Math.round(relativeLength$9(pick$1o(options.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight)), top = this.top = Math.round(relativeLength$9(pick$1o(options.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop)), left = this.left = Math.round(relativeLength$9(pick$1o(options.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft));
          this.bottom = chart.chartHeight - height - top;
          this.right = chart.chartWidth - width - left;
          this.len = Math.max(horiz ? width : height, 0);
          this.pos = horiz ? left : top;
        };
        Axis2.prototype.getExtremes = function() {
          var axis = this, log = axis.logarithmic;
          return {
            min: log ? correctFloat$b(log.lin2log(axis.min)) : axis.min,
            max: log ? correctFloat$b(log.lin2log(axis.max)) : axis.max,
            dataMin: axis.dataMin,
            dataMax: axis.dataMax,
            userMin: axis.userMin,
            userMax: axis.userMax
          };
        };
        Axis2.prototype.getThreshold = function(threshold) {
          var axis = this, log = axis.logarithmic, realMin = log ? log.lin2log(axis.min) : axis.min, realMax = log ? log.lin2log(axis.max) : axis.max;
          if (threshold === null || threshold === -Infinity) {
            threshold = realMin;
          } else if (threshold === Infinity) {
            threshold = realMax;
          } else if (realMin > threshold) {
            threshold = realMin;
          } else if (realMax < threshold) {
            threshold = realMax;
          }
          return axis.translate(threshold, 0, 1, 0, 1);
        };
        Axis2.prototype.autoLabelAlign = function(rotation) {
          var angle = (pick$1o(rotation, 0) - this.side * 90 + 720) % 360, evt = { align: "center" };
          fireEvent$y(this, "autoLabelAlign", evt, function(e2) {
            if (angle > 15 && angle < 165) {
              e2.align = "right";
            } else if (angle > 195 && angle < 345) {
              e2.align = "left";
            }
          });
          return evt.align;
        };
        Axis2.prototype.tickSize = function(prefix) {
          var options = this.options, tickWidth = pick$1o(
            options[prefix === "tick" ? "tickWidth" : "minorTickWidth"],
            // Default to 1 on linear and datetime X axes
            prefix === "tick" && this.isXAxis && !this.categories ? 1 : 0
          );
          var tickLength = options[prefix === "tick" ? "tickLength" : "minorTickLength"], tickSize;
          if (tickWidth && tickLength) {
            if (options[prefix + "Position"] === "inside") {
              tickLength = -tickLength;
            }
            tickSize = [tickLength, tickWidth];
          }
          var e2 = { tickSize };
          fireEvent$y(this, "afterTickSize", e2);
          return e2.tickSize;
        };
        Axis2.prototype.labelMetrics = function() {
          var index = this.tickPositions && this.tickPositions[0] || 0;
          return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[index] && this.ticks[index].label);
        };
        Axis2.prototype.unsquish = function() {
          var labelOptions = this.options.labels, horiz = this.horiz, tickInterval = this.tickInterval, slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval), rotationOption = labelOptions.rotation, labelMetrics = this.labelMetrics(), range = Math.max(this.max - this.min, 0), getStep = function(spaceNeeded) {
            var step2 = spaceNeeded / (slotSize || 1);
            step2 = step2 > 1 ? Math.ceil(step2) : 1;
            if (step2 * tickInterval > range && spaceNeeded !== Infinity && slotSize !== Infinity && range) {
              step2 = Math.ceil(range / tickInterval);
            }
            return correctFloat$b(step2 * tickInterval);
          };
          var newTickInterval = tickInterval, rotation, step, bestScore = Number.MAX_VALUE, autoRotation;
          if (horiz) {
            if (!labelOptions.staggerLines && !labelOptions.step) {
              if (isNumber$H(rotationOption)) {
                autoRotation = [rotationOption];
              } else if (slotSize < labelOptions.autoRotationLimit) {
                autoRotation = labelOptions.autoRotation;
              }
            }
            if (autoRotation) {
              autoRotation.forEach(function(rot) {
                var score;
                if (rot === rotationOption || rot && rot >= -90 && rot <= 90) {
                  step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad$5 * rot)));
                  score = step + Math.abs(rot / 360);
                  if (score < bestScore) {
                    bestScore = score;
                    rotation = rot;
                    newTickInterval = step;
                  }
                }
              });
            }
          } else if (!labelOptions.step) {
            newTickInterval = getStep(labelMetrics.h);
          }
          this.autoRotation = autoRotation;
          this.labelRotation = pick$1o(rotation, isNumber$H(rotationOption) ? rotationOption : 0);
          return newTickInterval;
        };
        Axis2.prototype.getSlotWidth = function(tick) {
          var chart = this.chart, horiz = this.horiz, labelOptions = this.options.labels, slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), marginLeft = chart.margin[3];
          if (tick && isNumber$H(tick.slotWidth)) {
            return tick.slotWidth;
          }
          if (horiz && labelOptions.step < 2) {
            if (labelOptions.rotation) {
              return 0;
            }
            return (this.staggerLines || 1) * this.len / slotCount;
          }
          if (!horiz) {
            var cssWidth = labelOptions.style.width;
            if (cssWidth !== void 0) {
              return parseInt(String(cssWidth), 10);
            }
            if (marginLeft) {
              return marginLeft - chart.spacing[3];
            }
          }
          return chart.chartWidth * 0.33;
        };
        Axis2.prototype.renderUnsquish = function() {
          var chart = this.chart, renderer = chart.renderer, tickPositions = this.tickPositions, ticks = this.ticks, labelOptions = this.options.labels, labelStyleOptions = labelOptions.style, horiz = this.horiz, slotWidth = this.getSlotWidth(), innerWidth = Math.max(1, Math.round(slotWidth - 2 * labelOptions.padding)), attr2 = {}, labelMetrics = this.labelMetrics(), textOverflowOption = labelStyleOptions.textOverflow;
          var commonWidth, commonTextOverflow, maxLabelLength = 0, label, i, pos;
          if (!isString$7(labelOptions.rotation)) {
            attr2.rotation = labelOptions.rotation || 0;
          }
          tickPositions.forEach(function(tickPosition) {
            var tick = ticks[tickPosition];
            if (tick.movedLabel) {
              tick.replaceMovedLabel();
            }
            if (tick && tick.label && tick.label.textPxLength > maxLabelLength) {
              maxLabelLength = tick.label.textPxLength;
            }
          });
          this.maxLabelLength = maxLabelLength;
          if (this.autoRotation) {
            if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {
              attr2.rotation = this.labelRotation;
            } else {
              this.labelRotation = 0;
            }
          } else if (slotWidth) {
            commonWidth = innerWidth;
            if (!textOverflowOption) {
              commonTextOverflow = "clip";
              i = tickPositions.length;
              while (!horiz && i--) {
                pos = tickPositions[i];
                label = ticks[pos].label;
                if (label) {
                  if (label.styles && label.styles.textOverflow === "ellipsis") {
                    label.css({ textOverflow: "clip" });
                  } else if (label.textPxLength > slotWidth) {
                    label.css({ width: slotWidth + "px" });
                  }
                  if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
                    label.specificTextOverflow = "ellipsis";
                  }
                }
              }
            }
          }
          if (attr2.rotation) {
            commonWidth = maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : maxLabelLength;
            if (!textOverflowOption) {
              commonTextOverflow = "ellipsis";
            }
          }
          this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);
          if (this.labelAlign) {
            attr2.align = this.labelAlign;
          }
          tickPositions.forEach(function(pos2) {
            var tick = ticks[pos2], label2 = tick && tick.label, widthOption = labelStyleOptions.width, css2 = {};
            if (label2) {
              label2.attr(attr2);
              if (tick.shortenLabel) {
                tick.shortenLabel();
              } else if (commonWidth && !widthOption && // Setting width in this case messes with the bounding box
              // (#7975)
              labelStyleOptions.whiteSpace !== "nowrap" && // Speed optimizing, #7656
              (commonWidth < label2.textPxLength || // Resetting CSS, #4928
              label2.element.tagName === "SPAN")) {
                css2.width = commonWidth + "px";
                if (!textOverflowOption) {
                  css2.textOverflow = label2.specificTextOverflow || commonTextOverflow;
                }
                label2.css(css2);
              } else if (label2.styles && label2.styles.width && !css2.width && !widthOption) {
                label2.css({ width: null });
              }
              delete label2.specificTextOverflow;
              tick.rotation = attr2.rotation;
            }
          }, this);
          this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
        };
        Axis2.prototype.hasData = function() {
          return this.series.some(function(s) {
            return s.hasData();
          }) || this.options.showEmpty && defined$N(this.min) && defined$N(this.max);
        };
        Axis2.prototype.addTitle = function(display) {
          var axis = this, renderer = axis.chart.renderer, horiz = axis.horiz, opposite = axis.opposite, options = axis.options, axisTitleOptions = options.title, styledMode = axis.chart.styledMode;
          var textAlign;
          if (!axis.axisTitle) {
            textAlign = axisTitleOptions.textAlign;
            if (!textAlign) {
              textAlign = (horiz ? {
                low: "left",
                middle: "center",
                high: "right"
              } : {
                low: opposite ? "right" : "left",
                middle: "center",
                high: opposite ? "left" : "right"
              })[axisTitleOptions.align];
            }
            axis.axisTitle = renderer.text(axisTitleOptions.text || "", 0, 0, axisTitleOptions.useHTML).attr({
              zIndex: 7,
              rotation: axisTitleOptions.rotation,
              align: textAlign
            }).addClass("highcharts-axis-title");
            if (!styledMode) {
              axis.axisTitle.css(merge$1g(axisTitleOptions.style));
            }
            axis.axisTitle.add(axis.axisGroup);
            axis.axisTitle.isNew = true;
          }
          if (!styledMode && !axisTitleOptions.style.width && !axis.isRadial) {
            axis.axisTitle.css({
              width: axis.len + "px"
            });
          }
          axis.axisTitle[display ? "show" : "hide"](display);
        };
        Axis2.prototype.generateTick = function(pos) {
          var axis = this, ticks = axis.ticks;
          if (!ticks[pos]) {
            ticks[pos] = new Tick(axis, pos);
          } else {
            ticks[pos].addLabel();
          }
        };
        Axis2.prototype.getOffset = function() {
          var _this = this;
          var axis = this, chart = axis.chart, renderer = chart.renderer, options = axis.options, tickPositions = axis.tickPositions, ticks = axis.ticks, horiz = axis.horiz, side = axis.side, invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side, hasData = axis.hasData(), axisTitleOptions = options.title, labelOptions = options.labels, axisOffset = chart.axisOffset, clipOffset = chart.clipOffset, directionFactor = [-1, 1, 1, -1][side], className = options.className, axisParent = axis.axisParent;
          var showAxis, titleOffset = 0, titleOffsetOption, titleMargin = 0, labelOffset = 0, labelOffsetPadded, lineHeightCorrection;
          axis.showAxis = showAxis = hasData || options.showEmpty;
          axis.staggerLines = axis.horiz && labelOptions.staggerLines || void 0;
          if (!axis.axisGroup) {
            var createGroup = function(name, suffix, zIndex) {
              return renderer.g(name).attr({ zIndex }).addClass("highcharts-" + _this.coll.toLowerCase() + suffix + " " + (_this.isRadial ? "highcharts-radial-axis" + suffix + " " : "") + (className || "")).add(axisParent);
            };
            axis.gridGroup = createGroup("grid", "-grid", options.gridZIndex);
            axis.axisGroup = createGroup("axis", "", options.zIndex);
            axis.labelGroup = createGroup("axis-labels", "-labels", labelOptions.zIndex);
          }
          if (hasData || axis.isLinked) {
            tickPositions.forEach(function(pos) {
              axis.generateTick(pos);
            });
            axis.renderUnsquish();
            axis.reserveSpaceDefault = side === 0 || side === 2 || { 1: "left", 3: "right" }[side] === axis.labelAlign;
            if (pick$1o(labelOptions.reserveSpace, axis.labelAlign === "center" ? true : null, axis.reserveSpaceDefault)) {
              tickPositions.forEach(function(pos) {
                labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);
              });
            }
            if (axis.staggerLines) {
              labelOffset *= axis.staggerLines;
            }
            axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
          } else {
            objectEach$s(ticks, function(tick, n) {
              tick.destroy();
              delete ticks[n];
            });
          }
          if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
            axis.addTitle(showAxis);
            if (showAxis && axisTitleOptions.reserveSpace !== false) {
              axis.titleOffset = titleOffset = axis.axisTitle.getBBox()[horiz ? "height" : "width"];
              titleOffsetOption = axisTitleOptions.offset;
              titleMargin = defined$N(titleOffsetOption) ? 0 : pick$1o(axisTitleOptions.margin, horiz ? 5 : 10);
            }
          }
          axis.renderLine();
          axis.offset = directionFactor * pick$1o(options.offset, axisOffset[side] ? axisOffset[side] + (options.margin || 0) : 0);
          axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 };
          if (side === 0) {
            lineHeightCorrection = -axis.labelMetrics().h;
          } else if (side === 2) {
            lineHeightCorrection = axis.tickRotCorr.y;
          } else {
            lineHeightCorrection = 0;
          }
          labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
          if (labelOffset) {
            labelOffsetPadded -= lineHeightCorrection;
            labelOffsetPadded += directionFactor * (horiz ? pick$1o(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);
          }
          axis.axisTitleMargin = pick$1o(titleOffsetOption, labelOffsetPadded);
          if (axis.getMaxLabelDimensions) {
            axis.maxLabelDimensions = axis.getMaxLabelDimensions(ticks, tickPositions);
          }
          var tickSize = this.tickSize("tick");
          axisOffset[side] = Math.max(
            axisOffset[side],
            (axis.axisTitleMargin || 0) + titleOffset + directionFactor * axis.offset,
            labelOffsetPadded,
            // #3027
            tickPositions && tickPositions.length && tickSize ? tickSize[0] + directionFactor * axis.offset : 0
            // #4866
          );
          var clip = options.offset ? 0 : (
            // #4308, #4371:
            Math.floor(axis.axisLine.strokeWidth() / 2) * 2
          );
          clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);
          fireEvent$y(this, "afterGetOffset");
        };
        Axis2.prototype.getLinePath = function(lineWidth) {
          var chart = this.chart, opposite = this.opposite, offset2 = this.offset, horiz = this.horiz, lineLeft = this.left + (opposite ? this.width : 0) + offset2, lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset2;
          if (opposite) {
            lineWidth *= -1;
          }
          return chart.renderer.crispLine([
            [
              "M",
              horiz ? this.left : lineLeft,
              horiz ? lineTop : this.top
            ],
            [
              "L",
              horiz ? chart.chartWidth - this.right : lineLeft,
              horiz ? lineTop : chart.chartHeight - this.bottom
            ]
          ], lineWidth);
        };
        Axis2.prototype.renderLine = function() {
          if (!this.axisLine) {
            this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup);
            if (!this.chart.styledMode) {
              this.axisLine.attr({
                stroke: this.options.lineColor,
                "stroke-width": this.options.lineWidth,
                zIndex: 7
              });
            }
          }
        };
        Axis2.prototype.getTitlePosition = function() {
          var horiz = this.horiz, axisLeft = this.left, axisTop = this.top, axisLength = this.len, axisTitleOptions = this.options.title, margin = horiz ? axisLeft : axisTop, opposite = this.opposite, offset2 = this.offset, xOption = axisTitleOptions.x, yOption = axisTitleOptions.y, axisTitle = this.axisTitle, fontMetrics = this.chart.renderer.fontMetrics(axisTitleOptions.style.fontSize, axisTitle), textHeightOvershoot = Math.max(axisTitle.getBBox(null, 0).height - fontMetrics.h - 1, 0), alongAxis = {
            low: margin + (horiz ? 0 : axisLength),
            middle: margin + axisLength / 2,
            high: margin + (horiz ? axisLength : 0)
          }[axisTitleOptions.align], offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * // horizontal axis reverses the margin
          (opposite ? -1 : 1) * // so does opposite axes
          this.axisTitleMargin + [
            -textHeightOvershoot,
            textHeightOvershoot,
            fontMetrics.f,
            -textHeightOvershoot
            // left
          ][this.side], titlePosition = {
            x: horiz ? alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset2 + xOption,
            y: horiz ? offAxis + yOption - (opposite ? this.height : 0) + offset2 : alongAxis + yOption
          };
          fireEvent$y(this, "afterGetTitlePosition", { titlePosition });
          return titlePosition;
        };
        Axis2.prototype.renderMinorTick = function(pos, slideIn) {
          var axis = this;
          var minorTicks = axis.minorTicks;
          if (!minorTicks[pos]) {
            minorTicks[pos] = new Tick(axis, pos, "minor");
          }
          if (slideIn && minorTicks[pos].isNew) {
            minorTicks[pos].render(null, true);
          }
          minorTicks[pos].render(null, false, 1);
        };
        Axis2.prototype.renderTick = function(pos, i, slideIn) {
          var axis = this, isLinked = axis.isLinked, ticks = axis.ticks;
          if (!isLinked || pos >= axis.min && pos <= axis.max || axis.grid && axis.grid.isColumn) {
            if (!ticks[pos]) {
              ticks[pos] = new Tick(axis, pos);
            }
            if (slideIn && ticks[pos].isNew) {
              ticks[pos].render(i, true, -1);
            }
            ticks[pos].render(i);
          }
        };
        Axis2.prototype.render = function() {
          var axis = this, chart = axis.chart, log = axis.logarithmic, renderer = chart.renderer, options = axis.options, isLinked = axis.isLinked, tickPositions = axis.tickPositions, axisTitle = axis.axisTitle, ticks = axis.ticks, minorTicks = axis.minorTicks, alternateBands = axis.alternateBands, stackLabelOptions = options.stackLabels, alternateGridColor = options.alternateGridColor, tickmarkOffset = axis.tickmarkOffset, axisLine = axis.axisLine, showAxis = axis.showAxis, animation = animObject$a(renderer.globalAnimation);
          var from, to;
          axis.labelEdge.length = 0;
          axis.overlap = false;
          [ticks, minorTicks, alternateBands].forEach(function(coll) {
            objectEach$s(coll, function(tick) {
              tick.isActive = false;
            });
          });
          if (axis.hasData() || isLinked) {
            var slideInTicks_1 = axis.chart.hasRendered && axis.old && isNumber$H(axis.old.min);
            if (axis.minorTickInterval && !axis.categories) {
              axis.getMinorTickPositions().forEach(function(pos) {
                axis.renderMinorTick(pos, slideInTicks_1);
              });
            }
            if (tickPositions.length) {
              tickPositions.forEach(function(pos, i) {
                axis.renderTick(pos, i, slideInTicks_1);
              });
              if (tickmarkOffset && (axis.min === 0 || axis.single)) {
                if (!ticks[-1]) {
                  ticks[-1] = new Tick(axis, -1, null, true);
                }
                ticks[-1].render(-1);
              }
            }
            if (alternateGridColor) {
              tickPositions.forEach(function(pos, i) {
                to = typeof tickPositions[i + 1] !== "undefined" ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;
                if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {
                  if (!alternateBands[pos]) {
                    alternateBands[pos] = new H.PlotLineOrBand(axis);
                  }
                  from = pos + tickmarkOffset;
                  alternateBands[pos].options = {
                    from: log ? log.lin2log(from) : from,
                    to: log ? log.lin2log(to) : to,
                    color: alternateGridColor,
                    className: "highcharts-alternate-grid"
                  };
                  alternateBands[pos].render();
                  alternateBands[pos].isActive = true;
                }
              });
            }
            if (!axis._addedPlotLB) {
              axis._addedPlotLB = true;
              (options.plotLines || []).concat(options.plotBands || []).forEach(function(plotLineOptions) {
                axis.addPlotBandOrLine(plotLineOptions);
              });
            }
          }
          [ticks, minorTicks, alternateBands].forEach(function(coll) {
            var forDestruction = [], delay = animation.duration, destroyInactiveItems = function() {
              var i = forDestruction.length;
              while (i--) {
                if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
                  coll[forDestruction[i]].destroy();
                  delete coll[forDestruction[i]];
                }
              }
            };
            objectEach$s(coll, function(tick, pos) {
              if (!tick.isActive) {
                tick.render(pos, false, 0);
                tick.isActive = false;
                forDestruction.push(pos);
              }
            });
            syncTimeout$7(destroyInactiveItems, coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay);
          });
          if (axisLine) {
            axisLine[axisLine.isPlaced ? "animate" : "attr"]({
              d: this.getLinePath(axisLine.strokeWidth())
            });
            axisLine.isPlaced = true;
            axisLine[showAxis ? "show" : "hide"](showAxis);
          }
          if (axisTitle && showAxis) {
            var titleXy = axis.getTitlePosition();
            if (isNumber$H(titleXy.y)) {
              axisTitle[axisTitle.isNew ? "attr" : "animate"](titleXy);
              axisTitle.isNew = false;
            } else {
              axisTitle.attr("y", -9999);
              axisTitle.isNew = true;
            }
          }
          if (stackLabelOptions && stackLabelOptions.enabled && axis.stacking) {
            axis.stacking.renderStackTotals();
          }
          axis.old = {
            len: axis.len,
            max: axis.max,
            min: axis.min,
            transA: axis.transA,
            userMax: axis.userMax,
            userMin: axis.userMin
          };
          axis.isDirty = false;
          fireEvent$y(this, "afterRender");
        };
        Axis2.prototype.redraw = function() {
          if (this.visible) {
            this.render();
            this.plotLinesAndBands.forEach(function(plotLine) {
              plotLine.render();
            });
          }
          this.series.forEach(function(series) {
            series.isDirty = true;
          });
        };
        Axis2.prototype.getKeepProps = function() {
          return this.keepProps || Axis2.keepProps;
        };
        Axis2.prototype.destroy = function(keepEvents) {
          var axis = this, plotLinesAndBands = axis.plotLinesAndBands, eventOptions = this.eventOptions;
          fireEvent$y(this, "destroy", { keepEvents });
          if (!keepEvents) {
            removeEvent$9(axis);
          }
          [axis.ticks, axis.minorTicks, axis.alternateBands].forEach(function(coll) {
            destroyObjectProperties$7(coll);
          });
          if (plotLinesAndBands) {
            var i = plotLinesAndBands.length;
            while (i--) {
              plotLinesAndBands[i].destroy();
            }
          }
          [
            "axisLine",
            "axisTitle",
            "axisGroup",
            "gridGroup",
            "labelGroup",
            "cross",
            "scrollbar"
          ].forEach(function(prop) {
            if (axis[prop]) {
              axis[prop] = axis[prop].destroy();
            }
          });
          for (var plotGroup in axis.plotLinesAndBandsGroups) {
            axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();
          }
          objectEach$s(axis, function(val, key) {
            if (axis.getKeepProps().indexOf(key) === -1) {
              delete axis[key];
            }
          });
          this.eventOptions = eventOptions;
        };
        Axis2.prototype.drawCrosshair = function(e2, point) {
          var options = this.crosshair, snap = pick$1o(options && options.snap, true), chart = this.chart;
          var path, pos, categorized, graphic = this.cross, crossOptions;
          fireEvent$y(this, "drawCrosshair", { e: e2, point });
          if (!e2) {
            e2 = this.cross && this.cross.e;
          }
          if (
            // Disabled in options
            !options || // Snap
            (defined$N(point) || !snap) === false
          ) {
            this.hideCrosshair();
          } else {
            if (!snap) {
              pos = e2 && (this.horiz ? e2.chartX - this.pos : this.len - e2.chartY + this.pos);
            } else if (defined$N(point)) {
              pos = pick$1o(this.coll !== "colorAxis" ? point.crosshairPos : (
                // 3D axis extension
                null
              ), this.isXAxis ? point.plotX : this.len - point.plotY);
            }
            if (defined$N(pos)) {
              crossOptions = {
                // value, only used on radial
                value: point && (this.isXAxis ? point.x : pick$1o(point.stackY, point.y)),
                translatedValue: pos
              };
              if (chart.polar) {
                extend$1i(crossOptions, {
                  isCrosshair: true,
                  chartX: e2 && e2.chartX,
                  chartY: e2 && e2.chartY,
                  point
                });
              }
              path = this.getPlotLinePath(crossOptions) || null;
            }
            if (!defined$N(path)) {
              this.hideCrosshair();
              return;
            }
            categorized = this.categories && !this.isRadial;
            if (!graphic) {
              this.cross = graphic = chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (categorized ? "category " : "thin ") + (options.className || "")).attr({
                zIndex: pick$1o(options.zIndex, 2)
              }).add();
              if (!chart.styledMode) {
                graphic.attr({
                  stroke: options.color || (categorized ? Color.parse(palette.highlightColor20).setOpacity(0.25).get() : palette.neutralColor20),
                  "stroke-width": pick$1o(options.width, 1)
                }).css({
                  "pointer-events": "none"
                });
                if (options.dashStyle) {
                  graphic.attr({
                    dashstyle: options.dashStyle
                  });
                }
              }
            }
            graphic.show().attr({
              d: path
            });
            if (categorized && !options.width) {
              graphic.attr({
                "stroke-width": this.transA
              });
            }
            this.cross.e = e2;
          }
          fireEvent$y(this, "afterDrawCrosshair", { e: e2, point });
        };
        Axis2.prototype.hideCrosshair = function() {
          if (this.cross) {
            this.cross.hide();
          }
          fireEvent$y(this, "afterHideCrosshair");
        };
        Axis2.prototype.hasVerticalPanning = function() {
          var panningOptions = this.chart.options.chart.panning;
          return Boolean(panningOptions && panningOptions.enabled && // #14624
          /y/.test(panningOptions.type));
        };
        Axis2.prototype.validatePositiveValue = function(value) {
          return isNumber$H(value) && value > 0;
        };
        Axis2.prototype.update = function(options, redraw) {
          var chart = this.chart;
          options = merge$1g(this.userOptions, options);
          this.destroy(true);
          this.init(chart, options);
          chart.isDirtyBox = true;
          if (pick$1o(redraw, true)) {
            chart.redraw();
          }
        };
        Axis2.prototype.remove = function(redraw) {
          var chart = this.chart, key = this.coll, axisSeries = this.series;
          var i = axisSeries.length;
          while (i--) {
            if (axisSeries[i]) {
              axisSeries[i].remove(false);
            }
          }
          erase$7(chart.axes, this);
          erase$7(chart[key], this);
          chart[key].forEach(function(axis, i2) {
            axis.options.index = axis.userOptions.index = i2;
          });
          this.destroy();
          chart.isDirtyBox = true;
          if (pick$1o(redraw, true)) {
            chart.redraw();
          }
        };
        Axis2.prototype.setTitle = function(titleOptions, redraw) {
          this.update({ title: titleOptions }, redraw);
        };
        Axis2.prototype.setCategories = function(categories, redraw) {
          this.update({ categories }, redraw);
        };
        Axis2.defaultOptions = AxisDefaults$1.defaultXAxisOptions;
        Axis2.keepProps = ["extKey", "hcEvents", "names", "series", "userMax", "userMin"];
        return Axis2;
      }()
    );
    var addEvent$_ = Utilities.addEvent, getMagnitude$1 = Utilities.getMagnitude, normalizeTickInterval$1 = Utilities.normalizeTickInterval, timeUnits$1 = Utilities.timeUnits;
    var DateTimeAxis;
    (function(DateTimeAxis2) {
      var composedClasses2 = [];
      function compose(AxisClass) {
        if (composedClasses2.indexOf(AxisClass) === -1) {
          composedClasses2.push(AxisClass);
          AxisClass.keepProps.push("dateTime");
          var axisProto = AxisClass.prototype;
          axisProto.getTimeTicks = getTimeTicks;
          addEvent$_(AxisClass, "init", onInit);
        }
        return AxisClass;
      }
      DateTimeAxis2.compose = compose;
      function getTimeTicks() {
        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
      }
      function onInit(e2) {
        var axis = this;
        var options = e2.userOptions;
        if (options.type !== "datetime") {
          axis.dateTime = void 0;
          return;
        }
        if (!axis.dateTime) {
          axis.dateTime = new Additions(axis);
        }
      }
      var Additions = (
        /** @class */
        function() {
          function Additions2(axis) {
            this.axis = axis;
          }
          Additions2.prototype.normalizeTimeTickInterval = function(tickInterval, unitsOption) {
            var units = unitsOption || [[
              "millisecond",
              [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]
              // allowed multiples
            ], [
              "second",
              [1, 2, 5, 10, 15, 30]
            ], [
              "minute",
              [1, 2, 5, 10, 15, 30]
            ], [
              "hour",
              [1, 2, 3, 4, 6, 8, 12]
            ], [
              "day",
              [1, 2]
            ], [
              "week",
              [1, 2]
            ], [
              "month",
              [1, 2, 3, 4, 6]
            ], [
              "year",
              null
            ]];
            var unit = units[units.length - 1], interval = timeUnits$1[unit[0]], multiples = unit[1], i;
            for (i = 0; i < units.length; i++) {
              unit = units[i];
              interval = timeUnits$1[unit[0]];
              multiples = unit[1];
              if (units[i + 1]) {
                var lessThan = (interval * multiples[multiples.length - 1] + timeUnits$1[units[i + 1][0]]) / 2;
                if (tickInterval <= lessThan) {
                  break;
                }
              }
            }
            if (interval === timeUnits$1.year && tickInterval < 5 * interval) {
              multiples = [1, 2, 5];
            }
            var count = normalizeTickInterval$1(tickInterval / interval, multiples, unit[0] === "year" ? (
              // #1913, #2360
              Math.max(getMagnitude$1(tickInterval / interval), 1)
            ) : 1);
            return {
              unitRange: interval,
              count,
              unitName: unit[0]
            };
          };
          Additions2.prototype.getXDateFormat = function(x, dateTimeLabelFormats) {
            var axis = this.axis;
            return axis.closestPointRange ? axis.chart.time.getDateFormat(axis.closestPointRange, x, axis.options.startOfWeek, dateTimeLabelFormats) || dateTimeLabelFormats.year : (
              // #2546, 2581
              dateTimeLabelFormats.day
            );
          };
          return Additions2;
        }()
      );
      DateTimeAxis2.Additions = Additions;
    })(DateTimeAxis || (DateTimeAxis = {}));
    const DateTimeAxis$1 = DateTimeAxis;
    var addEvent$Z = Utilities.addEvent, getMagnitude = Utilities.getMagnitude, normalizeTickInterval = Utilities.normalizeTickInterval, pick$1n = Utilities.pick;
    var LogarithmicAxis;
    (function(LogarithmicAxis2) {
      var composedClasses2 = [];
      function compose(AxisClass) {
        if (composedClasses2.indexOf(AxisClass) === -1) {
          composedClasses2.push(AxisClass);
          AxisClass.keepProps.push("logarithmic");
          addEvent$Z(AxisClass, "init", onInit);
          addEvent$Z(AxisClass, "afterInit", onAfterInit);
        }
        return AxisClass;
      }
      LogarithmicAxis2.compose = compose;
      function onInit(e2) {
        var axis = this;
        var options = e2.userOptions;
        var logarithmic = axis.logarithmic;
        if (options.type !== "logarithmic") {
          axis.logarithmic = void 0;
        } else {
          if (!logarithmic) {
            logarithmic = axis.logarithmic = new Additions(axis);
          }
        }
      }
      function onAfterInit() {
        var axis = this;
        var log = axis.logarithmic;
        if (log) {
          axis.lin2val = function(num) {
            return log.lin2log(num);
          };
          axis.val2lin = function(num) {
            return log.log2lin(num);
          };
        }
      }
      var Additions = (
        /** @class */
        function() {
          function Additions2(axis) {
            this.axis = axis;
          }
          Additions2.prototype.getLogTickPositions = function(interval, min, max, minor) {
            var log = this;
            var axis = log.axis;
            var axisLength = axis.len;
            var options = axis.options;
            var positions = [];
            if (!minor) {
              log.minorAutoInterval = void 0;
            }
            if (interval >= 0.5) {
              interval = Math.round(interval);
              positions = axis.getLinearTickPositions(interval, min, max);
            } else if (interval >= 0.08) {
              var roundedMin = Math.floor(min);
              var intermediate = void 0, i = void 0, j = void 0, len = void 0, pos = void 0, lastPos = void 0, break2 = void 0;
              if (interval > 0.3) {
                intermediate = [1, 2, 4];
              } else if (interval > 0.15) {
                intermediate = [1, 2, 4, 6, 8];
              } else {
                intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
              }
              for (i = roundedMin; i < max + 1 && !break2; i++) {
                len = intermediate.length;
                for (j = 0; j < len && !break2; j++) {
                  pos = log.log2lin(log.lin2log(i) * intermediate[j]);
                  if (pos > min && (!minor || lastPos <= max) && typeof lastPos !== "undefined") {
                    positions.push(lastPos);
                  }
                  if (lastPos > max) {
                    break2 = true;
                  }
                  lastPos = pos;
                }
              }
            } else {
              var realMin = log.lin2log(min), realMax = log.lin2log(max), tickIntervalOption = minor ? axis.getMinorTickInterval() : options.tickInterval, filteredTickIntervalOption = tickIntervalOption === "auto" ? null : tickIntervalOption, tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1), totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
              interval = pick$1n(filteredTickIntervalOption, log.minorAutoInterval, (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1));
              interval = normalizeTickInterval(interval, void 0, getMagnitude(interval));
              positions = axis.getLinearTickPositions(interval, realMin, realMax).map(log.log2lin);
              if (!minor) {
                log.minorAutoInterval = interval / 5;
              }
            }
            if (!minor) {
              axis.tickInterval = interval;
            }
            return positions;
          };
          Additions2.prototype.lin2log = function(num) {
            return Math.pow(10, num);
          };
          Additions2.prototype.log2lin = function(num) {
            return Math.log(num) / Math.LN10;
          };
          return Additions2;
        }()
      );
      LogarithmicAxis2.Additions = Additions;
    })(LogarithmicAxis || (LogarithmicAxis = {}));
    const LogarithmicAxis$1 = LogarithmicAxis;
    var erase$6 = Utilities.erase, extend$1h = Utilities.extend, isNumber$G = Utilities.isNumber;
    var PlotLineOrBandAxis;
    (function(PlotLineOrBandAxis2) {
      var composedClasses2 = [];
      var PlotLineOrBandClass;
      function compose(PlotLineOrBandType, AxisClass) {
        if (!PlotLineOrBandClass) {
          PlotLineOrBandClass = PlotLineOrBandType;
        }
        if (composedClasses2.indexOf(AxisClass) === -1) {
          composedClasses2.push(AxisClass);
          extend$1h(AxisClass.prototype, Additions.prototype);
        }
        return AxisClass;
      }
      PlotLineOrBandAxis2.compose = compose;
      var Additions = (
        /** @class */
        function() {
          function Additions2() {
          }
          Additions2.prototype.getPlotBandPath = function(from, to, options) {
            if (options === void 0) {
              options = this.options;
            }
            var toPath = this.getPlotLinePath({
              value: to,
              force: true,
              acrossPanes: options.acrossPanes
            }), result2 = [], horiz = this.horiz, outside = !isNumber$G(this.min) || !isNumber$G(this.max) || from < this.min && to < this.min || from > this.max && to > this.max;
            var path = this.getPlotLinePath({
              value: from,
              force: true,
              acrossPanes: options.acrossPanes
            }), i, plus = 1, isFlat;
            if (path && toPath) {
              if (outside) {
                isFlat = path.toString() === toPath.toString();
                plus = 0;
              }
              for (i = 0; i < path.length; i += 2) {
                var pathStart = path[i], pathEnd = path[i + 1], toPathStart = toPath[i], toPathEnd = toPath[i + 1];
                if ((pathStart[0] === "M" || pathStart[0] === "L") && (pathEnd[0] === "M" || pathEnd[0] === "L") && (toPathStart[0] === "M" || toPathStart[0] === "L") && (toPathEnd[0] === "M" || toPathEnd[0] === "L")) {
                  if (horiz && toPathStart[1] === pathStart[1]) {
                    toPathStart[1] += plus;
                    toPathEnd[1] += plus;
                  } else if (!horiz && toPathStart[2] === pathStart[2]) {
                    toPathStart[2] += plus;
                    toPathEnd[2] += plus;
                  }
                  result2.push(["M", pathStart[1], pathStart[2]], ["L", pathEnd[1], pathEnd[2]], ["L", toPathEnd[1], toPathEnd[2]], ["L", toPathStart[1], toPathStart[2]], ["Z"]);
                }
                result2.isFlat = isFlat;
              }
            } else {
              path = null;
            }
            return result2;
          };
          Additions2.prototype.addPlotBand = function(options) {
            return this.addPlotBandOrLine(options, "plotBands");
          };
          Additions2.prototype.addPlotLine = function(options) {
            return this.addPlotBandOrLine(options, "plotLines");
          };
          Additions2.prototype.addPlotBandOrLine = function(options, coll) {
            var _this = this;
            var userOptions = this.userOptions;
            var obj = new PlotLineOrBandClass(this, options);
            if (this.visible) {
              obj = obj.render();
            }
            if (obj) {
              if (!this._addedPlotLB) {
                this._addedPlotLB = true;
                (userOptions.plotLines || []).concat(userOptions.plotBands || []).forEach(function(plotLineOptions) {
                  _this.addPlotBandOrLine(plotLineOptions);
                });
              }
              if (coll) {
                var updatedOptions = userOptions[coll] || [];
                updatedOptions.push(options);
                userOptions[coll] = updatedOptions;
              }
              this.plotLinesAndBands.push(obj);
            }
            return obj;
          };
          Additions2.prototype.removePlotBandOrLine = function(id) {
            var plotLinesAndBands = this.plotLinesAndBands, options = this.options, userOptions = this.userOptions;
            if (plotLinesAndBands) {
              var i_1 = plotLinesAndBands.length;
              while (i_1--) {
                if (plotLinesAndBands[i_1].id === id) {
                  plotLinesAndBands[i_1].destroy();
                }
              }
              [
                options.plotLines || [],
                userOptions.plotLines || [],
                options.plotBands || [],
                userOptions.plotBands || []
              ].forEach(function(arr) {
                i_1 = arr.length;
                while (i_1--) {
                  if ((arr[i_1] || {}).id === id) {
                    erase$6(arr, arr[i_1]);
                  }
                }
              });
            }
          };
          Additions2.prototype.removePlotBand = function(id) {
            this.removePlotBandOrLine(id);
          };
          Additions2.prototype.removePlotLine = function(id) {
            this.removePlotBandOrLine(id);
          };
          return Additions2;
        }()
      );
    })(PlotLineOrBandAxis || (PlotLineOrBandAxis = {}));
    const PlotLineOrBandAxis$1 = PlotLineOrBandAxis;
    var arrayMax$8 = Utilities.arrayMax, arrayMin$7 = Utilities.arrayMin, defined$M = Utilities.defined, destroyObjectProperties$6 = Utilities.destroyObjectProperties, erase$5 = Utilities.erase, fireEvent$x = Utilities.fireEvent, merge$1f = Utilities.merge, objectEach$r = Utilities.objectEach, pick$1m = Utilities.pick;
    var PlotLineOrBand = (
      /** @class */
      function() {
        function PlotLineOrBand2(axis, options) {
          this.axis = axis;
          if (options) {
            this.options = options;
            this.id = options.id;
          }
        }
        PlotLineOrBand2.compose = function(AxisClass) {
          return PlotLineOrBandAxis$1.compose(PlotLineOrBand2, AxisClass);
        };
        PlotLineOrBand2.prototype.render = function() {
          fireEvent$x(this, "render");
          var plotLine = this, axis = plotLine.axis, horiz = axis.horiz, log = axis.logarithmic, options = plotLine.options, color2 = options.color, zIndex = pick$1m(options.zIndex, 0), events = options.events, groupAttribs = {}, renderer = axis.chart.renderer;
          var optionsLabel = options.label, label = plotLine.label, to = options.to, from = options.from, value = options.value, svgElem = plotLine.svgElem, path = [], group;
          var isBand = defined$M(from) && defined$M(to), isLine = defined$M(value), isNew = !svgElem, attribs = {
            "class": "highcharts-plot-" + (isBand ? "band " : "line ") + (options.className || "")
          };
          var groupName = isBand ? "bands" : "lines";
          if (log) {
            from = log.log2lin(from);
            to = log.log2lin(to);
            value = log.log2lin(value);
          }
          if (!axis.chart.styledMode) {
            if (isLine) {
              attribs.stroke = color2 || palette.neutralColor40;
              attribs["stroke-width"] = pick$1m(options.width, 1);
              if (options.dashStyle) {
                attribs.dashstyle = options.dashStyle;
              }
            } else if (isBand) {
              attribs.fill = color2 || palette.highlightColor10;
              if (options.borderWidth) {
                attribs.stroke = options.borderColor;
                attribs["stroke-width"] = options.borderWidth;
              }
            }
          }
          groupAttribs.zIndex = zIndex;
          groupName += "-" + zIndex;
          group = axis.plotLinesAndBandsGroups[groupName];
          if (!group) {
            axis.plotLinesAndBandsGroups[groupName] = group = renderer.g("plot-" + groupName).attr(groupAttribs).add();
          }
          if (isNew) {
            plotLine.svgElem = svgElem = renderer.path().attr(attribs).add(group);
          }
          if (isLine) {
            path = axis.getPlotLinePath({
              value,
              lineWidth: svgElem.strokeWidth(),
              acrossPanes: options.acrossPanes
            });
          } else if (isBand) {
            path = axis.getPlotBandPath(from, to, options);
          } else {
            return;
          }
          if (!plotLine.eventsAdded && events) {
            objectEach$r(events, function(event, eventType) {
              svgElem.on(eventType, function(e2) {
                events[eventType].apply(plotLine, [e2]);
              });
            });
            plotLine.eventsAdded = true;
          }
          if ((isNew || !svgElem.d) && path && path.length) {
            svgElem.attr({ d: path });
          } else if (svgElem) {
            if (path) {
              svgElem.show(true);
              svgElem.animate({ d: path });
            } else if (svgElem.d) {
              svgElem.hide();
              if (label) {
                plotLine.label = label = label.destroy();
              }
            }
          }
          if (optionsLabel && (defined$M(optionsLabel.text) || defined$M(optionsLabel.formatter)) && path && path.length && axis.width > 0 && axis.height > 0 && !path.isFlat) {
            optionsLabel = merge$1f({
              align: horiz && isBand && "center",
              x: horiz ? !isBand && 4 : 10,
              verticalAlign: !horiz && isBand && "middle",
              y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
              rotation: horiz && !isBand && 90
            }, optionsLabel);
            this.renderLabel(optionsLabel, path, isBand, zIndex);
          } else if (label) {
            label.hide();
          }
          return plotLine;
        };
        PlotLineOrBand2.prototype.renderLabel = function(optionsLabel, path, isBand, zIndex) {
          var plotLine = this, axis = plotLine.axis, renderer = axis.chart.renderer;
          var label = plotLine.label;
          if (!label) {
            plotLine.label = label = renderer.text(this.getLabelText(optionsLabel), 0, 0, optionsLabel.useHTML).attr({
              align: optionsLabel.textAlign || optionsLabel.align,
              rotation: optionsLabel.rotation,
              "class": "highcharts-plot-" + (isBand ? "band" : "line") + "-label " + (optionsLabel.className || ""),
              zIndex
            }).add();
            if (!axis.chart.styledMode) {
              label.css(merge$1f({
                textOverflow: "ellipsis"
              }, optionsLabel.style));
            }
          }
          var xBounds = path.xBounds || [path[0][1], path[1][1], isBand ? path[2][1] : path[0][1]];
          var yBounds = path.yBounds || [path[0][2], path[1][2], isBand ? path[2][2] : path[0][2]];
          var x = arrayMin$7(xBounds);
          var y = arrayMin$7(yBounds);
          label.align(optionsLabel, false, {
            x,
            y,
            width: arrayMax$8(xBounds) - x,
            height: arrayMax$8(yBounds) - y
          });
          if (!label.alignValue || label.alignValue === "left") {
            label.css({
              width: (label.rotation === 90 ? axis.height - (label.alignAttr.y - axis.top) : axis.width - (label.alignAttr.x - axis.left)) + "px"
            });
          }
          label.show(true);
        };
        PlotLineOrBand2.prototype.getLabelText = function(optionsLabel) {
          return defined$M(optionsLabel.formatter) ? optionsLabel.formatter.call(this) : optionsLabel.text;
        };
        PlotLineOrBand2.prototype.destroy = function() {
          erase$5(this.axis.plotLinesAndBands, this);
          delete this.axis;
          destroyObjectProperties$6(this);
        };
        return PlotLineOrBand2;
      }()
    );
    var format$d = FormatUtilities.format;
    var doc$i = H.doc;
    var distribute$3 = R.distribute;
    var addEvent$Y = Utilities.addEvent, clamp$f = Utilities.clamp, css$9 = Utilities.css, defined$L = Utilities.defined, discardElement$5 = Utilities.discardElement, extend$1g = Utilities.extend, fireEvent$w = Utilities.fireEvent, isArray$i = Utilities.isArray, isNumber$F = Utilities.isNumber, isString$6 = Utilities.isString, merge$1e = Utilities.merge, pick$1l = Utilities.pick, splat$f = Utilities.splat, syncTimeout$6 = Utilities.syncTimeout;
    var Tooltip = (
      /** @class */
      function() {
        function Tooltip2(chart, options) {
          this.container = void 0;
          this.crosshairs = [];
          this.distance = 0;
          this.isHidden = true;
          this.isSticky = false;
          this.now = {};
          this.options = {};
          this.outside = false;
          this.chart = chart;
          this.init(chart, options);
        }
        Tooltip2.prototype.applyFilter = function() {
          var chart = this.chart;
          chart.renderer.definition({
            tagName: "filter",
            attributes: {
              id: "drop-shadow-" + chart.index,
              opacity: 0.5
            },
            children: [{
              tagName: "feGaussianBlur",
              attributes: {
                "in": "SourceAlpha",
                stdDeviation: 1
              }
            }, {
              tagName: "feOffset",
              attributes: {
                dx: 1,
                dy: 1
              }
            }, {
              tagName: "feComponentTransfer",
              children: [{
                tagName: "feFuncA",
                attributes: {
                  type: "linear",
                  slope: 0.3
                }
              }]
            }, {
              tagName: "feMerge",
              children: [{
                tagName: "feMergeNode"
              }, {
                tagName: "feMergeNode",
                attributes: {
                  "in": "SourceGraphic"
                }
              }]
            }]
          });
        };
        Tooltip2.prototype.bodyFormatter = function(items) {
          return items.map(function(item2) {
            var tooltipOptions = item2.series.tooltipOptions;
            return (tooltipOptions[(item2.point.formatPrefix || "point") + "Formatter"] || item2.point.tooltipFormatter).call(item2.point, tooltipOptions[(item2.point.formatPrefix || "point") + "Format"] || "");
          });
        };
        Tooltip2.prototype.cleanSplit = function(force) {
          this.chart.series.forEach(function(series) {
            var tt = series && series.tt;
            if (tt) {
              if (!tt.isActive || force) {
                series.tt = tt.destroy();
              } else {
                tt.isActive = false;
              }
            }
          });
        };
        Tooltip2.prototype.defaultFormatter = function(tooltip) {
          var items = this.points || splat$f(this);
          var s;
          s = [tooltip.tooltipFooterHeaderFormatter(items[0])];
          s = s.concat(tooltip.bodyFormatter(items));
          s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));
          return s;
        };
        Tooltip2.prototype.destroy = function() {
          if (this.label) {
            this.label = this.label.destroy();
          }
          if (this.split && this.tt) {
            this.cleanSplit(this.chart, true);
            this.tt = this.tt.destroy();
          }
          if (this.renderer) {
            this.renderer = this.renderer.destroy();
            discardElement$5(this.container);
          }
          Utilities.clearTimeout(this.hideTimer);
          Utilities.clearTimeout(this.tooltipTimeout);
        };
        Tooltip2.prototype.getAnchor = function(points, mouseEvent) {
          var chart = this.chart, pointer = chart.pointer, inverted = chart.inverted, plotTop = chart.plotTop, plotLeft = chart.plotLeft;
          var ret, yAxis, xAxis, plotX = 0, plotY = 0;
          points = splat$f(points);
          if (this.followPointer && mouseEvent) {
            if (typeof mouseEvent.chartX === "undefined") {
              mouseEvent = pointer.normalize(mouseEvent);
            }
            ret = [
              mouseEvent.chartX - plotLeft,
              mouseEvent.chartY - plotTop
            ];
          } else if (points[0].tooltipPos) {
            ret = points[0].tooltipPos;
          } else {
            points.forEach(function(point) {
              yAxis = point.series.yAxis;
              xAxis = point.series.xAxis;
              plotX += point.plotX || 0;
              plotY += point.plotLow ? (point.plotLow + (point.plotHigh || 0)) / 2 : point.plotY || 0;
              if (xAxis && yAxis) {
                if (!inverted) {
                  plotX += xAxis.pos - plotLeft;
                  plotY += yAxis.pos - plotTop;
                } else {
                  plotX += plotTop + chart.plotHeight - xAxis.len - xAxis.pos;
                  plotY += plotLeft + chart.plotWidth - yAxis.len - yAxis.pos;
                }
              }
            });
            plotX /= points.length;
            plotY /= points.length;
            ret = [
              inverted ? chart.plotWidth - plotY : plotX,
              inverted ? chart.plotHeight - plotX : plotY
            ];
            if (this.shared && points.length > 1 && mouseEvent) {
              if (inverted) {
                ret[0] = mouseEvent.chartX - plotLeft;
              } else {
                ret[1] = mouseEvent.chartY - plotTop;
              }
            }
          }
          return ret.map(Math.round);
        };
        Tooltip2.prototype.getLabel = function() {
          var tooltip = this, styledMode = this.chart.styledMode, options = this.options, className = "tooltip" + (defined$L(options.className) ? " " + options.className : ""), pointerEvents = options.style.pointerEvents || (!this.followPointer && options.stickOnContact ? "auto" : "none"), onMouseEnter = function() {
            tooltip.inContact = true;
          }, onMouseLeave = function(e2) {
            var series = tooltip.chart.hoverSeries;
            tooltip.inContact = tooltip.shouldStickOnContact() && tooltip.chart.pointer.inClass(e2.relatedTarget, "highcharts-tooltip");
            if (!tooltip.inContact && series && series.onMouseOut) {
              series.onMouseOut();
            }
          };
          var container, renderer = this.chart.renderer;
          if (!this.label) {
            if (this.outside) {
              var chartStyle = this.chart.options.chart.style, Renderer2 = RendererRegistry$1.getRendererType();
              this.container = container = H.doc.createElement("div");
              container.className = "highcharts-tooltip-container";
              css$9(container, {
                position: "absolute",
                top: "1px",
                pointerEvents,
                zIndex: Math.max(this.options.style.zIndex || 0, (chartStyle && chartStyle.zIndex || 0) + 3)
              });
              addEvent$Y(container, "mouseenter", onMouseEnter);
              addEvent$Y(container, "mouseleave", onMouseLeave);
              H.doc.body.appendChild(container);
              this.renderer = renderer = new Renderer2(container, 0, 0, chartStyle, void 0, void 0, renderer.styledMode);
            }
            if (this.split) {
              this.label = renderer.g(className);
            } else {
              this.label = renderer.label("", 0, 0, options.shape, void 0, void 0, options.useHTML, void 0, className).attr({
                padding: options.padding,
                r: options.borderRadius
              });
              if (!styledMode) {
                this.label.attr({
                  fill: options.backgroundColor,
                  "stroke-width": options.borderWidth
                }).css(options.style).css({ pointerEvents }).shadow(options.shadow);
              }
            }
            if (styledMode && options.shadow) {
              this.applyFilter();
              this.label.attr({
                filter: "url(#drop-shadow-" + this.chart.index + ")"
              });
            }
            if (tooltip.outside && !tooltip.split) {
              var label_1 = this.label;
              var xSetter_1 = label_1.xSetter, ySetter_1 = label_1.ySetter;
              label_1.xSetter = function(value) {
                xSetter_1.call(label_1, tooltip.distance);
                container.style.left = value + "px";
              };
              label_1.ySetter = function(value) {
                ySetter_1.call(label_1, tooltip.distance);
                container.style.top = value + "px";
              };
            }
            this.label.on("mouseenter", onMouseEnter).on("mouseleave", onMouseLeave).attr({ zIndex: 8 }).add();
          }
          return this.label;
        };
        Tooltip2.prototype.getPosition = function(boxWidth, boxHeight, point) {
          var chart = this.chart, distance = this.distance, ret = {}, h = chart.inverted && point.h || 0, outside = this.outside, outerWidth = outside ? (
            // substract distance to prevent scrollbars
            doc$i.documentElement.clientWidth - 2 * distance
          ) : chart.chartWidth, outerHeight = outside ? Math.max(doc$i.body.scrollHeight, doc$i.documentElement.scrollHeight, doc$i.body.offsetHeight, doc$i.documentElement.offsetHeight, doc$i.documentElement.clientHeight) : chart.chartHeight, chartPosition = chart.pointer.getChartPosition(), scaleX = function(val) {
            return (
              // eslint-disable-line no-confusing-arrow
              val * chartPosition.scaleX
            );
          }, scaleY = function(val) {
            return (
              // eslint-disable-line no-confusing-arrow
              val * chartPosition.scaleY
            );
          }, buildDimensionArray = function(dim) {
            var isX = dim === "x";
            return [
              dim,
              isX ? outerWidth : outerHeight,
              isX ? boxWidth : boxHeight
            ].concat(outside ? [
              // If we are using tooltip.outside, we need to scale the
              // position to match scaling of the container in case there
              // is a transform/zoom on the container. #11329
              isX ? scaleX(boxWidth) : scaleY(boxHeight),
              isX ? chartPosition.left - distance + scaleX(point.plotX + chart.plotLeft) : chartPosition.top - distance + scaleY(point.plotY + chart.plotTop),
              0,
              isX ? outerWidth : outerHeight
            ] : [
              // Not outside, no scaling is needed
              isX ? boxWidth : boxHeight,
              isX ? point.plotX + chart.plotLeft : point.plotY + chart.plotTop,
              isX ? chart.plotLeft : chart.plotTop,
              isX ? chart.plotLeft + chart.plotWidth : chart.plotTop + chart.plotHeight
            ]);
          };
          var first = buildDimensionArray("y"), second = buildDimensionArray("x"), swapped;
          var preferFarSide = !this.followPointer && pick$1l(point.ttBelow, !chart.inverted === !!point.negative), firstDimension = function(dim, outerSize, innerSize, scaledInnerSize, point2, min, max) {
            var scaledDist = outside ? dim === "y" ? scaleY(distance) : scaleX(distance) : distance, scaleDiff = (innerSize - scaledInnerSize) / 2, roomLeft = scaledInnerSize < point2 - distance, roomRight = point2 + distance + scaledInnerSize < outerSize, alignedLeft = point2 - scaledDist - innerSize + scaleDiff, alignedRight = point2 + scaledDist - scaleDiff;
            if (preferFarSide && roomRight) {
              ret[dim] = alignedRight;
            } else if (!preferFarSide && roomLeft) {
              ret[dim] = alignedLeft;
            } else if (roomLeft) {
              ret[dim] = Math.min(max - scaledInnerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);
            } else if (roomRight) {
              ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);
            } else {
              return false;
            }
          }, secondDimension = function(dim, outerSize, innerSize, scaledInnerSize, point2) {
            var retVal;
            if (point2 < distance || point2 > outerSize - distance) {
              retVal = false;
            } else if (point2 < innerSize / 2) {
              ret[dim] = 1;
            } else if (point2 > outerSize - scaledInnerSize / 2) {
              ret[dim] = outerSize - scaledInnerSize - 2;
            } else {
              ret[dim] = point2 - innerSize / 2;
            }
            return retVal;
          }, swap = function(count) {
            var temp = first;
            first = second;
            second = temp;
            swapped = count;
          }, run = function() {
            if (firstDimension.apply(0, first) !== false) {
              if (secondDimension.apply(0, second) === false && !swapped) {
                swap(true);
                run();
              }
            } else if (!swapped) {
              swap(true);
              run();
            } else {
              ret.x = ret.y = 0;
            }
          };
          if (chart.inverted || this.len > 1) {
            swap();
          }
          run();
          return ret;
        };
        Tooltip2.prototype.hide = function(delay) {
          var tooltip = this;
          Utilities.clearTimeout(this.hideTimer);
          delay = pick$1l(delay, this.options.hideDelay);
          if (!this.isHidden) {
            this.hideTimer = syncTimeout$6(function() {
              tooltip.getLabel().fadeOut(delay ? void 0 : delay);
              tooltip.isHidden = true;
            }, delay);
          }
        };
        Tooltip2.prototype.init = function(chart, options) {
          this.chart = chart;
          this.options = options;
          this.crosshairs = [];
          this.now = { x: 0, y: 0 };
          this.isHidden = true;
          this.split = options.split && !chart.inverted && !chart.polar;
          this.shared = options.shared || this.split;
          this.outside = pick$1l(options.outside, Boolean(chart.scrollablePixelsX || chart.scrollablePixelsY));
        };
        Tooltip2.prototype.shouldStickOnContact = function() {
          return !!(!this.followPointer && this.options.stickOnContact);
        };
        Tooltip2.prototype.isStickyOnContact = function() {
          return !!(this.shouldStickOnContact() && this.inContact);
        };
        Tooltip2.prototype.move = function(x, y, anchorX, anchorY) {
          var tooltip = this, now = tooltip.now, animate2 = tooltip.options.animation !== false && !tooltip.isHidden && // When we get close to the target position, abort animation and
          // land on the right place (#3056)
          (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1), skipAnchor = tooltip.followPointer || tooltip.len > 1;
          extend$1g(now, {
            x: animate2 ? (2 * now.x + x) / 3 : x,
            y: animate2 ? (now.y + y) / 2 : y,
            anchorX: skipAnchor ? void 0 : animate2 ? (2 * now.anchorX + anchorX) / 3 : anchorX,
            anchorY: skipAnchor ? void 0 : animate2 ? (now.anchorY + anchorY) / 2 : anchorY
          });
          tooltip.getLabel().attr(now);
          tooltip.drawTracker();
          if (animate2) {
            Utilities.clearTimeout(this.tooltipTimeout);
            this.tooltipTimeout = setTimeout(function() {
              if (tooltip) {
                tooltip.move(x, y, anchorX, anchorY);
              }
            }, 32);
          }
        };
        Tooltip2.prototype.refresh = function(pointOrPoints, mouseEvent) {
          var tooltip = this, chart = this.chart, options = tooltip.options, points = splat$f(pointOrPoints), point = points[0], pointConfig = [], formatter = options.formatter || tooltip.defaultFormatter, shared = tooltip.shared, styledMode = chart.styledMode;
          var textConfig = {};
          if (!options.enabled) {
            return;
          }
          Utilities.clearTimeout(this.hideTimer);
          tooltip.followPointer = !tooltip.split && point.series.tooltipOptions.followPointer;
          var anchor = tooltip.getAnchor(pointOrPoints, mouseEvent), x = anchor[0], y = anchor[1];
          if (shared && !(!isArray$i(pointOrPoints) && pointOrPoints.series && pointOrPoints.series.noSharedTooltip)) {
            chart.pointer.applyInactiveState(points);
            points.forEach(function(item2) {
              item2.setState("hover");
              pointConfig.push(item2.getLabelConfig());
            });
            textConfig = {
              x: point.category,
              y: point.y
            };
            textConfig.points = pointConfig;
          } else {
            textConfig = point.getLabelConfig();
          }
          this.len = pointConfig.length;
          var text = formatter.call(textConfig, tooltip);
          var currentSeries = point.series;
          this.distance = pick$1l(currentSeries.tooltipOptions.distance, 16);
          if (text === false) {
            this.hide();
          } else {
            if (tooltip.split) {
              this.renderSplit(text, points);
            } else {
              var checkX = x;
              var checkY = y;
              if (mouseEvent && chart.pointer.isDirectTouch) {
                checkX = mouseEvent.chartX - chart.plotLeft;
                checkY = mouseEvent.chartY - chart.plotTop;
              }
              if (chart.polar || currentSeries.options.clip === false || currentSeries.shouldShowTooltip(checkX, checkY)) {
                var label = tooltip.getLabel();
                if (!options.style.width || styledMode) {
                  label.css({
                    width: this.chart.spacingBox.width + "px"
                  });
                }
                label.attr({
                  text: text && text.join ? text.join("") : text
                });
                label.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + pick$1l(point.colorIndex, currentSeries.colorIndex));
                if (!styledMode) {
                  label.attr({
                    stroke: options.borderColor || point.color || currentSeries.color || palette.neutralColor60
                  });
                }
                tooltip.updatePosition({
                  plotX: x,
                  plotY: y,
                  negative: point.negative,
                  ttBelow: point.ttBelow,
                  h: anchor[2] || 0
                });
              } else {
                tooltip.hide();
                return;
              }
            }
            if (tooltip.isHidden && tooltip.label) {
              tooltip.label.attr({
                opacity: 1
              }).show();
            }
            tooltip.isHidden = false;
          }
          fireEvent$w(this, "refresh");
        };
        Tooltip2.prototype.renderSplit = function(labels, points) {
          var tooltip = this;
          var chart = tooltip.chart, _a2 = tooltip.chart, chartWidth = _a2.chartWidth, chartHeight = _a2.chartHeight, plotHeight = _a2.plotHeight, plotLeft = _a2.plotLeft, plotTop = _a2.plotTop, pointer = _a2.pointer, _b = _a2.scrollablePixelsY, scrollablePixelsY = _b === void 0 ? 0 : _b, scrollablePixelsX = _a2.scrollablePixelsX, _c = _a2.scrollingContainer, _d = _c === void 0 ? { scrollLeft: 0, scrollTop: 0 } : _c, scrollLeft = _d.scrollLeft, scrollTop = _d.scrollTop, styledMode = _a2.styledMode, distance = tooltip.distance, options = tooltip.options, positioner = tooltip.options.positioner;
          var bounds = tooltip.outside && typeof scrollablePixelsX !== "number" ? doc$i.documentElement.getBoundingClientRect() : {
            left: scrollLeft,
            right: scrollLeft + chartWidth,
            top: scrollTop,
            bottom: scrollTop + chartHeight
          };
          var tooltipLabel = tooltip.getLabel();
          var ren = this.renderer || chart.renderer;
          var headerTop = Boolean(chart.xAxis[0] && chart.xAxis[0].opposite);
          var _e = pointer.getChartPosition(), chartLeft = _e.left, chartTop = _e.top;
          var distributionBoxTop = plotTop + scrollTop;
          var headerHeight = 0;
          var adjustedPlotHeight = plotHeight - scrollablePixelsY;
          function getAnchor(point) {
            var isHeader = point.isHeader, _a3 = point.plotX, plotX = _a3 === void 0 ? 0 : _a3, _b2 = point.plotY, plotY = _b2 === void 0 ? 0 : _b2, series = point.series;
            var anchorX;
            var anchorY;
            if (isHeader) {
              anchorX = plotLeft + plotX;
              anchorY = plotTop + plotHeight / 2;
            } else {
              var xAxis = series.xAxis, yAxis = series.yAxis;
              anchorX = xAxis.pos + clamp$f(plotX, -distance, xAxis.len + distance);
              if (series.shouldShowTooltip(0, yAxis.pos - plotTop + plotY, {
                ignoreX: true
              })) {
                anchorY = yAxis.pos + plotY;
              }
            }
            anchorX = clamp$f(anchorX, bounds.left - distance, bounds.right + distance);
            return { anchorX, anchorY };
          }
          function defaultPositioner(anchorX, anchorY, isHeader, boxWidth, alignedLeft) {
            if (alignedLeft === void 0) {
              alignedLeft = true;
            }
            var y2;
            var x2;
            if (isHeader) {
              y2 = headerTop ? 0 : adjustedPlotHeight;
              x2 = clamp$f(anchorX - boxWidth / 2, bounds.left, bounds.right - boxWidth - (tooltip.outside ? chartLeft : 0));
            } else {
              y2 = anchorY - distributionBoxTop;
              x2 = alignedLeft ? anchorX - boxWidth - distance : anchorX + distance;
              x2 = clamp$f(x2, alignedLeft ? x2 : bounds.left, bounds.right);
            }
            return { x: x2, y: y2 };
          }
          function updatePartialTooltip(partialTooltip, point, str) {
            var tt = partialTooltip;
            var isHeader = point.isHeader, series = point.series;
            var colorClass = "highcharts-color-" + pick$1l(point.colorIndex, series.colorIndex, "none");
            if (!tt) {
              var attribs = {
                padding: options.padding,
                r: options.borderRadius
              };
              if (!styledMode) {
                attribs.fill = options.backgroundColor;
                attribs["stroke-width"] = options.borderWidth;
              }
              tt = ren.label("", 0, 0, options[isHeader ? "headerShape" : "shape"], void 0, void 0, options.useHTML).addClass((isHeader ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + colorClass).attr(attribs).add(tooltipLabel);
            }
            tt.isActive = true;
            tt.attr({
              text: str
            });
            if (!styledMode) {
              tt.css(options.style).shadow(options.shadow).attr({
                stroke: options.borderColor || point.color || series.color || palette.neutralColor80
              });
            }
            return tt;
          }
          if (isString$6(labels)) {
            labels = [false, labels];
          }
          var boxes = labels.slice(0, points.length + 1).reduce(function(boxes2, str, i) {
            if (str !== false && str !== "") {
              var point = points[i - 1] || {
                // Item 0 is the header. Instead of this, we could also
                // use the crosshair label
                isHeader: true,
                plotX: points[0].plotX,
                plotY: plotHeight,
                series: {}
              };
              var isHeader = point.isHeader;
              var owner = isHeader ? tooltip : point.series;
              var tt = owner.tt = updatePartialTooltip(owner.tt, point, str.toString());
              var bBox = tt.getBBox();
              var boxWidth = bBox.width + tt.strokeWidth();
              if (isHeader) {
                headerHeight = bBox.height;
                adjustedPlotHeight += headerHeight;
                if (headerTop) {
                  distributionBoxTop -= headerHeight;
                }
              }
              var _a3 = getAnchor(point), anchorX = _a3.anchorX, anchorY = _a3.anchorY;
              if (typeof anchorY === "number") {
                var size = bBox.height + 1;
                var boxPosition = positioner ? positioner.call(tooltip, boxWidth, size, point) : defaultPositioner(anchorX, anchorY, isHeader, boxWidth);
                boxes2.push({
                  // 0-align to the top, 1-align to the bottom
                  align: positioner ? 0 : void 0,
                  anchorX,
                  anchorY,
                  boxWidth,
                  point,
                  rank: pick$1l(boxPosition.rank, isHeader ? 1 : 0),
                  size,
                  target: boxPosition.y,
                  tt,
                  x: boxPosition.x
                });
              } else {
                tt.isActive = false;
              }
            }
            return boxes2;
          }, []);
          if (!positioner && boxes.some(function(box) {
            var outside2 = tooltip.outside;
            var boxStart = (outside2 ? chartLeft : 0) + box.anchorX;
            if (boxStart < bounds.left && boxStart + box.boxWidth < bounds.right) {
              return true;
            }
            return boxStart < chartLeft - bounds.left + box.boxWidth && bounds.right - boxStart > boxStart;
          })) {
            boxes = boxes.map(function(box) {
              var _a3 = defaultPositioner(box.anchorX, box.anchorY, box.point.isHeader, box.boxWidth, false), x2 = _a3.x, y2 = _a3.y;
              return extend$1g(box, {
                target: y2,
                x: x2
              });
            });
          }
          tooltip.cleanSplit();
          distribute$3(boxes, adjustedPlotHeight);
          var boxExtremes = {
            left: chartLeft,
            right: chartLeft
          };
          boxes.forEach(function(box) {
            var x2 = box.x, boxWidth = box.boxWidth, isHeader = box.isHeader;
            if (!isHeader) {
              if (tooltip.outside && chartLeft + x2 < boxExtremes.left) {
                boxExtremes.left = chartLeft + x2;
              }
              if (!isHeader && tooltip.outside && boxExtremes.left + boxWidth > boxExtremes.right) {
                boxExtremes.right = chartLeft + x2;
              }
            }
          });
          boxes.forEach(function(box) {
            var x2 = box.x, anchorX = box.anchorX, anchorY = box.anchorY, pos = box.pos, isHeader = box.point.isHeader;
            var attributes = {
              visibility: typeof pos === "undefined" ? "hidden" : "inherit",
              x: x2,
              /* NOTE: y should equal pos to be consistent with !split
               * tooltip, but is currently relative to plotTop. Is left as is
               * to avoid breaking change. Remove distributionBoxTop to make
               * it consistent.
               */
              y: pos + distributionBoxTop,
              anchorX,
              anchorY
            };
            if (tooltip.outside && x2 < anchorX) {
              var offset2 = chartLeft - boxExtremes.left;
              if (offset2 > 0) {
                if (!isHeader) {
                  attributes.x = x2 + offset2;
                  attributes.anchorX = anchorX + offset2;
                }
                if (isHeader) {
                  attributes.x = (boxExtremes.right - boxExtremes.left) / 2;
                  attributes.anchorX = anchorX + offset2;
                }
              }
            }
            box.tt.attr(attributes);
          });
          var container = tooltip.container, outside = tooltip.outside, renderer = tooltip.renderer;
          if (outside && container && renderer) {
            var _f = tooltipLabel.getBBox(), width = _f.width, height = _f.height, x = _f.x, y = _f.y;
            renderer.setSize(width + x, height + y, false);
            container.style.left = boxExtremes.left + "px";
            container.style.top = chartTop + "px";
          }
        };
        Tooltip2.prototype.drawTracker = function() {
          var tooltip = this;
          if (tooltip.followPointer || !tooltip.options.stickOnContact) {
            if (tooltip.tracker) {
              tooltip.tracker.destroy();
            }
            return;
          }
          var chart = tooltip.chart;
          var label = tooltip.label;
          var points = tooltip.shared ? chart.hoverPoints : chart.hoverPoint;
          if (!label || !points) {
            return;
          }
          var box = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
          var anchorPos = this.getAnchor(points);
          var labelBBox = label.getBBox();
          anchorPos[0] += chart.plotLeft - label.translateX;
          anchorPos[1] += chart.plotTop - label.translateY;
          box.x = Math.min(0, anchorPos[0]);
          box.y = Math.min(0, anchorPos[1]);
          box.width = anchorPos[0] < 0 ? Math.max(Math.abs(anchorPos[0]), labelBBox.width - anchorPos[0]) : Math.max(Math.abs(anchorPos[0]), labelBBox.width);
          box.height = anchorPos[1] < 0 ? Math.max(Math.abs(anchorPos[1]), labelBBox.height - Math.abs(anchorPos[1])) : Math.max(Math.abs(anchorPos[1]), labelBBox.height);
          if (tooltip.tracker) {
            tooltip.tracker.attr(box);
          } else {
            tooltip.tracker = label.renderer.rect(box).addClass("highcharts-tracker").add(label);
            if (!chart.styledMode) {
              tooltip.tracker.attr({
                fill: "rgba(0,0,0,0)"
              });
            }
          }
        };
        Tooltip2.prototype.styledModeFormat = function(formatString) {
          return formatString.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
        };
        Tooltip2.prototype.tooltipFooterHeaderFormatter = function(labelConfig, isFooter) {
          var series = labelConfig.series, tooltipOptions = series.tooltipOptions, xAxis = series.xAxis, dateTime = xAxis && xAxis.dateTime, e2 = {
            isFooter,
            labelConfig
          };
          var xDateFormat = tooltipOptions.xDateFormat, formatString = tooltipOptions[isFooter ? "footerFormat" : "headerFormat"];
          fireEvent$w(this, "headerFormatter", e2, function(e3) {
            if (dateTime && !xDateFormat && isNumber$F(labelConfig.key)) {
              xDateFormat = dateTime.getXDateFormat(labelConfig.key, tooltipOptions.dateTimeLabelFormats);
            }
            if (dateTime && xDateFormat) {
              (labelConfig.point && labelConfig.point.tooltipDateKeys || ["key"]).forEach(function(key) {
                formatString = formatString.replace("{point." + key + "}", "{point." + key + ":" + xDateFormat + "}");
              });
            }
            if (series.chart.styledMode) {
              formatString = this.styledModeFormat(formatString);
            }
            e3.text = format$d(formatString, {
              point: labelConfig,
              series
            }, this.chart);
          });
          return e2.text;
        };
        Tooltip2.prototype.update = function(options) {
          this.destroy();
          merge$1e(true, this.chart.options.tooltip.userOptions, options);
          this.init(this.chart, merge$1e(true, this.options, options));
        };
        Tooltip2.prototype.updatePosition = function(point) {
          var chart = this.chart, options = this.options, pointer = chart.pointer, label = this.getLabel(), chartPosition = pointer.getChartPosition(), pos = (options.positioner || this.getPosition).call(this, label.width, label.height, point);
          var anchorX = point.plotX + chart.plotLeft, anchorY = point.plotY + chart.plotTop, pad2;
          if (this.outside) {
            pad2 = options.borderWidth + 2 * this.distance;
            this.renderer.setSize(label.width + pad2, label.height + pad2, false);
            if (chartPosition.scaleX !== 1 || chartPosition.scaleY !== 1) {
              css$9(this.container, {
                transform: "scale(" + chartPosition.scaleX + ", " + chartPosition.scaleY + ")"
              });
              anchorX *= chartPosition.scaleX;
              anchorY *= chartPosition.scaleY;
            }
            anchorX += chartPosition.left - pos.x;
            anchorY += chartPosition.top - pos.y;
          }
          this.move(
            Math.round(pos.x),
            Math.round(pos.y || 0),
            // can be undefined (#3977)
            anchorX,
            anchorY
          );
        };
        return Tooltip2;
      }()
    );
    var animObject$9 = animationExports.animObject;
    var defaultOptions$d = DefaultOptions.defaultOptions;
    var format$c = FormatUtilities.format;
    var addEvent$X = Utilities.addEvent, defined$K = Utilities.defined, erase$4 = Utilities.erase, extend$1f = Utilities.extend, fireEvent$v = Utilities.fireEvent, getNestedProperty$1 = Utilities.getNestedProperty, isArray$h = Utilities.isArray, isFunction$2 = Utilities.isFunction, isNumber$E = Utilities.isNumber, isObject$b = Utilities.isObject, merge$1d = Utilities.merge, objectEach$q = Utilities.objectEach, pick$1k = Utilities.pick, syncTimeout$5 = Utilities.syncTimeout, removeEvent$8 = Utilities.removeEvent, uniqueKey$5 = Utilities.uniqueKey;
    var Point$2 = (
      /** @class */
      function() {
        function Point2() {
          this.category = void 0;
          this.colorIndex = void 0;
          this.formatPrefix = "point";
          this.id = void 0;
          this.isNull = false;
          this.name = void 0;
          this.options = void 0;
          this.percentage = void 0;
          this.selected = false;
          this.series = void 0;
          this.total = void 0;
          this.visible = true;
          this.x = void 0;
        }
        Point2.prototype.animateBeforeDestroy = function() {
          var point = this, animateParams = { x: point.startXPos, opacity: 0 }, graphicalProps = point.getGraphicalProps();
          graphicalProps.singular.forEach(function(prop) {
            var isDataLabel = prop === "dataLabel";
            point[prop] = point[prop].animate(isDataLabel ? {
              x: point[prop].startXPos,
              y: point[prop].startYPos,
              opacity: 0
            } : animateParams);
          });
          graphicalProps.plural.forEach(function(plural) {
            point[plural].forEach(function(item2) {
              if (item2.element) {
                item2.animate(extend$1f({ x: point.startXPos }, item2.startYPos ? {
                  x: item2.startXPos,
                  y: item2.startYPos
                } : {}));
              }
            });
          });
        };
        Point2.prototype.applyOptions = function(options, x) {
          var point = this, series = point.series, pointValKey = series.options.pointValKey || series.pointValKey;
          options = Point2.prototype.optionsToObject.call(this, options);
          extend$1f(point, options);
          point.options = point.options ? extend$1f(point.options, options) : options;
          if (options.group) {
            delete point.group;
          }
          if (options.dataLabels) {
            delete point.dataLabels;
          }
          if (pointValKey) {
            point.y = Point2.prototype.getNestedProperty.call(point, pointValKey);
          }
          point.isNull = pick$1k(point.isValid && !point.isValid(), point.x === null || !isNumber$E(point.y));
          point.formatPrefix = point.isNull ? "null" : "point";
          if (point.selected) {
            point.state = "select";
          }
          if ("name" in point && typeof x === "undefined" && series.xAxis && series.xAxis.hasNames) {
            point.x = series.xAxis.nameToX(point);
          }
          if (typeof point.x === "undefined" && series) {
            if (typeof x === "undefined") {
              point.x = series.autoIncrement();
            } else {
              point.x = x;
            }
          } else if (isNumber$E(options.x) && series.options.relativeXValue) {
            point.x = series.autoIncrement(options.x);
          }
          return point;
        };
        Point2.prototype.destroy = function() {
          var point = this, series = point.series, chart = series.chart, dataSorting = series.options.dataSorting, hoverPoints = chart.hoverPoints, globalAnimation = point.series.chart.renderer.globalAnimation, animation = animObject$9(globalAnimation);
          var prop;
          function destroyPoint() {
            if (point.graphic || point.dataLabel || point.dataLabels) {
              removeEvent$8(point);
              point.destroyElements();
            }
            for (prop in point) {
              point[prop] = null;
            }
          }
          if (point.legendItem) {
            chart.legend.destroyItem(point);
          }
          if (hoverPoints) {
            point.setState();
            erase$4(hoverPoints, point);
            if (!hoverPoints.length) {
              chart.hoverPoints = null;
            }
          }
          if (point === chart.hoverPoint) {
            point.onMouseOut();
          }
          if (!dataSorting || !dataSorting.enabled) {
            destroyPoint();
          } else {
            this.animateBeforeDestroy();
            syncTimeout$5(destroyPoint, animation.duration);
          }
          chart.pointCount--;
        };
        Point2.prototype.destroyElements = function(kinds) {
          var point = this, props = point.getGraphicalProps(kinds);
          props.singular.forEach(function(prop) {
            point[prop] = point[prop].destroy();
          });
          props.plural.forEach(function(plural) {
            point[plural].forEach(function(item2) {
              if (item2.element) {
                item2.destroy();
              }
            });
            delete point[plural];
          });
        };
        Point2.prototype.firePointEvent = function(eventType, eventArgs, defaultFunction) {
          var point = this, series = this.series, seriesOptions = series.options;
          if (seriesOptions.point.events[eventType] || point.options && point.options.events && point.options.events[eventType]) {
            point.importEvents();
          }
          if (eventType === "click" && seriesOptions.allowPointSelect) {
            defaultFunction = function(event) {
              if (point.select) {
                point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
              }
            };
          }
          fireEvent$v(point, eventType, eventArgs, defaultFunction);
        };
        Point2.prototype.getClassName = function() {
          var point = this;
          return "highcharts-point" + (point.selected ? " highcharts-point-select" : "") + (point.negative ? " highcharts-negative" : "") + (point.isNull ? " highcharts-null-point" : "") + (typeof point.colorIndex !== "undefined" ? " highcharts-color-" + point.colorIndex : "") + (point.options.className ? " " + point.options.className : "") + (point.zone && point.zone.className ? " " + point.zone.className.replace("highcharts-negative", "") : "");
        };
        Point2.prototype.getGraphicalProps = function(kinds) {
          var point = this, props = [], graphicalProps = { singular: [], plural: [] };
          var prop, i;
          kinds = kinds || { graphic: 1, dataLabel: 1 };
          if (kinds.graphic) {
            props.push("graphic", "upperGraphic", "shadowGroup");
          }
          if (kinds.dataLabel) {
            props.push("dataLabel", "dataLabelUpper", "connector");
          }
          i = props.length;
          while (i--) {
            prop = props[i];
            if (point[prop]) {
              graphicalProps.singular.push(prop);
            }
          }
          ["dataLabel", "connector"].forEach(function(prop2) {
            var plural = prop2 + "s";
            if (kinds[prop2] && point[plural]) {
              graphicalProps.plural.push(plural);
            }
          });
          return graphicalProps;
        };
        Point2.prototype.getLabelConfig = function() {
          return {
            x: this.category,
            y: this.y,
            color: this.color,
            colorIndex: this.colorIndex,
            key: this.name || this.category,
            series: this.series,
            point: this,
            percentage: this.percentage,
            total: this.total || this.stackTotal
          };
        };
        Point2.prototype.getNestedProperty = function(key) {
          if (!key) {
            return;
          }
          if (key.indexOf("custom.") === 0) {
            return getNestedProperty$1(key, this.options);
          }
          return this[key];
        };
        Point2.prototype.getZone = function() {
          var series = this.series, zones = series.zones, zoneAxis = series.zoneAxis || "y";
          var zone, i = 0;
          zone = zones[i];
          while (this[zoneAxis] >= zone.value) {
            zone = zones[++i];
          }
          if (!this.nonZonedColor) {
            this.nonZonedColor = this.color;
          }
          if (zone && zone.color && !this.options.color) {
            this.color = zone.color;
          } else {
            this.color = this.nonZonedColor;
          }
          return zone;
        };
        Point2.prototype.hasNewShapeType = function() {
          var point = this;
          var oldShapeType = point.graphic && (point.graphic.symbolName || point.graphic.element.nodeName);
          return oldShapeType !== this.shapeType;
        };
        Point2.prototype.init = function(series, options, x) {
          this.series = series;
          this.applyOptions(options, x);
          this.id = defined$K(this.id) ? this.id : uniqueKey$5();
          this.resolveColor();
          series.chart.pointCount++;
          fireEvent$v(this, "afterInit");
          return this;
        };
        Point2.prototype.optionsToObject = function(options) {
          var series = this.series, keys2 = series.options.keys, pointArrayMap = keys2 || series.pointArrayMap || ["y"], valueCount = pointArrayMap.length;
          var ret = {}, firstItemType, i = 0, j = 0;
          if (isNumber$E(options) || options === null) {
            ret[pointArrayMap[0]] = options;
          } else if (isArray$h(options)) {
            if (!keys2 && options.length > valueCount) {
              firstItemType = typeof options[0];
              if (firstItemType === "string") {
                ret.name = options[0];
              } else if (firstItemType === "number") {
                ret.x = options[0];
              }
              i++;
            }
            while (j < valueCount) {
              if (!keys2 || typeof options[i] !== "undefined") {
                if (pointArrayMap[j].indexOf(".") > 0) {
                  Point2.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);
                } else {
                  ret[pointArrayMap[j]] = options[i];
                }
              }
              i++;
              j++;
            }
          } else if (typeof options === "object") {
            ret = options;
            if (options.dataLabels) {
              series._hasPointLabels = true;
            }
            if (options.marker) {
              series._hasPointMarkers = true;
            }
          }
          return ret;
        };
        Point2.prototype.resolveColor = function() {
          var series = this.series, optionsChart = series.chart.options.chart, styledMode = series.chart.styledMode;
          var color2, colors, colorCount = optionsChart.colorCount, colorIndex;
          delete this.nonZonedColor;
          if (series.options.colorByPoint) {
            if (!styledMode) {
              colors = series.options.colors || series.chart.options.colors;
              color2 = colors[series.colorCounter];
              colorCount = colors.length;
            }
            colorIndex = series.colorCounter;
            series.colorCounter++;
            if (series.colorCounter === colorCount) {
              series.colorCounter = 0;
            }
          } else {
            if (!styledMode) {
              color2 = series.color;
            }
            colorIndex = series.colorIndex;
          }
          this.colorIndex = pick$1k(this.options.colorIndex, colorIndex);
          this.color = pick$1k(this.options.color, color2);
        };
        Point2.prototype.setNestedProperty = function(object, value, key) {
          var nestedKeys = key.split(".");
          nestedKeys.reduce(function(result2, key2, i, arr) {
            var isLastKey = arr.length - 1 === i;
            result2[key2] = isLastKey ? value : isObject$b(result2[key2], true) ? result2[key2] : {};
            return result2[key2];
          }, object);
          return object;
        };
        Point2.prototype.tooltipFormatter = function(pointFormat) {
          var series = this.series, seriesTooltipOptions = series.tooltipOptions, valueDecimals = pick$1k(seriesTooltipOptions.valueDecimals, ""), valuePrefix = seriesTooltipOptions.valuePrefix || "", valueSuffix = seriesTooltipOptions.valueSuffix || "";
          if (series.chart.styledMode) {
            pointFormat = series.chart.tooltip.styledModeFormat(pointFormat);
          }
          (series.pointArrayMap || ["y"]).forEach(function(key) {
            key = "{point." + key;
            if (valuePrefix || valueSuffix) {
              pointFormat = pointFormat.replace(RegExp(key + "}", "g"), valuePrefix + key + "}" + valueSuffix);
            }
            pointFormat = pointFormat.replace(RegExp(key + "}", "g"), key + ":,." + valueDecimals + "f}");
          });
          return format$c(pointFormat, {
            point: this,
            series: this.series
          }, series.chart);
        };
        Point2.prototype.update = function(options, redraw, animation, runEvent) {
          var point = this, series = point.series, graphic = point.graphic, chart = series.chart, seriesOptions = series.options;
          var i;
          redraw = pick$1k(redraw, true);
          function update() {
            point.applyOptions(options);
            var hasDummyGraphic = graphic && point.hasDummyGraphic;
            var shouldDestroyGraphic = point.y === null ? !hasDummyGraphic : hasDummyGraphic;
            if (graphic && shouldDestroyGraphic) {
              point.graphic = graphic.destroy();
              delete point.hasDummyGraphic;
            }
            if (isObject$b(options, true)) {
              if (graphic && graphic.element) {
                if (options && options.marker && typeof options.marker.symbol !== "undefined") {
                  point.graphic = graphic.destroy();
                }
              }
              if (options && options.dataLabels && point.dataLabel) {
                point.dataLabel = point.dataLabel.destroy();
              }
              if (point.connector) {
                point.connector = point.connector.destroy();
              }
            }
            i = point.index;
            series.updateParallelArrays(point, i);
            seriesOptions.data[i] = isObject$b(seriesOptions.data[i], true) || isObject$b(options, true) ? point.options : pick$1k(options, seriesOptions.data[i]);
            series.isDirty = series.isDirtyData = true;
            if (!series.fixedBox && series.hasCartesianSeries) {
              chart.isDirtyBox = true;
            }
            if (seriesOptions.legendType === "point") {
              chart.isDirtyLegend = true;
            }
            if (redraw) {
              chart.redraw(animation);
            }
          }
          if (runEvent === false) {
            update();
          } else {
            point.firePointEvent("update", { options }, update);
          }
        };
        Point2.prototype.remove = function(redraw, animation) {
          this.series.removePoint(this.series.data.indexOf(this), redraw, animation);
        };
        Point2.prototype.select = function(selected, accumulate) {
          var point = this, series = point.series, chart = series.chart;
          selected = pick$1k(selected, !point.selected);
          this.selectedStaging = selected;
          point.firePointEvent(selected ? "select" : "unselect", { accumulate }, function() {
            point.selected = point.options.selected = selected;
            series.options.data[series.data.indexOf(point)] = point.options;
            point.setState(selected && "select");
            if (!accumulate) {
              chart.getSelectedPoints().forEach(function(loopPoint) {
                var loopSeries = loopPoint.series;
                if (loopPoint.selected && loopPoint !== point) {
                  loopPoint.selected = loopPoint.options.selected = false;
                  loopSeries.options.data[loopSeries.data.indexOf(loopPoint)] = loopPoint.options;
                  loopPoint.setState(chart.hoverPoints && loopSeries.options.inactiveOtherPoints ? "inactive" : "");
                  loopPoint.firePointEvent("unselect");
                }
              });
            }
          });
          delete this.selectedStaging;
        };
        Point2.prototype.onMouseOver = function(e2) {
          var point = this, series = point.series, chart = series.chart, pointer = chart.pointer;
          e2 = e2 ? pointer.normalize(e2) : (
            // In cases where onMouseOver is called directly without an event
            pointer.getChartCoordinatesFromPoint(point, chart.inverted)
          );
          pointer.runPointActions(e2, point);
        };
        Point2.prototype.onMouseOut = function() {
          var point = this, chart = point.series.chart;
          point.firePointEvent("mouseOut");
          if (!point.series.options.inactiveOtherPoints) {
            (chart.hoverPoints || []).forEach(function(p) {
              p.setState();
            });
          }
          chart.hoverPoints = chart.hoverPoint = null;
        };
        Point2.prototype.importEvents = function() {
          if (!this.hasImportedEvents) {
            var point_1 = this, options = merge$1d(point_1.series.options.point, point_1.options), events = options.events;
            point_1.events = events;
            objectEach$q(events, function(event, eventType) {
              if (isFunction$2(event)) {
                addEvent$X(point_1, eventType, event);
              }
            });
            this.hasImportedEvents = true;
          }
        };
        Point2.prototype.setState = function(state, move) {
          var point = this, series = point.series, previousState = point.state, stateOptions = series.options.states[state || "normal"] || {}, markerOptions = defaultOptions$d.plotOptions[series.type].marker && series.options.marker, normalDisabled = markerOptions && markerOptions.enabled === false, markerStateOptions = markerOptions && markerOptions.states && markerOptions.states[state || "normal"] || {}, stateDisabled = markerStateOptions.enabled === false, pointMarker = point.marker || {}, chart = series.chart, hasMarkers = markerOptions && series.markerAttribs;
          var halo = series.halo, markerAttribs, pointAttribs2, pointAttribsAnimation, stateMarkerGraphic = series.stateMarkerGraphic, newSymbol;
          state = state || "";
          if (
            // already has this state
            state === point.state && !move || // selected points don't respond to hover
            point.selected && state !== "select" || // series' state options is disabled
            stateOptions.enabled === false || // general point marker's state options is disabled
            state && (stateDisabled || normalDisabled && markerStateOptions.enabled === false) || // individual point marker's state options is disabled
            state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false
          ) {
            return;
          }
          point.state = state;
          if (hasMarkers) {
            markerAttribs = series.markerAttribs(point, state);
          }
          if (point.graphic && !point.hasDummyGraphic) {
            if (previousState) {
              point.graphic.removeClass("highcharts-point-" + previousState);
            }
            if (state) {
              point.graphic.addClass("highcharts-point-" + state);
            }
            if (!chart.styledMode) {
              pointAttribs2 = series.pointAttribs(point, state);
              pointAttribsAnimation = pick$1k(chart.options.chart.animation, stateOptions.animation);
              if (series.options.inactiveOtherPoints && isNumber$E(pointAttribs2.opacity)) {
                (point.dataLabels || []).forEach(function(label) {
                  if (label) {
                    label.animate({
                      opacity: pointAttribs2.opacity
                    }, pointAttribsAnimation);
                  }
                });
                if (point.connector) {
                  point.connector.animate({
                    opacity: pointAttribs2.opacity
                  }, pointAttribsAnimation);
                }
              }
              point.graphic.animate(pointAttribs2, pointAttribsAnimation);
            }
            if (markerAttribs) {
              point.graphic.animate(markerAttribs, pick$1k(
                // Turn off globally:
                chart.options.chart.animation,
                markerStateOptions.animation,
                markerOptions.animation
              ));
            }
            if (stateMarkerGraphic) {
              stateMarkerGraphic.hide();
            }
          } else {
            if (state && markerStateOptions) {
              newSymbol = pointMarker.symbol || series.symbol;
              if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
                stateMarkerGraphic = stateMarkerGraphic.destroy();
              }
              if (markerAttribs) {
                if (!stateMarkerGraphic) {
                  if (newSymbol) {
                    series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height).add(series.markerGroup);
                    stateMarkerGraphic.currentSymbol = newSymbol;
                  }
                } else {
                  stateMarkerGraphic[move ? "animate" : "attr"]({
                    x: markerAttribs.x,
                    y: markerAttribs.y
                  });
                }
              }
              if (!chart.styledMode && stateMarkerGraphic) {
                stateMarkerGraphic.attr(series.pointAttribs(point, state));
              }
            }
            if (stateMarkerGraphic) {
              stateMarkerGraphic[state && point.isInside ? "show" : "hide"]();
              stateMarkerGraphic.element.point = point;
              stateMarkerGraphic.addClass(point.getClassName(), true);
            }
          }
          var haloOptions = stateOptions.halo;
          var markerGraphic = point.graphic || stateMarkerGraphic;
          var markerVisibility = markerGraphic && markerGraphic.visibility || "inherit";
          if (haloOptions && haloOptions.size && markerGraphic && markerVisibility !== "hidden" && !point.isCluster) {
            if (!halo) {
              series.halo = halo = chart.renderer.path().add(markerGraphic.parentGroup);
            }
            halo.show()[move ? "animate" : "attr"]({
              d: point.haloPath(haloOptions.size)
            });
            halo.attr({
              "class": "highcharts-halo highcharts-color-" + pick$1k(point.colorIndex, series.colorIndex) + (point.className ? " " + point.className : ""),
              "visibility": markerVisibility,
              "zIndex": -1
              // #4929, #8276
            });
            halo.point = point;
            if (!chart.styledMode) {
              halo.attr(extend$1f({
                "fill": point.color || series.color,
                "fill-opacity": haloOptions.opacity
              }, AST.filterUserAttributes(haloOptions.attributes || {})));
            }
          } else if (halo && halo.point && halo.point.haloPath) {
            halo.animate(
              { d: halo.point.haloPath(0) },
              null,
              // Hide after unhovering. The `complete` callback runs in the
              // halo's context (#7681).
              halo.hide
            );
          }
          fireEvent$v(point, "afterSetState", { state });
        };
        Point2.prototype.haloPath = function(size) {
          var series = this.series, chart = series.chart;
          return chart.renderer.symbols.circle(Math.floor(this.plotX) - size, this.plotY - size, size * 2, size * 2);
        };
        return Point2;
      }()
    );
    var color$e = Color.parse;
    var charts$3 = H.charts, noop$j = H.noop;
    var addEvent$W = Utilities.addEvent, attr$2 = Utilities.attr, css$8 = Utilities.css, defined$J = Utilities.defined, extend$1e = Utilities.extend, find$i = Utilities.find, fireEvent$u = Utilities.fireEvent, isNumber$D = Utilities.isNumber, isObject$a = Utilities.isObject, objectEach$p = Utilities.objectEach, offset = Utilities.offset, pick$1j = Utilities.pick, splat$e = Utilities.splat;
    var Pointer = (
      /** @class */
      function() {
        function Pointer2(chart, options) {
          this.lastValidTouch = {};
          this.pinchDown = [];
          this.runChartClick = false;
          this.eventsToUnbind = [];
          this.chart = chart;
          this.hasDragged = false;
          this.options = options;
          this.init(chart, options);
        }
        Pointer2.prototype.applyInactiveState = function(points) {
          var activeSeries = [], series;
          (points || []).forEach(function(item2) {
            series = item2.series;
            activeSeries.push(series);
            if (series.linkedParent) {
              activeSeries.push(series.linkedParent);
            }
            if (series.linkedSeries) {
              activeSeries = activeSeries.concat(series.linkedSeries);
            }
            if (series.navigatorSeries) {
              activeSeries.push(series.navigatorSeries);
            }
          });
          this.chart.series.forEach(function(inactiveSeries) {
            if (activeSeries.indexOf(inactiveSeries) === -1) {
              inactiveSeries.setState("inactive", true);
            } else if (inactiveSeries.options.inactiveOtherPoints) {
              inactiveSeries.setAllPointsToState("inactive");
            }
          });
        };
        Pointer2.prototype.destroy = function() {
          var pointer = this;
          this.eventsToUnbind.forEach(function(unbind) {
            return unbind();
          });
          this.eventsToUnbind = [];
          if (!H.chartCount) {
            if (Pointer2.unbindDocumentMouseUp) {
              Pointer2.unbindDocumentMouseUp = Pointer2.unbindDocumentMouseUp();
            }
            if (Pointer2.unbindDocumentTouchEnd) {
              Pointer2.unbindDocumentTouchEnd = Pointer2.unbindDocumentTouchEnd();
            }
          }
          clearInterval(pointer.tooltipTimeout);
          objectEach$p(pointer, function(_val, prop) {
            pointer[prop] = void 0;
          });
        };
        Pointer2.prototype.drag = function(e2) {
          var chart = this.chart, chartOptions = chart.options.chart, zoomHor = this.zoomHor, zoomVert = this.zoomVert, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, mouseDownX = this.mouseDownX || 0, mouseDownY = this.mouseDownY || 0, panningEnabled = isObject$a(chartOptions.panning) ? chartOptions.panning && chartOptions.panning.enabled : chartOptions.panning, panKey = chartOptions.panKey && e2[chartOptions.panKey + "Key"];
          var chartX = e2.chartX, chartY = e2.chartY, clickedInside, size, selectionMarker = this.selectionMarker;
          if (selectionMarker && selectionMarker.touch) {
            return;
          }
          if (chartX < plotLeft) {
            chartX = plotLeft;
          } else if (chartX > plotLeft + plotWidth) {
            chartX = plotLeft + plotWidth;
          }
          if (chartY < plotTop) {
            chartY = plotTop;
          } else if (chartY > plotTop + plotHeight) {
            chartY = plotTop + plotHeight;
          }
          this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));
          if (this.hasDragged > 10) {
            clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop, {
              visiblePlotOnly: true
            });
            if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
              if (!selectionMarker) {
                this.selectionMarker = selectionMarker = chart.renderer.rect(plotLeft, plotTop, zoomHor ? 1 : plotWidth, zoomVert ? 1 : plotHeight, 0).attr({
                  "class": "highcharts-selection-marker",
                  zIndex: 7
                }).add();
                if (!chart.styledMode) {
                  selectionMarker.attr({
                    fill: chartOptions.selectionMarkerFill || color$e(palette.highlightColor80).setOpacity(0.25).get()
                  });
                }
              }
            }
            if (selectionMarker && zoomHor) {
              size = chartX - mouseDownX;
              selectionMarker.attr({
                width: Math.abs(size),
                x: (size > 0 ? 0 : size) + mouseDownX
              });
            }
            if (selectionMarker && zoomVert) {
              size = chartY - mouseDownY;
              selectionMarker.attr({
                height: Math.abs(size),
                y: (size > 0 ? 0 : size) + mouseDownY
              });
            }
            if (clickedInside && !selectionMarker && panningEnabled) {
              chart.pan(e2, chartOptions.panning);
            }
          }
        };
        Pointer2.prototype.dragStart = function(e2) {
          var chart = this.chart;
          chart.mouseIsDown = e2.type;
          chart.cancelClick = false;
          chart.mouseDownX = this.mouseDownX = e2.chartX;
          chart.mouseDownY = this.mouseDownY = e2.chartY;
        };
        Pointer2.prototype.drop = function(e2) {
          var pointer = this, chart = this.chart, hasPinched = this.hasPinched;
          if (this.selectionMarker) {
            var selectionData_1 = {
              originalEvent: e2,
              xAxis: [],
              yAxis: []
            }, selectionBox = this.selectionMarker, selectionLeft_1 = selectionBox.attr ? selectionBox.attr("x") : selectionBox.x, selectionTop_1 = selectionBox.attr ? selectionBox.attr("y") : selectionBox.y, selectionWidth_1 = selectionBox.attr ? selectionBox.attr("width") : selectionBox.width, selectionHeight_1 = selectionBox.attr ? selectionBox.attr("height") : selectionBox.height;
            var runZoom_1;
            if (this.hasDragged || hasPinched) {
              chart.axes.forEach(function(axis) {
                if (axis.zoomEnabled && defined$J(axis.min) && (hasPinched || pointer[{
                  xAxis: "zoomX",
                  yAxis: "zoomY"
                }[axis.coll]]) && isNumber$D(selectionLeft_1) && isNumber$D(selectionTop_1)) {
                  var horiz = axis.horiz, minPixelPadding = e2.type === "touchend" ? axis.minPixelPadding : 0, selectionMin = axis.toValue((horiz ? selectionLeft_1 : selectionTop_1) + minPixelPadding), selectionMax = axis.toValue((horiz ? selectionLeft_1 + selectionWidth_1 : selectionTop_1 + selectionHeight_1) - minPixelPadding);
                  selectionData_1[axis.coll].push({
                    axis,
                    // Min/max for reversed axes
                    min: Math.min(selectionMin, selectionMax),
                    max: Math.max(selectionMin, selectionMax)
                  });
                  runZoom_1 = true;
                }
              });
              if (runZoom_1) {
                fireEvent$u(chart, "selection", selectionData_1, function(args) {
                  chart.zoom(extend$1e(args, hasPinched ? { animation: false } : null));
                });
              }
            }
            if (isNumber$D(chart.index)) {
              this.selectionMarker = this.selectionMarker.destroy();
            }
            if (hasPinched) {
              this.scaleGroups();
            }
          }
          if (chart && isNumber$D(chart.index)) {
            css$8(chart.container, { cursor: chart._cursor });
            chart.cancelClick = this.hasDragged > 10;
            chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
            this.pinchDown = [];
          }
        };
        Pointer2.prototype.findNearestKDPoint = function(series, shared, e2) {
          var chart = this.chart;
          var hoverPoint = chart.hoverPoint;
          var tooltip = chart.tooltip;
          if (hoverPoint && tooltip && tooltip.isStickyOnContact()) {
            return hoverPoint;
          }
          var closest;
          function sort(p1, p2) {
            var isCloserX = p1.distX - p2.distX, isCloser = p1.dist - p2.dist, isAbove = (p2.series.group && p2.series.group.zIndex) - (p1.series.group && p1.series.group.zIndex);
            var result2;
            if (isCloserX !== 0 && shared) {
              result2 = isCloserX;
            } else if (isCloser !== 0) {
              result2 = isCloser;
            } else if (isAbove !== 0) {
              result2 = isAbove;
            } else {
              result2 = p1.series.index > p2.series.index ? -1 : 1;
            }
            return result2;
          }
          series.forEach(function(s) {
            var noSharedTooltip = s.noSharedTooltip && shared, compareX = !noSharedTooltip && s.options.findNearestPointBy.indexOf("y") < 0, point = s.searchPoint(e2, compareX);
            if (
              // Check that we actually found a point on the series.
              isObject$a(point, true) && point.series && // Use the new point if it is closer.
              (!isObject$a(closest, true) || sort(closest, point) > 0)
            ) {
              closest = point;
            }
          });
          return closest;
        };
        Pointer2.prototype.getChartCoordinatesFromPoint = function(point, inverted) {
          var series = point.series, xAxis = series.xAxis, yAxis = series.yAxis, shapeArgs = point.shapeArgs;
          if (xAxis && yAxis) {
            var x = pick$1j(point.clientX, point.plotX);
            var y = point.plotY || 0;
            if (point.isNode && shapeArgs && isNumber$D(shapeArgs.x) && isNumber$D(shapeArgs.y)) {
              x = shapeArgs.x;
              y = shapeArgs.y;
            }
            return inverted ? {
              chartX: yAxis.len + yAxis.pos - y,
              chartY: xAxis.len + xAxis.pos - x
            } : {
              chartX: x + xAxis.pos,
              chartY: y + yAxis.pos
            };
          }
          if (shapeArgs && shapeArgs.x && shapeArgs.y) {
            return {
              chartX: shapeArgs.x,
              chartY: shapeArgs.y
            };
          }
        };
        Pointer2.prototype.getChartPosition = function() {
          if (this.chartPosition) {
            return this.chartPosition;
          }
          var container = this.chart.container;
          var pos = offset(container);
          this.chartPosition = {
            left: pos.left,
            top: pos.top,
            scaleX: 1,
            scaleY: 1
          };
          var offsetWidth = container.offsetWidth;
          var offsetHeight = container.offsetHeight;
          if (offsetWidth > 2 && // #13342
          offsetHeight > 2) {
            this.chartPosition.scaleX = pos.width / offsetWidth;
            this.chartPosition.scaleY = pos.height / offsetHeight;
          }
          return this.chartPosition;
        };
        Pointer2.prototype.getCoordinates = function(e2) {
          var coordinates = {
            xAxis: [],
            yAxis: []
          };
          this.chart.axes.forEach(function(axis) {
            coordinates[axis.isXAxis ? "xAxis" : "yAxis"].push({
              axis,
              value: axis.toValue(e2[axis.horiz ? "chartX" : "chartY"])
            });
          });
          return coordinates;
        };
        Pointer2.prototype.getHoverData = function(existingHoverPoint, existingHoverSeries, series, isDirectTouch, shared, e2) {
          var hoverPoints = [], useExisting = !!(isDirectTouch && existingHoverPoint), filter = function(s) {
            return s.visible && !(!shared && s.directTouch) && // #3821
            pick$1j(s.options.enableMouseTracking, true);
          };
          var hoverSeries = existingHoverSeries, searchSeries, eventArgs = {
            chartX: e2 ? e2.chartX : void 0,
            chartY: e2 ? e2.chartY : void 0,
            shared
          };
          fireEvent$u(this, "beforeGetHoverData", eventArgs);
          var notSticky = hoverSeries && !hoverSeries.stickyTracking;
          searchSeries = notSticky ? (
            // Only search on hovered series if it has stickyTracking false
            [hoverSeries]
          ) : (
            // Filter what series to look in.
            series.filter(function(s) {
              return eventArgs.filter ? eventArgs.filter(s) : filter(s) && s.stickyTracking;
            })
          );
          var hoverPoint = useExisting || !e2 ? existingHoverPoint : this.findNearestKDPoint(searchSeries, shared, e2);
          hoverSeries = hoverPoint && hoverPoint.series;
          if (hoverPoint) {
            if (shared && !hoverSeries.noSharedTooltip) {
              searchSeries = series.filter(function(s) {
                return eventArgs.filter ? eventArgs.filter(s) : filter(s) && !s.noSharedTooltip;
              });
              searchSeries.forEach(function(s) {
                var point = find$i(s.points, function(p) {
                  return p.x === hoverPoint.x && !p.isNull;
                });
                if (isObject$a(point)) {
                  if (s.chart.isBoosting) {
                    point = s.getPoint(point);
                  }
                  hoverPoints.push(point);
                }
              });
            } else {
              hoverPoints.push(hoverPoint);
            }
          }
          eventArgs = { hoverPoint };
          fireEvent$u(this, "afterGetHoverData", eventArgs);
          return {
            hoverPoint: eventArgs.hoverPoint,
            hoverSeries,
            hoverPoints
          };
        };
        Pointer2.prototype.getPointFromEvent = function(e2) {
          var target = e2.target, point;
          while (target && !point) {
            point = target.point;
            target = target.parentNode;
          }
          return point;
        };
        Pointer2.prototype.onTrackerMouseOut = function(e2) {
          var chart = this.chart;
          var relatedTarget = e2.relatedTarget || e2.toElement;
          var series = chart.hoverSeries;
          this.isDirectTouch = false;
          if (series && relatedTarget && !series.stickyTracking && !this.inClass(relatedTarget, "highcharts-tooltip") && (!this.inClass(relatedTarget, "highcharts-series-" + series.index) || // #2499, #4465, #5553
          !this.inClass(relatedTarget, "highcharts-tracker"))) {
            series.onMouseOut();
          }
        };
        Pointer2.prototype.inClass = function(element, className) {
          var elemClassName;
          while (element) {
            elemClassName = attr$2(element, "class");
            if (elemClassName) {
              if (elemClassName.indexOf(className) !== -1) {
                return true;
              }
              if (elemClassName.indexOf("highcharts-container") !== -1) {
                return false;
              }
            }
            element = element.parentNode;
          }
        };
        Pointer2.prototype.init = function(chart, options) {
          this.options = options;
          this.chart = chart;
          this.runChartClick = Boolean(options.chart.events && options.chart.events.click);
          this.pinchDown = [];
          this.lastValidTouch = {};
          if (Tooltip) {
            chart.tooltip = new Tooltip(chart, options.tooltip);
            this.followTouchMove = pick$1j(options.tooltip.followTouchMove, true);
          }
          this.setDOMEvents();
        };
        Pointer2.prototype.normalize = function(e2, chartPosition) {
          var touches2 = e2.touches;
          var ePos = touches2 ? touches2.length ? touches2.item(0) : pick$1j(
            // #13534
            touches2.changedTouches,
            e2.changedTouches
          )[0] : e2;
          if (!chartPosition) {
            chartPosition = this.getChartPosition();
          }
          var chartX = ePos.pageX - chartPosition.left, chartY = ePos.pageY - chartPosition.top;
          chartX /= chartPosition.scaleX;
          chartY /= chartPosition.scaleY;
          return extend$1e(e2, {
            chartX: Math.round(chartX),
            chartY: Math.round(chartY)
          });
        };
        Pointer2.prototype.onContainerClick = function(e2) {
          var chart = this.chart;
          var hoverPoint = chart.hoverPoint;
          var pEvt = this.normalize(e2);
          var plotLeft = chart.plotLeft;
          var plotTop = chart.plotTop;
          if (!chart.cancelClick) {
            if (hoverPoint && this.inClass(pEvt.target, "highcharts-tracker")) {
              fireEvent$u(hoverPoint.series, "click", extend$1e(pEvt, {
                point: hoverPoint
              }));
              if (chart.hoverPoint) {
                hoverPoint.firePointEvent("click", pEvt);
              }
            } else {
              extend$1e(pEvt, this.getCoordinates(pEvt));
              if (chart.isInsidePlot(pEvt.chartX - plotLeft, pEvt.chartY - plotTop, {
                visiblePlotOnly: true
              })) {
                fireEvent$u(chart, "click", pEvt);
              }
            }
          }
        };
        Pointer2.prototype.onContainerMouseDown = function(e2) {
          var isPrimaryButton = ((e2.buttons || e2.button) & 1) === 1;
          e2 = this.normalize(e2);
          if (H.isFirefox && e2.button !== 0) {
            this.onContainerMouseMove(e2);
          }
          if (typeof e2.button === "undefined" || isPrimaryButton) {
            this.zoomOption(e2);
            if (isPrimaryButton && e2.preventDefault) {
              e2.preventDefault();
            }
            this.dragStart(e2);
          }
        };
        Pointer2.prototype.onContainerMouseLeave = function(e2) {
          var chart = charts$3[pick$1j(Pointer2.hoverChartIndex, -1)];
          var tooltip = this.chart.tooltip;
          if (tooltip && tooltip.shouldStickOnContact() && this.inClass(e2.relatedTarget, "highcharts-tooltip-container")) {
            return;
          }
          e2 = this.normalize(e2);
          if (chart && (e2.relatedTarget || e2.toElement)) {
            chart.pointer.reset();
            chart.pointer.chartPosition = void 0;
          }
          if (
            // #11635, Firefox wheel scroll does not fire out events consistently
            tooltip && !tooltip.isHidden
          ) {
            this.reset();
          }
        };
        Pointer2.prototype.onContainerMouseEnter = function(e2) {
          delete this.chartPosition;
        };
        Pointer2.prototype.onContainerMouseMove = function(e2) {
          var chart = this.chart;
          var pEvt = this.normalize(e2);
          this.setHoverChartIndex();
          if (!pEvt.preventDefault) {
            pEvt.returnValue = false;
          }
          if (chart.mouseIsDown === "mousedown" || this.touchSelect(pEvt)) {
            this.drag(pEvt);
          }
          if (!chart.openMenu && (this.inClass(pEvt.target, "highcharts-tracker") || chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
            visiblePlotOnly: true
          }))) {
            if (this.inClass(pEvt.target, "highcharts-no-tooltip")) {
              this.reset(false, 0);
            } else {
              this.runPointActions(pEvt);
            }
          }
        };
        Pointer2.prototype.onDocumentTouchEnd = function(e2) {
          var hoverChart = charts$3[pick$1j(Pointer2.hoverChartIndex, -1)];
          if (hoverChart) {
            hoverChart.pointer.drop(e2);
          }
        };
        Pointer2.prototype.onContainerTouchMove = function(e2) {
          if (this.touchSelect(e2)) {
            this.onContainerMouseMove(e2);
          } else {
            this.touch(e2);
          }
        };
        Pointer2.prototype.onContainerTouchStart = function(e2) {
          if (this.touchSelect(e2)) {
            this.onContainerMouseDown(e2);
          } else {
            this.zoomOption(e2);
            this.touch(e2, true);
          }
        };
        Pointer2.prototype.onDocumentMouseMove = function(e2) {
          var chart = this.chart;
          var chartPosition = this.chartPosition;
          var pEvt = this.normalize(e2, chartPosition);
          var tooltip = chart.tooltip;
          if (chartPosition && (!tooltip || !tooltip.isStickyOnContact()) && !chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
            visiblePlotOnly: true
          }) && !this.inClass(pEvt.target, "highcharts-tracker")) {
            this.reset();
          }
        };
        Pointer2.prototype.onDocumentMouseUp = function(e2) {
          var chart = charts$3[pick$1j(Pointer2.hoverChartIndex, -1)];
          if (chart) {
            chart.pointer.drop(e2);
          }
        };
        Pointer2.prototype.pinch = function(e2) {
          var self = this, chart = self.chart, pinchDown = self.pinchDown, touches2 = e2.touches || [], touchesLength = touches2.length, lastValidTouch = self.lastValidTouch, hasZoom = self.hasZoom, transform = {}, fireClickEvent = touchesLength === 1 && (self.inClass(e2.target, "highcharts-tracker") && chart.runTrackerClick || self.runChartClick), clip = {};
          var selectionMarker = self.selectionMarker;
          if (touchesLength > 1) {
            self.initiated = true;
          } else if (touchesLength === 1 && this.followTouchMove) {
            self.initiated = false;
          }
          if (hasZoom && self.initiated && !fireClickEvent && e2.cancelable !== false) {
            e2.preventDefault();
          }
          [].map.call(touches2, function(e3) {
            return self.normalize(e3);
          });
          if (e2.type === "touchstart") {
            [].forEach.call(touches2, function(e3, i) {
              pinchDown[i] = { chartX: e3.chartX, chartY: e3.chartY };
            });
            lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
            lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];
            chart.axes.forEach(function(axis) {
              if (axis.zoomEnabled) {
                var bounds = chart.bounds[axis.horiz ? "h" : "v"], minPixelPadding = axis.minPixelPadding, min = axis.toPixels(Math.min(pick$1j(axis.options.min, axis.dataMin), axis.dataMin)), max = axis.toPixels(Math.max(pick$1j(axis.options.max, axis.dataMax), axis.dataMax)), absMin = Math.min(min, max), absMax = Math.max(min, max);
                bounds.min = Math.min(axis.pos, absMin - minPixelPadding);
                bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);
              }
            });
            self.res = true;
          } else if (self.followTouchMove && touchesLength === 1) {
            this.runPointActions(self.normalize(e2));
          } else if (pinchDown.length) {
            if (!selectionMarker) {
              self.selectionMarker = selectionMarker = extend$1e({
                destroy: noop$j,
                touch: true
              }, chart.plotBox);
            }
            self.pinchTranslate(pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch);
            self.hasPinched = hasZoom;
            self.scaleGroups(transform, clip);
            if (self.res) {
              self.res = false;
              this.reset(false, 0);
            }
          }
        };
        Pointer2.prototype.pinchTranslate = function(pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch) {
          if (this.zoomHor) {
            this.pinchTranslateDirection(true, pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch);
          }
          if (this.zoomVert) {
            this.pinchTranslateDirection(false, pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch);
          }
        };
        Pointer2.prototype.pinchTranslateDirection = function(horiz, pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
          var chart = this.chart, xy = horiz ? "x" : "y", XY = horiz ? "X" : "Y", sChartXY = "chart" + XY, wh = horiz ? "width" : "height", plotLeftTop = chart["plot" + (horiz ? "Left" : "Top")], inverted = chart.inverted, bounds = chart.bounds[horiz ? "h" : "v"], singleTouch = pinchDown.length === 1, touch0Start = pinchDown[0][sChartXY], touch1Start = !singleTouch && pinchDown[1][sChartXY], setScale = function() {
            if (typeof touch1Now === "number" && Math.abs(touch0Start - touch1Start) > 20) {
              scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start);
            }
            clipXY = (plotLeftTop - touch0Now) / scale + touch0Start;
            selectionWH = chart["plot" + (horiz ? "Width" : "Height")] / scale;
          };
          var selectionWH, selectionXY, clipXY, scale = forcedScale || 1, touch0Now = touches2[0][sChartXY], touch1Now = !singleTouch && touches2[1][sChartXY], outOfBounds;
          setScale();
          selectionXY = clipXY;
          if (selectionXY < bounds.min) {
            selectionXY = bounds.min;
            outOfBounds = true;
          } else if (selectionXY + selectionWH > bounds.max) {
            selectionXY = bounds.max - selectionWH;
            outOfBounds = true;
          }
          if (outOfBounds) {
            touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
            if (typeof touch1Now === "number") {
              touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
            }
            setScale();
          } else {
            lastValidTouch[xy] = [touch0Now, touch1Now];
          }
          if (!inverted) {
            clip[xy] = clipXY - plotLeftTop;
            clip[wh] = selectionWH;
          }
          var scaleKey = inverted ? horiz ? "scaleY" : "scaleX" : "scale" + XY;
          var transformScale = inverted ? 1 / scale : scale;
          selectionMarker[wh] = selectionWH;
          selectionMarker[xy] = selectionXY;
          transform[scaleKey] = scale;
          transform["translate" + XY] = transformScale * plotLeftTop + (touch0Now - transformScale * touch0Start);
        };
        Pointer2.prototype.reset = function(allowMove, delay) {
          var pointer = this, chart = pointer.chart, hoverSeries = chart.hoverSeries, hoverPoint = chart.hoverPoint, hoverPoints = chart.hoverPoints, tooltip = chart.tooltip, tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;
          if (allowMove && tooltipPoints) {
            splat$e(tooltipPoints).forEach(function(point) {
              if (point.series.isCartesian && typeof point.plotX === "undefined") {
                allowMove = false;
              }
            });
          }
          if (allowMove) {
            if (tooltip && tooltipPoints && splat$e(tooltipPoints).length) {
              tooltip.refresh(tooltipPoints);
              if (tooltip.shared && hoverPoints) {
                hoverPoints.forEach(function(point) {
                  point.setState(point.state, true);
                  if (point.series.isCartesian) {
                    if (point.series.xAxis.crosshair) {
                      point.series.xAxis.drawCrosshair(null, point);
                    }
                    if (point.series.yAxis.crosshair) {
                      point.series.yAxis.drawCrosshair(null, point);
                    }
                  }
                });
              } else if (hoverPoint) {
                hoverPoint.setState(hoverPoint.state, true);
                chart.axes.forEach(function(axis) {
                  if (axis.crosshair && hoverPoint.series[axis.coll] === axis) {
                    axis.drawCrosshair(null, hoverPoint);
                  }
                });
              }
            }
          } else {
            if (hoverPoint) {
              hoverPoint.onMouseOut();
            }
            if (hoverPoints) {
              hoverPoints.forEach(function(point) {
                point.setState();
              });
            }
            if (hoverSeries) {
              hoverSeries.onMouseOut();
            }
            if (tooltip) {
              tooltip.hide(delay);
            }
            if (pointer.unDocMouseMove) {
              pointer.unDocMouseMove = pointer.unDocMouseMove();
            }
            chart.axes.forEach(function(axis) {
              axis.hideCrosshair();
            });
            pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;
          }
        };
        Pointer2.prototype.runPointActions = function(e2, p) {
          var pointer = this, chart = pointer.chart, series = chart.series, tooltip = chart.tooltip && chart.tooltip.options.enabled ? chart.tooltip : void 0, shared = tooltip ? tooltip.shared : false;
          var hoverPoint = p || chart.hoverPoint, hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries;
          var isDirectTouch = (!e2 || e2.type !== "touchmove") && (!!p || hoverSeries && hoverSeries.directTouch && pointer.isDirectTouch), hoverData = this.getHoverData(hoverPoint, hoverSeries, series, isDirectTouch, shared, e2);
          hoverPoint = hoverData.hoverPoint;
          hoverSeries = hoverData.hoverSeries;
          var points = hoverData.hoverPoints, followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer && !hoverSeries.tooltipOptions.split, useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip;
          if (hoverPoint && // !(hoverSeries && hoverSeries.directTouch) &&
          (hoverPoint !== chart.hoverPoint || tooltip && tooltip.isHidden)) {
            (chart.hoverPoints || []).forEach(function(p2) {
              if (points.indexOf(p2) === -1) {
                p2.setState();
              }
            });
            if (chart.hoverSeries !== hoverSeries) {
              hoverSeries.onMouseOver();
            }
            pointer.applyInactiveState(points);
            (points || []).forEach(function(p2) {
              p2.setState("hover");
            });
            if (chart.hoverPoint) {
              chart.hoverPoint.firePointEvent("mouseOut");
            }
            if (!hoverPoint.series) {
              return;
            }
            chart.hoverPoints = points;
            chart.hoverPoint = hoverPoint;
            hoverPoint.firePointEvent("mouseOver");
            if (tooltip) {
              tooltip.refresh(useSharedTooltip ? points : hoverPoint, e2);
            }
          } else if (followPointer && tooltip && !tooltip.isHidden) {
            var anchor = tooltip.getAnchor([{}], e2);
            if (chart.isInsidePlot(anchor[0], anchor[1], {
              visiblePlotOnly: true
            })) {
              tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
            }
          }
          if (!pointer.unDocMouseMove) {
            pointer.unDocMouseMove = addEvent$W(chart.container.ownerDocument, "mousemove", function(e3) {
              var chart2 = charts$3[Pointer2.hoverChartIndex];
              if (chart2) {
                chart2.pointer.onDocumentMouseMove(e3);
              }
            });
            pointer.eventsToUnbind.push(pointer.unDocMouseMove);
          }
          chart.axes.forEach(function drawAxisCrosshair(axis) {
            var snap = pick$1j((axis.crosshair || {}).snap, true);
            var point;
            if (snap) {
              point = chart.hoverPoint;
              if (!point || point.series[axis.coll] !== axis) {
                point = find$i(points, function(p2) {
                  return p2.series[axis.coll] === axis;
                });
              }
            }
            if (point || !snap) {
              axis.drawCrosshair(e2, point);
            } else {
              axis.hideCrosshair();
            }
          });
        };
        Pointer2.prototype.scaleGroups = function(attribs, clip) {
          var chart = this.chart;
          chart.series.forEach(function(series) {
            var seriesAttribs = attribs || series.getPlotBox();
            if (series.xAxis && series.xAxis.zoomEnabled && series.group) {
              series.group.attr(seriesAttribs);
              if (series.markerGroup) {
                series.markerGroup.attr(seriesAttribs);
                series.markerGroup.clip(clip ? chart.clipRect : null);
              }
              if (series.dataLabelsGroup) {
                series.dataLabelsGroup.attr(seriesAttribs);
              }
            }
          });
          chart.clipRect.attr(clip || chart.clipBox);
        };
        Pointer2.prototype.setDOMEvents = function() {
          var _this = this;
          var container = this.chart.container, ownerDoc = container.ownerDocument;
          container.onmousedown = this.onContainerMouseDown.bind(this);
          container.onmousemove = this.onContainerMouseMove.bind(this);
          container.onclick = this.onContainerClick.bind(this);
          this.eventsToUnbind.push(addEvent$W(container, "mouseenter", this.onContainerMouseEnter.bind(this)));
          this.eventsToUnbind.push(addEvent$W(container, "mouseleave", this.onContainerMouseLeave.bind(this)));
          if (!Pointer2.unbindDocumentMouseUp) {
            Pointer2.unbindDocumentMouseUp = addEvent$W(ownerDoc, "mouseup", this.onDocumentMouseUp.bind(this));
          }
          var parent = this.chart.renderTo.parentElement;
          while (parent && parent.tagName !== "BODY") {
            this.eventsToUnbind.push(addEvent$W(parent, "scroll", function() {
              delete _this.chartPosition;
            }));
            parent = parent.parentElement;
          }
          if (H.hasTouch) {
            this.eventsToUnbind.push(addEvent$W(container, "touchstart", this.onContainerTouchStart.bind(this), { passive: false }));
            this.eventsToUnbind.push(addEvent$W(container, "touchmove", this.onContainerTouchMove.bind(this), { passive: false }));
            if (!Pointer2.unbindDocumentTouchEnd) {
              Pointer2.unbindDocumentTouchEnd = addEvent$W(ownerDoc, "touchend", this.onDocumentTouchEnd.bind(this), { passive: false });
            }
          }
        };
        Pointer2.prototype.setHoverChartIndex = function() {
          var chart = this.chart;
          var hoverChart = H.charts[pick$1j(Pointer2.hoverChartIndex, -1)];
          if (hoverChart && hoverChart !== chart) {
            hoverChart.pointer.onContainerMouseLeave({ relatedTarget: true });
          }
          if (!hoverChart || !hoverChart.mouseIsDown) {
            Pointer2.hoverChartIndex = chart.index;
          }
        };
        Pointer2.prototype.touch = function(e2, start) {
          var chart = this.chart;
          var hasMoved, pinchDown, isInside;
          this.setHoverChartIndex();
          if (e2.touches.length === 1) {
            e2 = this.normalize(e2);
            isInside = chart.isInsidePlot(e2.chartX - chart.plotLeft, e2.chartY - chart.plotTop, {
              visiblePlotOnly: true
            });
            if (isInside && !chart.openMenu) {
              if (start) {
                this.runPointActions(e2);
              }
              if (e2.type === "touchmove") {
                pinchDown = this.pinchDown;
                hasMoved = pinchDown[0] ? Math.sqrt(
                  // #5266
                  Math.pow(pinchDown[0].chartX - e2.chartX, 2) + Math.pow(pinchDown[0].chartY - e2.chartY, 2)
                ) >= 4 : false;
              }
              if (pick$1j(hasMoved, true)) {
                this.pinch(e2);
              }
            } else if (start) {
              this.reset();
            }
          } else if (e2.touches.length === 2) {
            this.pinch(e2);
          }
        };
        Pointer2.prototype.touchSelect = function(e2) {
          return Boolean(this.chart.options.chart.zoomBySingleTouch && e2.touches && e2.touches.length === 1);
        };
        Pointer2.prototype.zoomOption = function(e2) {
          var chart = this.chart, options = chart.options.chart, inverted = chart.inverted;
          var zoomType = options.zoomType || "", zoomX, zoomY;
          if (/touch/.test(e2.type)) {
            zoomType = pick$1j(options.pinchType, zoomType);
          }
          this.zoomX = zoomX = /x/.test(zoomType);
          this.zoomY = zoomY = /y/.test(zoomType);
          this.zoomHor = zoomX && !inverted || zoomY && inverted;
          this.zoomVert = zoomY && !inverted || zoomX && inverted;
          this.hasZoom = zoomX || zoomY;
        };
        return Pointer2;
      }()
    );
    var __extends$V = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var charts$2 = H.charts, doc$h = H.doc, noop$i = H.noop, win$a = H.win;
    var addEvent$V = Utilities.addEvent, css$7 = Utilities.css, objectEach$o = Utilities.objectEach, removeEvent$7 = Utilities.removeEvent;
    var touches = {};
    var hasPointerEvent = !!win$a.PointerEvent;
    function getWebkitTouches() {
      var fake = [];
      fake.item = function(i) {
        return this[i];
      };
      objectEach$o(touches, function(touch) {
        fake.push({
          pageX: touch.pageX,
          pageY: touch.pageY,
          target: touch.target
        });
      });
      return fake;
    }
    function translateMSPointer(e2, method, wktype, func) {
      var chart = charts$2[Pointer.hoverChartIndex || NaN];
      if ((e2.pointerType === "touch" || e2.pointerType === e2.MSPOINTER_TYPE_TOUCH) && chart) {
        var p = chart.pointer;
        func(e2);
        p[method]({
          type: wktype,
          target: e2.currentTarget,
          preventDefault: noop$i,
          touches: getWebkitTouches()
        });
      }
    }
    var MSPointer = (
      /** @class */
      function(_super) {
        __extends$V(MSPointer2, _super);
        function MSPointer2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        MSPointer2.isRequired = function() {
          return !!(!H.hasTouch && (win$a.PointerEvent || win$a.MSPointerEvent));
        };
        MSPointer2.prototype.batchMSEvents = function(fn) {
          fn(this.chart.container, hasPointerEvent ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
          fn(this.chart.container, hasPointerEvent ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
          fn(doc$h, hasPointerEvent ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
        };
        MSPointer2.prototype.destroy = function() {
          this.batchMSEvents(removeEvent$7);
          _super.prototype.destroy.call(this);
        };
        MSPointer2.prototype.init = function(chart, options) {
          _super.prototype.init.call(this, chart, options);
          if (this.hasZoom) {
            css$7(chart.container, {
              "-ms-touch-action": "none",
              "touch-action": "none"
            });
          }
        };
        MSPointer2.prototype.onContainerPointerDown = function(e2) {
          translateMSPointer(e2, "onContainerTouchStart", "touchstart", function(e3) {
            touches[e3.pointerId] = {
              pageX: e3.pageX,
              pageY: e3.pageY,
              target: e3.currentTarget
            };
          });
        };
        MSPointer2.prototype.onContainerPointerMove = function(e2) {
          translateMSPointer(e2, "onContainerTouchMove", "touchmove", function(e3) {
            touches[e3.pointerId] = { pageX: e3.pageX, pageY: e3.pageY };
            if (!touches[e3.pointerId].target) {
              touches[e3.pointerId].target = e3.currentTarget;
            }
          });
        };
        MSPointer2.prototype.onDocumentPointerUp = function(e2) {
          translateMSPointer(e2, "onDocumentTouchEnd", "touchend", function(e3) {
            delete touches[e3.pointerId];
          });
        };
        MSPointer2.prototype.setDOMEvents = function() {
          _super.prototype.setDOMEvents.call(this);
          if (this.hasZoom || this.followTouchMove) {
            this.batchMSEvents(addEvent$V);
          }
        };
        return MSPointer2;
      }(Pointer)
    );
    var animObject$8 = animationExports.animObject, setAnimation$4 = animationExports.setAnimation;
    var format$b = FormatUtilities.format;
    var isFirefox$1 = H.isFirefox, marginNames$1 = H.marginNames, win$9 = H.win;
    var distribute$2 = R.distribute;
    var addEvent$U = Utilities.addEvent, createElement$6 = Utilities.createElement, css$6 = Utilities.css, defined$I = Utilities.defined, discardElement$4 = Utilities.discardElement, find$h = Utilities.find, fireEvent$t = Utilities.fireEvent, isNumber$C = Utilities.isNumber, merge$1c = Utilities.merge, pick$1i = Utilities.pick, relativeLength$8 = Utilities.relativeLength, stableSort$5 = Utilities.stableSort, syncTimeout$4 = Utilities.syncTimeout, wrap$c = Utilities.wrap;
    var Legend = (
      /** @class */
      function() {
        function Legend2(chart, options) {
          this.allItems = [];
          this.box = void 0;
          this.contentGroup = void 0;
          this.display = false;
          this.group = void 0;
          this.initialItemY = 0;
          this.itemHeight = 0;
          this.itemMarginBottom = 0;
          this.itemMarginTop = 0;
          this.itemX = 0;
          this.itemY = 0;
          this.lastItemY = 0;
          this.lastLineHeight = 0;
          this.legendHeight = 0;
          this.legendWidth = 0;
          this.maxItemWidth = 0;
          this.maxLegendWidth = 0;
          this.offsetWidth = 0;
          this.options = {};
          this.padding = 0;
          this.pages = [];
          this.proximate = false;
          this.scrollGroup = void 0;
          this.symbolHeight = 0;
          this.symbolWidth = 0;
          this.titleHeight = 0;
          this.totalItemWidth = 0;
          this.widthOption = 0;
          this.chart = chart;
          this.init(chart, options);
        }
        Legend2.prototype.init = function(chart, options) {
          this.chart = chart;
          this.setOptions(options);
          if (options.enabled) {
            this.render();
            addEvent$U(this.chart, "endResize", function() {
              this.legend.positionCheckboxes();
            });
            if (this.proximate) {
              this.unchartrender = addEvent$U(this.chart, "render", function() {
                this.legend.proximatePositions();
                this.legend.positionItems();
              });
            } else if (this.unchartrender) {
              this.unchartrender();
            }
          }
        };
        Legend2.prototype.setOptions = function(options) {
          var padding = pick$1i(options.padding, 8);
          this.options = options;
          if (!this.chart.styledMode) {
            this.itemStyle = options.itemStyle;
            this.itemHiddenStyle = merge$1c(this.itemStyle, options.itemHiddenStyle);
          }
          this.itemMarginTop = options.itemMarginTop || 0;
          this.itemMarginBottom = options.itemMarginBottom || 0;
          this.padding = padding;
          this.initialItemY = padding - 5;
          this.symbolWidth = pick$1i(options.symbolWidth, 16);
          this.pages = [];
          this.proximate = options.layout === "proximate" && !this.chart.inverted;
          this.baseline = void 0;
        };
        Legend2.prototype.update = function(options, redraw) {
          var chart = this.chart;
          this.setOptions(merge$1c(true, this.options, options));
          this.destroy();
          chart.isDirtyLegend = chart.isDirtyBox = true;
          if (pick$1i(redraw, true)) {
            chart.redraw();
          }
          fireEvent$t(this, "afterUpdate");
        };
        Legend2.prototype.colorizeItem = function(item2, visible) {
          item2.legendGroup[visible ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
          if (!this.chart.styledMode) {
            var legend = this, options = legend.options, legendItem = item2.legendItem, legendLine = item2.legendLine, legendSymbol = item2.legendSymbol, hiddenColor = legend.itemHiddenStyle.color, textColor = visible ? options.itemStyle.color : hiddenColor, symbolColor = visible ? item2.color || hiddenColor : hiddenColor, markerOptions = item2.options && item2.options.marker;
            var symbolAttr = { fill: symbolColor };
            if (legendItem) {
              legendItem.css({
                fill: textColor,
                color: textColor
                // #1553, oldIE
              });
            }
            if (legendLine) {
              legendLine.attr({ stroke: symbolColor });
            }
            if (legendSymbol) {
              if (markerOptions && legendSymbol.isMarker) {
                symbolAttr = item2.pointAttribs();
                if (!visible) {
                  symbolAttr.stroke = symbolAttr.fill = hiddenColor;
                }
              }
              legendSymbol.attr(symbolAttr);
            }
          }
          fireEvent$t(this, "afterColorizeItem", { item: item2, visible });
        };
        Legend2.prototype.positionItems = function() {
          this.allItems.forEach(this.positionItem, this);
          if (!this.chart.isResizing) {
            this.positionCheckboxes();
          }
        };
        Legend2.prototype.positionItem = function(item2) {
          var _this = this;
          var legend = this, options = legend.options, symbolPadding = options.symbolPadding, ltr = !options.rtl, legendItemPos = item2._legendItemPos, itemX = legendItemPos[0], itemY = legendItemPos[1], checkbox = item2.checkbox, legendGroup = item2.legendGroup;
          if (legendGroup && legendGroup.element) {
            var attribs = {
              translateX: ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
              translateY: itemY
            };
            var complete = function() {
              fireEvent$t(_this, "afterPositionItem", { item: item2 });
            };
            if (defined$I(legendGroup.translateY)) {
              legendGroup.animate(attribs, void 0, complete);
            } else {
              legendGroup.attr(attribs);
              complete();
            }
          }
          if (checkbox) {
            checkbox.x = itemX;
            checkbox.y = itemY;
          }
        };
        Legend2.prototype.destroyItem = function(item2) {
          var checkbox = item2.checkbox;
          ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function(key) {
            if (item2[key]) {
              item2[key] = item2[key].destroy();
            }
          });
          if (checkbox) {
            discardElement$4(item2.checkbox);
          }
        };
        Legend2.prototype.destroy = function() {
          function destroyItems(key) {
            if (this[key]) {
              this[key] = this[key].destroy();
            }
          }
          this.getAllItems().forEach(function(item2) {
            ["legendItem", "legendGroup"].forEach(destroyItems, item2);
          });
          [
            "clipRect",
            "up",
            "down",
            "pager",
            "nav",
            "box",
            "title",
            "group"
          ].forEach(destroyItems, this);
          this.display = null;
        };
        Legend2.prototype.positionCheckboxes = function() {
          var alignAttr = this.group && this.group.alignAttr, clipHeight = this.clipHeight || this.legendHeight, titleHeight = this.titleHeight;
          var translateY;
          if (alignAttr) {
            translateY = alignAttr.translateY;
            this.allItems.forEach(function(item2) {
              var checkbox = item2.checkbox;
              var top;
              if (checkbox) {
                top = translateY + titleHeight + checkbox.y + (this.scrollOffset || 0) + 3;
                css$6(checkbox, {
                  left: alignAttr.translateX + item2.checkboxOffset + checkbox.x - 20 + "px",
                  top: top + "px",
                  display: this.proximate || top > translateY - 6 && top < translateY + clipHeight - 6 ? "" : "none"
                });
              }
            }, this);
          }
        };
        Legend2.prototype.renderTitle = function() {
          var options = this.options, padding = this.padding, titleOptions = options.title;
          var bBox, titleHeight = 0;
          if (titleOptions.text) {
            if (!this.title) {
              this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, options.useHTML, null, "legend-title").attr({ zIndex: 1 });
              if (!this.chart.styledMode) {
                this.title.css(titleOptions.style);
              }
              this.title.add(this.group);
            }
            if (!titleOptions.width) {
              this.title.css({
                width: this.maxLegendWidth + "px"
              });
            }
            bBox = this.title.getBBox();
            titleHeight = bBox.height;
            this.offsetWidth = bBox.width;
            this.contentGroup.attr({ translateY: titleHeight });
          }
          this.titleHeight = titleHeight;
        };
        Legend2.prototype.setText = function(item2) {
          var options = this.options;
          item2.legendItem.attr({
            text: options.labelFormat ? format$b(options.labelFormat, item2, this.chart) : options.labelFormatter.call(item2)
          });
        };
        Legend2.prototype.renderItem = function(item2) {
          var legend = this, chart = legend.chart, renderer = chart.renderer, options = legend.options, horizontal = options.layout === "horizontal", symbolWidth = legend.symbolWidth, symbolPadding = options.symbolPadding || 0, itemStyle = legend.itemStyle, itemHiddenStyle = legend.itemHiddenStyle, itemDistance = horizontal ? pick$1i(options.itemDistance, 20) : 0, ltr = !options.rtl, isSeries = !item2.series, series = !isSeries && item2.series.drawLegendSymbol ? item2.series : item2, seriesOptions = series.options, showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox, useHTML = options.useHTML, itemClassName = item2.options.className;
          var li = item2.legendItem, itemExtraWidth = symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
          if (!li) {
            item2.legendGroup = renderer.g("legend-item").addClass("highcharts-" + series.type + "-series highcharts-color-" + item2.colorIndex + (itemClassName ? " " + itemClassName : "") + (isSeries ? " highcharts-series-" + item2.index : "")).attr({ zIndex: 1 }).add(legend.scrollGroup);
            item2.legendItem = li = renderer.text("", ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline || 0, useHTML);
            if (!chart.styledMode) {
              li.css(merge$1c(item2.visible ? itemStyle : itemHiddenStyle));
            }
            li.attr({
              align: ltr ? "left" : "right",
              zIndex: 2
            }).add(item2.legendGroup);
            if (!legend.baseline) {
              legend.fontMetrics = renderer.fontMetrics(chart.styledMode ? 12 : itemStyle.fontSize, li);
              legend.baseline = legend.fontMetrics.f + 3 + legend.itemMarginTop;
              li.attr("y", legend.baseline);
              legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;
              if (options.squareSymbol) {
                legend.symbolWidth = pick$1i(options.symbolWidth, Math.max(legend.symbolHeight, 16));
                itemExtraWidth = legend.symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
                if (ltr) {
                  li.attr("x", legend.symbolWidth + symbolPadding);
                }
              }
            }
            series.drawLegendSymbol(legend, item2);
            if (legend.setItemEvents) {
              legend.setItemEvents(item2, li, useHTML);
            }
          }
          if (showCheckbox && !item2.checkbox && legend.createCheckboxForItem) {
            legend.createCheckboxForItem(item2);
          }
          legend.colorizeItem(item2, item2.visible);
          if (chart.styledMode || !itemStyle.width) {
            li.css({
              width: (options.itemWidth || legend.widthOption || chart.spacingBox.width) - itemExtraWidth + "px"
            });
          }
          legend.setText(item2);
          var bBox = li.getBBox();
          item2.itemWidth = item2.checkboxOffset = options.itemWidth || item2.legendItemWidth || bBox.width + itemExtraWidth;
          legend.maxItemWidth = Math.max(legend.maxItemWidth, item2.itemWidth);
          legend.totalItemWidth += item2.itemWidth;
          legend.itemHeight = item2.itemHeight = Math.round(item2.legendItemHeight || bBox.height || legend.symbolHeight);
        };
        Legend2.prototype.layoutItem = function(item2) {
          var options = this.options, padding = this.padding, horizontal = options.layout === "horizontal", itemHeight = item2.itemHeight, itemMarginBottom = this.itemMarginBottom, itemMarginTop = this.itemMarginTop, itemDistance = horizontal ? pick$1i(options.itemDistance, 20) : 0, maxLegendWidth = this.maxLegendWidth, itemWidth = options.alignColumns && this.totalItemWidth > maxLegendWidth ? this.maxItemWidth : item2.itemWidth;
          if (horizontal && this.itemX - padding + itemWidth > maxLegendWidth) {
            this.itemX = padding;
            if (this.lastLineHeight) {
              this.itemY += itemMarginTop + this.lastLineHeight + itemMarginBottom;
            }
            this.lastLineHeight = 0;
          }
          this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;
          this.lastLineHeight = Math.max(
            // #915
            itemHeight,
            this.lastLineHeight
          );
          item2._legendItemPos = [this.itemX, this.itemY];
          if (horizontal) {
            this.itemX += itemWidth;
          } else {
            this.itemY += itemMarginTop + itemHeight + itemMarginBottom;
            this.lastLineHeight = itemHeight;
          }
          this.offsetWidth = this.widthOption || Math.max((horizontal ? this.itemX - padding - (item2.checkbox ? (
            // decrease by itemDistance only when no checkbox #4853
            0
          ) : itemDistance) : itemWidth) + padding, this.offsetWidth);
        };
        Legend2.prototype.getAllItems = function() {
          var allItems = [];
          this.chart.series.forEach(function(series) {
            var seriesOptions = series && series.options;
            if (series && pick$1i(seriesOptions.showInLegend, !defined$I(seriesOptions.linkedTo) ? void 0 : false, true)) {
              allItems = allItems.concat(series.legendItems || (seriesOptions.legendType === "point" ? series.data : series));
            }
          });
          fireEvent$t(this, "afterGetAllItems", { allItems });
          return allItems;
        };
        Legend2.prototype.getAlignment = function() {
          var options = this.options;
          if (this.proximate) {
            return options.align.charAt(0) + "tv";
          }
          return options.floating ? "" : options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0);
        };
        Legend2.prototype.adjustMargins = function(margin, spacing) {
          var chart = this.chart, options = this.options, alignment = this.getAlignment();
          if (alignment) {
            [
              /(lth|ct|rth)/,
              /(rtv|rm|rbv)/,
              /(rbh|cb|lbh)/,
              /(lbv|lm|ltv)/
            ].forEach(function(alignments, side) {
              if (alignments.test(alignment) && !defined$I(margin[side])) {
                chart[marginNames$1[side]] = Math.max(chart[marginNames$1[side]], chart.legend[(side + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][side] * options[side % 2 ? "x" : "y"] + pick$1i(options.margin, 12) + spacing[side] + (chart.titleOffset[side] || 0));
              }
            });
          }
        };
        Legend2.prototype.proximatePositions = function() {
          var chart = this.chart, boxes = [], alignLeft = this.options.align === "left";
          this.allItems.forEach(function(item2) {
            var lastPoint, height, useFirstPoint = alignLeft, target, top;
            if (item2.yAxis) {
              if (item2.xAxis.options.reversed) {
                useFirstPoint = !useFirstPoint;
              }
              if (item2.points) {
                lastPoint = find$h(useFirstPoint ? item2.points : item2.points.slice(0).reverse(), function(item3) {
                  return isNumber$C(item3.plotY);
                });
              }
              height = this.itemMarginTop + item2.legendItem.getBBox().height + this.itemMarginBottom;
              top = item2.yAxis.top - chart.plotTop;
              if (item2.visible) {
                target = lastPoint ? lastPoint.plotY : item2.yAxis.height;
                target += top - 0.3 * height;
              } else {
                target = top + item2.yAxis.height;
              }
              boxes.push({
                target,
                size: height,
                item: item2
              });
            }
          }, this);
          distribute$2(boxes, chart.plotHeight).forEach(function(box) {
            if (box.item._legendItemPos) {
              box.item._legendItemPos[1] = chart.plotTop - chart.spacing[0] + box.pos;
            }
          });
        };
        Legend2.prototype.render = function() {
          var legend = this, chart = legend.chart, renderer = chart.renderer, options = legend.options, padding = legend.padding, allItems = legend.getAllItems();
          var display, legendWidth, legendHeight, legendGroup = legend.group, allowedWidth, box = legend.box;
          legend.itemX = padding;
          legend.itemY = legend.initialItemY;
          legend.offsetWidth = 0;
          legend.lastItemY = 0;
          legend.widthOption = relativeLength$8(options.width, chart.spacingBox.width - padding);
          allowedWidth = chart.spacingBox.width - 2 * padding - options.x;
          if (["rm", "lm"].indexOf(legend.getAlignment().substring(0, 2)) > -1) {
            allowedWidth /= 2;
          }
          legend.maxLegendWidth = legend.widthOption || allowedWidth;
          if (!legendGroup) {
            legend.group = legendGroup = renderer.g("legend").addClass(options.className || "").attr({ zIndex: 7 }).add();
            legend.contentGroup = renderer.g().attr({ zIndex: 1 }).add(legendGroup);
            legend.scrollGroup = renderer.g().add(legend.contentGroup);
          }
          legend.renderTitle();
          stableSort$5(allItems, function(a, b) {
            return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
          });
          if (options.reversed) {
            allItems.reverse();
          }
          legend.allItems = allItems;
          legend.display = display = !!allItems.length;
          legend.lastLineHeight = 0;
          legend.maxItemWidth = 0;
          legend.totalItemWidth = 0;
          legend.itemHeight = 0;
          allItems.forEach(legend.renderItem, legend);
          allItems.forEach(legend.layoutItem, legend);
          legendWidth = (legend.widthOption || legend.offsetWidth) + padding;
          legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
          legendHeight = legend.handleOverflow(legendHeight);
          legendHeight += padding;
          if (!box) {
            legend.box = box = renderer.rect().addClass("highcharts-legend-box").attr({
              r: options.borderRadius
            }).add(legendGroup);
            box.isNew = true;
          }
          if (!chart.styledMode) {
            box.attr({
              stroke: options.borderColor,
              "stroke-width": options.borderWidth || 0,
              fill: options.backgroundColor || "none"
            }).shadow(options.shadow);
          }
          if (legendWidth > 0 && legendHeight > 0) {
            box[box.isNew ? "attr" : "animate"](box.crisp.call({}, {
              x: 0,
              y: 0,
              width: legendWidth,
              height: legendHeight
            }, box.strokeWidth()));
            box.isNew = false;
          }
          box[display ? "show" : "hide"]();
          if (chart.styledMode && legendGroup.getStyle("display") === "none") {
            legendWidth = legendHeight = 0;
          }
          legend.legendWidth = legendWidth;
          legend.legendHeight = legendHeight;
          if (display) {
            legend.align();
          }
          if (!this.proximate) {
            this.positionItems();
          }
          fireEvent$t(this, "afterRender");
        };
        Legend2.prototype.align = function(alignTo) {
          if (alignTo === void 0) {
            alignTo = this.chart.spacingBox;
          }
          var chart = this.chart, options = this.options;
          var y = alignTo.y;
          if (/(lth|ct|rth)/.test(this.getAlignment()) && chart.titleOffset[0] > 0) {
            y += chart.titleOffset[0];
          } else if (/(lbh|cb|rbh)/.test(this.getAlignment()) && chart.titleOffset[2] > 0) {
            y -= chart.titleOffset[2];
          }
          if (y !== alignTo.y) {
            alignTo = merge$1c(alignTo, { y });
          }
          this.group.align(merge$1c(options, {
            width: this.legendWidth,
            height: this.legendHeight,
            verticalAlign: this.proximate ? "top" : options.verticalAlign
          }), true, alignTo);
        };
        Legend2.prototype.handleOverflow = function(legendHeight) {
          var legend = this, chart = this.chart, renderer = chart.renderer, options = this.options, optionsY = options.y, alignTop = options.verticalAlign === "top", padding = this.padding, maxHeight = options.maxHeight, navOptions = options.navigation, animation = pick$1i(navOptions.animation, true), arrowSize = navOptions.arrowSize || 12, pages = this.pages, allItems = this.allItems, clipToHeight = function(height) {
            if (typeof height === "number") {
              clipRect.attr({
                height
              });
            } else if (clipRect) {
              legend.clipRect = clipRect.destroy();
              legend.contentGroup.clip();
            }
            if (legend.contentGroup.div) {
              legend.contentGroup.div.style.clip = height ? "rect(" + padding + "px,9999px," + (padding + height) + "px,0)" : "auto";
            }
          }, addTracker = function(key) {
            legend[key] = renderer.circle(0, 0, arrowSize * 1.3).translate(arrowSize / 2, arrowSize / 2).add(nav);
            if (!chart.styledMode) {
              legend[key].attr("fill", "rgba(0,0,0,0.0001)");
            }
            return legend[key];
          };
          var clipHeight, lastY, spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - padding, nav = this.nav, clipRect = this.clipRect;
          if (options.layout === "horizontal" && options.verticalAlign !== "middle" && !options.floating) {
            spaceHeight /= 2;
          }
          if (maxHeight) {
            spaceHeight = Math.min(spaceHeight, maxHeight);
          }
          pages.length = 0;
          if (legendHeight && spaceHeight > 0 && legendHeight > spaceHeight && navOptions.enabled !== false) {
            this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
            this.currentPage = pick$1i(this.currentPage, 1);
            this.fullHeight = legendHeight;
            allItems.forEach(function(item2, i) {
              var y = item2._legendItemPos[1], h = Math.round(item2.legendItem.getBBox().height);
              var len = pages.length;
              if (!len || y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1]) {
                pages.push(lastY || y);
                len++;
              }
              item2.pageIx = len - 1;
              if (lastY) {
                allItems[i - 1].pageIx = len - 1;
              }
              if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight && y !== lastY) {
                pages.push(y);
                item2.pageIx = len;
              }
              if (y !== lastY) {
                lastY = y;
              }
            });
            if (!clipRect) {
              clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
              legend.contentGroup.clip(clipRect);
            }
            clipToHeight(clipHeight);
            if (!nav) {
              this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
              this.up = renderer.symbol("triangle", 0, 0, arrowSize, arrowSize).add(nav);
              addTracker("upTracker").on("click", function() {
                legend.scroll(-1, animation);
              });
              this.pager = renderer.text("", 15, 10).addClass("highcharts-legend-navigation");
              if (!chart.styledMode) {
                this.pager.css(navOptions.style);
              }
              this.pager.add(nav);
              this.down = renderer.symbol("triangle-down", 0, 0, arrowSize, arrowSize).add(nav);
              addTracker("downTracker").on("click", function() {
                legend.scroll(1, animation);
              });
            }
            legend.scroll(0);
            legendHeight = spaceHeight;
          } else if (nav) {
            clipToHeight();
            this.nav = nav.destroy();
            this.scrollGroup.attr({
              translateY: 1
            });
            this.clipHeight = 0;
          }
          return legendHeight;
        };
        Legend2.prototype.scroll = function(scrollBy, animation) {
          var _this = this;
          var chart = this.chart, pages = this.pages, pageCount = pages.length, clipHeight = this.clipHeight, navOptions = this.options.navigation, pager = this.pager, padding = this.padding;
          var currentPage = this.currentPage + scrollBy;
          if (currentPage > pageCount) {
            currentPage = pageCount;
          }
          if (currentPage > 0) {
            if (typeof animation !== "undefined") {
              setAnimation$4(animation, chart);
            }
            this.nav.attr({
              translateX: padding,
              translateY: clipHeight + this.padding + 7 + this.titleHeight,
              visibility: "visible"
            });
            [this.up, this.upTracker].forEach(function(elem) {
              elem.attr({
                "class": currentPage === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
              });
            });
            pager.attr({
              text: currentPage + "/" + pageCount
            });
            [this.down, this.downTracker].forEach(function(elem) {
              elem.attr({
                // adjust to text width
                x: 18 + this.pager.getBBox().width,
                "class": currentPage === pageCount ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
              });
            }, this);
            if (!chart.styledMode) {
              this.up.attr({
                fill: currentPage === 1 ? navOptions.inactiveColor : navOptions.activeColor
              });
              this.upTracker.css({
                cursor: currentPage === 1 ? "default" : "pointer"
              });
              this.down.attr({
                fill: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor
              });
              this.downTracker.css({
                cursor: currentPage === pageCount ? "default" : "pointer"
              });
            }
            this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;
            this.scrollGroup.animate({
              translateY: this.scrollOffset
            });
            this.currentPage = currentPage;
            this.positionCheckboxes();
            var animOptions = animObject$8(pick$1i(animation, chart.renderer.globalAnimation, true));
            syncTimeout$4(function() {
              fireEvent$t(_this, "afterScroll", { currentPage });
            }, animOptions.duration);
          }
        };
        Legend2.prototype.setItemEvents = function(item2, legendItem, useHTML) {
          var legend = this, boxWrapper = legend.chart.renderer.boxWrapper, isPoint = item2 instanceof Point$2, activeClass = "highcharts-legend-" + (isPoint ? "point" : "series") + "-active", styledMode = legend.chart.styledMode, legendItems = useHTML ? [legendItem, item2.legendSymbol] : [item2.legendGroup];
          var setOtherItemsState = function(state) {
            legend.allItems.forEach(function(otherItem) {
              if (item2 !== otherItem) {
                [otherItem].concat(otherItem.linkedSeries || []).forEach(function(otherItem2) {
                  otherItem2.setState(state, !isPoint);
                });
              }
            });
          };
          legendItems.forEach(function(element) {
            if (element) {
              element.on("mouseover", function() {
                if (item2.visible) {
                  setOtherItemsState("inactive");
                }
                item2.setState("hover");
                if (item2.visible) {
                  boxWrapper.addClass(activeClass);
                }
                if (!styledMode) {
                  legendItem.css(legend.options.itemHoverStyle);
                }
              }).on("mouseout", function() {
                if (!legend.chart.styledMode) {
                  legendItem.css(merge$1c(item2.visible ? legend.itemStyle : legend.itemHiddenStyle));
                }
                setOtherItemsState("");
                boxWrapper.removeClass(activeClass);
                item2.setState();
              }).on("click", function(event) {
                var strLegendItemClick = "legendItemClick", fnLegendItemClick = function() {
                  if (item2.setVisible) {
                    item2.setVisible();
                  }
                  setOtherItemsState(item2.visible ? "inactive" : "");
                };
                boxWrapper.removeClass(activeClass);
                event = {
                  browserEvent: event
                };
                if (item2.firePointEvent) {
                  item2.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
                } else {
                  fireEvent$t(item2, strLegendItemClick, event, fnLegendItemClick);
                }
              });
            }
          });
        };
        Legend2.prototype.createCheckboxForItem = function(item2) {
          var legend = this;
          item2.checkbox = createElement$6("input", {
            type: "checkbox",
            className: "highcharts-legend-checkbox",
            checked: item2.selected,
            defaultChecked: item2.selected
            // required by IE7
          }, legend.options.itemCheckboxStyle, legend.chart.container);
          addEvent$U(item2.checkbox, "click", function(event) {
            var target = event.target;
            fireEvent$t(item2.series || item2, "checkboxClick", {
              checked: target.checked,
              item: item2
            }, function() {
              item2.select();
            });
          });
        };
        return Legend2;
      }()
    );
    if (/Trident\/7\.0/.test(win$9.navigator && win$9.navigator.userAgent) || isFirefox$1) {
      wrap$c(Legend.prototype, "positionItem", function(proceed, item2) {
        var legend = this, runPositionItem = function() {
          if (item2._legendItemPos) {
            proceed.call(legend, item2);
          }
        };
        runPositionItem();
        if (!legend.bubbleLegend) {
          setTimeout(runPositionItem);
        }
      });
    }
    var defaultOptions$c = DefaultOptions.defaultOptions;
    var error$6 = Utilities.error, extendClass$1 = Utilities.extendClass, merge$1b = Utilities.merge;
    var SeriesRegistry;
    (function(SeriesRegistry2) {
      SeriesRegistry2.seriesTypes = H.seriesTypes;
      function getSeries(chart, options) {
        if (options === void 0) {
          options = {};
        }
        var optionsChart = chart.options.chart, type = options.type || optionsChart.type || optionsChart.defaultSeriesType || "", SeriesClass = SeriesRegistry2.seriesTypes[type];
        if (!SeriesRegistry2) {
          error$6(17, true, chart, { missingModuleFor: type });
        }
        var series = new SeriesClass();
        if (typeof series.init === "function") {
          series.init(chart, options);
        }
        return series;
      }
      SeriesRegistry2.getSeries = getSeries;
      function registerSeriesType(seriesType2, seriesClass) {
        var defaultPlotOptions = defaultOptions$c.plotOptions || {}, seriesOptions = seriesClass.defaultOptions;
        if (!seriesClass.prototype.pointClass) {
          seriesClass.prototype.pointClass = Point$2;
        }
        seriesClass.prototype.type = seriesType2;
        if (seriesOptions) {
          defaultPlotOptions[seriesType2] = seriesOptions;
        }
        SeriesRegistry2.seriesTypes[seriesType2] = seriesClass;
      }
      SeriesRegistry2.registerSeriesType = registerSeriesType;
      function seriesType(type, parent, options, seriesProto2, pointProto2) {
        var defaultPlotOptions = defaultOptions$c.plotOptions || {};
        parent = parent || "";
        defaultPlotOptions[type] = merge$1b(defaultPlotOptions[parent], options);
        registerSeriesType(type, extendClass$1(SeriesRegistry2.seriesTypes[parent] || function() {
        }, seriesProto2));
        SeriesRegistry2.seriesTypes[type].prototype.type = type;
        if (pointProto2) {
          SeriesRegistry2.seriesTypes[type].prototype.pointClass = extendClass$1(Point$2, pointProto2);
        }
        return SeriesRegistry2.seriesTypes[type];
      }
      SeriesRegistry2.seriesType = seriesType;
    })(SeriesRegistry || (SeriesRegistry = {}));
    const SeriesRegistry$1 = SeriesRegistry;
    var animate = animationExports.animate, animObject$7 = animationExports.animObject, setAnimation$3 = animationExports.setAnimation;
    var numberFormat$1 = FormatUtilities.numberFormat;
    var registerEventOptions$1 = exports$3.registerEventOptions;
    var charts$1 = H.charts, doc$g = H.doc, marginNames = H.marginNames, svg$3 = H.svg, win$8 = H.win;
    var defaultOptions$b = DefaultOptions.defaultOptions, defaultTime = DefaultOptions.defaultTime;
    var seriesTypes$7 = SeriesRegistry$1.seriesTypes;
    var addEvent$T = Utilities.addEvent, attr$1 = Utilities.attr, cleanRecursively$1 = Utilities.cleanRecursively, createElement$5 = Utilities.createElement, css$5 = Utilities.css, defined$H = Utilities.defined, discardElement$3 = Utilities.discardElement, erase$3 = Utilities.erase, error$5 = Utilities.error, extend$1d = Utilities.extend, find$g = Utilities.find, fireEvent$s = Utilities.fireEvent, getStyle = Utilities.getStyle, isArray$g = Utilities.isArray, isNumber$B = Utilities.isNumber, isObject$9 = Utilities.isObject, isString$5 = Utilities.isString, merge$1a = Utilities.merge, objectEach$n = Utilities.objectEach, pick$1h = Utilities.pick, pInt$4 = Utilities.pInt, relativeLength$7 = Utilities.relativeLength, removeEvent$6 = Utilities.removeEvent, splat$d = Utilities.splat, syncTimeout$3 = Utilities.syncTimeout, uniqueKey$4 = Utilities.uniqueKey;
    var Chart$1 = (
      /** @class */
      function() {
        function Chart2(a, b, c) {
          this.axes = void 0;
          this.axisOffset = void 0;
          this.bounds = void 0;
          this.chartHeight = void 0;
          this.chartWidth = void 0;
          this.clipBox = void 0;
          this.colorCounter = void 0;
          this.container = void 0;
          this.eventOptions = void 0;
          this.index = void 0;
          this.isResizing = void 0;
          this.labelCollectors = void 0;
          this.legend = void 0;
          this.margin = void 0;
          this.numberFormatter = void 0;
          this.options = void 0;
          this.plotBox = void 0;
          this.plotHeight = void 0;
          this.plotLeft = void 0;
          this.plotTop = void 0;
          this.plotWidth = void 0;
          this.pointCount = void 0;
          this.pointer = void 0;
          this.renderer = void 0;
          this.renderTo = void 0;
          this.series = void 0;
          this.sharedClips = {};
          this.spacing = void 0;
          this.spacingBox = void 0;
          this.symbolCounter = void 0;
          this.time = void 0;
          this.titleOffset = void 0;
          this.userOptions = void 0;
          this.xAxis = void 0;
          this.yAxis = void 0;
          this.getArgs(a, b, c);
        }
        Chart2.chart = function(a, b, c) {
          return new Chart2(a, b, c);
        };
        Chart2.prototype.getArgs = function(a, b, c) {
          if (isString$5(a) || a.nodeName) {
            this.renderTo = a;
            this.init(b, c);
          } else {
            this.init(a, b);
          }
        };
        Chart2.prototype.init = function(userOptions, callback) {
          var userPlotOptions = userOptions.plotOptions || {};
          fireEvent$s(this, "init", { args: arguments }, function() {
            var options = merge$1a(defaultOptions$b, userOptions);
            var optionsChart = options.chart;
            objectEach$n(options.plotOptions, function(typeOptions, type) {
              if (isObject$9(typeOptions)) {
                typeOptions.tooltip = userPlotOptions[type] && // override by copy:
                merge$1a(userPlotOptions[type].tooltip) || void 0;
              }
            });
            options.tooltip.userOptions = userOptions.chart && userOptions.chart.forExport && userOptions.tooltip.userOptions || userOptions.tooltip;
            this.userOptions = userOptions;
            this.margin = [];
            this.spacing = [];
            this.bounds = { h: {}, v: {} };
            this.labelCollectors = [];
            this.callback = callback;
            this.isResizing = 0;
            this.options = options;
            this.axes = [];
            this.series = [];
            this.time = userOptions.time && Object.keys(userOptions.time).length ? new Time(userOptions.time) : H.time;
            this.numberFormatter = optionsChart.numberFormatter || numberFormat$1;
            this.styledMode = optionsChart.styledMode;
            this.hasCartesianSeries = optionsChart.showAxes;
            var chart = this;
            chart.index = charts$1.length;
            charts$1.push(chart);
            H.chartCount++;
            registerEventOptions$1(this, optionsChart);
            chart.xAxis = [];
            chart.yAxis = [];
            chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;
            fireEvent$s(chart, "afterInit");
            chart.firstRender();
          });
        };
        Chart2.prototype.initSeries = function(options) {
          var chart = this, optionsChart = chart.options.chart, type = options.type || optionsChart.type || optionsChart.defaultSeriesType, SeriesClass = seriesTypes$7[type];
          if (!SeriesClass) {
            error$5(17, true, chart, { missingModuleFor: type });
          }
          var series = new SeriesClass();
          if (typeof series.init === "function") {
            series.init(chart, options);
          }
          return series;
        };
        Chart2.prototype.setSeriesData = function() {
          this.getSeriesOrderByLinks().forEach(function(series) {
            if (!series.points && !series.data && series.enabledDataSorting) {
              series.setData(series.options.data, false);
            }
          });
        };
        Chart2.prototype.getSeriesOrderByLinks = function() {
          return this.series.concat().sort(function(a, b) {
            if (a.linkedSeries.length || b.linkedSeries.length) {
              return b.linkedSeries.length - a.linkedSeries.length;
            }
            return 0;
          });
        };
        Chart2.prototype.orderSeries = function(fromIndex) {
          var series = this.series;
          for (var i = fromIndex || 0, iEnd = series.length; i < iEnd; ++i) {
            if (series[i]) {
              series[i].index = i;
              series[i].name = series[i].getName();
            }
          }
        };
        Chart2.prototype.isInsidePlot = function(plotX, plotY, options) {
          var _a2;
          if (options === void 0) {
            options = {};
          }
          var _b = this, inverted = _b.inverted, plotBox = _b.plotBox, plotLeft = _b.plotLeft, plotTop = _b.plotTop, scrollablePlotBox = _b.scrollablePlotBox;
          var scrollLeft = 0, scrollTop = 0;
          if (options.visiblePlotOnly && this.scrollingContainer) {
            _a2 = this.scrollingContainer, scrollLeft = _a2.scrollLeft, scrollTop = _a2.scrollTop;
          }
          var series = options.series, box = options.visiblePlotOnly && scrollablePlotBox || plotBox, x = options.inverted ? plotY : plotX, y = options.inverted ? plotX : plotY, e2 = {
            x,
            y,
            isInsidePlot: true
          };
          if (!options.ignoreX) {
            var xAxis = series && (inverted ? series.yAxis : series.xAxis) || {
              pos: plotLeft,
              len: Infinity
            };
            var chartX = options.paneCoordinates ? xAxis.pos + x : plotLeft + x;
            if (!(chartX >= Math.max(scrollLeft + plotLeft, xAxis.pos) && chartX <= Math.min(scrollLeft + plotLeft + box.width, xAxis.pos + xAxis.len))) {
              e2.isInsidePlot = false;
            }
          }
          if (!options.ignoreY && e2.isInsidePlot) {
            var yAxis = series && (inverted ? series.xAxis : series.yAxis) || {
              pos: plotTop,
              len: Infinity
            };
            var chartY = options.paneCoordinates ? yAxis.pos + y : plotTop + y;
            if (!(chartY >= Math.max(scrollTop + plotTop, yAxis.pos) && chartY <= Math.min(scrollTop + plotTop + box.height, yAxis.pos + yAxis.len))) {
              e2.isInsidePlot = false;
            }
          }
          fireEvent$s(this, "afterIsInsidePlot", e2);
          return e2.isInsidePlot;
        };
        Chart2.prototype.redraw = function(animation) {
          fireEvent$s(this, "beforeRedraw");
          var chart = this, axes = chart.hasCartesianSeries ? chart.axes : chart.colorAxis || [], series = chart.series, pointer = chart.pointer, legend = chart.legend, legendUserOptions = chart.userOptions.legend, renderer = chart.renderer, isHiddenChart = renderer.isHidden(), afterRedraw = [];
          var hasDirtyStacks, hasStackedSeries, i, isDirtyBox = chart.isDirtyBox, redrawLegend = chart.isDirtyLegend, serie;
          if (chart.setResponsive) {
            chart.setResponsive(false);
          }
          setAnimation$3(chart.hasRendered ? animation : false, chart);
          if (isHiddenChart) {
            chart.temporaryDisplay();
          }
          chart.layOutTitles();
          i = series.length;
          while (i--) {
            serie = series[i];
            if (serie.options.stacking || serie.options.centerInCategory) {
              hasStackedSeries = true;
              if (serie.isDirty) {
                hasDirtyStacks = true;
                break;
              }
            }
          }
          if (hasDirtyStacks) {
            i = series.length;
            while (i--) {
              serie = series[i];
              if (serie.options.stacking) {
                serie.isDirty = true;
              }
            }
          }
          series.forEach(function(serie2) {
            if (serie2.isDirty) {
              if (serie2.options.legendType === "point") {
                if (typeof serie2.updateTotals === "function") {
                  serie2.updateTotals();
                }
                redrawLegend = true;
              } else if (legendUserOptions && (legendUserOptions.labelFormatter || legendUserOptions.labelFormat)) {
                redrawLegend = true;
              }
            }
            if (serie2.isDirtyData) {
              fireEvent$s(serie2, "updatedData");
            }
          });
          if (redrawLegend && legend && legend.options.enabled) {
            legend.render();
            chart.isDirtyLegend = false;
          }
          if (hasStackedSeries) {
            chart.getStacks();
          }
          axes.forEach(function(axis) {
            axis.updateNames();
            axis.setScale();
          });
          chart.getMargins();
          axes.forEach(function(axis) {
            if (axis.isDirty) {
              isDirtyBox = true;
            }
          });
          axes.forEach(function(axis) {
            var key = axis.min + "," + axis.max;
            if (axis.extKey !== key) {
              axis.extKey = key;
              afterRedraw.push(function() {
                fireEvent$s(axis, "afterSetExtremes", extend$1d(axis.eventArgs, axis.getExtremes()));
                delete axis.eventArgs;
              });
            }
            if (isDirtyBox || hasStackedSeries) {
              axis.redraw();
            }
          });
          if (isDirtyBox) {
            chart.drawChartBox();
          }
          fireEvent$s(chart, "predraw");
          series.forEach(function(serie2) {
            if ((isDirtyBox || serie2.isDirty) && serie2.visible) {
              serie2.redraw();
            }
            serie2.isDirtyData = false;
          });
          if (pointer) {
            pointer.reset(true);
          }
          renderer.draw();
          fireEvent$s(chart, "redraw");
          fireEvent$s(chart, "render");
          if (isHiddenChart) {
            chart.temporaryDisplay(true);
          }
          afterRedraw.forEach(function(callback) {
            callback.call();
          });
        };
        Chart2.prototype.get = function(id) {
          var series = this.series;
          function itemById(item2) {
            return item2.id === id || item2.options && item2.options.id === id;
          }
          var ret = (
            // Search axes
            find$g(this.axes, itemById) || // Search series
            find$g(this.series, itemById)
          );
          for (var i = 0; !ret && i < series.length; i++) {
            ret = find$g(series[i].points || [], itemById);
          }
          return ret;
        };
        Chart2.prototype.getAxes = function() {
          var chart = this, options = this.options, xAxisOptions = options.xAxis = splat$d(options.xAxis || {}), yAxisOptions = options.yAxis = splat$d(options.yAxis || {});
          fireEvent$s(this, "getAxes");
          xAxisOptions.forEach(function(axis, i) {
            axis.index = i;
            axis.isX = true;
          });
          yAxisOptions.forEach(function(axis, i) {
            axis.index = i;
          });
          var optionsArray = xAxisOptions.concat(yAxisOptions);
          optionsArray.forEach(function(axisOptions) {
            new Axis(chart, axisOptions);
          });
          fireEvent$s(this, "afterGetAxes");
        };
        Chart2.prototype.getSelectedPoints = function() {
          return this.series.reduce(function(acc, series) {
            series.getPointsCollection().forEach(function(point) {
              if (pick$1h(point.selectedStaging, point.selected)) {
                acc.push(point);
              }
            });
            return acc;
          }, []);
        };
        Chart2.prototype.getSelectedSeries = function() {
          return this.series.filter(function(serie) {
            return serie.selected;
          });
        };
        Chart2.prototype.setTitle = function(titleOptions, subtitleOptions, redraw) {
          this.applyDescription("title", titleOptions);
          this.applyDescription("subtitle", subtitleOptions);
          this.applyDescription("caption", void 0);
          this.layOutTitles(redraw);
        };
        Chart2.prototype.applyDescription = function(name, explicitOptions) {
          var chart = this;
          var style = name === "title" ? {
            color: palette.neutralColor80,
            fontSize: this.options.isStock ? "16px" : "18px"
            // #2944
          } : {
            color: palette.neutralColor60
          };
          var options = this.options[name] = merge$1a(
            // Default styles
            !this.styledMode && { style },
            this.options[name],
            explicitOptions
          );
          var elem = this[name];
          if (elem && explicitOptions) {
            this[name] = elem = elem.destroy();
          }
          if (options && !elem) {
            elem = this.renderer.text(options.text, 0, 0, options.useHTML).attr({
              align: options.align,
              "class": "highcharts-" + name,
              zIndex: options.zIndex || 4
            }).add();
            elem.update = function(updateOptions) {
              var fn = {
                title: "setTitle",
                subtitle: "setSubtitle",
                caption: "setCaption"
              }[name];
              chart[fn](updateOptions);
            };
            if (!this.styledMode) {
              elem.css(options.style);
            }
            this[name] = elem;
          }
        };
        Chart2.prototype.layOutTitles = function(redraw) {
          var titleOffset = [0, 0, 0], renderer = this.renderer, spacingBox = this.spacingBox;
          ["title", "subtitle", "caption"].forEach(function(key) {
            var title = this[key], titleOptions = this.options[key], verticalAlign = titleOptions.verticalAlign || "top", offset2 = key === "title" ? verticalAlign === "top" ? -3 : 0 : (
              // Floating subtitle (#6574)
              verticalAlign === "top" ? titleOffset[0] + 2 : 0
            );
            var titleSize, height;
            if (title) {
              if (!this.styledMode) {
                titleSize = titleOptions.style && titleOptions.style.fontSize;
              }
              titleSize = renderer.fontMetrics(titleSize, title).b;
              title.css({
                width: (titleOptions.width || spacingBox.width + (titleOptions.widthAdjust || 0)) + "px"
              });
              height = Math.round(title.getBBox(titleOptions.useHTML).height);
              title.align(extend$1d({
                y: verticalAlign === "bottom" ? titleSize : offset2 + titleSize,
                height
              }, titleOptions), false, "spacingBox");
              if (!titleOptions.floating) {
                if (verticalAlign === "top") {
                  titleOffset[0] = Math.ceil(titleOffset[0] + height);
                } else if (verticalAlign === "bottom") {
                  titleOffset[2] = Math.ceil(titleOffset[2] + height);
                }
              }
            }
          }, this);
          if (titleOffset[0] && (this.options.title.verticalAlign || "top") === "top") {
            titleOffset[0] += this.options.title.margin;
          }
          if (titleOffset[2] && this.options.caption.verticalAlign === "bottom") {
            titleOffset[2] += this.options.caption.margin;
          }
          var requiresDirtyBox = !this.titleOffset || this.titleOffset.join(",") !== titleOffset.join(",");
          this.titleOffset = titleOffset;
          fireEvent$s(this, "afterLayOutTitles");
          if (!this.isDirtyBox && requiresDirtyBox) {
            this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox;
            if (this.hasRendered && pick$1h(redraw, true) && this.isDirtyBox) {
              this.redraw();
            }
          }
        };
        Chart2.prototype.getChartSize = function() {
          var chart = this, optionsChart = chart.options.chart, widthOption = optionsChart.width, heightOption = optionsChart.height, renderTo = chart.renderTo;
          if (!defined$H(widthOption)) {
            chart.containerWidth = getStyle(renderTo, "width");
          }
          if (!defined$H(heightOption)) {
            chart.containerHeight = getStyle(renderTo, "height");
          }
          chart.chartWidth = Math.max(
            // #1393
            0,
            widthOption || chart.containerWidth || 600
            // #1460
          );
          chart.chartHeight = Math.max(0, relativeLength$7(heightOption, chart.chartWidth) || (chart.containerHeight > 1 ? chart.containerHeight : 400));
        };
        Chart2.prototype.temporaryDisplay = function(revert) {
          var node = this.renderTo, tempStyle;
          if (!revert) {
            while (node && node.style) {
              if (!doc$g.body.contains(node) && !node.parentNode) {
                node.hcOrigDetached = true;
                doc$g.body.appendChild(node);
              }
              if (getStyle(node, "display", false) === "none" || node.hcOricDetached) {
                node.hcOrigStyle = {
                  display: node.style.display,
                  height: node.style.height,
                  overflow: node.style.overflow
                };
                tempStyle = {
                  display: "block",
                  overflow: "hidden"
                };
                if (node !== this.renderTo) {
                  tempStyle.height = 0;
                }
                css$5(node, tempStyle);
                if (!node.offsetWidth) {
                  node.style.setProperty("display", "block", "important");
                }
              }
              node = node.parentNode;
              if (node === doc$g.body) {
                break;
              }
            }
          } else {
            while (node && node.style) {
              if (node.hcOrigStyle) {
                css$5(node, node.hcOrigStyle);
                delete node.hcOrigStyle;
              }
              if (node.hcOrigDetached) {
                doc$g.body.removeChild(node);
                node.hcOrigDetached = false;
              }
              node = node.parentNode;
            }
          }
        };
        Chart2.prototype.setClassName = function(className) {
          this.container.className = "highcharts-container " + (className || "");
        };
        Chart2.prototype.getContainer = function() {
          var chart = this, options = chart.options, optionsChart = options.chart, indexAttrName = "data-highcharts-chart", containerId = uniqueKey$4();
          var containerStyle, renderTo = chart.renderTo;
          if (!renderTo) {
            chart.renderTo = renderTo = optionsChart.renderTo;
          }
          if (isString$5(renderTo)) {
            chart.renderTo = renderTo = doc$g.getElementById(renderTo);
          }
          if (!renderTo) {
            error$5(13, true, chart);
          }
          var oldChartIndex = pInt$4(attr$1(renderTo, indexAttrName));
          if (isNumber$B(oldChartIndex) && charts$1[oldChartIndex] && charts$1[oldChartIndex].hasRendered) {
            charts$1[oldChartIndex].destroy();
          }
          attr$1(renderTo, indexAttrName, chart.index);
          renderTo.innerHTML = "";
          if (!optionsChart.skipClone && !renderTo.offsetWidth) {
            chart.temporaryDisplay();
          }
          chart.getChartSize();
          var chartWidth = chart.chartWidth;
          var chartHeight = chart.chartHeight;
          css$5(renderTo, { overflow: "hidden" });
          if (!chart.styledMode) {
            containerStyle = extend$1d({
              position: "relative",
              // needed for context menu (avoidscrollbars) and content
              // overflow in IE
              overflow: "hidden",
              width: chartWidth + "px",
              height: chartHeight + "px",
              textAlign: "left",
              lineHeight: "normal",
              zIndex: 0,
              "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
              userSelect: "none",
              "touch-action": "manipulation",
              outline: "none"
            }, optionsChart.style || {});
          }
          var container = createElement$5("div", {
            id: containerId
          }, containerStyle, renderTo);
          chart.container = container;
          chart._cursor = container.style.cursor;
          var Renderer2 = optionsChart.renderer || !svg$3 ? RendererRegistry$1.getRendererType(optionsChart.renderer) : SVGRenderer;
          chart.renderer = new Renderer2(container, chartWidth, chartHeight, void 0, optionsChart.forExport, options.exporting && options.exporting.allowHTML, chart.styledMode);
          setAnimation$3(void 0, chart);
          chart.setClassName(optionsChart.className);
          if (!chart.styledMode) {
            chart.renderer.setStyle(optionsChart.style);
          } else {
            for (var key in options.defs) {
              this.renderer.definition(options.defs[key]);
            }
          }
          chart.renderer.chartIndex = chart.index;
          fireEvent$s(this, "afterGetContainer");
        };
        Chart2.prototype.getMargins = function(skipAxes) {
          var _a2 = this, spacing = _a2.spacing, margin = _a2.margin, titleOffset = _a2.titleOffset;
          this.resetMargins();
          if (titleOffset[0] && !defined$H(margin[0])) {
            this.plotTop = Math.max(this.plotTop, titleOffset[0] + spacing[0]);
          }
          if (titleOffset[2] && !defined$H(margin[2])) {
            this.marginBottom = Math.max(this.marginBottom, titleOffset[2] + spacing[2]);
          }
          if (this.legend && this.legend.display) {
            this.legend.adjustMargins(margin, spacing);
          }
          fireEvent$s(this, "getMargins");
          if (!skipAxes) {
            this.getAxisMargins();
          }
        };
        Chart2.prototype.getAxisMargins = function() {
          var chart = this, axisOffset = chart.axisOffset = [0, 0, 0, 0], colorAxis = chart.colorAxis, margin = chart.margin, getOffset = function(axes) {
            axes.forEach(function(axis) {
              if (axis.visible) {
                axis.getOffset();
              }
            });
          };
          if (chart.hasCartesianSeries) {
            getOffset(chart.axes);
          } else if (colorAxis && colorAxis.length) {
            getOffset(colorAxis);
          }
          marginNames.forEach(function(m, side) {
            if (!defined$H(margin[side])) {
              chart[m] += axisOffset[side];
            }
          });
          chart.setChartSize();
        };
        Chart2.prototype.reflow = function(e2) {
          var chart = this, optionsChart = chart.options.chart, renderTo = chart.renderTo, hasUserSize = defined$H(optionsChart.width) && defined$H(optionsChart.height), width = optionsChart.width || getStyle(renderTo, "width"), height = optionsChart.height || getStyle(renderTo, "height"), target = e2 ? e2.target : win$8;
          delete chart.pointer.chartPosition;
          if (!hasUserSize && !chart.isPrinting && width && height && (target === win$8 || target === doc$g)) {
            if (width !== chart.containerWidth || height !== chart.containerHeight) {
              Utilities.clearTimeout(chart.reflowTimeout);
              chart.reflowTimeout = syncTimeout$3(function() {
                if (chart.container) {
                  chart.setSize(void 0, void 0, false);
                }
              }, e2 ? 100 : 0);
            }
            chart.containerWidth = width;
            chart.containerHeight = height;
          }
        };
        Chart2.prototype.setReflow = function(reflow) {
          var chart = this;
          if (reflow !== false && !this.unbindReflow) {
            this.unbindReflow = addEvent$T(win$8, "resize", function(e2) {
              if (chart.options) {
                chart.reflow(e2);
              }
            });
            addEvent$T(this, "destroy", this.unbindReflow);
          } else if (reflow === false && this.unbindReflow) {
            this.unbindReflow = this.unbindReflow();
          }
        };
        Chart2.prototype.setSize = function(width, height, animation) {
          var chart = this, renderer = chart.renderer;
          chart.isResizing += 1;
          setAnimation$3(animation, chart);
          var globalAnimation = renderer.globalAnimation;
          chart.oldChartHeight = chart.chartHeight;
          chart.oldChartWidth = chart.chartWidth;
          if (typeof width !== "undefined") {
            chart.options.chart.width = width;
          }
          if (typeof height !== "undefined") {
            chart.options.chart.height = height;
          }
          chart.getChartSize();
          if (!chart.styledMode) {
            (globalAnimation ? animate : css$5)(chart.container, {
              width: chart.chartWidth + "px",
              height: chart.chartHeight + "px"
            }, globalAnimation);
          }
          chart.setChartSize(true);
          renderer.setSize(chart.chartWidth, chart.chartHeight, globalAnimation);
          chart.axes.forEach(function(axis) {
            axis.isDirty = true;
            axis.setScale();
          });
          chart.isDirtyLegend = true;
          chart.isDirtyBox = true;
          chart.layOutTitles();
          chart.getMargins();
          chart.redraw(globalAnimation);
          chart.oldChartHeight = null;
          fireEvent$s(chart, "resize");
          syncTimeout$3(function() {
            if (chart) {
              fireEvent$s(chart, "endResize", null, function() {
                chart.isResizing -= 1;
              });
            }
          }, animObject$7(globalAnimation).duration);
        };
        Chart2.prototype.setChartSize = function(skipAxes) {
          var chart = this, inverted = chart.inverted, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, optionsChart = chart.options.chart, spacing = chart.spacing, clipOffset = chart.clipOffset;
          var plotLeft, plotTop, plotWidth, plotHeight;
          chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
          chart.plotTop = plotTop = Math.round(chart.plotTop);
          chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));
          chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));
          chart.plotSizeX = inverted ? plotHeight : plotWidth;
          chart.plotSizeY = inverted ? plotWidth : plotHeight;
          chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;
          chart.spacingBox = renderer.spacingBox = {
            x: spacing[3],
            y: spacing[0],
            width: chartWidth - spacing[3] - spacing[1],
            height: chartHeight - spacing[0] - spacing[2]
          };
          chart.plotBox = renderer.plotBox = {
            x: plotLeft,
            y: plotTop,
            width: plotWidth,
            height: plotHeight
          };
          var plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2), clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2), clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);
          chart.clipBox = {
            x: clipX,
            y: clipY,
            width: Math.floor(chart.plotSizeX - Math.max(plotBorderWidth, clipOffset[1]) / 2 - clipX),
            height: Math.max(0, Math.floor(chart.plotSizeY - Math.max(plotBorderWidth, clipOffset[2]) / 2 - clipY))
          };
          if (!skipAxes) {
            chart.axes.forEach(function(axis) {
              axis.setAxisSize();
              axis.setAxisTranslation();
            });
            renderer.alignElements();
          }
          fireEvent$s(chart, "afterSetChartSize", { skipAxes });
        };
        Chart2.prototype.resetMargins = function() {
          fireEvent$s(this, "resetMargins");
          var chart = this, chartOptions = chart.options.chart;
          ["margin", "spacing"].forEach(function splashArrays(target) {
            var value = chartOptions[target], values = isObject$9(value) ? value : [value, value, value, value];
            [
              "Top",
              "Right",
              "Bottom",
              "Left"
            ].forEach(function(sideName, side) {
              chart[target][side] = pick$1h(chartOptions[target + sideName], values[side]);
            });
          });
          marginNames.forEach(function(m, side) {
            chart[m] = pick$1h(chart.margin[side], chart.spacing[side]);
          });
          chart.axisOffset = [0, 0, 0, 0];
          chart.clipOffset = [0, 0, 0, 0];
        };
        Chart2.prototype.drawChartBox = function() {
          var chart = this, optionsChart = chart.options.chart, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, styledMode = chart.styledMode, plotBGImage = chart.plotBGImage, chartBackgroundColor = optionsChart.backgroundColor, plotBackgroundColor = optionsChart.plotBackgroundColor, plotBackgroundImage = optionsChart.plotBackgroundImage, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotBox = chart.plotBox, clipRect = chart.clipRect, clipBox = chart.clipBox;
          var chartBackground = chart.chartBackground, plotBackground = chart.plotBackground, plotBorder = chart.plotBorder, chartBorderWidth, mgn, bgAttr, verb = "animate";
          if (!chartBackground) {
            chart.chartBackground = chartBackground = renderer.rect().addClass("highcharts-background").add();
            verb = "attr";
          }
          if (!styledMode) {
            chartBorderWidth = optionsChart.borderWidth || 0;
            mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
            bgAttr = {
              fill: chartBackgroundColor || "none"
            };
            if (chartBorderWidth || chartBackground["stroke-width"]) {
              bgAttr.stroke = optionsChart.borderColor;
              bgAttr["stroke-width"] = chartBorderWidth;
            }
            chartBackground.attr(bgAttr).shadow(optionsChart.shadow);
          } else {
            chartBorderWidth = mgn = chartBackground.strokeWidth();
          }
          chartBackground[verb]({
            x: mgn / 2,
            y: mgn / 2,
            width: chartWidth - mgn - chartBorderWidth % 2,
            height: chartHeight - mgn - chartBorderWidth % 2,
            r: optionsChart.borderRadius
          });
          verb = "animate";
          if (!plotBackground) {
            verb = "attr";
            chart.plotBackground = plotBackground = renderer.rect().addClass("highcharts-plot-background").add();
          }
          plotBackground[verb](plotBox);
          if (!styledMode) {
            plotBackground.attr({
              fill: plotBackgroundColor || "none"
            }).shadow(optionsChart.plotShadow);
            if (plotBackgroundImage) {
              if (!plotBGImage) {
                chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight).add();
              } else {
                if (plotBackgroundImage !== plotBGImage.attr("href")) {
                  plotBGImage.attr("href", plotBackgroundImage);
                }
                plotBGImage.animate(plotBox);
              }
            }
          }
          if (!clipRect) {
            chart.clipRect = renderer.clipRect(clipBox);
          } else {
            clipRect.animate({
              width: clipBox.width,
              height: clipBox.height
            });
          }
          verb = "animate";
          if (!plotBorder) {
            verb = "attr";
            chart.plotBorder = plotBorder = renderer.rect().addClass("highcharts-plot-border").attr({
              zIndex: 1
              // Above the grid
            }).add();
          }
          if (!styledMode) {
            plotBorder.attr({
              stroke: optionsChart.plotBorderColor,
              "stroke-width": optionsChart.plotBorderWidth || 0,
              fill: "none"
            });
          }
          plotBorder[verb](plotBorder.crisp({
            x: plotLeft,
            y: plotTop,
            width: plotWidth,
            height: plotHeight
          }, -plotBorder.strokeWidth()));
          chart.isDirtyBox = false;
          fireEvent$s(this, "afterDrawChartBox");
        };
        Chart2.prototype.propFromSeries = function() {
          var chart = this, optionsChart = chart.options.chart, seriesOptions = chart.options.series;
          var i, klass, value;
          ["inverted", "angular", "polar"].forEach(function(key) {
            klass = seriesTypes$7[optionsChart.type || optionsChart.defaultSeriesType];
            value = // It is set in the options:
            optionsChart[key] || // The default series class:
            klass && klass.prototype[key];
            i = seriesOptions && seriesOptions.length;
            while (!value && i--) {
              klass = seriesTypes$7[seriesOptions[i].type];
              if (klass && klass.prototype[key]) {
                value = true;
              }
            }
            chart[key] = value;
          });
        };
        Chart2.prototype.linkSeries = function() {
          var chart = this, chartSeries = chart.series;
          chartSeries.forEach(function(series) {
            series.linkedSeries.length = 0;
          });
          chartSeries.forEach(function(series) {
            var linkedTo = series.options.linkedTo;
            if (isString$5(linkedTo)) {
              if (linkedTo === ":previous") {
                linkedTo = chart.series[series.index - 1];
              } else {
                linkedTo = chart.get(linkedTo);
              }
              if (linkedTo && linkedTo.linkedParent !== series) {
                linkedTo.linkedSeries.push(series);
                series.linkedParent = linkedTo;
                if (linkedTo.enabledDataSorting) {
                  series.setDataSortingOptions();
                }
                series.visible = pick$1h(series.options.visible, linkedTo.options.visible, series.visible);
              }
            }
          });
          fireEvent$s(this, "afterLinkSeries");
        };
        Chart2.prototype.renderSeries = function() {
          this.series.forEach(function(serie) {
            serie.translate();
            serie.render();
          });
        };
        Chart2.prototype.renderLabels = function() {
          var chart = this, labels = chart.options.labels;
          if (labels.items) {
            labels.items.forEach(function(label) {
              var style = extend$1d(labels.style, label.style), x = pInt$4(style.left) + chart.plotLeft, y = pInt$4(style.top) + chart.plotTop + 12;
              delete style.left;
              delete style.top;
              chart.renderer.text(label.html, x, y).attr({ zIndex: 2 }).css(style).add();
            });
          }
        };
        Chart2.prototype.render = function() {
          var chart = this, axes = chart.axes, colorAxis = chart.colorAxis, renderer = chart.renderer, options = chart.options, renderAxes = function(axes2) {
            axes2.forEach(function(axis) {
              if (axis.visible) {
                axis.render();
              }
            });
          };
          var correction = 0;
          chart.setTitle();
          chart.legend = new Legend(chart, options.legend);
          if (chart.getStacks) {
            chart.getStacks();
          }
          chart.getMargins(true);
          chart.setChartSize();
          var tempWidth = chart.plotWidth;
          axes.some(function(axis) {
            if (axis.horiz && axis.visible && axis.options.labels.enabled && axis.series.length) {
              correction = 21;
              return true;
            }
          });
          chart.plotHeight = Math.max(chart.plotHeight - correction, 0);
          var tempHeight = chart.plotHeight;
          axes.forEach(function(axis) {
            axis.setScale();
          });
          chart.getAxisMargins();
          var redoHorizontal = tempWidth / chart.plotWidth > 1.1;
          var redoVertical = tempHeight / chart.plotHeight > 1.05;
          if (redoHorizontal || redoVertical) {
            axes.forEach(function(axis) {
              if (axis.horiz && redoHorizontal || !axis.horiz && redoVertical) {
                axis.setTickInterval(true);
              }
            });
            chart.getMargins();
          }
          chart.drawChartBox();
          if (chart.hasCartesianSeries) {
            renderAxes(axes);
          } else if (colorAxis && colorAxis.length) {
            renderAxes(colorAxis);
          }
          if (!chart.seriesGroup) {
            chart.seriesGroup = renderer.g("series-group").attr({ zIndex: 3 }).add();
          }
          chart.renderSeries();
          chart.renderLabels();
          chart.addCredits();
          if (chart.setResponsive) {
            chart.setResponsive();
          }
          chart.hasRendered = true;
        };
        Chart2.prototype.addCredits = function(credits) {
          var chart = this, creds = merge$1a(true, this.options.credits, credits);
          if (creds.enabled && !this.credits) {
            this.credits = this.renderer.text(creds.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
              if (creds.href) {
                win$8.location.href = creds.href;
              }
            }).attr({
              align: creds.position.align,
              zIndex: 8
            });
            if (!chart.styledMode) {
              this.credits.css(creds.style);
            }
            this.credits.add().align(creds.position);
            this.credits.update = function(options) {
              chart.credits = chart.credits.destroy();
              chart.addCredits(options);
            };
          }
        };
        Chart2.prototype.destroy = function() {
          var chart = this, axes = chart.axes, series = chart.series, container = chart.container, parentNode = container && container.parentNode;
          var i;
          fireEvent$s(chart, "destroy");
          if (chart.renderer.forExport) {
            erase$3(charts$1, chart);
          } else {
            charts$1[chart.index] = void 0;
          }
          H.chartCount--;
          chart.renderTo.removeAttribute("data-highcharts-chart");
          removeEvent$6(chart);
          i = axes.length;
          while (i--) {
            axes[i] = axes[i].destroy();
          }
          if (this.scroller && this.scroller.destroy) {
            this.scroller.destroy();
          }
          i = series.length;
          while (i--) {
            series[i] = series[i].destroy();
          }
          [
            "title",
            "subtitle",
            "chartBackground",
            "plotBackground",
            "plotBGImage",
            "plotBorder",
            "seriesGroup",
            "clipRect",
            "credits",
            "pointer",
            "rangeSelector",
            "legend",
            "resetZoomButton",
            "tooltip",
            "renderer"
          ].forEach(function(name) {
            var prop = chart[name];
            if (prop && prop.destroy) {
              chart[name] = prop.destroy();
            }
          });
          if (container) {
            container.innerHTML = "";
            removeEvent$6(container);
            if (parentNode) {
              discardElement$3(container);
            }
          }
          objectEach$n(chart, function(val, key) {
            delete chart[key];
          });
        };
        Chart2.prototype.firstRender = function() {
          var chart = this, options = chart.options;
          if (chart.isReadyToRender && !chart.isReadyToRender()) {
            return;
          }
          chart.getContainer();
          chart.resetMargins();
          chart.setChartSize();
          chart.propFromSeries();
          chart.getAxes();
          (isArray$g(options.series) ? options.series : []).forEach(
            // #9680
            function(serieOptions) {
              chart.initSeries(serieOptions);
            }
          );
          chart.linkSeries();
          chart.setSeriesData();
          fireEvent$s(chart, "beforeRender");
          if (Pointer) {
            if (MSPointer.isRequired()) {
              chart.pointer = new MSPointer(chart, options);
            } else {
              chart.pointer = new Pointer(chart, options);
            }
          }
          chart.render();
          chart.pointer.getChartPosition();
          if (!chart.renderer.imgCount && !chart.hasLoaded) {
            chart.onload();
          }
          chart.temporaryDisplay(true);
        };
        Chart2.prototype.onload = function() {
          this.callbacks.concat([this.callback]).forEach(function(fn) {
            if (fn && typeof this.index !== "undefined") {
              fn.apply(this, [this]);
            }
          }, this);
          fireEvent$s(this, "load");
          fireEvent$s(this, "render");
          if (defined$H(this.index)) {
            this.setReflow(this.options.chart.reflow);
          }
          this.hasLoaded = true;
        };
        Chart2.prototype.addSeries = function(options, redraw, animation) {
          var chart = this;
          var series;
          if (options) {
            redraw = pick$1h(redraw, true);
            fireEvent$s(chart, "addSeries", { options }, function() {
              series = chart.initSeries(options);
              chart.isDirtyLegend = true;
              chart.linkSeries();
              if (series.enabledDataSorting) {
                series.setData(options.data, false);
              }
              fireEvent$s(chart, "afterAddSeries", { series });
              if (redraw) {
                chart.redraw(animation);
              }
            });
          }
          return series;
        };
        Chart2.prototype.addAxis = function(options, isX, redraw, animation) {
          return this.createAxis(isX ? "xAxis" : "yAxis", { axis: options, redraw, animation });
        };
        Chart2.prototype.addColorAxis = function(options, redraw, animation) {
          return this.createAxis("colorAxis", { axis: options, redraw, animation });
        };
        Chart2.prototype.createAxis = function(type, options) {
          var axis = new Axis(this, merge$1a(options.axis, {
            index: this[type].length,
            isX: type === "xAxis"
          }));
          if (pick$1h(options.redraw, true)) {
            this.redraw(options.animation);
          }
          return axis;
        };
        Chart2.prototype.showLoading = function(str) {
          var chart = this, options = chart.options, loadingOptions = options.loading, setLoadingSize = function() {
            if (loadingDiv) {
              css$5(loadingDiv, {
                left: chart.plotLeft + "px",
                top: chart.plotTop + "px",
                width: chart.plotWidth + "px",
                height: chart.plotHeight + "px"
              });
            }
          };
          var loadingDiv = chart.loadingDiv, loadingSpan = chart.loadingSpan;
          if (!loadingDiv) {
            chart.loadingDiv = loadingDiv = createElement$5("div", {
              className: "highcharts-loading highcharts-loading-hidden"
            }, null, chart.container);
          }
          if (!loadingSpan) {
            chart.loadingSpan = loadingSpan = createElement$5("span", { className: "highcharts-loading-inner" }, null, loadingDiv);
            addEvent$T(chart, "redraw", setLoadingSize);
          }
          loadingDiv.className = "highcharts-loading";
          AST.setElementHTML(loadingSpan, pick$1h(str, options.lang.loading, ""));
          if (!chart.styledMode) {
            css$5(loadingDiv, extend$1d(loadingOptions.style, {
              zIndex: 10
            }));
            css$5(loadingSpan, loadingOptions.labelStyle);
            if (!chart.loadingShown) {
              css$5(loadingDiv, {
                opacity: 0,
                display: ""
              });
              animate(loadingDiv, {
                opacity: loadingOptions.style.opacity || 0.5
              }, {
                duration: loadingOptions.showDuration || 0
              });
            }
          }
          chart.loadingShown = true;
          setLoadingSize();
        };
        Chart2.prototype.hideLoading = function() {
          var options = this.options, loadingDiv = this.loadingDiv;
          if (loadingDiv) {
            loadingDiv.className = "highcharts-loading highcharts-loading-hidden";
            if (!this.styledMode) {
              animate(loadingDiv, {
                opacity: 0
              }, {
                duration: options.loading.hideDuration || 100,
                complete: function() {
                  css$5(loadingDiv, { display: "none" });
                }
              });
            }
          }
          this.loadingShown = false;
        };
        Chart2.prototype.update = function(options, redraw, oneToOne, animation) {
          var chart = this, adders = {
            credits: "addCredits",
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }, isResponsiveOptions = options.isResponsiveOptions, itemsForRemoval = [];
          var updateAllAxes, updateAllSeries, runSetSize;
          fireEvent$s(chart, "update", { options });
          if (!isResponsiveOptions) {
            chart.setResponsive(false, true);
          }
          options = cleanRecursively$1(options, chart.options);
          chart.userOptions = merge$1a(chart.userOptions, options);
          var optionsChart = options.chart;
          if (optionsChart) {
            merge$1a(true, chart.options.chart, optionsChart);
            if ("className" in optionsChart) {
              chart.setClassName(optionsChart.className);
            }
            if ("reflow" in optionsChart) {
              chart.setReflow(optionsChart.reflow);
            }
            if ("inverted" in optionsChart || "polar" in optionsChart || "type" in optionsChart) {
              chart.propFromSeries();
              updateAllAxes = true;
            }
            if ("alignTicks" in optionsChart) {
              updateAllAxes = true;
            }
            if ("events" in optionsChart) {
              registerEventOptions$1(this, optionsChart);
            }
            objectEach$n(optionsChart, function(val, key) {
              if (chart.propsRequireUpdateSeries.indexOf("chart." + key) !== -1) {
                updateAllSeries = true;
              }
              if (chart.propsRequireDirtyBox.indexOf(key) !== -1) {
                chart.isDirtyBox = true;
              }
              if (chart.propsRequireReflow.indexOf(key) !== -1) {
                if (isResponsiveOptions) {
                  chart.isDirtyBox = true;
                } else {
                  runSetSize = true;
                }
              }
            });
            if (!chart.styledMode && optionsChart.style) {
              chart.renderer.setStyle(chart.options.chart.style || {});
            }
          }
          if (!chart.styledMode && options.colors) {
            this.options.colors = options.colors;
          }
          if (options.time) {
            if (this.time === defaultTime) {
              this.time = new Time(options.time);
            }
            merge$1a(true, chart.options.time, options.time);
          }
          objectEach$n(options, function(val, key) {
            if (chart[key] && typeof chart[key].update === "function") {
              chart[key].update(val, false);
            } else if (typeof chart[adders[key]] === "function") {
              chart[adders[key]](val);
            } else if (key !== "colors" && chart.collectionsWithUpdate.indexOf(key) === -1) {
              merge$1a(true, chart.options[key], options[key]);
            }
            if (key !== "chart" && chart.propsRequireUpdateSeries.indexOf(key) !== -1) {
              updateAllSeries = true;
            }
          });
          this.collectionsWithUpdate.forEach(function(coll) {
            var indexMap;
            if (options[coll]) {
              indexMap = [];
              chart[coll].forEach(function(s, i) {
                if (!s.options.isInternal) {
                  indexMap.push(pick$1h(s.options.index, i));
                }
              });
              splat$d(options[coll]).forEach(function(newOptions, i) {
                var hasId = defined$H(newOptions.id);
                var item2;
                if (hasId) {
                  item2 = chart.get(newOptions.id);
                }
                if (!item2 && chart[coll]) {
                  item2 = chart[coll][indexMap ? indexMap[i] : i];
                  if (item2 && hasId && defined$H(item2.options.id)) {
                    item2 = void 0;
                  }
                }
                if (item2 && item2.coll === coll) {
                  item2.update(newOptions, false);
                  if (oneToOne) {
                    item2.touched = true;
                  }
                }
                if (!item2 && oneToOne && chart.collectionsWithInit[coll]) {
                  chart.collectionsWithInit[coll][0].apply(
                    chart,
                    // [newOptions, ...extraArguments, redraw=false]
                    [
                      newOptions
                    ].concat(
                      // Not all initializers require extra args
                      chart.collectionsWithInit[coll][1] || []
                    ).concat([
                      false
                    ])
                  ).touched = true;
                }
              });
              if (oneToOne) {
                chart[coll].forEach(function(item2) {
                  if (!item2.touched && !item2.options.isInternal) {
                    itemsForRemoval.push(item2);
                  } else {
                    delete item2.touched;
                  }
                });
              }
            }
          });
          itemsForRemoval.forEach(function(item2) {
            if (item2.chart && item2.remove) {
              item2.remove(false);
            }
          });
          if (updateAllAxes) {
            chart.axes.forEach(function(axis) {
              axis.update({}, false);
            });
          }
          if (updateAllSeries) {
            chart.getSeriesOrderByLinks().forEach(function(series) {
              if (series.chart) {
                series.update({}, false);
              }
            }, this);
          }
          var newWidth = optionsChart && optionsChart.width;
          var newHeight = optionsChart && (isString$5(optionsChart.height) ? relativeLength$7(optionsChart.height, newWidth || chart.chartWidth) : optionsChart.height);
          if (
            // In this case, run chart.setSize with newWidth and newHeight which
            // are undefined, only for reflowing chart elements because margin
            // or spacing has been set (#8190)
            runSetSize || // In this case, the size is actually set
            isNumber$B(newWidth) && newWidth !== chart.chartWidth || isNumber$B(newHeight) && newHeight !== chart.chartHeight
          ) {
            chart.setSize(newWidth, newHeight, animation);
          } else if (pick$1h(redraw, true)) {
            chart.redraw(animation);
          }
          fireEvent$s(chart, "afterUpdate", {
            options,
            redraw,
            animation
          });
        };
        Chart2.prototype.setSubtitle = function(options, redraw) {
          this.applyDescription("subtitle", options);
          this.layOutTitles(redraw);
        };
        Chart2.prototype.setCaption = function(options, redraw) {
          this.applyDescription("caption", options);
          this.layOutTitles(redraw);
        };
        Chart2.prototype.showResetZoom = function() {
          var chart = this, lang2 = defaultOptions$b.lang, btnOptions = chart.options.chart.resetZoomButton, theme2 = btnOptions.theme, states = theme2.states, alignTo = btnOptions.relativeTo === "chart" || btnOptions.relativeTo === "spacingBox" ? null : "scrollablePlotBox";
          function zoomOut() {
            chart.zoomOut();
          }
          fireEvent$s(this, "beforeShowResetZoom", null, function() {
            chart.resetZoomButton = chart.renderer.button(lang2.resetZoom, null, null, zoomOut, theme2, states && states.hover).attr({
              align: btnOptions.position.align,
              title: lang2.resetZoomTitle
            }).addClass("highcharts-reset-zoom").add().align(btnOptions.position, false, alignTo);
          });
          fireEvent$s(this, "afterShowResetZoom");
        };
        Chart2.prototype.zoomOut = function() {
          fireEvent$s(this, "selection", { resetSelection: true }, this.zoom);
        };
        Chart2.prototype.zoom = function(event) {
          var chart = this, pointer = chart.pointer, mouseDownPos = chart.inverted ? pointer.mouseDownX : pointer.mouseDownY;
          var displayButton = false, hasZoomed;
          if (!event || event.resetSelection) {
            chart.axes.forEach(function(axis) {
              hasZoomed = axis.zoom();
            });
            pointer.initiated = false;
          } else {
            event.xAxis.concat(event.yAxis).forEach(function(axisData) {
              var axis = axisData.axis, axisStartPos = chart.inverted ? axis.left : axis.top, axisEndPos = chart.inverted ? axisStartPos + axis.width : axisStartPos + axis.height, isXAxis = axis.isXAxis;
              var isWithinPane = false;
              if (!isXAxis && mouseDownPos >= axisStartPos && mouseDownPos <= axisEndPos || isXAxis || !defined$H(mouseDownPos)) {
                isWithinPane = true;
              }
              if (pointer[isXAxis ? "zoomX" : "zoomY"] && isWithinPane) {
                hasZoomed = axis.zoom(axisData.min, axisData.max);
                if (axis.displayBtn) {
                  displayButton = true;
                }
              }
            });
          }
          var resetZoomButton = chart.resetZoomButton;
          if (displayButton && !resetZoomButton) {
            chart.showResetZoom();
          } else if (!displayButton && isObject$9(resetZoomButton)) {
            chart.resetZoomButton = resetZoomButton.destroy();
          }
          if (hasZoomed) {
            chart.redraw(pick$1h(chart.options.chart.animation, event && event.animation, chart.pointCount < 100));
          }
        };
        Chart2.prototype.pan = function(e2, panning) {
          var chart = this, hoverPoints = chart.hoverPoints, panningOptions = typeof panning === "object" ? panning : {
            enabled: panning,
            type: "x"
          }, chartOptions = chart.options.chart, hasMapNavigation = chart.options.mapNavigation && chart.options.mapNavigation.enabled;
          if (chartOptions && chartOptions.panning) {
            chartOptions.panning = panningOptions;
          }
          var type = panningOptions.type;
          var doRedraw;
          fireEvent$s(this, "pan", { originalEvent: e2 }, function() {
            if (hoverPoints) {
              hoverPoints.forEach(function(point) {
                point.setState();
              });
            }
            var axes = chart.xAxis;
            if (type === "xy") {
              axes = axes.concat(chart.yAxis);
            } else if (type === "y") {
              axes = chart.yAxis;
            }
            var nextMousePos = {};
            axes.forEach(function(axis) {
              if (!axis.options.panningEnabled || axis.options.isInternal) {
                return;
              }
              var horiz = axis.horiz, mousePos = e2[horiz ? "chartX" : "chartY"], mouseDown = horiz ? "mouseDownX" : "mouseDownY", startPos = chart[mouseDown], halfPointRange = axis.minPointOffset || 0, pointRangeDirection = axis.reversed && !chart.inverted || !axis.reversed && chart.inverted ? -1 : 1, extremes = axis.getExtremes(), panMin = axis.toValue(startPos - mousePos, true) + halfPointRange * pointRangeDirection, panMax = axis.toValue(startPos + axis.len - mousePos, true) - (halfPointRange * pointRangeDirection || axis.isXAxis && axis.pointRangePadding || 0), flipped = panMax < panMin, hasVerticalPanning = axis.hasVerticalPanning();
              var newMin = flipped ? panMax : panMin, newMax = flipped ? panMin : panMax, panningState = axis.panningState, spill;
              if (hasVerticalPanning && !axis.isXAxis && (!panningState || panningState.isDirty)) {
                axis.series.forEach(function(series) {
                  var processedData = series.getProcessedData(true), dataExtremes = series.getExtremes(processedData.yData, true);
                  if (!panningState) {
                    panningState = {
                      startMin: Number.MAX_VALUE,
                      startMax: -Number.MAX_VALUE
                    };
                  }
                  if (isNumber$B(dataExtremes.dataMin) && isNumber$B(dataExtremes.dataMax)) {
                    panningState.startMin = Math.min(pick$1h(series.options.threshold, Infinity), dataExtremes.dataMin, panningState.startMin);
                    panningState.startMax = Math.max(pick$1h(series.options.threshold, -Infinity), dataExtremes.dataMax, panningState.startMax);
                  }
                });
              }
              var paddedMin = Math.min(pick$1h(panningState && panningState.startMin, extremes.dataMin), halfPointRange ? extremes.min : axis.toValue(axis.toPixels(extremes.min) - axis.minPixelPadding));
              var paddedMax = Math.max(pick$1h(panningState && panningState.startMax, extremes.dataMax), halfPointRange ? extremes.max : axis.toValue(axis.toPixels(extremes.max) + axis.minPixelPadding));
              axis.panningState = panningState;
              if (!axis.isOrdinal) {
                spill = paddedMin - newMin;
                if (spill > 0) {
                  newMax += spill;
                  newMin = paddedMin;
                }
                spill = newMax - paddedMax;
                if (spill > 0) {
                  newMax = paddedMax;
                  newMin -= spill;
                }
                if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max && newMin >= paddedMin && newMax <= paddedMax) {
                  axis.setExtremes(newMin, newMax, false, false, { trigger: "pan" });
                  if (!chart.resetZoomButton && !hasMapNavigation && // Show reset zoom button only when both newMin and
                  // newMax values are between padded axis range.
                  newMin !== paddedMin && newMax !== paddedMax && type.match("y")) {
                    chart.showResetZoom();
                    axis.displayBtn = false;
                  }
                  doRedraw = true;
                }
                nextMousePos[mouseDown] = mousePos;
              }
            });
            objectEach$n(nextMousePos, function(pos, down) {
              chart[down] = pos;
            });
            if (doRedraw) {
              chart.redraw(false);
            }
            css$5(chart.container, { cursor: "move" });
          });
        };
        return Chart2;
      }()
    );
    extend$1d(Chart$1.prototype, {
      // Hook for adding callbacks in modules
      callbacks: [],
      /**
       * These collections (arrays) implement `Chart.addSomethig` method used in
       * chart.update() to create new object in the collection. Equivalent for
       * deleting is resolved by simple `Somethig.remove()`.
       *
       * Note: We need to define these references after initializers are bound to
       * chart's prototype.
       */
      collectionsWithInit: {
        // collectionName: [ initializingMethod, [extraArguments] ]
        xAxis: [Chart$1.prototype.addAxis, [true]],
        yAxis: [Chart$1.prototype.addAxis, [false]],
        series: [Chart$1.prototype.addSeries]
      },
      /**
       * These collections (arrays) implement update() methods with support for
       * one-to-one option.
       */
      collectionsWithUpdate: [
        "xAxis",
        "yAxis",
        "series"
      ],
      /**
       * These properties cause isDirtyBox to be set to true when updating. Can be
       * extended from plugins.
       */
      propsRequireDirtyBox: [
        "backgroundColor",
        "borderColor",
        "borderWidth",
        "borderRadius",
        "plotBackgroundColor",
        "plotBackgroundImage",
        "plotBorderColor",
        "plotBorderWidth",
        "plotShadow",
        "shadow"
      ],
      /**
       * These properties require a full reflow of chart elements, best
       * implemented through running `Chart.setSize` internally (#8190).
       * @type {Array}
       */
      propsRequireReflow: [
        "margin",
        "marginTop",
        "marginRight",
        "marginBottom",
        "marginLeft",
        "spacing",
        "spacingTop",
        "spacingRight",
        "spacingBottom",
        "spacingLeft"
      ],
      /**
       * These properties cause all series to be updated when updating. Can be
       * extended from plugins.
       */
      propsRequireUpdateSeries: [
        "chart.inverted",
        "chart.polar",
        "chart.ignoreHiddenSeries",
        "chart.type",
        "colors",
        "plotOptions",
        "time",
        "tooltip"
      ]
    });
    var merge$19 = Utilities.merge, pick$1g = Utilities.pick;
    var LegendSymbol;
    (function(LegendSymbol2) {
      function drawLineMarker(legend) {
        var options = this.options, symbolWidth = legend.symbolWidth, symbolHeight = legend.symbolHeight, generalRadius = symbolHeight / 2, renderer = this.chart.renderer, legendItemGroup = this.legendGroup, verticalCenter = legend.baseline - Math.round(legend.fontMetrics.b * 0.3);
        var attr2 = {}, legendSymbol, markerOptions = options.marker;
        if (!this.chart.styledMode) {
          attr2 = {
            "stroke-width": options.lineWidth || 0
          };
          if (options.dashStyle) {
            attr2.dashstyle = options.dashStyle;
          }
        }
        this.legendLine = renderer.path([
          ["M", 0, verticalCenter],
          ["L", symbolWidth, verticalCenter]
        ]).addClass("highcharts-graph").attr(attr2).add(legendItemGroup);
        if (markerOptions && markerOptions.enabled !== false && symbolWidth) {
          var radius = Math.min(pick$1g(markerOptions.radius, generalRadius), generalRadius);
          if (this.symbol.indexOf("url") === 0) {
            markerOptions = merge$19(markerOptions, {
              width: symbolHeight,
              height: symbolHeight
            });
            radius = 0;
          }
          this.legendSymbol = legendSymbol = renderer.symbol(this.symbol, symbolWidth / 2 - radius, verticalCenter - radius, 2 * radius, 2 * radius, markerOptions).addClass("highcharts-point").add(legendItemGroup);
          legendSymbol.isMarker = true;
        }
      }
      LegendSymbol2.drawLineMarker = drawLineMarker;
      function drawRectangle(legend, item2) {
        var options = legend.options, symbolHeight = legend.symbolHeight, square = options.squareSymbol, symbolWidth = square ? symbolHeight : legend.symbolWidth;
        item2.legendSymbol = this.chart.renderer.rect(
          square ? (legend.symbolWidth - symbolHeight) / 2 : 0,
          legend.baseline - symbolHeight + 1,
          // #3988
          symbolWidth,
          symbolHeight,
          pick$1g(legend.options.symbolRadius, symbolHeight / 2)
        ).addClass("highcharts-point").attr({
          zIndex: 3
        }).add(item2.legendGroup);
      }
      LegendSymbol2.drawRectangle = drawRectangle;
    })(LegendSymbol || (LegendSymbol = {}));
    const LegendSymbol$1 = LegendSymbol;
    var seriesDefaults = {
      // base series options
      /**
       * The SVG value used for the `stroke-linecap` and `stroke-linejoin`
       * of a line graph. Round means that lines are rounded in the ends and
       * bends.
       *
       * @type       {Highcharts.SeriesLinecapValue}
       * @default    round
       * @since      3.0.7
       * @apioption  plotOptions.line.linecap
       */
      /**
       * Pixel width of the graph line.
       *
       * @see In styled mode, the line stroke-width can be set with the
       *      `.highcharts-graph` class name.
       *
       * @sample {highcharts} highcharts/plotoptions/series-linewidth-general/
       *         On all series
       * @sample {highcharts} highcharts/plotoptions/series-linewidth-specific/
       *         On one single series
       *
       * @product highcharts highstock
       *
       * @private
       */
      lineWidth: 2,
      /**
       * For some series, there is a limit that shuts down initial animation
       * by default when the total number of points in the chart is too high.
       * For example, for a column chart and its derivatives, animation does
       * not run if there is more than 250 points totally. To disable this
       * cap, set `animationLimit` to `Infinity`.
       *
       * @type      {number}
       * @apioption plotOptions.series.animationLimit
       */
      /**
       * Allow this series' points to be selected by clicking on the graphic
       * (columns, point markers, pie slices, map areas etc).
       *
       * The selected points can be handled by point select and unselect
       * events, or collectively by the [getSelectedPoints
       * ](/class-reference/Highcharts.Chart#getSelectedPoints) function.
       *
       * And alternative way of selecting points is through dragging.
       *
       * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/
       *         Line
       * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/
       *         Column
       * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/
       *         Pie
       * @sample {highcharts} highcharts/chart/events-selection-points/
       *         Select a range of points through a drag selection
       * @sample {highmaps} maps/plotoptions/series-allowpointselect/
       *         Map area
       * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
       *         Map bubble
       *
       * @since 1.2.0
       *
       * @private
       */
      allowPointSelect: false,
      /**
       * When true, each point or column edge is rounded to its nearest pixel
       * in order to render sharp on screen. In some cases, when there are a
       * lot of densely packed columns, this leads to visible difference
       * in column widths or distance between columns. In these cases,
       * setting `crisp` to `false` may look better, even though each column
       * is rendered blurry.
       *
       * @sample {highcharts} highcharts/plotoptions/column-crisp-false/
       *         Crisp is false
       *
       * @since   5.0.10
       * @product highcharts highstock gantt
       *
       * @private
       */
      crisp: true,
      /**
       * If true, a checkbox is displayed next to the legend item to allow
       * selecting the series. The state of the checkbox is determined by
       * the `selected` option.
       *
       * @productdesc {highmaps}
       * Note that if a `colorAxis` is defined, the color axis is represented
       * in the legend, not the series.
       *
       * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/
       *         Show select box
       *
       * @since 1.2.0
       *
       * @private
       */
      showCheckbox: false,
      /**
       * Enable or disable the initial animation when a series is displayed.
       * The animation can also be set as a configuration object. Please
       * note that this option only applies to the initial animation of the
       * series itself. For other animations, see [chart.animation](
       * #chart.animation) and the animation parameter under the API methods.
       * The following properties are supported:
       *
       * - `defer`: The animation delay time in milliseconds.
       *
       * - `duration`: The duration of the animation in milliseconds.
       *
       * - `easing`: Can be a string reference to an easing function set on
       *   the `Math` object or a function. See the _Custom easing function_
       *   demo below.
       *
       * Due to poor performance, animation is disabled in old IE browsers
       * for several chart types.
       *
       * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/
       *         Animation disabled
       * @sample {highcharts} highcharts/plotoptions/series-animation-slower/
       *         Slower animation
       * @sample {highcharts} highcharts/plotoptions/series-animation-easing/
       *         Custom easing function
       * @sample {highstock} stock/plotoptions/animation-slower/
       *         Slower animation
       * @sample {highstock} stock/plotoptions/animation-easing/
       *         Custom easing function
       * @sample {highmaps} maps/plotoptions/series-animation-true/
       *         Animation enabled on map series
       * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/
       *         Disabled on mapbubble series
       *
       * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}
       * @default {highcharts} true
       * @default {highstock} true
       * @default {highmaps} false
       *
       * @private
       */
      animation: {
        /** @internal */
        duration: 1e3
      },
      /**
       * @default   0
       * @type      {number}
       * @since     8.2.0
       * @apioption plotOptions.series.animation.defer
       */
      /**
       * An additional class name to apply to the series' graphical elements.
       * This option does not replace default class names of the graphical
       * element.
       *
       * @type      {string}
       * @since     5.0.0
       * @apioption plotOptions.series.className
       */
      /**
       * Disable this option to allow series rendering in the whole plotting
       * area.
       *
       * **Note:** Clipping should be always enabled when
       * [chart.zoomType](#chart.zoomType) is set
       *
       * @sample {highcharts} highcharts/plotoptions/series-clip/
       *         Disabled clipping
       *
       * @default   true
       * @type      {boolean}
       * @since     3.0.0
       * @apioption plotOptions.series.clip
       */
      /**
       * The main color of the series. In line type series it applies to the
       * line and the point markers unless otherwise specified. In bar type
       * series it applies to the bars unless a color is specified per point.
       * The default value is pulled from the `options.colors` array.
       *
       * In styled mode, the color can be defined by the
       * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
       * color can be set with the `.highcharts-series`,
       * `.highcharts-color-{n}`, `.highcharts-{type}-series` or
       * `.highcharts-series-{n}` class, or individual classes given by the
       * `className` option.
       *
       * @productdesc {highmaps}
       * In maps, the series color is rarely used, as most choropleth maps use
       * the color to denote the value of each point. The series color can
       * however be used in a map with multiple series holding categorized
       * data.
       *
       * @sample {highcharts} highcharts/plotoptions/series-color-general/
       *         General plot option
       * @sample {highcharts} highcharts/plotoptions/series-color-specific/
       *         One specific series
       * @sample {highcharts} highcharts/plotoptions/series-color-area/
       *         Area color
       * @sample {highcharts} highcharts/series/infographic/
       *         Pattern fill
       * @sample {highmaps} maps/demo/category-map/
       *         Category map by multiple series
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @apioption plotOptions.series.color
       */
      /**
       * Styled mode only. A specific color index to use for the series, so
       * its graphic representations are given the class name
       * `highcharts-color-{n}`.
       *
       * @type      {number}
       * @since     5.0.0
       * @apioption plotOptions.series.colorIndex
       */
      /**
       * Whether to connect a graph line across null points, or render a gap
       * between the two points on either side of the null.
       *
       * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/
       *         False by default
       * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/
       *         True
       *
       * @type      {boolean}
       * @default   false
       * @product   highcharts highstock
       * @apioption plotOptions.series.connectNulls
       */
      /**
       * You can set the cursor to "pointer" if you have click events attached
       * to the series, to signal to the user that the points and lines can
       * be clicked.
       *
       * In styled mode, the series cursor can be set with the same classes
       * as listed under [series.color](#plotOptions.series.color).
       *
       * @sample {highcharts} highcharts/plotoptions/series-cursor-line/
       *         On line graph
       * @sample {highcharts} highcharts/plotoptions/series-cursor-column/
       *         On columns
       * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/
       *         On scatter markers
       * @sample {highstock} stock/plotoptions/cursor/
       *         Pointer on a line graph
       * @sample {highmaps} maps/plotoptions/series-allowpointselect/
       *         Map area
       * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
       *         Map bubble
       *
       * @type      {string|Highcharts.CursorValue}
       * @apioption plotOptions.series.cursor
       */
      /**
       * A reserved subspace to store options and values for customized
       * functionality. Here you can add additional data for your own event
       * callbacks and formatter callbacks.
       *
       * @sample {highcharts} highcharts/point/custom/
       *         Point and series with custom data
       *
       * @type      {Highcharts.Dictionary<*>}
       * @apioption plotOptions.series.custom
       */
      /**
       * Name of the dash style to use for the graph, or for some series types
       * the outline of each shape.
       *
       * In styled mode, the
       * [stroke dash-array](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-dashstyle/)
       * can be set with the same classes as listed under
       * [series.color](#plotOptions.series.color).
       *
       * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
       *         Possible values demonstrated
       * @sample {highcharts} highcharts/plotoptions/series-dashstyle/
       *         Chart suitable for printing in black and white
       * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/
       *         Possible values demonstrated
       * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/
       *         Possible values demonstrated
       * @sample {highmaps} maps/plotoptions/series-dashstyle/
       *         Dotted borders on a map
       *
       * @type      {Highcharts.DashStyleValue}
       * @default   Solid
       * @since     2.1
       * @apioption plotOptions.series.dashStyle
       */
      /**
       * A description of the series to add to the screen reader information
       * about the series.
       *
       * @type      {string}
       * @since     5.0.0
       * @requires  modules/accessibility
       * @apioption plotOptions.series.description
       */
      /**
       * Options for the series data sorting.
       *
       * @type      {Highcharts.DataSortingOptionsObject}
       * @since     8.0.0
       * @product   highcharts highstock
       * @apioption plotOptions.series.dataSorting
       */
      /**
       * Enable or disable data sorting for the series. Use [xAxis.reversed](
       * #xAxis.reversed) to change the sorting order.
       *
       * @sample {highcharts} highcharts/datasorting/animation/
       *         Data sorting in scatter-3d
       * @sample {highcharts} highcharts/datasorting/labels-animation/
       *         Axis labels animation
       * @sample {highcharts} highcharts/datasorting/dependent-sorting/
       *         Dependent series sorting
       * @sample {highcharts} highcharts/datasorting/independent-sorting/
       *         Independent series sorting
       *
       * @type      {boolean}
       * @since     8.0.0
       * @apioption plotOptions.series.dataSorting.enabled
       */
      /**
       * Whether to allow matching points by name in an update. If this option
       * is disabled, points will be matched by order.
       *
       * @sample {highcharts} highcharts/datasorting/match-by-name/
       *         Enabled match by name
       *
       * @type      {boolean}
       * @since     8.0.0
       * @apioption plotOptions.series.dataSorting.matchByName
       */
      /**
       * Determines what data value should be used to sort by.
       *
       * @sample {highcharts} highcharts/datasorting/sort-key/
       *         Sort key as `z` value
       *
       * @type      {string}
       * @since     8.0.0
       * @default   y
       * @apioption plotOptions.series.dataSorting.sortKey
       */
      /**
       * Enable or disable the mouse tracking for a specific series. This
       * includes point tooltips and click events on graphs and points. For
       * large datasets it improves performance.
       *
       * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/
       *         No mouse tracking
       * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/
       *         No mouse tracking
       *
       * @type      {boolean}
       * @default   true
       * @apioption plotOptions.series.enableMouseTracking
       */
      /**
       * Whether to use the Y extremes of the total chart width or only the
       * zoomed area when zooming in on parts of the X axis. By default, the
       * Y axis adjusts to the min and max of the visible data. Cartesian
       * series only.
       *
       * @type      {boolean}
       * @default   false
       * @since     4.1.6
       * @product   highcharts highstock gantt
       * @apioption plotOptions.series.getExtremesFromAll
       */
      /**
       * An array specifying which option maps to which key in the data point
       * array. This makes it convenient to work with unstructured data arrays
       * from different sources.
       *
       * @see [series.data](#series.line.data)
       *
       * @sample {highcharts|highstock} highcharts/series/data-keys/
       *         An extended data array with keys
       * @sample {highcharts|highstock} highcharts/series/data-nested-keys/
       *         Nested keys used to access object properties
       *
       * @type      {Array<string>}
       * @since     4.1.6
       * @apioption plotOptions.series.keys
       */
      /**
       * The line cap used for line ends and line joins on the graph.
       *
       * @type       {Highcharts.SeriesLinecapValue}
       * @default    round
       * @product    highcharts highstock
       * @apioption  plotOptions.series.linecap
       */
      /**
       * The [id](#series.id) of another series to link to. Additionally,
       * the value can be ":previous" to link to the previous series. When
       * two series are linked, only the first one appears in the legend.
       * Toggling the visibility of this also toggles the linked series.
       *
       * If master series uses data sorting and linked series does not have
       * its own sorting definition, the linked series will be sorted in the
       * same order as the master one.
       *
       * @sample {highcharts|highstock} highcharts/demo/arearange-line/
       *         Linked series
       *
       * @type      {string}
       * @since     3.0
       * @product   highcharts highstock gantt
       * @apioption plotOptions.series.linkedTo
       */
      /**
       * Options for the corresponding navigator series if `showInNavigator`
       * is `true` for this series. Available options are the same as any
       * series, documented at [plotOptions](#plotOptions.series) and
       * [series](#series).
       *
       * These options are merged with options in [navigator.series](
       * #navigator.series), and will take precedence if the same option is
       * defined both places.
       *
       * @see [navigator.series](#navigator.series)
       *
       * @type      {Highcharts.PlotSeriesOptions}
       * @since     5.0.0
       * @product   highstock
       * @apioption plotOptions.series.navigatorOptions
       */
      /**
       * The color for the parts of the graph or points that are below the
       * [threshold](#plotOptions.series.threshold). Note that `zones` takes
       * precedence over the negative color. Using `negativeColor` is
       * equivalent to applying a zone with value of 0.
       *
       * @see In styled mode, a negative color is applied by setting this option
       *      to `true` combined with the `.highcharts-negative` class name.
       *
       * @sample {highcharts} highcharts/plotoptions/series-negative-color/
       *         Spline, area and column
       * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/
       *         Arearange
       * @sample {highcharts} highcharts/css/series-negative-color/
       *         Styled mode
       * @sample {highstock} highcharts/plotoptions/series-negative-color/
       *         Spline, area and column
       * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/
       *         Arearange
       * @sample {highmaps} highcharts/plotoptions/series-negative-color/
       *         Spline, area and column
       * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/
       *         Arearange
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since     3.0
       * @apioption plotOptions.series.negativeColor
       */
      /**
       * Same as
       * [accessibility.series.descriptionFormatter](#accessibility.series.descriptionFormatter),
       * but for an individual series. Overrides the chart wide configuration.
       *
       * @type      {Function}
       * @since     5.0.12
       * @apioption plotOptions.series.pointDescriptionFormatter
       */
      /**
       * If no x values are given for the points in a series, `pointInterval`
       * defines the interval of the x values. For example, if a series
       * contains one value every decade starting from year 0, set
       * `pointInterval` to `10`. In true `datetime` axes, the `pointInterval`
       * is set in milliseconds.
       *
       * It can be also be combined with `pointIntervalUnit` to draw irregular
       * time intervals.
       *
       * If combined with `relativeXValue`, an x value can be set on each
       * point, and the `pointInterval` is added x times to the `pointStart`
       * setting.
       *
       * Please note that this options applies to the _series data_, not the
       * interval of the axis ticks, which is independent.
       *
       * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
       *         Datetime X axis
       * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
       *         Relative x value
       * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
       *         Using pointStart and pointInterval
       * @sample {highstock} stock/plotoptions/relativexvalue/
       *         Relative x value
       *
       * @type      {number}
       * @default   1
       * @product   highcharts highstock gantt
       * @apioption plotOptions.series.pointInterval
       */
      /**
       * On datetime series, this allows for setting the
       * [pointInterval](#plotOptions.series.pointInterval) to irregular time
       * units, `day`, `month` and `year`. A day is usually the same as 24
       * hours, but `pointIntervalUnit` also takes the DST crossover into
       * consideration when dealing with local time. Combine this option with
       * `pointInterval` to draw weeks, quarters, 6 months, 10 years etc.
       *
       * Please note that this options applies to the _series data_, not the
       * interval of the axis ticks, which is independent.
       *
       * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/
       *         One point a month
       * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/
       *         One point a month
       *
       * @type       {string}
       * @since      4.1.0
       * @product    highcharts highstock gantt
       * @validvalue ["day", "month", "year"]
       * @apioption  plotOptions.series.pointIntervalUnit
       */
      /**
       * Possible values: `"on"`, `"between"`, `number`.
       *
       * In a column chart, when pointPlacement is `"on"`, the point will not
       * create any padding of the X axis. In a polar column chart this means
       * that the first column points directly north. If the pointPlacement is
       * `"between"`, the columns will be laid out between ticks. This is
       * useful for example for visualising an amount between two points in
       * time or in a certain sector of a polar chart.
       *
       * Since Highcharts 3.0.2, the point placement can also be numeric,
       * where 0 is on the axis value, -0.5 is between this value and the
       * previous, and 0.5 is between this value and the next. Unlike the
       * textual options, numeric point placement options won't affect axis
       * padding.
       *
       * Note that pointPlacement needs a [pointRange](
       * #plotOptions.series.pointRange) to work. For column series this is
       * computed, but for line-type series it needs to be set.
       *
       * For the `xrange` series type and gantt charts, if the Y axis is a
       * category axis, the `pointPlacement` applies to the Y axis rather than
       * the (typically datetime) X axis.
       *
       * Defaults to `undefined` in cartesian charts, `"between"` in polar
       * charts.
       *
       * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)
       *
       * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-between/
       *         Between in a column chart
       * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-numeric/
       *         Numeric placement for custom layout
       * @sample {highcharts|highstock} maps/plotoptions/heatmap-pointplacement/
       *         Placement in heatmap
       *
       * @type      {string|number}
       * @since     2.3.0
       * @product   highcharts highstock gantt
       * @apioption plotOptions.series.pointPlacement
       */
      /**
       * If no x values are given for the points in a series, pointStart
       * defines on what value to start. For example, if a series contains one
       * yearly value starting from 1945, set pointStart to 1945.
       *
       * If combined with `relativeXValue`, an x value can be set on each
       * point. The x value from the point options is multiplied by
       * `pointInterval` and added to `pointStart` to produce a modified x
       * value.
       *
       * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/
       *         Linear
       * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
       *         Datetime
       * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
       *         Relative x value
       * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
       *         Using pointStart and pointInterval
       * @sample {highstock} stock/plotoptions/relativexvalue/
       *         Relative x value
       *
       * @type      {number}
       * @default   0
       * @product   highcharts highstock gantt
       * @apioption plotOptions.series.pointStart
       */
      /**
       * When true, X values in the data set are relative to the current
       * `pointStart`, `pointInterval` and `pointIntervalUnit` settings. This
       * allows compression of the data for datasets with irregular X values.
       *
       * The real X values are computed on the formula `f(x) = ax + b`, where
       * `a` is the `pointInterval` (optionally with a time unit given by
       * `pointIntervalUnit`), and `b` is the `pointStart`.
       *
       * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
       *         Relative X value
       * @sample {highstock} stock/plotoptions/relativexvalue/
       *         Relative X value
       *
       * @type      {boolean}
       * @default   false
       * @product   highcharts highstock
       * @apioption plotOptions.series.relativeXValue
       */
      /**
       * Whether to select the series initially. If `showCheckbox` is true,
       * the checkbox next to the series name in the legend will be checked
       * for a selected series.
       *
       * @sample {highcharts} highcharts/plotoptions/series-selected/
       *         One out of two series selected
       *
       * @type      {boolean}
       * @default   false
       * @since     1.2.0
       * @apioption plotOptions.series.selected
       */
      /**
       * Whether to apply a drop shadow to the graph line. Since 2.3 the
       * shadow can be an object configuration containing `color`, `offsetX`,
       * `offsetY`, `opacity` and `width`.
       *
       * @sample {highcharts} highcharts/plotoptions/series-shadow/
       *         Shadow enabled
       *
       * @type      {boolean|Highcharts.ShadowOptionsObject}
       * @default   false
       * @apioption plotOptions.series.shadow
       */
      /**
       * Whether to display this particular series or series type in the
       * legend. Standalone series are shown in legend by default, and linked
       * series are not. Since v7.2.0 it is possible to show series that use
       * colorAxis by setting this option to `true`.
       *
       * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
       *         One series in the legend, one hidden
       *
       * @type      {boolean}
       * @apioption plotOptions.series.showInLegend
       */
      /**
       * Whether or not to show the series in the navigator. Takes precedence
       * over [navigator.baseSeries](#navigator.baseSeries) if defined.
       *
       * @type      {boolean}
       * @since     5.0.0
       * @product   highstock
       * @apioption plotOptions.series.showInNavigator
       */
      /**
       * If set to `true`, the accessibility module will skip past the points
       * in this series for keyboard navigation.
       *
       * @type      {boolean}
       * @since     5.0.12
       * @apioption plotOptions.series.skipKeyboardNavigation
       */
      /**
       * Whether to stack the values of each series on top of each other.
       * Possible values are `undefined` to disable, `"normal"` to stack by
       * value or `"percent"`.
       *
       * When stacking is enabled, data must be sorted
       * in ascending X order.
       *
       * Some stacking options are related to specific series types. In the
       * streamgraph series type, the stacking option is set to `"stream"`.
       * The second one is `"overlap"`, which only applies to waterfall
       * series.
       *
       * @see [yAxis.reversedStacks](#yAxis.reversedStacks)
       *
       * @sample {highcharts} highcharts/plotoptions/series-stacking-line/
       *         Line
       * @sample {highcharts} highcharts/plotoptions/series-stacking-column/
       *         Column
       * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/
       *         Bar
       * @sample {highcharts} highcharts/plotoptions/series-stacking-area/
       *         Area
       * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/
       *         Line
       * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/
       *         Column
       * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/
       *         Bar
       * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/
       *         Area
       * @sample {highcharts} highcharts/plotoptions/series-waterfall-with-normal-stacking
       *         Waterfall with normal stacking
       * @sample {highcharts} highcharts/plotoptions/series-waterfall-with-overlap-stacking
       *         Waterfall with overlap stacking
       * @sample {highstock} stock/plotoptions/stacking/
       *         Area
       *
       * @type       {string}
       * @product    highcharts highstock
       * @validvalue ["normal", "overlap", "percent", "stream"]
       * @apioption  plotOptions.series.stacking
       */
      /**
       * Whether to apply steps to the line. Possible values are `left`,
       * `center` and `right`.
       *
       * @sample {highcharts} highcharts/plotoptions/line-step/
       *         Different step line options
       * @sample {highcharts} highcharts/plotoptions/area-step/
       *         Stepped, stacked area
       * @sample {highstock} stock/plotoptions/line-step/
       *         Step line
       *
       * @type       {string}
       * @since      1.2.5
       * @product    highcharts highstock
       * @validvalue ["left", "center", "right"]
       * @apioption  plotOptions.series.step
       */
      /**
       * The threshold, also called zero level or base level. For line type
       * series this is only used in conjunction with
       * [negativeColor](#plotOptions.series.negativeColor).
       *
       * @see [softThreshold](#plotOptions.series.softThreshold).
       *
       * @type      {number|null}
       * @default   0
       * @since     3.0
       * @product   highcharts highstock
       * @apioption plotOptions.series.threshold
       */
      /**
       * Set the initial visibility of the series.
       *
       * @sample {highcharts} highcharts/plotoptions/series-visible/
       *         Two series, one hidden and one visible
       * @sample {highstock} stock/plotoptions/series-visibility/
       *         Hidden series
       *
       * @type      {boolean}
       * @default   true
       * @apioption plotOptions.series.visible
       */
      /**
       * Defines the Axis on which the zones are applied.
       *
       * @see [zones](#plotOptions.series.zones)
       *
       * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/
       *         Zones on the X-Axis
       * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/
       *         Zones on the X-Axis
       *
       * @type      {string}
       * @default   y
       * @since     4.1.0
       * @product   highcharts highstock
       * @apioption plotOptions.series.zoneAxis
       */
      /**
       * General event handlers for the series items. These event hooks can
       * also be attached to the series at run time using the
       * `Highcharts.addEvent` function.
       *
       * @declare Highcharts.SeriesEventsOptionsObject
       *
       * @private
       */
      events: {},
      /**
       * Fires after the series has finished its initial animation, or in case
       * animation is disabled, immediately as the series is displayed.
       *
       * @sample {highcharts} highcharts/plotoptions/series-events-afteranimate/
       *         Show label after animate
       * @sample {highstock} highcharts/plotoptions/series-events-afteranimate/
       *         Show label after animate
       *
       * @type      {Highcharts.SeriesAfterAnimateCallbackFunction}
       * @since     4.0
       * @product   highcharts highstock gantt
       * @context   Highcharts.Series
       * @apioption plotOptions.series.events.afterAnimate
       */
      /**
       * Fires when the checkbox next to the series' name in the legend is
       * clicked. One parameter, `event`, is passed to the function. The state
       * of the checkbox is found by `event.checked`. The checked item is
       * found by `event.item`. Return `false` to prevent the default action
       * which is to toggle the select state of the series.
       *
       * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
       *         Alert checkbox status
       *
       * @type      {Highcharts.SeriesCheckboxClickCallbackFunction}
       * @since     1.2.0
       * @context   Highcharts.Series
       * @apioption plotOptions.series.events.checkboxClick
       */
      /**
       * Fires when the series is clicked. One parameter, `event`, is passed
       * to the function, containing common event information. Additionally,
       * `event.point` holds a pointer to the nearest point on the graph.
       *
       * @sample {highcharts} highcharts/plotoptions/series-events-click/
       *         Alert click info
       * @sample {highstock} stock/plotoptions/series-events-click/
       *         Alert click info
       * @sample {highmaps} maps/plotoptions/series-events-click/
       *         Display click info in subtitle
       *
       * @type      {Highcharts.SeriesClickCallbackFunction}
       * @context   Highcharts.Series
       * @apioption plotOptions.series.events.click
       */
      /**
       * Fires when the series is hidden after chart generation time, either
       * by clicking the legend item or by calling `.hide()`.
       *
       * @sample {highcharts} highcharts/plotoptions/series-events-hide/
       *         Alert when the series is hidden by clicking the legend item
       *
       * @type      {Highcharts.SeriesHideCallbackFunction}
       * @since     1.2.0
       * @context   Highcharts.Series
       * @apioption plotOptions.series.events.hide
       */
      /**
       * Fires when the legend item belonging to the series is clicked. One
       * parameter, `event`, is passed to the function. The default action
       * is to toggle the visibility of the series. This can be prevented
       * by returning `false` or calling `event.preventDefault()`.
       *
       * @sample {highcharts} highcharts/plotoptions/series-events-legenditemclick/
       *         Confirm hiding and showing
       *
       * @type      {Highcharts.SeriesLegendItemClickCallbackFunction}
       * @context   Highcharts.Series
       * @apioption plotOptions.series.events.legendItemClick
       */
      /**
       * Fires when the mouse leaves the graph. One parameter, `event`, is
       * passed to the function, containing common event information. If the
       * [stickyTracking](#plotOptions.series) option is true, `mouseOut`
       * doesn't happen before the mouse enters another graph or leaves the
       * plot area.
       *
       * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
       *         With sticky tracking by default
       * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
       *         Without sticky tracking
       *
       * @type      {Highcharts.SeriesMouseOutCallbackFunction}
       * @context   Highcharts.Series
       * @apioption plotOptions.series.events.mouseOut
       */
      /**
       * Fires when the mouse enters the graph. One parameter, `event`, is
       * passed to the function, containing common event information.
       *
       * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
       *         With sticky tracking by default
       * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
       *         Without sticky tracking
       *
       * @type      {Highcharts.SeriesMouseOverCallbackFunction}
       * @context   Highcharts.Series
       * @apioption plotOptions.series.events.mouseOver
       */
      /**
       * Fires when the series is shown after chart generation time, either
       * by clicking the legend item or by calling `.show()`.
       *
       * @sample {highcharts} highcharts/plotoptions/series-events-show/
       *         Alert when the series is shown by clicking the legend item.
       *
       * @type      {Highcharts.SeriesShowCallbackFunction}
       * @since     1.2.0
       * @context   Highcharts.Series
       * @apioption plotOptions.series.events.show
       */
      /**
       * Options for the point markers of line-like series. Properties like
       * `fillColor`, `lineColor` and `lineWidth` define the visual appearance
       * of the markers. Other series types, like column series, don't have
       * markers, but have visual options on the series level instead.
       *
       * In styled mode, the markers can be styled with the
       * `.highcharts-point`, `.highcharts-point-hover` and
       * `.highcharts-point-select` class names.
       *
       * @declare Highcharts.PointMarkerOptionsObject
       *
       * @private
       */
      marker: {
        /**
         * Enable or disable the point marker. If `undefined`, the markers
         * are hidden when the data is dense, and shown for more widespread
         * data points.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-enabled/
         *         Disabled markers
         * @sample {highcharts} highcharts/plotoptions/series-marker-enabled-false/
         *         Disabled in normal state but enabled on hover
         * @sample {highstock} stock/plotoptions/series-marker/
         *         Enabled markers
         *
         * @type      {boolean}
         * @default   {highcharts} undefined
         * @default   {highstock} false
         * @apioption plotOptions.series.marker.enabled
         */
        /**
         * The threshold for how dense the point markers should be before
         * they are hidden, given that `enabled` is not defined. The number
         * indicates the horizontal distance between the two closest points
         * in the series, as multiples of the `marker.radius`. In other
         * words, the default value of 2 means points are hidden if
         * overlapping horizontally.
         *
         * @sample highcharts/plotoptions/series-marker-enabledthreshold
         *         A higher threshold
         *
         * @since 6.0.5
         */
        enabledThreshold: 2,
        /**
         * The fill color of the point marker. When `undefined`, the series'
         * or point's color is used.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
         *         White fill
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption plotOptions.series.marker.fillColor
         */
        /**
         * Image markers only. Set the image width explicitly. When using
         * this option, a `width` must also be set.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
         *         Fixed width and height
         * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
         *         Fixed width and height
         *
         * @type      {number}
         * @since     4.0.4
         * @apioption plotOptions.series.marker.height
         */
        /**
         * The color of the point marker's outline. When `undefined`, the
         * series' or point's color is used.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
         *         Inherit from series color (undefined)
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        lineColor: palette.backgroundColor,
        /**
         * The width of the point marker's outline.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
         *         2px blue marker
         */
        lineWidth: 0,
        /**
         * The radius of the point marker.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-radius/
         *         Bigger markers
         *
         * @default {highstock} 2
         * @default {highcharts} 4
         *
         */
        radius: 4,
        /**
         * A predefined shape or symbol for the marker. When undefined, the
         * symbol is pulled from options.symbols. Other possible values are
         * `'circle'`, `'square'`,`'diamond'`, `'triangle'` and
         * `'triangle-down'`.
         *
         * Additionally, the URL to a graphic can be given on this form:
         * `'url(graphic.png)'`. Note that for the image to be applied to
         * exported charts, its URL needs to be accessible by the export
         * server.
         *
         * Custom callbacks for symbol path generation can also be added to
         * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
         * used by its method name, as shown in the demo.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
         *         Predefined, graphic and custom markers
         * @sample {highstock} highcharts/plotoptions/series-marker-symbol/
         *         Predefined, graphic and custom markers
         *
         * @type      {string}
         * @apioption plotOptions.series.marker.symbol
         */
        /**
         * Image markers only. Set the image width explicitly. When using
         * this option, a `height` must also be set.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
         *         Fixed width and height
         * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
         *         Fixed width and height
         *
         * @type      {number}
         * @since     4.0.4
         * @apioption plotOptions.series.marker.width
         */
        /**
         * States for a single point marker.
         *
         * @declare Highcharts.PointStatesOptionsObject
         */
        states: {
          /**
           * The normal state of a single point marker. Currently only
           * used for setting animation when returning to normal state
           * from hover.
           *
           * @declare Highcharts.PointStatesNormalOptionsObject
           */
          normal: {
            /**
             * Animation when returning to normal state after hovering.
             *
             * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
             */
            animation: true
          },
          /**
           * The hover state for a single point marker.
           *
           * @declare Highcharts.PointStatesHoverOptionsObject
           */
          hover: {
            /**
             * Animation when hovering over the marker.
             *
             * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
             */
            animation: {
              /** @internal */
              duration: 50
            },
            /**
             * Enable or disable the point marker.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/
             *         Disabled hover state
             */
            enabled: true,
            /**
             * The fill color of the marker in hover state. When
             * `undefined`, the series' or point's fillColor for normal
             * state is used.
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @apioption plotOptions.series.marker.states.hover.fillColor
             */
            /**
             * The color of the point marker's outline. When
             * `undefined`, the series' or point's lineColor for normal
             * state is used.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linecolor/
             *         White fill color, black line color
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @apioption plotOptions.series.marker.states.hover.lineColor
             */
            /**
             * The width of the point marker's outline. When
             * `undefined`, the series' or point's lineWidth for normal
             * state is used.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linewidth/
             *         3px line width
             *
             * @type      {number}
             * @apioption plotOptions.series.marker.states.hover.lineWidth
             */
            /**
             * The radius of the point marker. In hover state, it
             * defaults to the normal state's radius + 2 as per the
             * [radiusPlus](#plotOptions.series.marker.states.hover.radiusPlus)
             * option.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-radius/
             *         10px radius
             *
             * @type      {number}
             * @apioption plotOptions.series.marker.states.hover.radius
             */
            /**
             * The number of pixels to increase the radius of the
             * hovered point.
             *
             * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
             *         5 pixels greater radius on hover
             * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
             *         5 pixels greater radius on hover
             *
             * @since 4.0.3
             */
            radiusPlus: 2,
            /**
             * The additional line width for a hovered point.
             *
             * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
             *         2 pixels wider on hover
             * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
             *         2 pixels wider on hover
             *
             * @since 4.0.3
             */
            lineWidthPlus: 1
          },
          /**
           * The appearance of the point marker when selected. In order to
           * allow a point to be selected, set the
           * `series.allowPointSelect` option to true.
           *
           * @declare Highcharts.PointStatesSelectOptionsObject
           */
          select: {
            /**
             * Enable or disable visible feedback for selection.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-enabled/
             *         Disabled select state
             *
             * @type      {boolean}
             * @default   true
             * @apioption plotOptions.series.marker.states.select.enabled
             */
            /**
             * The radius of the point marker. In hover state, it
             * defaults to the normal state's radius + 2.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-radius/
             *         10px radius for selected points
             *
             * @type      {number}
             * @apioption plotOptions.series.marker.states.select.radius
             */
            /**
             * The fill color of the point marker.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-fillcolor/
             *         Solid red discs for selected points
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             */
            fillColor: palette.neutralColor20,
            /**
             * The color of the point marker's outline. When
             * `undefined`, the series' or point's color is used.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linecolor/
             *         Red line color for selected points
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             */
            lineColor: palette.neutralColor100,
            /**
             * The width of the point marker's outline.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linewidth/
             *         3px line width for selected points
             */
            lineWidth: 2
          }
        }
      },
      /**
       * Properties for each single point.
       *
       * @declare Highcharts.PlotSeriesPointOptions
       *
       * @private
       */
      point: {
        /**
         * Fires when a point is clicked. One parameter, `event`, is passed
         * to the function, containing common event information.
         *
         * If the `series.allowPointSelect` option is true, the default
         * action for the point's click event is to toggle the point's
         * select state. Returning `false` cancels this action.
         *
         * @sample {highcharts} highcharts/plotoptions/series-point-events-click/
         *         Click marker to alert values
         * @sample {highcharts} highcharts/plotoptions/series-point-events-click-column/
         *         Click column
         * @sample {highcharts} highcharts/plotoptions/series-point-events-click-url/
         *         Go to URL
         * @sample {highmaps} maps/plotoptions/series-point-events-click/
         *         Click marker to display values
         * @sample {highmaps} maps/plotoptions/series-point-events-click-url/
         *         Go to URL
         *
         * @type      {Highcharts.PointClickCallbackFunction}
         * @context   Highcharts.Point
         * @apioption plotOptions.series.point.events.click
         */
        /**
         * Fires when the mouse leaves the area close to the point. One
         * parameter, `event`, is passed to the function, containing common
         * event information.
         *
         * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
         *         Show values in the chart's corner on mouse over
         *
         * @type      {Highcharts.PointMouseOutCallbackFunction}
         * @context   Highcharts.Point
         * @apioption plotOptions.series.point.events.mouseOut
         */
        /**
         * Fires when the mouse enters the area close to the point. One
         * parameter, `event`, is passed to the function, containing common
         * event information.
         *
         * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
         *         Show values in the chart's corner on mouse over
         *
         * @type      {Highcharts.PointMouseOverCallbackFunction}
         * @context   Highcharts.Point
         * @apioption plotOptions.series.point.events.mouseOver
         */
        /**
         * Fires when the point is removed using the `.remove()` method. One
         * parameter, `event`, is passed to the function. Returning `false`
         * cancels the operation.
         *
         * @sample {highcharts} highcharts/plotoptions/series-point-events-remove/
         *         Remove point and confirm
         *
         * @type      {Highcharts.PointRemoveCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Point
         * @apioption plotOptions.series.point.events.remove
         */
        /**
         * Fires when the point is selected either programmatically or
         * following a click on the point. One parameter, `event`, is passed
         * to the function. Returning `false` cancels the operation.
         *
         * @sample {highcharts} highcharts/plotoptions/series-point-events-select/
         *         Report the last selected point
         * @sample {highmaps} maps/plotoptions/series-allowpointselect/
         *         Report select and unselect
         *
         * @type      {Highcharts.PointSelectCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Point
         * @apioption plotOptions.series.point.events.select
         */
        /**
         * Fires when the point is unselected either programmatically or
         * following a click on the point. One parameter, `event`, is passed
         * to the function.
         *  Returning `false` cancels the operation.
         *
         * @sample {highcharts} highcharts/plotoptions/series-point-events-unselect/
         *         Report the last unselected point
         * @sample {highmaps} maps/plotoptions/series-allowpointselect/
         *         Report select and unselect
         *
         * @type      {Highcharts.PointUnselectCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Point
         * @apioption plotOptions.series.point.events.unselect
         */
        /**
         * Fires when the point is updated programmatically through the
         * `.update()` method. One parameter, `event`, is passed to the
         * function. The new point options can be accessed through
         * `event.options`. Returning `false` cancels the operation.
         *
         * @sample {highcharts} highcharts/plotoptions/series-point-events-update/
         *         Confirm point updating
         *
         * @type      {Highcharts.PointUpdateCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Point
         * @apioption plotOptions.series.point.events.update
         */
        /**
         * Events for each single point.
         *
         * @declare Highcharts.PointEventsOptionsObject
         */
        events: {}
      },
      /**
       * Options for the series data labels, appearing next to each data
       * point.
       *
       * Since v6.2.0, multiple data labels can be applied to each single
       * point by defining them as an array of configs.
       *
       * In styled mode, the data labels can be styled with the
       * `.highcharts-data-label-box` and `.highcharts-data-label` class names
       * ([see example](https://www.highcharts.com/samples/highcharts/css/series-datalabels)).
       *
       * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled
       *         Data labels enabled
       * @sample {highcharts} highcharts/plotoptions/series-datalabels-multiple
       *         Multiple data labels on a bar series
       * @sample {highcharts} highcharts/css/series-datalabels
       *         Style mode example
       *
       * @type    {*|Array<*>}
       * @product highcharts highstock highmaps gantt
       *
       * @private
       */
      dataLabels: {
        /**
         * Enable or disable the initial animation when a series is
         * displayed for the `dataLabels`. The animation can also be set as
         * a configuration object. Please note that this option only
         * applies to the initial animation.
         * For other animations, see [chart.animation](#chart.animation)
         * and the animation parameter under the API methods.
         * The following properties are supported:
         *
         * - `defer`: The animation delay time in milliseconds.
         *
         * @sample {highcharts} highcharts/plotoptions/animation-defer/
         *          Animation defer settings
         *
         * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
         * @since     8.2.0
         * @apioption plotOptions.series.dataLabels.animation
         */
        animation: {},
        /**
         * The animation delay time in milliseconds.
         * Set to `0` renders dataLabel immediately.
         * As `undefined` inherits defer time from the [series.animation.defer](#plotOptions.series.animation.defer).
         *
         * @type      {number}
         * @since     8.2.0
         * @apioption plotOptions.series.dataLabels.animation.defer
         */
        /**
         * The alignment of the data label compared to the point. If
         * `right`, the right side of the label should be touching the
         * point. For points with an extent, like columns, the alignments
         * also dictates how to align it inside the box, as given with the
         * [inside](#plotOptions.column.dataLabels.inside)
         * option. Can be one of `left`, `center` or `right`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-align-left/
         *         Left aligned
         * @sample {highcharts} highcharts/plotoptions/bar-datalabels-align-inside-bar/
         *         Data labels inside the bar
         *
         * @type {Highcharts.AlignValue|null}
         */
        align: "center",
        /**
         * Whether to allow data labels to overlap. To make the labels less
         * sensitive for overlapping, the
         * [dataLabels.padding](#plotOptions.series.dataLabels.padding)
         * can be set to 0.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-allowoverlap-false/
         *         Don't allow overlap
         *
         * @type      {boolean}
         * @default   false
         * @since     4.1.0
         * @apioption plotOptions.series.dataLabels.allowOverlap
         */
        /**
         * The background color or gradient for the data label.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
         *         Data labels box options
         * @sample {highmaps} maps/plotoptions/series-datalabels-box/
         *         Data labels box options
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @since     2.2.1
         * @apioption plotOptions.series.dataLabels.backgroundColor
         */
        /**
         * The border color for the data label. Defaults to `undefined`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
         *         Data labels box options
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @since     2.2.1
         * @apioption plotOptions.series.dataLabels.borderColor
         */
        /**
         * The border radius in pixels for the data label.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
         *         Data labels box options
         * @sample {highmaps} maps/plotoptions/series-datalabels-box/
         *         Data labels box options
         *
         * @type      {number}
         * @default   0
         * @since     2.2.1
         * @apioption plotOptions.series.dataLabels.borderRadius
         */
        /**
         * The border width in pixels for the data label.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
         *         Data labels box options
         *
         * @type      {number}
         * @default   0
         * @since     2.2.1
         * @apioption plotOptions.series.dataLabels.borderWidth
         */
        /**
         * A class name for the data label. Particularly in styled mode,
         * this can be used to give each series' or point's data label
         * unique styling. In addition to this option, a default color class
         * name is added so that we can give the labels a contrast text
         * shadow.
         *
         * @sample {highcharts} highcharts/css/data-label-contrast/
         *         Contrast text shadow
         * @sample {highcharts} highcharts/css/series-datalabels/
         *         Styling by CSS
         *
         * @type      {string}
         * @since     5.0.0
         * @apioption plotOptions.series.dataLabels.className
         */
        /**
         * The text color for the data labels. Defaults to `undefined`. For
         * certain series types, like column or map, the data labels can be
         * drawn inside the points. In this case the data label will be
         * drawn with maximum contrast by default. Additionally, it will be
         * given a `text-outline` style with the opposite color, to further
         * increase the contrast. This can be overridden by setting the
         * `text-outline` style to `none` in the `dataLabels.style` option.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/
         *         Red data labels
         * @sample {highmaps} maps/demo/color-axis/
         *         White data labels
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption plotOptions.series.dataLabels.color
         */
        /**
         * Whether to hide data labels that are outside the plot area. By
         * default, the data label is moved inside the plot area according
         * to the
         * [overflow](#plotOptions.series.dataLabels.overflow)
         * option.
         *
         * @type      {boolean}
         * @default   true
         * @since     2.3.3
         * @apioption plotOptions.series.dataLabels.crop
         */
        /**
         * Whether to defer displaying the data labels until the initial
         * series animation has finished. Setting to `false` renders the
         * data label immediately. If set to `true` inherits the defer
         * time set in [plotOptions.series.animation](#plotOptions.series.animation).
         * If set to a number, a defer time is specified in milliseconds.
         *
         * @sample highcharts/plotoptions/animation-defer
         *         Set defer time
         *
         * @since     4.0.0
         * @type      {boolean|number}
         * @product   highcharts highstock gantt
         */
        defer: true,
        /**
         * Enable or disable the data labels.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/
         *         Data labels enabled
         * @sample {highmaps} maps/demo/color-axis/
         *         Data labels enabled
         *
         * @type      {boolean}
         * @default   false
         * @apioption plotOptions.series.dataLabels.enabled
         */
        /**
         * A declarative filter to control of which data labels to display.
         * The declarative filter is designed for use when callback
         * functions are not available, like when the chart options require
         * a pure JSON structure or for use with graphical editors. For
         * programmatic control, use the `formatter` instead, and return
         * `undefined` to disable a single data label.
         *
         * @example
         * filter: {
         *     property: 'percentage',
         *     operator: '>',
         *     value: 4
         * }
         *
         * @sample {highcharts} highcharts/demo/pie-monochrome
         *         Data labels filtered by percentage
         *
         * @declare   Highcharts.DataLabelsFilterOptionsObject
         * @since     6.0.3
         * @apioption plotOptions.series.dataLabels.filter
         */
        /**
         * The operator to compare by. Can be one of `>`, `<`, `>=`, `<=`,
         * `==`, and `===`.
         *
         * @type       {string}
         * @validvalue [">", "<", ">=", "<=", "==", "==="]
         * @apioption  plotOptions.series.dataLabels.filter.operator
         */
        /**
         * The point property to filter by. Point options are passed
         * directly to properties, additionally there are `y` value,
         * `percentage` and others listed under {@link Highcharts.Point}
         * members.
         *
         * @type      {string}
         * @apioption plotOptions.series.dataLabels.filter.property
         */
        /**
         * The value to compare against.
         *
         * @type      {number}
         * @apioption plotOptions.series.dataLabels.filter.value
         */
        /**
         * A
         * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
         * for the data label. Available variables are the same as for
         * `formatter`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
         *         Add a unit
         * @sample {highmaps} maps/plotoptions/series-datalabels-format/
         *         Formatted value in the data label
         *
         * @type      {string}
         * @default   y
         * @default   point.value
         * @since     3.0
         * @apioption plotOptions.series.dataLabels.format
         */
        // eslint-disable-next-line valid-jsdoc
        /**
         * Callback JavaScript function to format the data label. Note that
         * if a `format` is defined, the format takes precedence and the
         * formatter is ignored.
         *
         * @sample {highmaps} maps/plotoptions/series-datalabels-format/
         *         Formatted value
         *
         * @type {Highcharts.DataLabelsFormatterCallbackFunction}
         */
        formatter: function() {
          var numberFormatter = this.series.chart.numberFormatter;
          return typeof this.y !== "number" ? "" : numberFormatter(this.y, -1);
        },
        /**
         * For points with an extent, like columns or map areas, whether to
         * align the data label inside the box or to the actual value point.
         * Defaults to `false` in most cases, `true` in stacked columns.
         *
         * @type      {boolean}
         * @since     3.0
         * @apioption plotOptions.series.dataLabels.inside
         */
        /**
         * Format for points with the value of null. Works analogously to
         * [format](#plotOptions.series.dataLabels.format). `nullFormat` can
         * be applied only to series which support displaying null points.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
         *         Format data label and tooltip for null point.
         *
         * @type      {boolean|string}
         * @since     7.1.0
         * @apioption plotOptions.series.dataLabels.nullFormat
         */
        /**
         * Callback JavaScript function that defines formatting for points
         * with the value of null. Works analogously to
         * [formatter](#plotOptions.series.dataLabels.formatter).
         * `nullPointFormatter` can be applied only to series which support
         * displaying null points.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
         *         Format data label and tooltip for null point.
         *
         * @type      {Highcharts.DataLabelsFormatterCallbackFunction}
         * @since     7.1.0
         * @apioption plotOptions.series.dataLabels.nullFormatter
         */
        /**
         * How to handle data labels that flow outside the plot area. The
         * default is `"justify"`, which aligns them inside the plot area.
         * For columns and bars, this means it will be moved inside the bar.
         * To display data labels outside the plot area, set `crop` to
         * `false` and `overflow` to `"allow"`.
         *
         * @type       {Highcharts.DataLabelsOverflowValue}
         * @default    justify
         * @since      3.0.6
         * @apioption  plotOptions.series.dataLabels.overflow
         */
        /**
         * When either the `borderWidth` or the `backgroundColor` is set,
         * this is the padding within the box.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
         *         Data labels box options
         * @sample {highmaps} maps/plotoptions/series-datalabels-box/
         *         Data labels box options
         *
         * @since 2.2.1
         */
        padding: 5,
        /**
         * Aligns data labels relative to points. If `center` alignment is
         * not possible, it defaults to `right`.
         *
         * @type      {Highcharts.AlignValue}
         * @default   center
         * @apioption plotOptions.series.dataLabels.position
         */
        /**
         * Text rotation in degrees. Note that due to a more complex
         * structure, backgrounds, borders and padding will be lost on a
         * rotated data label.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
         *         Vertical labels
         *
         * @type      {number}
         * @default   0
         * @apioption plotOptions.series.dataLabels.rotation
         */
        /**
         * The shadow of the box. Works best with `borderWidth` or
         * `backgroundColor`. Since 2.3 the shadow can be an object
         * configuration containing `color`, `offsetX`, `offsetY`, `opacity`
         * and `width`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
         *         Data labels box options
         *
         * @type      {boolean|Highcharts.ShadowOptionsObject}
         * @default   false
         * @since     2.2.1
         * @apioption plotOptions.series.dataLabels.shadow
         */
        /**
         * The name of a symbol to use for the border around the label.
         * Symbols are predefined functions on the Renderer object.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-shape/
         *         A callout for annotations
         *
         * @type      {string}
         * @default   square
         * @since     4.1.2
         * @apioption plotOptions.series.dataLabels.shape
         */
        /**
         * Styles for the label. The default `color` setting is
         * `"contrast"`, which is a pseudo color that Highcharts picks up
         * and applies the maximum contrast to the underlying point item,
         * for example the bar in a bar chart.
         *
         * The `textOutline` is a pseudo property that applies an outline of
         * the given width with the given color, which by default is the
         * maximum contrast to the text. So a bright text color will result
         * in a black text outline for maximum readability on a mixed
         * background. In some cases, especially with grayscale text, the
         * text outline doesn't work well, in which cases it can be disabled
         * by setting it to `"none"`. When `useHTML` is true, the
         * `textOutline` will not be picked up. In this, case, the same
         * effect can be acheived through the `text-shadow` CSS property.
         *
         * For some series types, where each point has an extent, like for
         * example tree maps, the data label may overflow the point. There
         * are two strategies for handling overflow. By default, the text
         * will wrap to multiple lines. The other strategy is to set
         * `style.textOverflow` to `ellipsis`, which will keep the text on
         * one line plus it will break inside long words.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-style/
         *         Bold labels
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow/
         *         Long labels truncated with an ellipsis in a pie
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow-wrap/
         *         Long labels are wrapped in a pie
         * @sample {highmaps} maps/demo/color-axis/
         *         Bold labels
         *
         * @type      {Highcharts.CSSObject}
         * @since     4.1.0
         * @apioption plotOptions.series.dataLabels.style
         */
        style: {
          /** @internal */
          fontSize: "11px",
          /** @internal */
          fontWeight: "bold",
          /** @internal */
          color: "contrast",
          /** @internal */
          textOutline: "1px contrast"
        },
        /**
         * Options for a label text which should follow marker's shape.
         * Border and background are disabled for a label that follows a
         * path.
         *
         * **Note:** Only SVG-based renderer supports this option. Setting
         * `useHTML` to true will disable this option.
         *
         * @declare   Highcharts.DataLabelsTextPathOptionsObject
         * @since     7.1.0
         * @apioption plotOptions.series.dataLabels.textPath
         */
        /**
         * Presentation attributes for the text path.
         *
         * @type      {Highcharts.SVGAttributes}
         * @since     7.1.0
         * @apioption plotOptions.series.dataLabels.textPath.attributes
         */
        /**
         * Enable or disable `textPath` option for link's or marker's data
         * labels.
         *
         * @type      {boolean}
         * @since     7.1.0
         * @apioption plotOptions.series.dataLabels.textPath.enabled
         */
        /**
         * Whether to
         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
         * to render the labels.
         *
         * @type      {boolean}
         * @default   false
         * @apioption plotOptions.series.dataLabels.useHTML
         */
        /**
         * The vertical alignment of a data label. Can be one of `top`,
         * `middle` or `bottom`. The default value depends on the data, for
         * instance in a column chart, the label is above positive values
         * and below negative values.
         *
         * @type  {Highcharts.VerticalAlignValue|null}
         * @since 2.3.3
         */
        verticalAlign: "bottom",
        /**
         * The x position offset of the label relative to the point in
         * pixels.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
         *         Vertical and positioned
         * @sample {highcharts} highcharts/plotoptions/bar-datalabels-align-inside-bar/
         *         Data labels inside the bar
         */
        x: 0,
        /**
         * The Z index of the data labels. The default Z index puts it above
         * the series. Use a Z index of 2 to display it behind the series.
         *
         * @type      {number}
         * @default   6
         * @since     2.3.5
         * @apioption plotOptions.series.dataLabels.z
         */
        /**
         * The y position offset of the label relative to the point in
         * pixels.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
         *         Vertical and positioned
         */
        y: 0
      },
      /**
       * When the series contains less points than the crop threshold, all
       * points are drawn, even if the points fall outside the visible plot
       * area at the current zoom. The advantage of drawing all points
       * (including markers and columns), is that animation is performed on
       * updates. On the other hand, when the series contains more points than
       * the crop threshold, the series data is cropped to only contain points
       * that fall within the plot area. The advantage of cropping away
       * invisible points is to increase performance on large series.
       *
       * @since   2.2
       * @product highcharts highstock
       *
       * @private
       */
      cropThreshold: 300,
      /**
       * Opacity of a series parts: line, fill (e.g. area) and dataLabels.
       *
       * @see [states.inactive.opacity](#plotOptions.series.states.inactive.opacity)
       *
       * @since 7.1.0
       *
       * @private
       */
      opacity: 1,
      /**
       * The width of each point on the x axis. For example in a column chart
       * with one value each day, the pointRange would be 1 day (= 24 * 3600
       * * 1000 milliseconds). This is normally computed automatically, but
       * this option can be used to override the automatic value.
       *
       * @product highstock
       *
       * @private
       */
      pointRange: 0,
      /**
       * When this is true, the series will not cause the Y axis to cross
       * the zero plane (or [threshold](#plotOptions.series.threshold) option)
       * unless the data actually crosses the plane.
       *
       * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
       * 3 will make the Y axis show negative values according to the
       * `minPadding` option. If `softThreshold` is `true`, the Y axis starts
       * at 0.
       *
       * @since   4.1.9
       * @product highcharts highstock
       *
       * @private
       */
      softThreshold: true,
      /**
       * @declare Highcharts.SeriesStatesOptionsObject
       *
       * @private
       */
      states: {
        /**
         * The normal state of a series, or for point items in column, pie
         * and similar series. Currently only used for setting animation
         * when returning to normal state from hover.
         *
         * @declare Highcharts.SeriesStatesNormalOptionsObject
         */
        normal: {
          /**
           * Animation when returning to normal state after hovering.
           *
               * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
           */
          animation: true
        },
        /**
         * Options for the hovered series. These settings override the
         * normal state options when a series is moused over or touched.
         *
         * @declare Highcharts.SeriesStatesHoverOptionsObject
         */
        hover: {
          /**
           * Enable separate styles for the hovered series to visualize
           * that the user hovers either the series itself or the legend.
           *
           * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled/
           *         Line
           * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-column/
           *         Column
           * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-pie/
           *         Pie
           *
           * @type      {boolean}
           * @default   true
           * @since     1.2
           * @apioption plotOptions.series.states.hover.enabled
           */
          /**
           * Animation setting for hovering the graph in line-type series.
           *
           * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
           * @since   5.0.8
           * @product highcharts highstock
           */
          animation: {
            /**
             * The duration of the hover animation in milliseconds. By
             * default the hover state animates quickly in, and slowly
             * back to normal.
             *
             * @internal
             */
            duration: 50
          },
          /**
           * Pixel width of the graph line. By default this property is
           * undefined, and the `lineWidthPlus` property dictates how much
           * to increase the linewidth from normal state.
           *
           * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidth/
           *         5px line on hover
           *
           * @type      {number}
           * @product   highcharts highstock
           * @apioption plotOptions.series.states.hover.lineWidth
           */
          /**
           * The additional line width for the graph of a hovered series.
           *
           * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
           *         5 pixels wider
           * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
           *         5 pixels wider
           *
           * @since   4.0.3
           * @product highcharts highstock
           */
          lineWidthPlus: 1,
          /**
           * In Highcharts 1.0, the appearance of all markers belonging
           * to the hovered series. For settings on the hover state of the
           * individual point, see
           * [marker.states.hover](#plotOptions.series.marker.states.hover).
           *
           * @deprecated
           *
           * @extends   plotOptions.series.marker
           * @excluding states
           * @product   highcharts highstock
           */
          marker: {
            // lineWidth: base + 1,
            // radius: base + 1
          },
          /**
           * Options for the halo appearing around the hovered point in
           * line-type series as well as outside the hovered slice in pie
           * charts. By default the halo is filled by the current point or
           * series color with an opacity of 0.25\. The halo can be
           * disabled by setting the `halo` option to `null`.
           *
           * In styled mode, the halo is styled with the
           * `.highcharts-halo` class, with colors inherited from
           * `.highcharts-color-{n}`.
           *
           * @sample {highcharts} highcharts/plotoptions/halo/
           *         Halo options
           * @sample {highstock} highcharts/plotoptions/halo/
           *         Halo options
           *
           * @declare Highcharts.SeriesStatesHoverHaloOptionsObject
           * @type    {null|*}
           * @since   4.0
           * @product highcharts highstock
           */
          halo: {
            /**
             * A collection of SVG attributes to override the appearance
             * of the halo, for example `fill`, `stroke` and
             * `stroke-width`.
             *
             * @type      {Highcharts.SVGAttributes}
             * @since     4.0
             * @product   highcharts highstock
             * @apioption plotOptions.series.states.hover.halo.attributes
             */
            /**
             * The pixel size of the halo. For point markers this is the
             * radius of the halo. For pie slices it is the width of the
             * halo outside the slice. For bubbles it defaults to 5 and
             * is the width of the halo outside the bubble.
             *
             * @since   4.0
             * @product highcharts highstock
             */
            size: 10,
            /**
             * Opacity for the halo unless a specific fill is overridden
             * using the `attributes` setting. Note that Highcharts is
             * only able to apply opacity to colors of hex or rgb(a)
             * formats.
             *
             * @since   4.0
             * @product highcharts highstock
             */
            opacity: 0.25
          }
        },
        /**
         * Specific options for point in selected states, after being
         * selected by
         * [allowPointSelect](#plotOptions.series.allowPointSelect)
         * or programmatically.
         *
         * @sample maps/plotoptions/series-allowpointselect/
         *         Allow point select demo
         *
         * @declare   Highcharts.SeriesStatesSelectOptionsObject
         * @extends   plotOptions.series.states.hover
         * @excluding brightness
         */
        select: {
          animation: {
            /** @internal */
            duration: 0
          }
        },
        /**
         * The opposite state of a hover for series.
         *
         * @sample highcharts/plotoptions/series-states-inactive-disabled
         *         Disabled inactive state
         *
         * @declare Highcharts.SeriesStatesInactiveOptionsObject
         */
        inactive: {
          /**
           * Enable or disable the inactive state for a series
           *
           * @sample highcharts/plotoptions/series-states-inactive-disabled
           *         Disabled inactive state
           *
           * @type {boolean}
           * @default true
           * @apioption plotOptions.series.states.inactive.enabled
           */
          /**
           * The animation for entering the inactive state.
           *
           * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
           */
          animation: {
            /** @internal */
            duration: 50
          },
          /**
           * Opacity of series elements (dataLabels, line, area).
           *
           * @type {number}
           */
          opacity: 0.2
        }
      },
      /**
       * Sticky tracking of mouse events. When true, the `mouseOut` event on a
       * series isn't triggered until the mouse moves over another series, or
       * out of the plot area. When false, the `mouseOut` event on a series is
       * triggered when the mouse leaves the area around the series' graph or
       * markers. This also implies the tooltip when not shared. When
       * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
       * will be hidden when moving the mouse between series. Defaults to true
       * for line and area type series, but to false for columns, pies etc.
       *
       * **Note:** The boost module will force this option because of
       * technical limitations.
       *
       * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/
       *         True by default
       * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/
       *         False
       *
       * @default {highcharts} true
       * @default {highstock} true
       * @default {highmaps} false
       * @since   2.0
       *
       * @private
       */
      stickyTracking: true,
      /**
       * A configuration object for the tooltip rendering of each single
       * series. Properties are inherited from [tooltip](#tooltip), but only
       * the following properties can be defined on a series level.
       *
       * @declare   Highcharts.SeriesTooltipOptionsObject
       * @since     2.3
       * @extends   tooltip
       * @excluding animation, backgroundColor, borderColor, borderRadius,
       *            borderWidth, className, crosshairs, enabled, formatter,
       *            headerShape, hideDelay, outside, padding, positioner,
       *            shadow, shape, shared, snap, split, stickOnContact,
       *            style, useHTML
       * @apioption plotOptions.series.tooltip
       */
      /**
       * When a series contains a data array that is longer than this, only
       * one dimensional arrays of numbers, or two dimensional arrays with
       * x and y values are allowed. Also, only the first point is tested,
       * and the rest are assumed to be the same format. This saves expensive
       * data checking and indexing in long series. Set it to `0` disable.
       *
       * Note:
       * In boost mode turbo threshold is forced. Only array of numbers or
       * two dimensional arrays are allowed.
       *
       * @since   2.2
       * @product highcharts highstock gantt
       *
       * @private
       */
      turboThreshold: 1e3,
      /**
       * An array defining zones within a series. Zones can be applied to the
       * X axis, Y axis or Z axis for bubbles, according to the `zoneAxis`
       * option. The zone definitions have to be in ascending order regarding
       * to the value.
       *
       * In styled mode, the color zones are styled with the
       * `.highcharts-zone-{n}` class, or custom classed from the `className`
       * option
       * ([view live demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/color-zones/)).
       *
       * @see [zoneAxis](#plotOptions.series.zoneAxis)
       *
       * @sample {highcharts} highcharts/series/color-zones-simple/
       *         Color zones
       * @sample {highstock} highcharts/series/color-zones-simple/
       *         Color zones
       *
       * @declare   Highcharts.SeriesZonesOptionsObject
       * @type      {Array<*>}
       * @since     4.1.0
       * @product   highcharts highstock
       * @apioption plotOptions.series.zones
       */
      /**
       * Styled mode only. A custom class name for the zone.
       *
       * @sample highcharts/css/color-zones/
       *         Zones styled by class name
       *
       * @type      {string}
       * @since     5.0.0
       * @apioption plotOptions.series.zones.className
       */
      /**
       * Defines the color of the series.
       *
       * @see [series color](#plotOptions.series.color)
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since     4.1.0
       * @product   highcharts highstock
       * @apioption plotOptions.series.zones.color
       */
      /**
       * A name for the dash style to use for the graph.
       *
       * @see [plotOptions.series.dashStyle](#plotOptions.series.dashStyle)
       *
       * @sample {highcharts|highstock} highcharts/series/color-zones-dashstyle-dot/
       *         Dashed line indicates prognosis
       *
       * @type      {Highcharts.DashStyleValue}
       * @since     4.1.0
       * @product   highcharts highstock
       * @apioption plotOptions.series.zones.dashStyle
       */
      /**
       * Defines the fill color for the series (in area type series)
       *
       * @see [fillColor](#plotOptions.area.fillColor)
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since     4.1.0
       * @product   highcharts highstock
       * @apioption plotOptions.series.zones.fillColor
       */
      /**
       * The value up to where the zone extends, if undefined the zones
       * stretches to the last value in the series.
       *
       * @type      {number}
       * @since     4.1.0
       * @product   highcharts highstock
       * @apioption plotOptions.series.zones.value
       */
      /**
       * When using dual or multiple color axes, this number defines which
       * colorAxis the particular series is connected to. It refers to
       * either the
       * {@link #colorAxis.id|axis id}
       * or the index of the axis in the colorAxis array, with 0 being the
       * first. Set this option to false to prevent a series from connecting
       * to the default color axis.
       *
       * Since v7.2.0 the option can also be an axis id or an axis index
       * instead of a boolean flag.
       *
       * @sample highcharts/coloraxis/coloraxis-with-pie/
       *         Color axis with pie series
       * @sample highcharts/coloraxis/multiple-coloraxis/
       *         Multiple color axis
       *
       * @type      {number|string|boolean}
       * @default   0
       * @product   highcharts highstock highmaps
       * @apioption plotOptions.series.colorAxis
       */
      /**
       * Determines what data value should be used to calculate point color
       * if `colorAxis` is used. Requires to set `min` and `max` if some
       * custom point property is used or if approximation for data grouping
       * is set to `'sum'`.
       *
       * @sample highcharts/coloraxis/custom-color-key/
       *         Custom color key
       * @sample highcharts/coloraxis/changed-default-color-key/
       *         Changed default color key
       *
       * @type      {string}
       * @default   y
       * @since     7.2.0
       * @product   highcharts highstock highmaps
       * @apioption plotOptions.series.colorKey
       */
      /**
       * Determines whether the series should look for the nearest point
       * in both dimensions or just the x-dimension when hovering the series.
       * Defaults to `'xy'` for scatter series and `'x'` for most other
       * series. If the data has duplicate x-values, it is recommended to
       * set this to `'xy'` to allow hovering over all points.
       *
       * Applies only to series types using nearest neighbor search (not
       * direct hover) for tooltip.
       *
       * @sample {highcharts} highcharts/series/findnearestpointby/
       *         Different hover behaviors
       * @sample {highstock} highcharts/series/findnearestpointby/
       *         Different hover behaviors
       * @sample {highmaps} highcharts/series/findnearestpointby/
       *         Different hover behaviors
       *
       * @since      5.0.10
       * @validvalue ["x", "xy"]
       *
       * @private
       */
      findNearestPointBy: "x"
    };
    var animObject$6 = animationExports.animObject, setAnimation$2 = animationExports.setAnimation;
    var defaultOptions$a = DefaultOptions.defaultOptions;
    var registerEventOptions = exports$3.registerEventOptions;
    var hasTouch$2 = H.hasTouch, svg$2 = H.svg, win$7 = H.win;
    var seriesTypes$6 = SeriesRegistry$1.seriesTypes;
    var addEvent$S = Utilities.addEvent, arrayMax$7 = Utilities.arrayMax, arrayMin$6 = Utilities.arrayMin, clamp$e = Utilities.clamp, cleanRecursively = Utilities.cleanRecursively, correctFloat$a = Utilities.correctFloat, defined$G = Utilities.defined, erase$2 = Utilities.erase, error$4 = Utilities.error, extend$1c = Utilities.extend, find$f = Utilities.find, fireEvent$r = Utilities.fireEvent, getNestedProperty = Utilities.getNestedProperty, isArray$f = Utilities.isArray, isNumber$A = Utilities.isNumber, isString$4 = Utilities.isString, merge$18 = Utilities.merge, objectEach$m = Utilities.objectEach, pick$1f = Utilities.pick, removeEvent$5 = Utilities.removeEvent, splat$c = Utilities.splat, syncTimeout$2 = Utilities.syncTimeout;
    var Series$e = (
      /** @class */
      function() {
        function Series2() {
          this._i = void 0;
          this.chart = void 0;
          this.data = void 0;
          this.eventOptions = void 0;
          this.eventsToUnbind = void 0;
          this.index = void 0;
          this.linkedSeries = void 0;
          this.options = void 0;
          this.points = void 0;
          this.processedXData = void 0;
          this.processedYData = void 0;
          this.tooltipOptions = void 0;
          this.userOptions = void 0;
          this.xAxis = void 0;
          this.yAxis = void 0;
          this.zones = void 0;
        }
        Series2.prototype.init = function(chart, userOptions) {
          fireEvent$r(this, "init", { options: userOptions });
          var series = this, chartSeries = chart.series;
          this.eventsToUnbind = [];
          series.chart = chart;
          series.options = series.setOptions(userOptions);
          var options = series.options;
          series.linkedSeries = [];
          series.bindAxes();
          extend$1c(series, {
            /**
             * The series name as given in the options. Defaults to
             * "Series {n}".
             *
             * @name Highcharts.Series#name
             * @type {string}
             */
            name: options.name,
            state: "",
            /**
             * Read only. The series' visibility state as set by {@link
             * Series#show}, {@link Series#hide}, or in the initial
             * configuration.
             *
             * @name Highcharts.Series#visible
             * @type {boolean}
             */
            visible: options.visible !== false,
            /**
             * Read only. The series' selected state as set by {@link
             * Highcharts.Series#select}.
             *
             * @name Highcharts.Series#selected
             * @type {boolean}
             */
            selected: options.selected === true
            // false by default
          });
          registerEventOptions(this, options);
          var events = options.events;
          if (events && events.click || options.point && options.point.events && options.point.events.click || options.allowPointSelect) {
            chart.runTrackerClick = true;
          }
          series.getColor();
          series.getSymbol();
          series.parallelArrays.forEach(function(key) {
            if (!series[key + "Data"]) {
              series[key + "Data"] = [];
            }
          });
          if (series.isCartesian) {
            chart.hasCartesianSeries = true;
          }
          var lastSeries;
          if (chartSeries.length) {
            lastSeries = chartSeries[chartSeries.length - 1];
          }
          series._i = pick$1f(lastSeries && lastSeries._i, -1) + 1;
          series.opacity = series.options.opacity;
          chart.orderSeries(this.insert(chartSeries));
          if (options.dataSorting && options.dataSorting.enabled) {
            series.setDataSortingOptions();
          } else if (!series.points && !series.data) {
            series.setData(options.data, false);
          }
          fireEvent$r(this, "afterInit");
        };
        Series2.prototype.is = function(type) {
          return seriesTypes$6[type] && this instanceof seriesTypes$6[type];
        };
        Series2.prototype.insert = function(collection) {
          var indexOption = this.options.index;
          var i;
          if (isNumber$A(indexOption)) {
            i = collection.length;
            while (i--) {
              if (indexOption >= pick$1f(collection[i].options.index, collection[i]._i)) {
                collection.splice(i + 1, 0, this);
                break;
              }
            }
            if (i === -1) {
              collection.unshift(this);
            }
            i = i + 1;
          } else {
            collection.push(this);
          }
          return pick$1f(i, collection.length - 1);
        };
        Series2.prototype.bindAxes = function() {
          var series = this, seriesOptions = series.options, chart = series.chart;
          var axisOptions;
          fireEvent$r(this, "bindAxes", null, function() {
            (series.axisTypes || []).forEach(function(AXIS) {
              var index = 0;
              chart[AXIS].forEach(function(axis) {
                axisOptions = axis.options;
                if (seriesOptions[AXIS] === index && !axisOptions.isInternal || typeof seriesOptions[AXIS] !== "undefined" && seriesOptions[AXIS] === axisOptions.id || typeof seriesOptions[AXIS] === "undefined" && axisOptions.index === 0) {
                  series.insert(axis.series);
                  series[AXIS] = axis;
                  axis.isDirty = true;
                }
                if (!axisOptions.isInternal) {
                  index++;
                }
              });
              if (!series[AXIS] && series.optionalAxis !== AXIS) {
                error$4(18, true, chart);
              }
            });
          });
          fireEvent$r(this, "afterBindAxes");
        };
        Series2.prototype.updateParallelArrays = function(point, i) {
          var series = point.series, args = arguments, fn = isNumber$A(i) ? (
            // Insert the value in the given position
            function(key) {
              var val = key === "y" && series.toYData ? series.toYData(point) : point[key];
              series[key + "Data"][i] = val;
            }
          ) : (
            // Apply the method specified in i with the following
            // arguments as arguments
            function(key) {
              Array.prototype[i].apply(series[key + "Data"], Array.prototype.slice.call(args, 2));
            }
          );
          series.parallelArrays.forEach(fn);
        };
        Series2.prototype.hasData = function() {
          return this.visible && typeof this.dataMax !== "undefined" && typeof this.dataMin !== "undefined" || // #3703
          this.visible && this.yData && this.yData.length > 0;
        };
        Series2.prototype.autoIncrement = function(x) {
          var options = this.options, pointIntervalUnit = options.pointIntervalUnit, relativeXValue = options.relativeXValue, time = this.chart.time;
          var xIncrement = this.xIncrement, date, pointInterval;
          xIncrement = pick$1f(xIncrement, options.pointStart, 0);
          this.pointInterval = pointInterval = pick$1f(this.pointInterval, options.pointInterval, 1);
          if (relativeXValue && isNumber$A(x)) {
            pointInterval *= x;
          }
          if (pointIntervalUnit) {
            date = new time.Date(xIncrement);
            if (pointIntervalUnit === "day") {
              time.set("Date", date, time.get("Date", date) + pointInterval);
            } else if (pointIntervalUnit === "month") {
              time.set("Month", date, time.get("Month", date) + pointInterval);
            } else if (pointIntervalUnit === "year") {
              time.set("FullYear", date, time.get("FullYear", date) + pointInterval);
            }
            pointInterval = date.getTime() - xIncrement;
          }
          if (relativeXValue && isNumber$A(x)) {
            return xIncrement + pointInterval;
          }
          this.xIncrement = xIncrement + pointInterval;
          return xIncrement;
        };
        Series2.prototype.setDataSortingOptions = function() {
          var options = this.options;
          extend$1c(this, {
            requireSorting: false,
            sorted: false,
            enabledDataSorting: true,
            allowDG: false
          });
          if (!defined$G(options.pointRange)) {
            options.pointRange = 1;
          }
        };
        Series2.prototype.setOptions = function(itemOptions) {
          var chart = this.chart, chartOptions = chart.options, plotOptions = chartOptions.plotOptions, userOptions = chart.userOptions || {}, seriesUserOptions = merge$18(itemOptions), styledMode = chart.styledMode, e2 = {
            plotOptions,
            userOptions: seriesUserOptions
          };
          var zone;
          fireEvent$r(this, "setOptions", e2);
          var typeOptions = e2.plotOptions[this.type], userPlotOptions = userOptions.plotOptions || {};
          this.userOptions = e2.userOptions;
          var options = merge$18(
            typeOptions,
            plotOptions.series,
            // #3881, chart instance plotOptions[type] should trump
            // plotOptions.series
            userOptions.plotOptions && userOptions.plotOptions[this.type],
            seriesUserOptions
          );
          this.tooltipOptions = merge$18(
            defaultOptions$a.tooltip,
            // 1
            defaultOptions$a.plotOptions.series && defaultOptions$a.plotOptions.series.tooltip,
            // 2
            defaultOptions$a.plotOptions[this.type].tooltip,
            // 3
            chartOptions.tooltip.userOptions,
            // 4
            plotOptions.series && plotOptions.series.tooltip,
            // 5
            plotOptions[this.type].tooltip,
            // 6
            seriesUserOptions.tooltip
            // 7
          );
          this.stickyTracking = pick$1f(seriesUserOptions.stickyTracking, userPlotOptions[this.type] && userPlotOptions[this.type].stickyTracking, userPlotOptions.series && userPlotOptions.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : options.stickyTracking);
          if (typeOptions.marker === null) {
            delete options.marker;
          }
          this.zoneAxis = options.zoneAxis;
          var zones = this.zones = (options.zones || []).slice();
          if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
            zone = {
              value: options[this.zoneAxis + "Threshold"] || options.threshold || 0,
              className: "highcharts-negative"
            };
            if (!styledMode) {
              zone.color = options.negativeColor;
              zone.fillColor = options.negativeFillColor;
            }
            zones.push(zone);
          }
          if (zones.length) {
            if (defined$G(zones[zones.length - 1].value)) {
              zones.push(styledMode ? {} : {
                color: this.color,
                fillColor: this.fillColor
              });
            }
          }
          fireEvent$r(this, "afterSetOptions", { options });
          return options;
        };
        Series2.prototype.getName = function() {
          return pick$1f(this.options.name, "Series " + (this.index + 1));
        };
        Series2.prototype.getCyclic = function(prop, value, defaults) {
          var chart = this.chart, userOptions = this.userOptions, indexName = prop + "Index", counterName = prop + "Counter", len = defaults ? defaults.length : pick$1f(chart.options.chart[prop + "Count"], chart[prop + "Count"]);
          var i, setting;
          if (!value) {
            setting = pick$1f(userOptions[indexName], userOptions["_" + indexName]);
            if (defined$G(setting)) {
              i = setting;
            } else {
              if (!chart.series.length) {
                chart[counterName] = 0;
              }
              userOptions["_" + indexName] = i = chart[counterName] % len;
              chart[counterName] += 1;
            }
            if (defaults) {
              value = defaults[i];
            }
          }
          if (typeof i !== "undefined") {
            this[indexName] = i;
          }
          this[prop] = value;
        };
        Series2.prototype.getColor = function() {
          if (this.chart.styledMode) {
            this.getCyclic("color");
          } else if (this.options.colorByPoint) {
            this.color = palette.neutralColor20;
          } else {
            this.getCyclic("color", this.options.color || defaultOptions$a.plotOptions[this.type].color, this.chart.options.colors);
          }
        };
        Series2.prototype.getPointsCollection = function() {
          return (this.hasGroupedData ? this.points : this.data) || [];
        };
        Series2.prototype.getSymbol = function() {
          var seriesMarkerOption = this.options.marker;
          this.getCyclic("symbol", seriesMarkerOption.symbol, this.chart.options.symbols);
        };
        Series2.prototype.findPointIndex = function(optionsObject, fromIndex) {
          var id = optionsObject.id, x = optionsObject.x, oldData = this.points, dataSorting = this.options.dataSorting;
          var matchingPoint, matchedById, pointIndex;
          if (id) {
            var item2 = this.chart.get(id);
            if (item2 instanceof Point$2) {
              matchingPoint = item2;
            }
          } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
            var matcher = function(oldPoint) {
              return !oldPoint.touched && oldPoint.index === optionsObject.index;
            };
            if (dataSorting && dataSorting.matchByName) {
              matcher = function(oldPoint) {
                return !oldPoint.touched && oldPoint.name === optionsObject.name;
              };
            } else if (this.options.relativeXValue) {
              matcher = function(oldPoint) {
                return !oldPoint.touched && oldPoint.options.x === optionsObject.x;
              };
            }
            matchingPoint = find$f(oldData, matcher);
            if (!matchingPoint) {
              return void 0;
            }
          }
          if (matchingPoint) {
            pointIndex = matchingPoint && matchingPoint.index;
            if (typeof pointIndex !== "undefined") {
              matchedById = true;
            }
          }
          if (typeof pointIndex === "undefined" && isNumber$A(x)) {
            pointIndex = this.xData.indexOf(x, fromIndex);
          }
          if (pointIndex !== -1 && typeof pointIndex !== "undefined" && this.cropped) {
            pointIndex = pointIndex >= this.cropStart ? pointIndex - this.cropStart : pointIndex;
          }
          if (!matchedById && isNumber$A(pointIndex) && oldData[pointIndex] && oldData[pointIndex].touched) {
            pointIndex = void 0;
          }
          return pointIndex;
        };
        Series2.prototype.updateData = function(data, animation) {
          var options = this.options, dataSorting = options.dataSorting, oldData = this.points, pointsToAdd = [], requireSorting = this.requireSorting, equalLength = data.length === oldData.length;
          var hasUpdatedByKey, i, point, lastIndex, succeeded = true;
          this.xIncrement = null;
          data.forEach(function(pointOptions, i2) {
            var optionsObject = defined$G(pointOptions) && this.pointClass.prototype.optionsToObject.call({ series: this }, pointOptions) || {};
            var pointIndex;
            var x = optionsObject.x, id = optionsObject.id;
            if (id || isNumber$A(x)) {
              pointIndex = this.findPointIndex(optionsObject, lastIndex);
              if (pointIndex === -1 || typeof pointIndex === "undefined") {
                pointsToAdd.push(pointOptions);
              } else if (oldData[pointIndex] && pointOptions !== options.data[pointIndex]) {
                oldData[pointIndex].update(pointOptions, false, null, false);
                oldData[pointIndex].touched = true;
                if (requireSorting) {
                  lastIndex = pointIndex + 1;
                }
              } else if (oldData[pointIndex]) {
                oldData[pointIndex].touched = true;
              }
              if (!equalLength || i2 !== pointIndex || dataSorting && dataSorting.enabled || this.hasDerivedData) {
                hasUpdatedByKey = true;
              }
            } else {
              pointsToAdd.push(pointOptions);
            }
          }, this);
          if (hasUpdatedByKey) {
            i = oldData.length;
            while (i--) {
              point = oldData[i];
              if (point && !point.touched && point.remove) {
                point.remove(false, animation);
              }
            }
          } else if (equalLength && (!dataSorting || !dataSorting.enabled)) {
            data.forEach(function(point2, i2) {
              if (point2 !== oldData[i2].y && oldData[i2].update) {
                oldData[i2].update(point2, false, null, false);
              }
            });
            pointsToAdd.length = 0;
          } else {
            succeeded = false;
          }
          oldData.forEach(function(point2) {
            if (point2) {
              point2.touched = false;
            }
          });
          if (!succeeded) {
            return false;
          }
          pointsToAdd.forEach(function(point2) {
            this.addPoint(point2, false, null, null, false);
          }, this);
          if (this.xIncrement === null && this.xData && this.xData.length) {
            this.xIncrement = arrayMax$7(this.xData);
            this.autoIncrement();
          }
          return true;
        };
        Series2.prototype.setData = function(data, redraw, animation, updatePoints) {
          var series = this, oldData = series.points, oldDataLength = oldData && oldData.length || 0, options = series.options, chart = series.chart, dataSorting = options.dataSorting, xAxis = series.xAxis, turboThreshold = options.turboThreshold, xData = this.xData, yData = this.yData, pointArrayMap = series.pointArrayMap, valueCount = pointArrayMap && pointArrayMap.length, keys2 = options.keys;
          var i, pt, updatedData, indexOfX = 0, indexOfY = 1, firstPoint = null;
          data = data || [];
          var dataLength = data.length;
          redraw = pick$1f(redraw, true);
          if (dataSorting && dataSorting.enabled) {
            data = this.sortData(data);
          }
          if (updatePoints !== false && dataLength && oldDataLength && !series.cropped && !series.hasGroupedData && series.visible && // Soft updating has no benefit in boost, and causes JS error
          // (#8355)
          !series.isSeriesBoosting) {
            updatedData = this.updateData(data, animation);
          }
          if (!updatedData) {
            series.xIncrement = null;
            series.colorCounter = 0;
            this.parallelArrays.forEach(function(key) {
              series[key + "Data"].length = 0;
            });
            if (turboThreshold && dataLength > turboThreshold) {
              firstPoint = series.getFirstValidPoint(data);
              if (isNumber$A(firstPoint)) {
                for (i = 0; i < dataLength; i++) {
                  xData[i] = this.autoIncrement();
                  yData[i] = data[i];
                }
              } else if (isArray$f(firstPoint)) {
                if (valueCount) {
                  for (i = 0; i < dataLength; i++) {
                    pt = data[i];
                    xData[i] = pt[0];
                    yData[i] = pt.slice(1, valueCount + 1);
                  }
                } else {
                  if (keys2) {
                    indexOfX = keys2.indexOf("x");
                    indexOfY = keys2.indexOf("y");
                    indexOfX = indexOfX >= 0 ? indexOfX : 0;
                    indexOfY = indexOfY >= 0 ? indexOfY : 1;
                  }
                  for (i = 0; i < dataLength; i++) {
                    pt = data[i];
                    xData[i] = pt[indexOfX];
                    yData[i] = pt[indexOfY];
                  }
                }
              } else {
                error$4(12, false, chart);
              }
            } else {
              for (i = 0; i < dataLength; i++) {
                if (typeof data[i] !== "undefined") {
                  pt = { series };
                  series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
                  series.updateParallelArrays(pt, i);
                }
              }
            }
            if (yData && isString$4(yData[0])) {
              error$4(14, true, chart);
            }
            series.data = [];
            series.options.data = series.userOptions.data = data;
            i = oldDataLength;
            while (i--) {
              if (oldData[i] && oldData[i].destroy) {
                oldData[i].destroy();
              }
            }
            if (xAxis) {
              xAxis.minRange = xAxis.userMinRange;
            }
            series.isDirty = chart.isDirtyBox = true;
            series.isDirtyData = !!oldData;
            animation = false;
          }
          if (options.legendType === "point") {
            this.processData();
            this.generatePoints();
          }
          if (redraw) {
            chart.redraw(animation);
          }
        };
        Series2.prototype.sortData = function(data) {
          var series = this, options = series.options, dataSorting = options.dataSorting, sortKey = dataSorting.sortKey || "y", getPointOptionsObject = function(series2, pointOptions) {
            return defined$G(pointOptions) && series2.pointClass.prototype.optionsToObject.call({
              series: series2
            }, pointOptions) || {};
          };
          data.forEach(function(pointOptions, i) {
            data[i] = getPointOptionsObject(series, pointOptions);
            data[i].index = i;
          }, this);
          var sortedData = data.concat().sort(function(a, b) {
            var aValue = getNestedProperty(sortKey, a);
            var bValue = getNestedProperty(sortKey, b);
            return bValue < aValue ? -1 : bValue > aValue ? 1 : 0;
          });
          sortedData.forEach(function(point, i) {
            point.x = i;
          }, this);
          if (series.linkedSeries) {
            series.linkedSeries.forEach(function(linkedSeries) {
              var options2 = linkedSeries.options, seriesData = options2.data;
              if ((!options2.dataSorting || !options2.dataSorting.enabled) && seriesData) {
                seriesData.forEach(function(pointOptions, i) {
                  seriesData[i] = getPointOptionsObject(linkedSeries, pointOptions);
                  if (data[i]) {
                    seriesData[i].x = data[i].x;
                    seriesData[i].index = i;
                  }
                });
                linkedSeries.setData(seriesData, false);
              }
            });
          }
          return data;
        };
        Series2.prototype.getProcessedData = function(forceExtremesFromAll) {
          var series = this, xAxis = series.xAxis, options = series.options, cropThreshold = options.cropThreshold, getExtremesFromAll = forceExtremesFromAll || series.getExtremesFromAll || options.getExtremesFromAll, isCartesian = series.isCartesian, val2lin = xAxis && xAxis.val2lin, isLog = !!(xAxis && xAxis.logarithmic);
          var croppedData, cropped, cropStart = 0, distance, closestPointRange, i, xExtremes, min, max, processedXData = series.xData, processedYData = series.yData, throwOnUnsorted = series.requireSorting, updatingNames = false;
          var dataLength = processedXData.length;
          if (xAxis) {
            xExtremes = xAxis.getExtremes();
            min = xExtremes.min;
            max = xExtremes.max;
            updatingNames = xAxis.categories && !xAxis.names.length;
          }
          if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
            if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
              processedXData = [];
              processedYData = [];
            } else if (series.yData && (processedXData[0] < min || processedXData[dataLength - 1] > max)) {
              croppedData = this.cropData(series.xData, series.yData, min, max);
              processedXData = croppedData.xData;
              processedYData = croppedData.yData;
              cropStart = croppedData.start;
              cropped = true;
            }
          }
          i = processedXData.length || 1;
          while (--i) {
            distance = isLog ? val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) : processedXData[i] - processedXData[i - 1];
            if (distance > 0 && (typeof closestPointRange === "undefined" || distance < closestPointRange)) {
              closestPointRange = distance;
            } else if (distance < 0 && throwOnUnsorted && !updatingNames) {
              error$4(15, false, series.chart);
              throwOnUnsorted = false;
            }
          }
          return {
            xData: processedXData,
            yData: processedYData,
            cropped,
            cropStart,
            closestPointRange
          };
        };
        Series2.prototype.processData = function(force) {
          var series = this, xAxis = series.xAxis;
          if (series.isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
            return false;
          }
          var processedData = series.getProcessedData();
          series.cropped = processedData.cropped;
          series.cropStart = processedData.cropStart;
          series.processedXData = processedData.xData;
          series.processedYData = processedData.yData;
          series.closestPointRange = series.basePointRange = processedData.closestPointRange;
        };
        Series2.prototype.cropData = function(xData, yData, min, max, cropShoulder) {
          var dataLength = xData.length;
          var i, j, cropStart = 0, cropEnd = dataLength;
          cropShoulder = pick$1f(cropShoulder, this.cropShoulder);
          for (i = 0; i < dataLength; i++) {
            if (xData[i] >= min) {
              cropStart = Math.max(0, i - cropShoulder);
              break;
            }
          }
          for (j = i; j < dataLength; j++) {
            if (xData[j] > max) {
              cropEnd = j + cropShoulder;
              break;
            }
          }
          return {
            xData: xData.slice(cropStart, cropEnd),
            yData: yData.slice(cropStart, cropEnd),
            start: cropStart,
            end: cropEnd
          };
        };
        Series2.prototype.generatePoints = function() {
          var series = this, options = series.options, dataOptions = options.data, processedXData = series.processedXData, processedYData = series.processedYData, PointClass = series.pointClass, processedDataLength = processedXData.length, cropStart = series.cropStart || 0, hasGroupedData = series.hasGroupedData, keys2 = options.keys, points = [], groupCropStartIndex = options.dataGrouping && options.dataGrouping.groupAll ? cropStart : 0;
          var dataLength, cursor, point, i, data = series.data;
          if (!data && !hasGroupedData) {
            var arr = [];
            arr.length = dataOptions.length;
            data = series.data = arr;
          }
          if (keys2 && hasGroupedData) {
            series.options.keys = false;
          }
          for (i = 0; i < processedDataLength; i++) {
            cursor = cropStart + i;
            if (!hasGroupedData) {
              point = data[cursor];
              if (!point && typeof dataOptions[cursor] !== "undefined") {
                data[cursor] = point = new PointClass().init(series, dataOptions[cursor], processedXData[i]);
              }
            } else {
              point = new PointClass().init(series, [processedXData[i]].concat(splat$c(processedYData[i])));
              point.dataGroup = series.groupMap[groupCropStartIndex + i];
              if (point.dataGroup.options) {
                point.options = point.dataGroup.options;
                extend$1c(point, point.dataGroup.options);
                delete point.dataLabels;
              }
            }
            if (point) {
              point.index = hasGroupedData ? groupCropStartIndex + i : cursor;
              points[i] = point;
            }
          }
          series.options.keys = keys2;
          if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
            for (i = 0; i < dataLength; i++) {
              if (i === cropStart && !hasGroupedData) {
                i += processedDataLength;
              }
              if (data[i]) {
                data[i].destroyElements();
                data[i].plotX = void 0;
              }
            }
          }
          series.data = data;
          series.points = points;
          fireEvent$r(this, "afterGeneratePoints");
        };
        Series2.prototype.getXExtremes = function(xData) {
          return {
            min: arrayMin$6(xData),
            max: arrayMax$7(xData)
          };
        };
        Series2.prototype.getExtremes = function(yData, forceExtremesFromAll) {
          var xAxis = this.xAxis, yAxis = this.yAxis, xData = this.processedXData || this.xData, activeYData = [], shoulder = this.requireSorting ? this.cropShoulder : 0, positiveValuesOnly = yAxis ? yAxis.positiveValuesOnly : false;
          var xExtremes, validValue, withinRange, x, y, i, j, xMin = 0, xMax = 0, activeCounter = 0;
          yData = yData || this.stackedYData || this.processedYData || [];
          var yDataLength = yData.length;
          if (xAxis) {
            xExtremes = xAxis.getExtremes();
            xMin = xExtremes.min;
            xMax = xExtremes.max;
          }
          for (i = 0; i < yDataLength; i++) {
            x = xData[i];
            y = yData[i];
            validValue = (isNumber$A(y) || isArray$f(y)) && (y.length || y > 0 || !positiveValuesOnly);
            withinRange = forceExtremesFromAll || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !xAxis || // for colorAxis support
            (xData[i + shoulder] || x) >= xMin && (xData[i - shoulder] || x) <= xMax;
            if (validValue && withinRange) {
              j = y.length;
              if (j) {
                while (j--) {
                  if (isNumber$A(y[j])) {
                    activeYData[activeCounter++] = y[j];
                  }
                }
              } else {
                activeYData[activeCounter++] = y;
              }
            }
          }
          var dataExtremes = {
            dataMin: arrayMin$6(activeYData),
            dataMax: arrayMax$7(activeYData)
          };
          fireEvent$r(this, "afterGetExtremes", { dataExtremes });
          return dataExtremes;
        };
        Series2.prototype.applyExtremes = function() {
          var dataExtremes = this.getExtremes();
          this.dataMin = dataExtremes.dataMin;
          this.dataMax = dataExtremes.dataMax;
          return dataExtremes;
        };
        Series2.prototype.getFirstValidPoint = function(data) {
          var dataLength = data.length;
          var i = 0, firstPoint = null;
          while (firstPoint === null && i < dataLength) {
            firstPoint = data[i];
            i++;
          }
          return firstPoint;
        };
        Series2.prototype.translate = function() {
          if (!this.processedXData) {
            this.processData();
          }
          this.generatePoints();
          var series = this, options = series.options, stacking = options.stacking, xAxis = series.xAxis, categories = xAxis.categories, enabledDataSorting = series.enabledDataSorting, yAxis = series.yAxis, points = series.points, dataLength = points.length, hasModifyValue = !!series.modifyValue, pointPlacement = series.pointPlacementToXValue(), dynamicallyPlaced = Boolean(pointPlacement), threshold = options.threshold, stackThreshold = options.startFromThreshold ? threshold : 0, zoneAxis = this.zoneAxis || "y";
          var i, plotX, lastPlotX, stackIndicator, closestPointRangePx = Number.MAX_VALUE;
          function limitedRange(val) {
            return clamp$e(val, -1e5, 1e5);
          }
          for (i = 0; i < dataLength; i++) {
            var point = points[i], xValue = point.x;
            var pointStack = void 0, stackValues = void 0, yValue = point.y, yBottom = point.low;
            var stack = stacking && yAxis.stacking && yAxis.stacking.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? "-" : "") + series.stackKey];
            if (yAxis.positiveValuesOnly && !yAxis.validatePositiveValue(yValue) || xAxis.positiveValuesOnly && !xAxis.validatePositiveValue(xValue)) {
              point.isNull = true;
            }
            point.plotX = plotX = correctFloat$a(
              // #5236
              limitedRange(xAxis.translate(
                // #3923
                xValue,
                0,
                0,
                0,
                1,
                pointPlacement,
                this.type === "flags"
              ))
              // #3923
            );
            if (stacking && series.visible && stack && stack[xValue]) {
              stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
              if (!point.isNull) {
                pointStack = stack[xValue];
                stackValues = pointStack.points[stackIndicator.key];
              }
            }
            if (isArray$f(stackValues)) {
              yBottom = stackValues[0];
              yValue = stackValues[1];
              if (yBottom === stackThreshold && stackIndicator.key === stack[xValue].base) {
                yBottom = pick$1f(isNumber$A(threshold) && threshold, yAxis.min);
              }
              if (yAxis.positiveValuesOnly && yBottom <= 0) {
                yBottom = null;
              }
              point.total = point.stackTotal = pointStack.total;
              point.percentage = pointStack.total && point.y / pointStack.total * 100;
              point.stackY = yValue;
              if (!series.irregularWidths) {
                pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);
              }
            }
            point.yBottom = defined$G(yBottom) ? limitedRange(yAxis.translate(yBottom, 0, 1, 0, 1)) : null;
            if (hasModifyValue) {
              yValue = series.modifyValue(yValue, point);
            }
            point.plotY = void 0;
            if (isNumber$A(yValue)) {
              var translated = yAxis.translate(yValue, false, true, false, true);
              if (typeof translated !== "undefined") {
                point.plotY = limitedRange(translated);
              }
            }
            point.isInside = this.isPointInside(point);
            point.clientX = dynamicallyPlaced ? correctFloat$a(xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)) : plotX;
            point.negative = point[zoneAxis] < (options[zoneAxis + "Threshold"] || threshold || 0);
            point.category = categories && typeof categories[point.x] !== "undefined" ? categories[point.x] : point.x;
            if (!point.isNull && point.visible !== false) {
              if (typeof lastPlotX !== "undefined") {
                closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));
              }
              lastPlotX = plotX;
            }
            point.zone = this.zones.length && point.getZone();
            if (!point.graphic && series.group && enabledDataSorting) {
              point.isNew = true;
            }
          }
          series.closestPointRangePx = closestPointRangePx;
          fireEvent$r(this, "afterTranslate");
        };
        Series2.prototype.getValidPoints = function(points, insideOnly, allowNull) {
          var chart = this.chart;
          return (points || this.points || []).filter(function(point) {
            if (insideOnly && !chart.isInsidePlot(point.plotX, point.plotY, { inverted: chart.inverted })) {
              return false;
            }
            return point.visible !== false && (allowNull || !point.isNull);
          });
        };
        Series2.prototype.getClipBox = function(animation, finalBox) {
          var series = this, options = series.options, chart = series.chart, inverted = chart.inverted, xAxis = series.xAxis, yAxis = xAxis && series.yAxis, scrollablePlotAreaOptions = chart.options.chart.scrollablePlotArea || {};
          var clipBox;
          if (animation && options.clip === false && yAxis) {
            clipBox = inverted ? {
              y: -chart.chartWidth + yAxis.len + yAxis.pos,
              height: chart.chartWidth,
              width: chart.chartHeight,
              x: -chart.chartHeight + xAxis.len + xAxis.pos
            } : {
              y: -yAxis.pos,
              height: chart.chartHeight,
              width: chart.chartWidth,
              x: -xAxis.pos
            };
          } else {
            clipBox = series.clipBox || chart.clipBox;
            if (finalBox) {
              clipBox.width = chart.plotSizeX;
              clipBox.x = (chart.scrollablePixelsX || 0) * (scrollablePlotAreaOptions.scrollPositionX || 0);
            }
          }
          return !finalBox ? clipBox : {
            width: clipBox.width,
            x: clipBox.x
          };
        };
        Series2.prototype.getSharedClipKey = function(animation) {
          if (this.sharedClipKey) {
            return this.sharedClipKey;
          }
          var sharedClipKey = [
            animation && animation.duration,
            animation && animation.easing,
            animation && animation.defer,
            this.getClipBox(animation).height,
            this.options.xAxis,
            this.options.yAxis
          ].join(",");
          if (this.options.clip !== false || animation) {
            this.sharedClipKey = sharedClipKey;
          }
          return sharedClipKey;
        };
        Series2.prototype.setClip = function(animation) {
          var chart = this.chart, options = this.options, renderer = chart.renderer, inverted = chart.inverted, seriesClipBox = this.clipBox, clipBox = this.getClipBox(animation), sharedClipKey = this.getSharedClipKey(animation);
          var clipRect = chart.sharedClips[sharedClipKey], markerClipRect = chart.sharedClips[sharedClipKey + "m"];
          if (animation) {
            clipBox.width = 0;
            if (inverted) {
              clipBox.x = chart.plotHeight + (options.clip !== false ? 0 : chart.plotTop);
            }
          }
          if (!clipRect) {
            if (animation) {
              chart.sharedClips[sharedClipKey + "m"] = markerClipRect = renderer.clipRect(
                // include the width of the first marker
                inverted ? (chart.plotSizeX || 0) + 99 : -99,
                inverted ? -chart.plotLeft : -chart.plotTop,
                99,
                inverted ? chart.chartWidth : chart.chartHeight
              );
            }
            chart.sharedClips[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
            clipRect.count = { length: 0 };
          } else if (!chart.hasLoaded) {
            clipRect.attr(clipBox);
          }
          if (animation) {
            if (!clipRect.count[this.index]) {
              clipRect.count[this.index] = true;
              clipRect.count.length += 1;
            }
          }
          if (options.clip !== false || animation) {
            this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
            this.markerGroup.clip(markerClipRect);
          }
          if (!animation) {
            if (clipRect.count[this.index]) {
              delete clipRect.count[this.index];
              clipRect.count.length -= 1;
            }
            if (clipRect.count.length === 0) {
              if (!seriesClipBox) {
                chart.sharedClips[sharedClipKey] = clipRect.destroy();
              }
              if (markerClipRect) {
                chart.sharedClips[sharedClipKey + "m"] = markerClipRect.destroy();
              }
            }
          }
        };
        Series2.prototype.animate = function(init) {
          var series = this, chart = series.chart, animation = animObject$6(series.options.animation), sharedClipKey = this.sharedClipKey;
          if (init) {
            series.setClip(animation);
          } else if (sharedClipKey) {
            var clipRect = chart.sharedClips[sharedClipKey];
            var markerClipRect = chart.sharedClips[sharedClipKey + "m"];
            var finalBox = series.getClipBox(animation, true);
            if (clipRect) {
              clipRect.animate(finalBox, animation);
            }
            if (markerClipRect) {
              markerClipRect.animate({
                width: finalBox.width + 99,
                x: finalBox.x - (chart.inverted ? 0 : 99)
              }, animation);
            }
          }
        };
        Series2.prototype.afterAnimate = function() {
          this.setClip();
          fireEvent$r(this, "afterAnimate");
          this.finishedAnimating = true;
        };
        Series2.prototype.drawPoints = function() {
          var series = this, points = series.points, chart = series.chart, options = series.options, seriesMarkerOptions = options.marker, markerGroup = series[series.specialGroup] || series.markerGroup, xAxis = series.xAxis, globallyEnabled = pick$1f(
            seriesMarkerOptions.enabled,
            !xAxis || xAxis.isRadial ? true : null,
            // Use larger or equal as radius is null in bubbles (#6321)
            series.closestPointRangePx >= seriesMarkerOptions.enabledThreshold * seriesMarkerOptions.radius
          );
          var i, point, graphic, verb, pointMarkerOptions, hasPointMarker, markerAttribs;
          if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {
            for (i = 0; i < points.length; i++) {
              point = points[i];
              graphic = point.graphic;
              verb = graphic ? "animate" : "attr";
              pointMarkerOptions = point.marker || {};
              hasPointMarker = !!point.marker;
              var shouldDrawMarker = (globallyEnabled && typeof pointMarkerOptions.enabled === "undefined" || pointMarkerOptions.enabled) && !point.isNull && point.visible !== false;
              if (shouldDrawMarker) {
                var symbol = pick$1f(pointMarkerOptions.symbol, series.symbol, "rect");
                markerAttribs = series.markerAttribs(point, point.selected && "select");
                if (series.enabledDataSorting) {
                  point.startXPos = xAxis.reversed ? -(markerAttribs.width || 0) : xAxis.width;
                }
                var isInside = point.isInside !== false;
                if (graphic) {
                  graphic[isInside ? "show" : "hide"](isInside).animate(markerAttribs);
                } else if (isInside && ((markerAttribs.width || 0) > 0 || point.hasImage)) {
                  point.graphic = graphic = chart.renderer.symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ? pointMarkerOptions : seriesMarkerOptions).add(markerGroup);
                  if (series.enabledDataSorting && chart.hasRendered) {
                    graphic.attr({
                      x: point.startXPos
                    });
                    verb = "animate";
                  }
                }
                if (graphic && verb === "animate") {
                  graphic[isInside ? "show" : "hide"](isInside).animate(markerAttribs);
                }
                if (graphic && !chart.styledMode) {
                  graphic[verb](series.pointAttribs(point, point.selected && "select"));
                }
                if (graphic) {
                  graphic.addClass(point.getClassName(), true);
                }
              } else if (graphic) {
                point.graphic = graphic.destroy();
              }
            }
          }
        };
        Series2.prototype.markerAttribs = function(point, state) {
          var seriesOptions = this.options, seriesMarkerOptions = seriesOptions.marker, pointMarkerOptions = point.marker || {}, symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol;
          var seriesStateOptions, pointStateOptions, radius = pick$1f(pointMarkerOptions.radius, seriesMarkerOptions.radius);
          if (state) {
            seriesStateOptions = seriesMarkerOptions.states[state];
            pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state];
            radius = pick$1f(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0));
          }
          point.hasImage = symbol && symbol.indexOf("url") === 0;
          if (point.hasImage) {
            radius = 0;
          }
          var attribs = {
            // Math.floor for #1843:
            x: seriesOptions.crisp ? Math.floor(point.plotX - radius) : point.plotX - radius,
            y: point.plotY - radius
          };
          if (radius) {
            attribs.width = attribs.height = 2 * radius;
          }
          return attribs;
        };
        Series2.prototype.pointAttribs = function(point, state) {
          var seriesMarkerOptions = this.options.marker, pointOptions = point && point.options, pointMarkerOptions = pointOptions && pointOptions.marker || {}, pointColorOption = pointOptions && pointOptions.color, pointColor = point && point.color, zoneColor = point && point.zone && point.zone.color;
          var seriesStateOptions, pointStateOptions, color2 = this.color, fill, stroke, strokeWidth = pick$1f(pointMarkerOptions.lineWidth, seriesMarkerOptions.lineWidth), opacity = 1;
          color2 = pointColorOption || zoneColor || pointColor || color2;
          fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color2;
          stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color2;
          state = state || "normal";
          if (state) {
            seriesStateOptions = seriesMarkerOptions.states[state];
            pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
            strokeWidth = pick$1f(pointStateOptions.lineWidth, seriesStateOptions.lineWidth, strokeWidth + pick$1f(pointStateOptions.lineWidthPlus, seriesStateOptions.lineWidthPlus, 0));
            fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;
            stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;
            opacity = pick$1f(pointStateOptions.opacity, seriesStateOptions.opacity, opacity);
          }
          return {
            "stroke": stroke,
            "stroke-width": strokeWidth,
            "fill": fill,
            "opacity": opacity
          };
        };
        Series2.prototype.destroy = function(keepEventsForUpdate) {
          var series = this, chart = series.chart, issue134 = /AppleWebKit\/533/.test(win$7.navigator.userAgent), data = series.data || [];
          var destroy, i, point, axis;
          fireEvent$r(series, "destroy");
          this.removeEvents(keepEventsForUpdate);
          (series.axisTypes || []).forEach(function(AXIS) {
            axis = series[AXIS];
            if (axis && axis.series) {
              erase$2(axis.series, series);
              axis.isDirty = axis.forceRedraw = true;
            }
          });
          if (series.legendItem) {
            series.chart.legend.destroyItem(series);
          }
          i = data.length;
          while (i--) {
            point = data[i];
            if (point && point.destroy) {
              point.destroy();
            }
          }
          if (series.clips) {
            series.clips.forEach(function(clip) {
              return clip.destroy();
            });
          }
          Utilities.clearTimeout(series.animationTimeout);
          objectEach$m(series, function(val, prop) {
            if (val instanceof SVGElement && !val.survive) {
              destroy = issue134 && prop === "group" ? "hide" : "destroy";
              val[destroy]();
            }
          });
          if (chart.hoverSeries === series) {
            chart.hoverSeries = void 0;
          }
          erase$2(chart.series, series);
          chart.orderSeries();
          objectEach$m(series, function(val, prop) {
            if (!keepEventsForUpdate || prop !== "hcEvents") {
              delete series[prop];
            }
          });
        };
        Series2.prototype.applyZones = function() {
          var series = this, chart = this.chart, renderer = chart.renderer, zones = this.zones, clips = this.clips || [], graph = this.graph, area = this.area, chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight), axis = this[(this.zoneAxis || "y") + "Axis"], inverted = chart.inverted;
          var translatedFrom, translatedTo, clipAttr, extremes, reversed, horiz, pxRange, pxPosMin, pxPosMax, zoneArea, zoneGraph, ignoreZones = false;
          if (zones.length && (graph || area) && axis && typeof axis.min !== "undefined") {
            reversed = axis.reversed;
            horiz = axis.horiz;
            if (graph && !this.showLine) {
              graph.hide();
            }
            if (area) {
              area.hide();
            }
            extremes = axis.getExtremes();
            zones.forEach(function(threshold, i) {
              translatedFrom = reversed ? horiz ? chart.plotWidth : 0 : horiz ? 0 : axis.toPixels(extremes.min) || 0;
              translatedFrom = clamp$e(pick$1f(translatedTo, translatedFrom), 0, chartSizeMax);
              translatedTo = clamp$e(Math.round(axis.toPixels(pick$1f(threshold.value, extremes.max), true) || 0), 0, chartSizeMax);
              if (ignoreZones) {
                translatedFrom = translatedTo = axis.toPixels(extremes.max);
              }
              pxRange = Math.abs(translatedFrom - translatedTo);
              pxPosMin = Math.min(translatedFrom, translatedTo);
              pxPosMax = Math.max(translatedFrom, translatedTo);
              if (axis.isXAxis) {
                clipAttr = {
                  x: inverted ? pxPosMax : pxPosMin,
                  y: 0,
                  width: pxRange,
                  height: chartSizeMax
                };
                if (!horiz) {
                  clipAttr.x = chart.plotHeight - clipAttr.x;
                }
              } else {
                clipAttr = {
                  x: 0,
                  y: inverted ? pxPosMax : pxPosMin,
                  width: chartSizeMax,
                  height: pxRange
                };
                if (horiz) {
                  clipAttr.y = chart.plotWidth - clipAttr.y;
                }
              }
              if (inverted && renderer.isVML) {
                if (axis.isXAxis) {
                  clipAttr = {
                    x: 0,
                    y: reversed ? pxPosMin : pxPosMax,
                    height: clipAttr.width,
                    width: chart.chartWidth
                  };
                } else {
                  clipAttr = {
                    x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
                    y: 0,
                    width: clipAttr.height,
                    height: chart.chartHeight
                  };
                }
              }
              if (clips[i]) {
                clips[i].animate(clipAttr);
              } else {
                clips[i] = renderer.clipRect(clipAttr);
              }
              zoneArea = series["zone-area-" + i];
              zoneGraph = series["zone-graph-" + i];
              if (graph && zoneGraph) {
                zoneGraph.clip(clips[i]);
              }
              if (area && zoneArea) {
                zoneArea.clip(clips[i]);
              }
              ignoreZones = threshold.value > extremes.max;
              if (series.resetZones && translatedTo === 0) {
                translatedTo = void 0;
              }
            });
            this.clips = clips;
          } else if (series.visible) {
            if (graph) {
              graph.show(true);
            }
            if (area) {
              area.show(true);
            }
          }
        };
        Series2.prototype.invertGroups = function(inverted) {
          var series = this, chart = series.chart;
          function setInvert() {
            ["group", "markerGroup"].forEach(function(groupName) {
              if (series[groupName]) {
                if (chart.renderer.isVML) {
                  series[groupName].attr({
                    width: series.yAxis.len,
                    height: series.xAxis.len
                  });
                }
                series[groupName].width = series.yAxis.len;
                series[groupName].height = series.xAxis.len;
                series[groupName].invert(series.isRadialSeries ? false : inverted);
              }
            });
          }
          if (!series.xAxis) {
            return;
          }
          series.eventsToUnbind.push(addEvent$S(chart, "resize", setInvert));
          setInvert();
          series.invertGroups = setInvert;
        };
        Series2.prototype.plotGroup = function(prop, name, visibility, zIndex, parent) {
          var group = this[prop];
          var isNew = !group, attrs = {
            visibility,
            zIndex: zIndex || 0.1
            // IE8 and pointer logic use this
          };
          if (typeof this.opacity !== "undefined" && !this.chart.styledMode && this.state !== "inactive") {
            attrs.opacity = this.opacity;
          }
          if (isNew) {
            this[prop] = group = this.chart.renderer.g().add(parent);
          }
          group.addClass("highcharts-" + name + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (defined$G(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (group.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
          group.attr(attrs)[isNew ? "attr" : "animate"](this.getPlotBox());
          return group;
        };
        Series2.prototype.getPlotBox = function() {
          var chart = this.chart;
          var xAxis = this.xAxis, yAxis = this.yAxis;
          if (chart.inverted) {
            xAxis = yAxis;
            yAxis = this.xAxis;
          }
          return {
            translateX: xAxis ? xAxis.left : chart.plotLeft,
            translateY: yAxis ? yAxis.top : chart.plotTop,
            scaleX: 1,
            scaleY: 1
          };
        };
        Series2.prototype.removeEvents = function(keepEventsForUpdate) {
          var series = this;
          if (!keepEventsForUpdate) {
            removeEvent$5(series);
          }
          if (series.eventsToUnbind.length) {
            series.eventsToUnbind.forEach(function(unbind) {
              unbind();
            });
            series.eventsToUnbind.length = 0;
          }
        };
        Series2.prototype.render = function() {
          var series = this, chart = series.chart, options = series.options, animOptions = animObject$6(options.animation), visibility = series.visible ? "inherit" : "hidden", zIndex = options.zIndex, hasRendered = series.hasRendered, chartSeriesGroup = chart.seriesGroup, inverted = chart.inverted;
          var animDuration = !series.finishedAnimating && chart.renderer.isSVG && animOptions.duration;
          fireEvent$r(this, "render");
          var group = series.plotGroup("group", "series", visibility, zIndex, chartSeriesGroup);
          series.markerGroup = series.plotGroup("markerGroup", "markers", visibility, zIndex, chartSeriesGroup);
          if (animDuration && series.animate) {
            series.animate(true);
          }
          group.inverted = pick$1f(series.invertible, series.isCartesian) ? inverted : false;
          if (series.drawGraph) {
            series.drawGraph();
            series.applyZones();
          }
          if (series.visible) {
            series.drawPoints();
          }
          if (series.drawDataLabels) {
            series.drawDataLabels();
          }
          if (series.redrawPoints) {
            series.redrawPoints();
          }
          if (series.drawTracker && series.options.enableMouseTracking !== false) {
            series.drawTracker();
          }
          series.invertGroups(inverted);
          if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
            group.clip(chart.clipRect);
          }
          if (animDuration && series.animate) {
            series.animate();
          }
          if (!hasRendered) {
            if (animDuration && animOptions.defer) {
              animDuration += animOptions.defer;
            }
            series.animationTimeout = syncTimeout$2(function() {
              series.afterAnimate();
            }, animDuration || 0);
          }
          series.isDirty = false;
          series.hasRendered = true;
          fireEvent$r(series, "afterRender");
        };
        Series2.prototype.redraw = function() {
          var series = this, chart = series.chart, wasDirty = series.isDirty || series.isDirtyData, group = series.group, xAxis = series.xAxis, yAxis = series.yAxis;
          if (group) {
            if (chart.inverted) {
              group.attr({
                width: chart.plotWidth,
                height: chart.plotHeight
              });
            }
            group.animate({
              translateX: pick$1f(xAxis && xAxis.left, chart.plotLeft),
              translateY: pick$1f(yAxis && yAxis.top, chart.plotTop)
            });
          }
          series.translate();
          series.render();
          if (wasDirty) {
            delete this.kdTree;
          }
        };
        Series2.prototype.searchPoint = function(e2, compareX) {
          var series = this, xAxis = series.xAxis, yAxis = series.yAxis, inverted = series.chart.inverted;
          return this.searchKDTree({
            clientX: inverted ? xAxis.len - e2.chartY + xAxis.pos : e2.chartX - xAxis.pos,
            plotY: inverted ? yAxis.len - e2.chartX + yAxis.pos : e2.chartY - yAxis.pos
          }, compareX, e2);
        };
        Series2.prototype.buildKDTree = function(e2) {
          this.buildingKdTree = true;
          var series = this, dimensions = series.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
          function _kdtree(points, depth, dimensions2) {
            var length = points && points.length;
            var axis, median;
            if (length) {
              axis = series.kdAxisArray[depth % dimensions2];
              points.sort(function(a, b) {
                return a[axis] - b[axis];
              });
              median = Math.floor(length / 2);
              return {
                point: points[median],
                left: _kdtree(points.slice(0, median), depth + 1, dimensions2),
                right: _kdtree(points.slice(median + 1), depth + 1, dimensions2)
              };
            }
          }
          function startRecursive() {
            series.kdTree = _kdtree(series.getValidPoints(
              null,
              // For line-type series restrict to plot area, but
              // column-type series not (#3916, #4511)
              !series.directTouch
            ), dimensions, dimensions);
            series.buildingKdTree = false;
          }
          delete series.kdTree;
          syncTimeout$2(startRecursive, series.options.kdNow || e2 && e2.type === "touchstart" ? 0 : 1);
        };
        Series2.prototype.searchKDTree = function(point, compareX, e2) {
          var series = this, kdX = this.kdAxisArray[0], kdY = this.kdAxisArray[1], kdComparer = compareX ? "distX" : "dist", kdDimensions = series.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
          function setDistance(p1, p2) {
            var x = defined$G(p1[kdX]) && defined$G(p2[kdX]) ? Math.pow(p1[kdX] - p2[kdX], 2) : null, y = defined$G(p1[kdY]) && defined$G(p2[kdY]) ? Math.pow(p1[kdY] - p2[kdY], 2) : null, r = (x || 0) + (y || 0);
            p2.dist = defined$G(r) ? Math.sqrt(r) : Number.MAX_VALUE;
            p2.distX = defined$G(x) ? Math.sqrt(x) : Number.MAX_VALUE;
          }
          function _search(search, tree, depth, dimensions) {
            var point2 = tree.point, axis = series.kdAxisArray[depth % dimensions];
            var nPoint1, nPoint2, ret = point2;
            setDistance(search, point2);
            var tdist = search[axis] - point2[axis], sideA = tdist < 0 ? "left" : "right", sideB = tdist < 0 ? "right" : "left";
            if (tree[sideA]) {
              nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);
              ret = nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point2;
            }
            if (tree[sideB]) {
              if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
                nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
                ret = nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret;
              }
            }
            return ret;
          }
          if (!this.kdTree && !this.buildingKdTree) {
            this.buildKDTree(e2);
          }
          if (this.kdTree) {
            return _search(point, this.kdTree, kdDimensions, kdDimensions);
          }
        };
        Series2.prototype.pointPlacementToXValue = function() {
          var _a2 = this, _b = _a2.options, pointPlacement = _b.pointPlacement, pointRange = _b.pointRange, axis = _a2.xAxis;
          var factor = pointPlacement;
          if (factor === "between") {
            factor = axis.reversed ? -0.5 : 0.5;
          }
          return isNumber$A(factor) ? factor * (pointRange || axis.pointRange) : 0;
        };
        Series2.prototype.isPointInside = function(point) {
          var isInside = typeof point.plotY !== "undefined" && typeof point.plotX !== "undefined" && point.plotY >= 0 && point.plotY <= this.yAxis.len && // #3519
          point.plotX >= 0 && point.plotX <= this.xAxis.len;
          return isInside;
        };
        Series2.prototype.drawTracker = function() {
          var series = this, options = series.options, trackByArea = options.trackByArea, trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath), chart = series.chart, pointer = chart.pointer, renderer = chart.renderer, snap = chart.options.tooltip.snap, tracker = series.tracker, onMouseOver = function(e2) {
            if (chart.hoverSeries !== series) {
              series.onMouseOver();
            }
          }, TRACKER_FILL2 = "rgba(192,192,192," + (svg$2 ? 1e-4 : 2e-3) + ")";
          if (tracker) {
            tracker.attr({ d: trackerPath });
          } else if (series.graph) {
            series.tracker = renderer.path(trackerPath).attr({
              visibility: series.visible ? "visible" : "hidden",
              zIndex: 2
            }).addClass(trackByArea ? "highcharts-tracker-area" : "highcharts-tracker-line").add(series.group);
            if (!chart.styledMode) {
              series.tracker.attr({
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                stroke: TRACKER_FILL2,
                fill: trackByArea ? TRACKER_FILL2 : "none",
                "stroke-width": series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap)
              });
            }
            [
              series.tracker,
              series.markerGroup,
              series.dataLabelsGroup
            ].forEach(function(tracker2) {
              if (tracker2) {
                tracker2.addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", function(e2) {
                  pointer.onTrackerMouseOut(e2);
                });
                if (options.cursor && !chart.styledMode) {
                  tracker2.css({ cursor: options.cursor });
                }
                if (hasTouch$2) {
                  tracker2.on("touchstart", onMouseOver);
                }
              }
            });
          }
          fireEvent$r(this, "afterDrawTracker");
        };
        Series2.prototype.addPoint = function(options, redraw, shift, animation, withEvent) {
          var series = this, seriesOptions = series.options, data = series.data, chart = series.chart, xAxis = series.xAxis, names = xAxis && xAxis.hasNames && xAxis.names, dataOptions = seriesOptions.data, xData = series.xData;
          var isInTheMiddle, i;
          redraw = pick$1f(redraw, true);
          var point = { series };
          series.pointClass.prototype.applyOptions.apply(point, [options]);
          var x = point.x;
          i = xData.length;
          if (series.requireSorting && x < xData[i - 1]) {
            isInTheMiddle = true;
            while (i && xData[i - 1] > x) {
              i--;
            }
          }
          series.updateParallelArrays(point, "splice", i, 0, 0);
          series.updateParallelArrays(point, i);
          if (names && point.name) {
            names[x] = point.name;
          }
          dataOptions.splice(i, 0, options);
          if (isInTheMiddle) {
            series.data.splice(i, 0, null);
            series.processData();
          }
          if (seriesOptions.legendType === "point") {
            series.generatePoints();
          }
          if (shift) {
            if (data[0] && data[0].remove) {
              data[0].remove(false);
            } else {
              data.shift();
              series.updateParallelArrays(point, "shift");
              dataOptions.shift();
            }
          }
          if (withEvent !== false) {
            fireEvent$r(series, "addPoint", { point });
          }
          series.isDirty = true;
          series.isDirtyData = true;
          if (redraw) {
            chart.redraw(animation);
          }
        };
        Series2.prototype.removePoint = function(i, redraw, animation) {
          var series = this, data = series.data, point = data[i], points = series.points, chart = series.chart, remove = function() {
            if (points && points.length === data.length) {
              points.splice(i, 1);
            }
            data.splice(i, 1);
            series.options.data.splice(i, 1);
            series.updateParallelArrays(point || { series }, "splice", i, 1);
            if (point) {
              point.destroy();
            }
            series.isDirty = true;
            series.isDirtyData = true;
            if (redraw) {
              chart.redraw();
            }
          };
          setAnimation$2(animation, chart);
          redraw = pick$1f(redraw, true);
          if (point) {
            point.firePointEvent("remove", null, remove);
          } else {
            remove();
          }
        };
        Series2.prototype.remove = function(redraw, animation, withEvent, keepEvents) {
          var series = this, chart = series.chart;
          function remove() {
            series.destroy(keepEvents);
            chart.isDirtyLegend = chart.isDirtyBox = true;
            chart.linkSeries();
            if (pick$1f(redraw, true)) {
              chart.redraw(animation);
            }
          }
          if (withEvent !== false) {
            fireEvent$r(series, "remove", null, remove);
          } else {
            remove();
          }
        };
        Series2.prototype.update = function(options, redraw) {
          options = cleanRecursively(options, this.userOptions);
          fireEvent$r(this, "update", { options });
          var series = this, chart = series.chart, oldOptions = series.userOptions, initialType = series.initialType || series.type, plotOptions = chart.options.plotOptions, initialSeriesProto = seriesTypes$6[initialType].prototype, groups = [
            "group",
            "markerGroup",
            "dataLabelsGroup",
            "transformGroup"
          ], animation = series.finishedAnimating && { animation: false }, kinds = {};
          var seriesOptions, n, preserve = [
            "eventOptions",
            "navigatorSeries",
            "baseSeries"
          ], newType = options.type || oldOptions.type || chart.options.chart.type;
          var keepPoints = !// Indicators, histograms etc recalculate the data. It should be
          // possible to omit this.
          (this.hasDerivedData || // New type requires new point classes
          newType && newType !== this.type || // New options affecting how the data points are built
          typeof options.pointStart !== "undefined" || typeof options.pointInterval !== "undefined" || typeof options.relativeXValue !== "undefined" || // Changes to data grouping requires new points in new group
          series.hasOptionChanged("dataGrouping") || series.hasOptionChanged("pointStart") || series.hasOptionChanged("pointInterval") || series.hasOptionChanged("pointIntervalUnit") || series.hasOptionChanged("keys"));
          newType = newType || initialType;
          if (keepPoints) {
            preserve.push(
              "data",
              "isDirtyData",
              "points",
              "processedXData",
              "processedYData",
              "xIncrement",
              "cropped",
              "_hasPointMarkers",
              "_hasPointLabels",
              "clips",
              // #15420
              // Networkgraph (#14397)
              "nodes",
              "layout",
              // Map specific, consider moving it to series-specific preserve-
              // properties (#10617)
              "mapMap",
              "mapData",
              "minY",
              "maxY",
              "minX",
              "maxX"
            );
            if (options.visible !== false) {
              preserve.push("area", "graph");
            }
            series.parallelArrays.forEach(function(key) {
              preserve.push(key + "Data");
            });
            if (options.data) {
              if (options.dataSorting) {
                extend$1c(series.options.dataSorting, options.dataSorting);
              }
              this.setData(options.data, false);
            }
          }
          options = merge$18(oldOptions, animation, {
            // When oldOptions.index is null it should't be cleared.
            // Otherwise navigator series will have wrong indexes (#10193).
            index: typeof oldOptions.index === "undefined" ? series.index : oldOptions.index,
            pointStart: pick$1f(
              // when updating from blank (#7933)
              plotOptions && plotOptions.series && plotOptions.series.pointStart,
              oldOptions.pointStart,
              // when updating after addPoint
              series.xData[0]
            )
          }, !keepPoints && { data: series.options.data }, options);
          if (keepPoints && options.data) {
            options.data = series.options.data;
          }
          preserve = groups.concat(preserve);
          preserve.forEach(function(prop) {
            preserve[prop] = series[prop];
            delete series[prop];
          });
          var casting = false;
          if (seriesTypes$6[newType]) {
            casting = newType !== series.type;
            series.remove(false, false, false, true);
            if (casting) {
              if (Object.setPrototypeOf) {
                Object.setPrototypeOf(series, seriesTypes$6[newType].prototype);
              } else {
                var ownEvents = Object.hasOwnProperty.call(series, "hcEvents") && series.hcEvents;
                for (n in initialSeriesProto) {
                  series[n] = void 0;
                }
                extend$1c(series, seriesTypes$6[newType].prototype);
                if (ownEvents) {
                  series.hcEvents = ownEvents;
                } else {
                  delete series.hcEvents;
                }
              }
            }
          } else {
            error$4(17, true, chart, { missingModuleFor: newType });
          }
          preserve.forEach(function(prop) {
            series[prop] = preserve[prop];
          });
          series.init(chart, options);
          if (keepPoints && this.points) {
            seriesOptions = series.options;
            if (seriesOptions.visible === false) {
              kinds.graphic = 1;
              kinds.dataLabel = 1;
            } else if (!series._hasPointLabels) {
              var marker = seriesOptions.marker, dataLabels = seriesOptions.dataLabels;
              if (marker && (marker.enabled === false || (oldOptions.marker && oldOptions.marker.symbol) !== marker.symbol)) {
                kinds.graphic = 1;
              }
              if (dataLabels && dataLabels.enabled === false) {
                kinds.dataLabel = 1;
              }
            }
            this.points.forEach(function(point) {
              if (point && point.series) {
                point.resolveColor();
                if (Object.keys(kinds).length) {
                  point.destroyElements(kinds);
                }
                if (seriesOptions.showInLegend === false && point.legendItem) {
                  chart.legend.destroyItem(point);
                }
              }
            }, this);
          }
          series.initialType = initialType;
          chart.linkSeries();
          if (casting && series.linkedSeries.length) {
            series.isDirtyData = true;
          }
          fireEvent$r(this, "afterUpdate");
          if (pick$1f(redraw, true)) {
            chart.redraw(keepPoints ? void 0 : false);
          }
        };
        Series2.prototype.setName = function(name) {
          this.name = this.options.name = this.userOptions.name = name;
          this.chart.isDirtyLegend = true;
        };
        Series2.prototype.hasOptionChanged = function(optionName) {
          var chart = this.chart, option = this.options[optionName], plotOptions = chart.options.plotOptions, oldOption = this.userOptions[optionName];
          if (oldOption) {
            return option !== oldOption;
          }
          return option !== pick$1f(plotOptions && plotOptions[this.type] && plotOptions[this.type][optionName], plotOptions && plotOptions.series && plotOptions.series[optionName], option);
        };
        Series2.prototype.onMouseOver = function() {
          var series = this, chart = series.chart, hoverSeries = chart.hoverSeries, pointer = chart.pointer;
          pointer.setHoverChartIndex();
          if (hoverSeries && hoverSeries !== series) {
            hoverSeries.onMouseOut();
          }
          if (series.options.events.mouseOver) {
            fireEvent$r(series, "mouseOver");
          }
          series.setState("hover");
          chart.hoverSeries = series;
        };
        Series2.prototype.onMouseOut = function() {
          var series = this, options = series.options, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;
          chart.hoverSeries = null;
          if (hoverPoint) {
            hoverPoint.onMouseOut();
          }
          if (series && options.events.mouseOut) {
            fireEvent$r(series, "mouseOut");
          }
          if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
            tooltip.hide();
          }
          chart.series.forEach(function(s) {
            s.setState("", true);
          });
        };
        Series2.prototype.setState = function(state, inherit) {
          var series = this, options = series.options, graph = series.graph, inactiveOtherPoints = options.inactiveOtherPoints, stateOptions = options.states, stateAnimation = pick$1f(stateOptions[state || "normal"] && stateOptions[state || "normal"].animation, series.chart.options.chart.animation);
          var attribs, lineWidth = options.lineWidth, i = 0, opacity = options.opacity;
          state = state || "";
          if (series.state !== state) {
            [
              series.group,
              series.markerGroup,
              series.dataLabelsGroup
            ].forEach(function(group) {
              if (group) {
                if (series.state) {
                  group.removeClass("highcharts-series-" + series.state);
                }
                if (state) {
                  group.addClass("highcharts-series-" + state);
                }
              }
            });
            series.state = state;
            if (!series.chart.styledMode) {
              if (stateOptions[state] && stateOptions[state].enabled === false) {
                return;
              }
              if (state) {
                lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0);
                opacity = pick$1f(stateOptions[state].opacity, opacity);
              }
              if (graph && !graph.dashstyle) {
                attribs = {
                  "stroke-width": lineWidth
                };
                graph.animate(attribs, stateAnimation);
                while (series["zone-graph-" + i]) {
                  series["zone-graph-" + i].animate(attribs, stateAnimation);
                  i = i + 1;
                }
              }
              if (!inactiveOtherPoints) {
                [
                  series.group,
                  series.markerGroup,
                  series.dataLabelsGroup,
                  series.labelBySeries
                ].forEach(function(group) {
                  if (group) {
                    group.animate({
                      opacity
                    }, stateAnimation);
                  }
                });
              }
            }
          }
          if (inherit && inactiveOtherPoints && series.points) {
            series.setAllPointsToState(state || void 0);
          }
        };
        Series2.prototype.setAllPointsToState = function(state) {
          this.points.forEach(function(point) {
            if (point.setState) {
              point.setState(state);
            }
          });
        };
        Series2.prototype.setVisible = function(vis, redraw) {
          var series = this, chart = series.chart, legendItem = series.legendItem, ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries, oldVisibility = series.visible;
          series.visible = vis = series.options.visible = series.userOptions.visible = typeof vis === "undefined" ? !oldVisibility : vis;
          var showOrHide = vis ? "show" : "hide";
          [
            "group",
            "dataLabelsGroup",
            "markerGroup",
            "tracker",
            "tt"
          ].forEach(function(key) {
            if (series[key]) {
              series[key][showOrHide]();
            }
          });
          if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
            series.onMouseOut();
          }
          if (legendItem) {
            chart.legend.colorizeItem(series, vis);
          }
          series.isDirty = true;
          if (series.options.stacking) {
            chart.series.forEach(function(otherSeries) {
              if (otherSeries.options.stacking && otherSeries.visible) {
                otherSeries.isDirty = true;
              }
            });
          }
          series.linkedSeries.forEach(function(otherSeries) {
            otherSeries.setVisible(vis, false);
          });
          if (ignoreHiddenSeries) {
            chart.isDirtyBox = true;
          }
          fireEvent$r(series, showOrHide);
          if (redraw !== false) {
            chart.redraw();
          }
        };
        Series2.prototype.show = function() {
          this.setVisible(true);
        };
        Series2.prototype.hide = function() {
          this.setVisible(false);
        };
        Series2.prototype.select = function(selected) {
          var series = this;
          series.selected = selected = this.options.selected = typeof selected === "undefined" ? !series.selected : selected;
          if (series.checkbox) {
            series.checkbox.checked = selected;
          }
          fireEvent$r(series, selected ? "select" : "unselect");
        };
        Series2.prototype.shouldShowTooltip = function(plotX, plotY, options) {
          if (options === void 0) {
            options = {};
          }
          options.series = this;
          options.visiblePlotOnly = true;
          return this.chart.isInsidePlot(plotX, plotY, options);
        };
        Series2.defaultOptions = seriesDefaults;
        return Series2;
      }()
    );
    extend$1c(Series$e.prototype, {
      axisTypes: ["xAxis", "yAxis"],
      coll: "series",
      colorCounter: 0,
      cropShoulder: 1,
      directTouch: false,
      drawLegendSymbol: LegendSymbol$1.drawLineMarker,
      isCartesian: true,
      kdAxisArray: ["clientX", "plotY"],
      // each point's x and y values are stored in this.xData and this.yData:
      parallelArrays: ["x", "y"],
      pointClass: Point$2,
      requireSorting: true,
      // requires the data to be sorted:
      sorted: true
    });
    SeriesRegistry$1.series = Series$e;
    var stop = animationExports.stop;
    var addEvent$R = Utilities.addEvent, createElement$4 = Utilities.createElement, merge$17 = Utilities.merge, pick$1e = Utilities.pick;
    addEvent$R(Chart$1, "afterSetChartSize", function(e2) {
      var scrollablePlotArea = this.options.chart.scrollablePlotArea, scrollableMinWidth = scrollablePlotArea && scrollablePlotArea.minWidth, scrollableMinHeight = scrollablePlotArea && scrollablePlotArea.minHeight, scrollablePixelsX, scrollablePixelsY, corrections;
      if (!this.renderer.forExport) {
        if (scrollableMinWidth) {
          this.scrollablePixelsX = scrollablePixelsX = Math.max(0, scrollableMinWidth - this.chartWidth);
          if (scrollablePixelsX) {
            this.scrollablePlotBox = this.renderer.scrollablePlotBox = merge$17(this.plotBox);
            this.plotBox.width = this.plotWidth += scrollablePixelsX;
            if (this.inverted) {
              this.clipBox.height += scrollablePixelsX;
            } else {
              this.clipBox.width += scrollablePixelsX;
            }
            corrections = {
              // Corrections for right side
              1: { name: "right", value: scrollablePixelsX }
            };
          }
        } else if (scrollableMinHeight) {
          this.scrollablePixelsY = scrollablePixelsY = Math.max(0, scrollableMinHeight - this.chartHeight);
          if (scrollablePixelsY) {
            this.scrollablePlotBox = this.renderer.scrollablePlotBox = merge$17(this.plotBox);
            this.plotBox.height = this.plotHeight += scrollablePixelsY;
            if (this.inverted) {
              this.clipBox.width += scrollablePixelsY;
            } else {
              this.clipBox.height += scrollablePixelsY;
            }
            corrections = {
              2: { name: "bottom", value: scrollablePixelsY }
            };
          }
        }
        if (corrections && !e2.skipAxes) {
          this.axes.forEach(function(axis) {
            if (corrections[axis.side]) {
              axis.getPlotLinePath = function() {
                var marginName = corrections[axis.side].name, correctionValue = corrections[axis.side].value, margin = this[marginName], path;
                this[marginName] = margin - correctionValue;
                path = Axis.prototype.getPlotLinePath.apply(this, arguments);
                this[marginName] = margin;
                return path;
              };
            } else {
              axis.setAxisSize();
              axis.setAxisTranslation();
            }
          });
        }
      }
    });
    addEvent$R(Chart$1, "render", function() {
      if (this.scrollablePixelsX || this.scrollablePixelsY) {
        if (this.setUpScrolling) {
          this.setUpScrolling();
        }
        this.applyFixed();
      } else if (this.fixedDiv) {
        this.applyFixed();
      }
    });
    Chart$1.prototype.setUpScrolling = function() {
      var _this = this;
      var css2 = {
        WebkitOverflowScrolling: "touch",
        overflowX: "hidden",
        overflowY: "hidden"
      };
      if (this.scrollablePixelsX) {
        css2.overflowX = "auto";
      }
      if (this.scrollablePixelsY) {
        css2.overflowY = "auto";
      }
      this.scrollingParent = createElement$4("div", {
        className: "highcharts-scrolling-parent"
      }, {
        position: "relative"
      }, this.renderTo);
      this.scrollingContainer = createElement$4("div", {
        "className": "highcharts-scrolling"
      }, css2, this.scrollingParent);
      addEvent$R(this.scrollingContainer, "scroll", function() {
        if (_this.pointer) {
          delete _this.pointer.chartPosition;
        }
      });
      this.innerContainer = createElement$4("div", {
        "className": "highcharts-inner-container"
      }, null, this.scrollingContainer);
      this.innerContainer.appendChild(this.container);
      this.setUpScrolling = null;
    };
    Chart$1.prototype.moveFixedElements = function() {
      var container = this.container, fixedRenderer = this.fixedRenderer, fixedSelectors = [
        ".highcharts-contextbutton",
        ".highcharts-credits",
        ".highcharts-legend",
        ".highcharts-legend-checkbox",
        ".highcharts-navigator-series",
        ".highcharts-navigator-xaxis",
        ".highcharts-navigator-yaxis",
        ".highcharts-navigator",
        ".highcharts-reset-zoom",
        ".highcharts-drillup-button",
        ".highcharts-scrollbar",
        ".highcharts-subtitle",
        ".highcharts-title"
      ], axisClass;
      if (this.scrollablePixelsX && !this.inverted) {
        axisClass = ".highcharts-yaxis";
      } else if (this.scrollablePixelsX && this.inverted) {
        axisClass = ".highcharts-xaxis";
      } else if (this.scrollablePixelsY && !this.inverted) {
        axisClass = ".highcharts-xaxis";
      } else if (this.scrollablePixelsY && this.inverted) {
        axisClass = ".highcharts-yaxis";
      }
      if (axisClass) {
        fixedSelectors.push(axisClass + ":not(.highcharts-radial-axis)", axisClass + "-labels:not(.highcharts-radial-axis-labels)");
      }
      fixedSelectors.forEach(function(className) {
        [].forEach.call(container.querySelectorAll(className), function(elem) {
          (elem.namespaceURI === fixedRenderer.SVG_NS ? fixedRenderer.box : fixedRenderer.box.parentNode).appendChild(elem);
          elem.style.pointerEvents = "auto";
        });
      });
    };
    Chart$1.prototype.applyFixed = function() {
      var firstTime = !this.fixedDiv, chartOptions = this.options.chart, scrollableOptions = chartOptions.scrollablePlotArea, Renderer2 = RendererRegistry$1.getRendererType();
      var fixedRenderer, scrollableWidth, scrollableHeight;
      if (firstTime) {
        this.fixedDiv = createElement$4("div", {
          className: "highcharts-fixed"
        }, {
          position: "absolute",
          overflow: "hidden",
          pointerEvents: "none",
          zIndex: (chartOptions.style && chartOptions.style.zIndex || 0) + 2,
          top: 0
        }, null, true);
        if (this.scrollingContainer) {
          this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer);
        }
        this.renderTo.style.overflow = "visible";
        this.fixedRenderer = fixedRenderer = new Renderer2(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style);
        this.scrollableMask = fixedRenderer.path().attr({
          fill: this.options.chart.backgroundColor || "#fff",
          "fill-opacity": pick$1e(scrollableOptions.opacity, 0.85),
          zIndex: -1
        }).addClass("highcharts-scrollable-mask").add();
        addEvent$R(this, "afterShowResetZoom", this.moveFixedElements);
        addEvent$R(this, "afterDrilldown", this.moveFixedElements);
        addEvent$R(this, "afterLayOutTitles", this.moveFixedElements);
      } else {
        this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
      }
      if (this.scrollableDirty || firstTime) {
        this.scrollableDirty = false;
        this.moveFixedElements();
      }
      scrollableWidth = this.chartWidth + (this.scrollablePixelsX || 0);
      scrollableHeight = this.chartHeight + (this.scrollablePixelsY || 0);
      stop(this.container);
      this.container.style.width = scrollableWidth + "px";
      this.container.style.height = scrollableHeight + "px";
      this.renderer.boxWrapper.attr({
        width: scrollableWidth,
        height: scrollableHeight,
        viewBox: [0, 0, scrollableWidth, scrollableHeight].join(" ")
      });
      this.chartBackground.attr({
        width: scrollableWidth,
        height: scrollableHeight
      });
      this.scrollingContainer.style.height = this.chartHeight + "px";
      if (firstTime) {
        if (scrollableOptions.scrollPositionX) {
          this.scrollingContainer.scrollLeft = this.scrollablePixelsX * scrollableOptions.scrollPositionX;
        }
        if (scrollableOptions.scrollPositionY) {
          this.scrollingContainer.scrollTop = this.scrollablePixelsY * scrollableOptions.scrollPositionY;
        }
      }
      var axisOffset = this.axisOffset, maskTop = this.plotTop - axisOffset[0] - 1, maskLeft = this.plotLeft - axisOffset[3] - 1, maskBottom = this.plotTop + this.plotHeight + axisOffset[2] + 1, maskRight = this.plotLeft + this.plotWidth + axisOffset[1] + 1, maskPlotRight = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), maskPlotBottom = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0), d;
      if (this.scrollablePixelsX) {
        d = [
          // Left side
          ["M", 0, maskTop],
          ["L", this.plotLeft - 1, maskTop],
          ["L", this.plotLeft - 1, maskBottom],
          ["L", 0, maskBottom],
          ["Z"],
          // Right side
          ["M", maskPlotRight, maskTop],
          ["L", this.chartWidth, maskTop],
          ["L", this.chartWidth, maskBottom],
          ["L", maskPlotRight, maskBottom],
          ["Z"]
        ];
      } else if (this.scrollablePixelsY) {
        d = [
          // Top side
          ["M", maskLeft, 0],
          ["L", maskLeft, this.plotTop - 1],
          ["L", maskRight, this.plotTop - 1],
          ["L", maskRight, 0],
          ["Z"],
          // Bottom side
          ["M", maskLeft, maskPlotBottom],
          ["L", maskLeft, this.chartHeight],
          ["L", maskRight, this.chartHeight],
          ["L", maskRight, maskPlotBottom],
          ["Z"]
        ];
      } else {
        d = [["M", 0, 0]];
      }
      if (this.redrawTrigger !== "adjustHeight") {
        this.scrollableMask.attr({ d });
      }
    };
    addEvent$R(Axis, "afterInit", function() {
      this.chart.scrollableDirty = true;
    });
    addEvent$R(Series$e, "show", function() {
      this.chart.scrollableDirty = true;
    });
    var getDeferredAnimation$2 = animationExports.getDeferredAnimation;
    var addEvent$Q = Utilities.addEvent, destroyObjectProperties$5 = Utilities.destroyObjectProperties, fireEvent$q = Utilities.fireEvent, isNumber$z = Utilities.isNumber, objectEach$l = Utilities.objectEach;
    var StackingAxis;
    (function(StackingAxis2) {
      var composedClasses2 = [];
      function compose(AxisClass) {
        if (composedClasses2.indexOf(AxisClass) === -1) {
          composedClasses2.push(AxisClass);
          addEvent$Q(AxisClass, "init", onInit);
          addEvent$Q(AxisClass, "destroy", onDestroy);
        }
        return AxisClass;
      }
      StackingAxis2.compose = compose;
      function onDestroy() {
        var stacking = this.stacking;
        if (!stacking) {
          return;
        }
        var stacks = stacking.stacks;
        objectEach$l(stacks, function(stack, stackKey) {
          destroyObjectProperties$5(stack);
          stacks[stackKey] = null;
        });
        if (stacking && stacking.stackTotalGroup) {
          stacking.stackTotalGroup.destroy();
        }
      }
      function onInit() {
        var axis = this;
        if (!axis.stacking) {
          axis.stacking = new Additions(axis);
        }
      }
      var Additions = (
        /** @class */
        function() {
          function Additions2(axis) {
            this.oldStacks = {};
            this.stacks = {};
            this.stacksTouched = 0;
            this.axis = axis;
          }
          Additions2.prototype.buildStacks = function() {
            var stacking = this;
            var axis = stacking.axis;
            var axisSeries = axis.series;
            var reversedStacks = axis.options.reversedStacks;
            var len = axisSeries.length;
            var actualSeries, i;
            if (!axis.isXAxis) {
              stacking.usePercentage = false;
              i = len;
              while (i--) {
                actualSeries = axisSeries[reversedStacks ? i : len - i - 1];
                actualSeries.setStackedPoints();
                actualSeries.setGroupedPoints();
              }
              for (i = 0; i < len; i++) {
                axisSeries[i].modifyStacks();
              }
              fireEvent$q(axis, "afterBuildStacks");
            }
          };
          Additions2.prototype.cleanStacks = function() {
            var stacking = this, axis = stacking.axis;
            var stacks;
            if (!axis.isXAxis) {
              if (stacking.oldStacks) {
                stacks = stacking.stacks = stacking.oldStacks;
              }
              objectEach$l(stacks, function(type) {
                objectEach$l(type, function(stack) {
                  stack.cumulative = stack.total;
                });
              });
            }
          };
          Additions2.prototype.resetStacks = function() {
            var stacking = this, axis = stacking.axis, stacks = stacking.stacks;
            if (!axis.isXAxis) {
              objectEach$l(stacks, function(type) {
                objectEach$l(type, function(stack, x) {
                  if (isNumber$z(stack.touched) && stack.touched < stacking.stacksTouched) {
                    stack.destroy();
                    delete type[x];
                  } else {
                    stack.total = null;
                    stack.cumulative = null;
                  }
                });
              });
            }
          };
          Additions2.prototype.renderStackTotals = function() {
            var stacking = this, axis = stacking.axis, chart = axis.chart, renderer = chart.renderer, stacks = stacking.stacks, stackLabelsAnim = axis.options.stackLabels && axis.options.stackLabels.animation, animationConfig = getDeferredAnimation$2(chart, stackLabelsAnim || false), stackTotalGroup = stacking.stackTotalGroup = stacking.stackTotalGroup || renderer.g("stack-labels").attr({
              visibility: "visible",
              zIndex: 6,
              opacity: 0
            }).add();
            stackTotalGroup.translate(chart.plotLeft, chart.plotTop);
            objectEach$l(stacks, function(type) {
              objectEach$l(type, function(stack) {
                stack.render(stackTotalGroup);
              });
            });
            stackTotalGroup.animate({
              opacity: 1
            }, animationConfig);
          };
          return Additions2;
        }()
      );
      StackingAxis2.Additions = Additions;
    })(StackingAxis || (StackingAxis = {}));
    const StackingAxis$1 = StackingAxis;
    var format$a = FormatUtilities.format;
    var correctFloat$9 = Utilities.correctFloat, defined$F = Utilities.defined, destroyObjectProperties$4 = Utilities.destroyObjectProperties, isArray$e = Utilities.isArray, isNumber$y = Utilities.isNumber, objectEach$k = Utilities.objectEach, pick$1d = Utilities.pick;
    var StackItem = (
      /** @class */
      function() {
        function StackItem2(axis, options, isNegative, x, stackOption) {
          var inverted = axis.chart.inverted;
          this.axis = axis;
          this.isNegative = isNegative;
          this.options = options = options || {};
          this.x = x;
          this.total = null;
          this.points = {};
          this.hasValidPoints = false;
          this.stack = stackOption;
          this.leftCliff = 0;
          this.rightCliff = 0;
          this.alignOptions = {
            align: options.align || (inverted ? isNegative ? "left" : "right" : "center"),
            verticalAlign: options.verticalAlign || (inverted ? "middle" : isNegative ? "bottom" : "top"),
            y: options.y,
            x: options.x
          };
          this.textAlign = options.textAlign || (inverted ? isNegative ? "right" : "left" : "center");
        }
        StackItem2.prototype.destroy = function() {
          destroyObjectProperties$4(this, this.axis);
        };
        StackItem2.prototype.render = function(group) {
          var chart = this.axis.chart, options = this.options, formatOption = options.format, attr2 = {}, str = formatOption ? (
            // format the text in the label
            format$a(formatOption, this, chart)
          ) : options.formatter.call(this);
          if (this.label) {
            this.label.attr({ text: str, visibility: "hidden" });
          } else {
            this.label = chart.renderer.label(str, null, null, options.shape, null, null, options.useHTML, false, "stack-labels");
            attr2 = {
              r: options.borderRadius || 0,
              text: str,
              rotation: options.rotation,
              padding: pick$1d(options.padding, 5),
              visibility: "hidden"
              // hidden until setOffset is called
            };
            if (!chart.styledMode) {
              attr2.fill = options.backgroundColor;
              attr2.stroke = options.borderColor;
              attr2["stroke-width"] = options.borderWidth;
              this.label.css(options.style);
            }
            this.label.attr(attr2);
            if (!this.label.added) {
              this.label.add(group);
            }
          }
          this.label.labelrank = chart.plotSizeY;
        };
        StackItem2.prototype.setOffset = function(xOffset, xWidth, boxBottom, boxTop, defaultX) {
          var stackItem = this, axis = stackItem.axis, chart = axis.chart, y = axis.translate(axis.stacking.usePercentage ? 100 : boxTop ? boxTop : stackItem.total, 0, 0, 0, 1), yZero = axis.translate(boxBottom ? boxBottom : 0), h = defined$F(y) && Math.abs(y - yZero), x = pick$1d(defaultX, chart.xAxis[0].translate(stackItem.x)) + xOffset, stackBox = defined$F(y) && stackItem.getStackBox(chart, stackItem, x, y, xWidth, h, axis), label = stackItem.label, isNegative = stackItem.isNegative, isJustify = pick$1d(stackItem.options.overflow, "justify") === "justify", textAlign = stackItem.textAlign, visible;
          if (label && stackBox) {
            var bBox = label.getBBox(), padding = label.padding, boxOffsetX = void 0, boxOffsetY = void 0;
            if (textAlign === "left") {
              boxOffsetX = chart.inverted ? -padding : padding;
            } else if (textAlign === "right") {
              boxOffsetX = bBox.width;
            } else {
              if (chart.inverted && textAlign === "center") {
                boxOffsetX = bBox.width / 2;
              } else {
                boxOffsetX = chart.inverted ? isNegative ? bBox.width + padding : -padding : bBox.width / 2;
              }
            }
            boxOffsetY = chart.inverted ? bBox.height / 2 : isNegative ? -padding : bBox.height;
            stackItem.alignOptions.x = pick$1d(stackItem.options.x, 0);
            stackItem.alignOptions.y = pick$1d(stackItem.options.y, 0);
            stackBox.x -= boxOffsetX;
            stackBox.y -= boxOffsetY;
            label.align(stackItem.alignOptions, null, stackBox);
            if (chart.isInsidePlot(label.alignAttr.x + boxOffsetX - stackItem.alignOptions.x, label.alignAttr.y + boxOffsetY - stackItem.alignOptions.y)) {
              label.show();
            } else {
              label.alignAttr.y = -9999;
              isJustify = false;
            }
            if (isJustify) {
              Series$e.prototype.justifyDataLabel.call(this.axis, label, stackItem.alignOptions, label.alignAttr, bBox, stackBox);
            }
            label.attr({
              x: label.alignAttr.x,
              y: label.alignAttr.y
            });
            if (pick$1d(!isJustify && stackItem.options.crop, true)) {
              visible = isNumber$y(label.x) && isNumber$y(label.y) && chart.isInsidePlot(label.x - padding + label.width, label.y) && chart.isInsidePlot(label.x + padding, label.y);
              if (!visible) {
                label.hide();
              }
            }
          }
        };
        StackItem2.prototype.getStackBox = function(chart, stackItem, x, y, xWidth, h, axis) {
          var reversed = stackItem.axis.reversed, inverted = chart.inverted, axisPos = axis.height + axis.pos - (inverted ? chart.plotLeft : chart.plotTop), neg = stackItem.isNegative && !reversed || !stackItem.isNegative && reversed;
          return {
            x: inverted ? neg ? y - axis.right : y - h + axis.pos - chart.plotLeft : x + chart.xAxis[0].transB - chart.plotLeft,
            y: inverted ? axis.height - x - xWidth : neg ? axisPos - y - h : axisPos - y,
            width: inverted ? h : xWidth,
            height: inverted ? xWidth : h
          };
        };
        return StackItem2;
      }()
    );
    Chart$1.prototype.getStacks = function() {
      var chart = this, inverted = chart.inverted;
      chart.yAxis.forEach(function(axis) {
        if (axis.stacking && axis.stacking.stacks && axis.hasVisibleSeries) {
          axis.stacking.oldStacks = axis.stacking.stacks;
        }
      });
      chart.series.forEach(function(series) {
        var xAxisOptions = series.xAxis && series.xAxis.options || {};
        if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
          series.stackKey = [
            series.type,
            pick$1d(series.options.stack, ""),
            inverted ? xAxisOptions.top : xAxisOptions.left,
            inverted ? xAxisOptions.height : xAxisOptions.width
          ].join(",");
        }
      });
    };
    StackingAxis$1.compose(Axis);
    Series$e.prototype.setGroupedPoints = function() {
      var stacking = this.yAxis.stacking;
      if (this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && // With stacking enabled, we already have stacks that we can compute
      // from
      !this.options.stacking && // With only one series, we don't need to consider centerInCategory
      this.chart.series.length > 1) {
        Series$e.prototype.setStackedPoints.call(this, "group");
      } else if (stacking) {
        objectEach$k(stacking.stacks, function(type, key) {
          if (key.slice(-5) === "group") {
            objectEach$k(type, function(stack) {
              return stack.destroy();
            });
            delete stacking.stacks[key];
          }
        });
      }
    };
    Series$e.prototype.setStackedPoints = function(stackingParam) {
      var stacking = stackingParam || this.options.stacking;
      if (!stacking || this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false) {
        return;
      }
      var series = this, xData = series.processedXData, yData = series.processedYData, stackedYData = [], yDataLength = yData.length, seriesOptions = series.options, threshold = seriesOptions.threshold, stackThreshold = pick$1d(seriesOptions.startFromThreshold && threshold, 0), stackOption = seriesOptions.stack, stackKey = stackingParam ? series.type + "," + stacking : series.stackKey, negKey = "-" + stackKey, negStacks = series.negStacks, yAxis = series.yAxis, stacks = yAxis.stacking.stacks, oldStacks = yAxis.stacking.oldStacks, stackIndicator, isNegative, stack, other, key, pointKey, i, x, y;
      yAxis.stacking.stacksTouched += 1;
      for (i = 0; i < yDataLength; i++) {
        x = xData[i];
        y = yData[i];
        stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
        pointKey = stackIndicator.key;
        isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
        key = isNegative ? negKey : stackKey;
        if (!stacks[key]) {
          stacks[key] = {};
        }
        if (!stacks[key][x]) {
          if (oldStacks[key] && oldStacks[key][x]) {
            stacks[key][x] = oldStacks[key][x];
            stacks[key][x].total = null;
          } else {
            stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
          }
        }
        stack = stacks[key][x];
        if (y !== null) {
          stack.points[pointKey] = stack.points[series.index] = [pick$1d(stack.cumulative, stackThreshold)];
          if (!defined$F(stack.cumulative)) {
            stack.base = pointKey;
          }
          stack.touched = yAxis.stacking.stacksTouched;
          if (stackIndicator.index > 0 && series.singleStacks === false) {
            stack.points[pointKey][0] = stack.points[series.index + "," + x + ",0"][0];
          }
        } else {
          stack.points[pointKey] = stack.points[series.index] = null;
        }
        if (stacking === "percent") {
          other = isNegative ? stackKey : negKey;
          if (negStacks && stacks[other] && stacks[other][x]) {
            other = stacks[other][x];
            stack.total = other.total = Math.max(other.total, stack.total) + Math.abs(y) || 0;
          } else {
            stack.total = correctFloat$9(stack.total + (Math.abs(y) || 0));
          }
        } else if (stacking === "group") {
          if (isArray$e(y)) {
            y = y[0];
          }
          if (y !== null) {
            stack.total = (stack.total || 0) + 1;
          }
        } else {
          stack.total = correctFloat$9(stack.total + (y || 0));
        }
        if (stacking === "group") {
          stack.cumulative = (stack.total || 1) - 1;
        } else {
          stack.cumulative = pick$1d(stack.cumulative, stackThreshold) + (y || 0);
        }
        if (y !== null) {
          stack.points[pointKey].push(stack.cumulative);
          stackedYData[i] = stack.cumulative;
          stack.hasValidPoints = true;
        }
      }
      if (stacking === "percent") {
        yAxis.stacking.usePercentage = true;
      }
      if (stacking !== "group") {
        this.stackedYData = stackedYData;
      }
      yAxis.stacking.oldStacks = {};
    };
    Series$e.prototype.modifyStacks = function() {
      var series = this, yAxis = series.yAxis, stackKey = series.stackKey, stacks = yAxis.stacking.stacks, processedXData = series.processedXData, stackIndicator, stacking = series.options.stacking;
      if (series[stacking + "Stacker"]) {
        [stackKey, "-" + stackKey].forEach(function(key) {
          var i = processedXData.length, x, stack, pointExtremes;
          while (i--) {
            x = processedXData[i];
            stackIndicator = series.getStackIndicator(stackIndicator, x, series.index, key);
            stack = stacks[key] && stacks[key][x];
            pointExtremes = stack && stack.points[stackIndicator.key];
            if (pointExtremes) {
              series[stacking + "Stacker"](pointExtremes, stack, i);
            }
          }
        });
      }
    };
    Series$e.prototype.percentStacker = function(pointExtremes, stack, i) {
      var totalFactor = stack.total ? 100 / stack.total : 0;
      pointExtremes[0] = correctFloat$9(pointExtremes[0] * totalFactor);
      pointExtremes[1] = correctFloat$9(pointExtremes[1] * totalFactor);
      this.stackedYData[i] = pointExtremes[1];
    };
    Series$e.prototype.getStackIndicator = function(stackIndicator, x, index, key) {
      if (!defined$F(stackIndicator) || stackIndicator.x !== x || key && stackIndicator.key !== key) {
        stackIndicator = {
          x,
          index: 0,
          key
        };
      } else {
        stackIndicator.index++;
      }
      stackIndicator.key = [index, x, stackIndicator.index].join(",");
      return stackIndicator;
    };
    H.StackItem = StackItem;
    const StackItem$1 = H.StackItem;
    var __extends$U = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var defined$E = Utilities.defined, merge$16 = Utilities.merge;
    var LineSeries$5 = (
      /** @class */
      function(_super) {
        __extends$U(LineSeries2, _super);
        function LineSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        LineSeries2.prototype.drawGraph = function() {
          var series = this, options = this.options, graphPath = (this.gappedPath || this.getGraphPath).call(this), styledMode = this.chart.styledMode;
          var props = [[
            "graph",
            "highcharts-graph"
          ]];
          if (!styledMode) {
            props[0].push(options.lineColor || this.color || palette.neutralColor20, options.dashStyle);
          }
          props = series.getZonesGraphs(props);
          props.forEach(function(prop, i) {
            var graphKey = prop[0];
            var attribs, graph = series[graphKey];
            var verb = graph ? "animate" : "attr";
            if (graph) {
              graph.endX = series.preventGraphAnimation ? null : graphPath.xMap;
              graph.animate({ d: graphPath });
            } else if (graphPath.length) {
              series[graphKey] = graph = series.chart.renderer.path(graphPath).addClass(prop[1]).attr({ zIndex: 1 }).add(series.group);
            }
            if (graph && !styledMode) {
              attribs = {
                "stroke": prop[2],
                "stroke-width": options.lineWidth,
                // Polygon series use filled graph
                "fill": series.fillGraph && series.color || "none"
              };
              if (prop[3]) {
                attribs.dashstyle = prop[3];
              } else if (options.linecap !== "square") {
                attribs["stroke-linecap"] = attribs["stroke-linejoin"] = "round";
              }
              graph[verb](attribs).shadow(i < 2 && options.shadow);
            }
            if (graph) {
              graph.startX = graphPath.xMap;
              graph.isArea = graphPath.isArea;
            }
          });
        };
        LineSeries2.prototype.getGraphPath = function(points, nullsAsZeroes, connectCliffs) {
          var series = this, options = series.options, graphPath = [], xMap = [];
          var gap, step = options.step;
          points = points || series.points;
          var reversed = points.reversed;
          if (reversed) {
            points.reverse();
          }
          step = {
            right: 1,
            center: 2
          }[step] || step && 3;
          if (step && reversed) {
            step = 4 - step;
          }
          points = this.getValidPoints(points, false, !(options.connectNulls && !nullsAsZeroes && !connectCliffs));
          points.forEach(function(point, i) {
            var plotX = point.plotX, plotY = point.plotY, lastPoint = points[i - 1];
            var pathToPoint;
            if ((point.leftCliff || lastPoint && lastPoint.rightCliff) && !connectCliffs) {
              gap = true;
            }
            if (point.isNull && !defined$E(nullsAsZeroes) && i > 0) {
              gap = !options.connectNulls;
            } else if (point.isNull && !nullsAsZeroes) {
              gap = true;
            } else {
              if (i === 0 || gap) {
                pathToPoint = [[
                  "M",
                  point.plotX,
                  point.plotY
                ]];
              } else if (series.getPointSpline) {
                pathToPoint = [series.getPointSpline(points, point, i)];
              } else if (step) {
                if (step === 1) {
                  pathToPoint = [[
                    "L",
                    lastPoint.plotX,
                    plotY
                  ]];
                } else if (step === 2) {
                  pathToPoint = [[
                    "L",
                    (lastPoint.plotX + plotX) / 2,
                    lastPoint.plotY
                  ], [
                    "L",
                    (lastPoint.plotX + plotX) / 2,
                    plotY
                  ]];
                } else {
                  pathToPoint = [[
                    "L",
                    plotX,
                    lastPoint.plotY
                  ]];
                }
                pathToPoint.push([
                  "L",
                  plotX,
                  plotY
                ]);
              } else {
                pathToPoint = [[
                  "L",
                  plotX,
                  plotY
                ]];
              }
              xMap.push(point.x);
              if (step) {
                xMap.push(point.x);
                if (step === 2) {
                  xMap.push(point.x);
                }
              }
              graphPath.push.apply(graphPath, pathToPoint);
              gap = false;
            }
          });
          graphPath.xMap = xMap;
          series.graphPath = graphPath;
          return graphPath;
        };
        LineSeries2.prototype.getZonesGraphs = function(props) {
          this.zones.forEach(function(zone, i) {
            var propset = [
              "zone-graph-" + i,
              "highcharts-graph highcharts-zone-graph-" + i + " " + (zone.className || "")
            ];
            if (!this.chart.styledMode) {
              propset.push(zone.color || this.color, zone.dashStyle || this.options.dashStyle);
            }
            props.push(propset);
          }, this);
          return props;
        };
        LineSeries2.defaultOptions = merge$16(Series$e.defaultOptions, {
          // nothing here yet
        });
        return LineSeries2;
      }(Series$e)
    );
    SeriesRegistry$1.registerSeriesType("line", LineSeries$5);
    var __extends$T = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var color$d = Color.parse;
    var LineSeries$4 = SeriesRegistry$1.seriesTypes.line;
    var extend$1b = Utilities.extend, merge$15 = Utilities.merge, objectEach$j = Utilities.objectEach, pick$1c = Utilities.pick;
    var AreaSeries$1 = (
      /** @class */
      function(_super) {
        __extends$T(AreaSeries2, _super);
        function AreaSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        AreaSeries2.prototype.drawGraph = function() {
          this.areaPath = [];
          _super.prototype.drawGraph.apply(this);
          var series = this, areaPath = this.areaPath, options = this.options, zones = this.zones, props = [[
            "area",
            "highcharts-area",
            this.color,
            options.fillColor
          ]];
          zones.forEach(function(zone, i) {
            props.push([
              "zone-area-" + i,
              "highcharts-area highcharts-zone-area-" + i + " " + zone.className,
              zone.color || series.color,
              zone.fillColor || options.fillColor
            ]);
          });
          props.forEach(function(prop) {
            var areaKey = prop[0], area = series[areaKey], verb = area ? "animate" : "attr", attribs = {};
            if (area) {
              area.endX = series.preventGraphAnimation ? null : areaPath.xMap;
              area.animate({ d: areaPath });
            } else {
              attribs.zIndex = 0;
              area = series[areaKey] = series.chart.renderer.path(areaPath).addClass(prop[1]).add(series.group);
              area.isArea = true;
            }
            if (!series.chart.styledMode) {
              attribs.fill = pick$1c(prop[3], color$d(prop[2]).setOpacity(pick$1c(options.fillOpacity, 0.75)).get());
            }
            area[verb](attribs);
            area.startX = areaPath.xMap;
            area.shiftUnit = options.step ? 2 : 1;
          });
        };
        AreaSeries2.prototype.getGraphPath = function(points) {
          var getGraphPath = LineSeries$4.prototype.getGraphPath, graphPath, options = this.options, stacking = options.stacking, yAxis = this.yAxis, topPath, bottomPath, bottomPoints = [], graphPoints = [], seriesIndex = this.index, i, areaPath, plotX, stacks = yAxis.stacking.stacks[this.stackKey], threshold = options.threshold, translatedThreshold = Math.round(
            // #10909
            yAxis.getThreshold(options.threshold)
          ), isNull, yBottom, connectNulls = pick$1c(
            // #10574
            options.connectNulls,
            stacking === "percent"
          ), addDummyPoints = function(i2, otherI, side) {
            var point = points[i2], stackedValues = stacking && stacks[point.x].points[seriesIndex], nullVal = point[side + "Null"] || 0, cliffVal = point[side + "Cliff"] || 0, top, bottom, isNull2 = true;
            if (cliffVal || nullVal) {
              top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
              bottom = stackedValues[0] + cliffVal;
              isNull2 = !!nullVal;
            } else if (!stacking && points[otherI] && points[otherI].isNull) {
              top = bottom = threshold;
            }
            if (typeof top !== "undefined") {
              graphPoints.push({
                plotX,
                plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),
                isNull: isNull2,
                isCliff: true
              });
              bottomPoints.push({
                plotX,
                plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),
                doCurve: false
                // #1041, gaps in areaspline areas
              });
            }
          };
          points = points || this.points;
          if (stacking) {
            points = this.getStackPoints(points);
          }
          for (i = 0; i < points.length; i++) {
            if (!stacking) {
              points[i].leftCliff = points[i].rightCliff = points[i].leftNull = points[i].rightNull = void 0;
            }
            isNull = points[i].isNull;
            plotX = pick$1c(points[i].rectPlotX, points[i].plotX);
            yBottom = stacking ? pick$1c(points[i].yBottom, translatedThreshold) : translatedThreshold;
            if (!isNull || connectNulls) {
              if (!connectNulls) {
                addDummyPoints(i, i - 1, "left");
              }
              if (!(isNull && !stacking && connectNulls)) {
                graphPoints.push(points[i]);
                bottomPoints.push({
                  x: i,
                  plotX,
                  plotY: yBottom
                });
              }
              if (!connectNulls) {
                addDummyPoints(i, i + 1, "right");
              }
            }
          }
          topPath = getGraphPath.call(this, graphPoints, true, true);
          bottomPoints.reversed = true;
          bottomPath = getGraphPath.call(this, bottomPoints, true, true);
          var firstBottomPoint = bottomPath[0];
          if (firstBottomPoint && firstBottomPoint[0] === "M") {
            bottomPath[0] = ["L", firstBottomPoint[1], firstBottomPoint[2]];
          }
          areaPath = topPath.concat(bottomPath);
          if (areaPath.length) {
            areaPath.push(["Z"]);
          }
          graphPath = getGraphPath.call(this, graphPoints, false, connectNulls);
          areaPath.xMap = topPath.xMap;
          this.areaPath = areaPath;
          return graphPath;
        };
        AreaSeries2.prototype.getStackPoints = function(points) {
          var series = this, segment = [], keys2 = [], xAxis = this.xAxis, yAxis = this.yAxis, stack = yAxis.stacking.stacks[this.stackKey], pointMap = {}, yAxisSeries = yAxis.series, seriesLength = yAxisSeries.length, upOrDown = yAxis.options.reversedStacks ? 1 : -1, seriesIndex = yAxisSeries.indexOf(series);
          points = points || this.points;
          if (this.options.stacking) {
            for (var i = 0; i < points.length; i++) {
              points[i].leftNull = points[i].rightNull = void 0;
              pointMap[points[i].x] = points[i];
            }
            objectEach$j(stack, function(stackX, x) {
              if (stackX.total !== null) {
                keys2.push(x);
              }
            });
            keys2.sort(function(a, b) {
              return a - b;
            });
            var visibleSeries_1 = yAxisSeries.map(function(s) {
              return s.visible;
            });
            keys2.forEach(function(x, idx) {
              var y = 0, stackPoint, stackedValues;
              if (pointMap[x] && !pointMap[x].isNull) {
                segment.push(pointMap[x]);
                [-1, 1].forEach(function(direction) {
                  var nullName = direction === 1 ? "rightNull" : "leftNull", cliffName = direction === 1 ? "rightCliff" : "leftCliff", cliff = 0, otherStack = stack[keys2[idx + direction]];
                  if (otherStack) {
                    var i3 = seriesIndex;
                    while (i3 >= 0 && i3 < seriesLength) {
                      var si2 = yAxisSeries[i3].index;
                      stackPoint = otherStack.points[si2];
                      if (!stackPoint) {
                        if (si2 === series.index) {
                          pointMap[x][nullName] = true;
                        } else if (visibleSeries_1[i3]) {
                          stackedValues = stack[x].points[si2];
                          if (stackedValues) {
                            cliff -= stackedValues[1] - stackedValues[0];
                          }
                        }
                      }
                      i3 += upOrDown;
                    }
                  }
                  pointMap[x][cliffName] = cliff;
                });
              } else {
                var i2 = seriesIndex;
                while (i2 >= 0 && i2 < seriesLength) {
                  var si = yAxisSeries[i2].index;
                  stackPoint = stack[x].points[si];
                  if (stackPoint) {
                    y = stackPoint[1];
                    break;
                  }
                  i2 += upOrDown;
                }
                y = pick$1c(y, 0);
                y = yAxis.translate(
                  // #6272
                  y,
                  0,
                  1,
                  0,
                  1
                );
                segment.push({
                  isNull: true,
                  plotX: xAxis.translate(
                    // #6272
                    x,
                    0,
                    0,
                    0,
                    1
                  ),
                  x,
                  plotY: y,
                  yBottom: y
                });
              }
            });
          }
          return segment;
        };
        AreaSeries2.defaultOptions = merge$15(LineSeries$4.defaultOptions, {
          /**
           * @see [fillColor](#plotOptions.area.fillColor)
           * @see [fillOpacity](#plotOptions.area.fillOpacity)
           *
           * @apioption plotOptions.area.color
           */
          /**
           * Fill color or gradient for the area. When `null`, the series' `color`
           * is used with the series' `fillOpacity`.
           *
           * In styled mode, the fill color can be set with the `.highcharts-area`
           * class name.
           *
           * @see [color](#plotOptions.area.color)
           * @see [fillOpacity](#plotOptions.area.fillOpacity)
           *
           * @sample {highcharts} highcharts/plotoptions/area-fillcolor-default/
           *         Null by default
           * @sample {highcharts} highcharts/plotoptions/area-fillcolor-gradient/
           *         Gradient
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @product   highcharts highstock
           * @apioption plotOptions.area.fillColor
           */
          /**
           * Fill opacity for the area. When you set an explicit `fillColor`,
           * the `fillOpacity` is not applied. Instead, you should define the
           * opacity in the `fillColor` with an rgba color definition. The
           * `fillOpacity` setting, also the default setting, overrides the alpha
           * component of the `color` setting.
           *
           * In styled mode, the fill opacity can be set with the
           * `.highcharts-area` class name.
           *
           * @see [color](#plotOptions.area.color)
           * @see [fillColor](#plotOptions.area.fillColor)
           *
           * @sample {highcharts} highcharts/plotoptions/area-fillopacity/
           *         Automatic fill color and fill opacity of 0.1
           *
           * @type      {number}
           * @default   {highcharts} 0.75
           * @default   {highstock} 0.75
           * @product   highcharts highstock
           * @apioption plotOptions.area.fillOpacity
           */
          /**
           * A separate color for the graph line. By default the line takes the
           * `color` of the series, but the lineColor setting allows setting a
           * separate color for the line without altering the `fillColor`.
           *
           * In styled mode, the line stroke can be set with the
           * `.highcharts-graph` class name.
           *
           * @sample {highcharts} highcharts/plotoptions/area-linecolor/
           *         Dark gray line
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @product   highcharts highstock
           * @apioption plotOptions.area.lineColor
           */
          /**
           * A separate color for the negative part of the area.
           *
           * In styled mode, a negative color is set with the
           * `.highcharts-negative` class name.
           *
           * @see [negativeColor](#plotOptions.area.negativeColor)
           *
           * @sample {highcharts} highcharts/css/series-negative-color/
           *         Negative color in styled mode
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @since     3.0
           * @product   highcharts
           * @apioption plotOptions.area.negativeFillColor
           */
          /**
           * Whether the whole area or just the line should respond to mouseover
           * tooltips and other mouse or touch events.
           *
           * @sample {highcharts|highstock} highcharts/plotoptions/area-trackbyarea/
           *         Display the tooltip when the area is hovered
           *
           * @type      {boolean}
           * @default   false
           * @since     1.1.6
           * @product   highcharts highstock
           * @apioption plotOptions.area.trackByArea
           */
          /**
           * The Y axis value to serve as the base for the area, for
           * distinguishing between values above and below a threshold. The area
           * between the graph and the threshold is filled.
           *
           * * If a number is given, the Y axis will scale to the threshold.
           * * If `null`, the scaling behaves like a line series with fill between
           *   the graph and the Y axis minimum.
           * * If `Infinity` or `-Infinity`, the area between the graph and the
           *   corresponding Y axis extreme is filled (since v6.1.0).
           *
           * @sample {highcharts} highcharts/plotoptions/area-threshold/
           *         A threshold of 100
           * @sample {highcharts} highcharts/plotoptions/area-threshold-infinity/
           *         A threshold of Infinity
           *
           * @type    {number|null}
           * @since   2.0
           * @product highcharts highstock
           */
          threshold: 0
        });
        return AreaSeries2;
      }(LineSeries$4)
    );
    extend$1b(AreaSeries$1.prototype, {
      singleStacks: false,
      drawLegendSymbol: LegendSymbol$1.drawRectangle
    });
    SeriesRegistry$1.registerSeriesType("area", AreaSeries$1);
    var __extends$S = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var LineSeries$3 = SeriesRegistry$1.seriesTypes.line;
    var merge$14 = Utilities.merge, pick$1b = Utilities.pick;
    var SplineSeries$1 = (
      /** @class */
      function(_super) {
        __extends$S(SplineSeries2, _super);
        function SplineSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        SplineSeries2.prototype.getPointSpline = function(points, point, i) {
          var smoothing = 1.5, denom = smoothing + 1, plotX = point.plotX || 0, plotY = point.plotY || 0, lastPoint = points[i - 1], nextPoint = points[i + 1], leftContX, leftContY, rightContX, rightContY, ret;
          function doCurve(otherPoint) {
            return otherPoint && !otherPoint.isNull && otherPoint.doCurve !== false && // #6387, area splines next to null:
            !point.isCliff;
          }
          if (doCurve(lastPoint) && doCurve(nextPoint)) {
            var lastX = lastPoint.plotX || 0, lastY = lastPoint.plotY || 0, nextX = nextPoint.plotX || 0, nextY = nextPoint.plotY || 0, correction = 0;
            leftContX = (smoothing * plotX + lastX) / denom;
            leftContY = (smoothing * plotY + lastY) / denom;
            rightContX = (smoothing * plotX + nextX) / denom;
            rightContY = (smoothing * plotY + nextY) / denom;
            if (rightContX !== leftContX) {
              correction = (rightContY - leftContY) * (rightContX - plotX) / (rightContX - leftContX) + plotY - rightContY;
            }
            leftContY += correction;
            rightContY += correction;
            if (leftContY > lastY && leftContY > plotY) {
              leftContY = Math.max(lastY, plotY);
              rightContY = 2 * plotY - leftContY;
            } else if (leftContY < lastY && leftContY < plotY) {
              leftContY = Math.min(lastY, plotY);
              rightContY = 2 * plotY - leftContY;
            }
            if (rightContY > nextY && rightContY > plotY) {
              rightContY = Math.max(nextY, plotY);
              leftContY = 2 * plotY - rightContY;
            } else if (rightContY < nextY && rightContY < plotY) {
              rightContY = Math.min(nextY, plotY);
              leftContY = 2 * plotY - rightContY;
            }
            point.rightContX = rightContX;
            point.rightContY = rightContY;
          }
          ret = [
            "C",
            pick$1b(lastPoint.rightContX, lastPoint.plotX, 0),
            pick$1b(lastPoint.rightContY, lastPoint.plotY, 0),
            pick$1b(leftContX, plotX, 0),
            pick$1b(leftContY, plotY, 0),
            plotX,
            plotY
          ];
          lastPoint.rightContX = lastPoint.rightContY = void 0;
          return ret;
        };
        SplineSeries2.defaultOptions = merge$14(LineSeries$3.defaultOptions);
        return SplineSeries2;
      }(LineSeries$3)
    );
    SeriesRegistry$1.registerSeriesType("spline", SplineSeries$1);
    var __extends$R = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var areaProto$1 = AreaSeries$1.prototype;
    var extend$1a = Utilities.extend, merge$13 = Utilities.merge;
    var AreaSplineSeries = (
      /** @class */
      function(_super) {
        __extends$R(AreaSplineSeries2, _super);
        function AreaSplineSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.points = void 0;
          _this.options = void 0;
          return _this;
        }
        AreaSplineSeries2.defaultOptions = merge$13(SplineSeries$1.defaultOptions, AreaSeries$1.defaultOptions);
        return AreaSplineSeries2;
      }(SplineSeries$1)
    );
    extend$1a(AreaSplineSeries.prototype, {
      getGraphPath: areaProto$1.getGraphPath,
      getStackPoints: areaProto$1.getStackPoints,
      drawGraph: areaProto$1.drawGraph,
      drawLegendSymbol: LegendSymbol$1.drawRectangle
    });
    SeriesRegistry$1.registerSeriesType("areaspline", AreaSplineSeries);
    var __extends$Q = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var animObject$5 = animationExports.animObject;
    var color$c = Color.parse;
    var hasTouch$1 = H.hasTouch, noop$h = H.noop;
    var clamp$d = Utilities.clamp, css$4 = Utilities.css, defined$D = Utilities.defined, extend$19 = Utilities.extend, fireEvent$p = Utilities.fireEvent, isArray$d = Utilities.isArray, isNumber$x = Utilities.isNumber, merge$12 = Utilities.merge, pick$1a = Utilities.pick, objectEach$i = Utilities.objectEach;
    var ColumnSeries$h = (
      /** @class */
      function(_super) {
        __extends$Q(ColumnSeries2, _super);
        function ColumnSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.borderWidth = void 0;
          _this.data = void 0;
          _this.group = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        ColumnSeries2.prototype.animate = function(init) {
          var series = this, yAxis = this.yAxis, options = series.options, inverted = this.chart.inverted, attr2 = {}, translateProp = inverted ? "translateX" : "translateY";
          var translateStart, translatedThreshold;
          if (init) {
            attr2.scaleY = 1e-3;
            translatedThreshold = clamp$d(yAxis.toPixels(options.threshold), yAxis.pos, yAxis.pos + yAxis.len);
            if (inverted) {
              attr2.translateX = translatedThreshold - yAxis.len;
            } else {
              attr2.translateY = translatedThreshold;
            }
            if (series.clipBox) {
              series.setClip();
            }
            series.group.attr(attr2);
          } else {
            translateStart = Number(series.group.attr(translateProp));
            series.group.animate({ scaleY: 1 }, extend$19(animObject$5(series.options.animation), {
              // Do the scale synchronously to ensure smooth
              // updating (#5030, #7228)
              step: function(val, fx) {
                if (series.group) {
                  attr2[translateProp] = translateStart + fx.pos * (yAxis.pos - translateStart);
                  series.group.attr(attr2);
                }
              }
            }));
          }
        };
        ColumnSeries2.prototype.init = function(chart, options) {
          _super.prototype.init.apply(this, arguments);
          var series = this;
          chart = series.chart;
          if (chart.hasRendered) {
            chart.series.forEach(function(otherSeries) {
              if (otherSeries.type === series.type) {
                otherSeries.isDirty = true;
              }
            });
          }
        };
        ColumnSeries2.prototype.getColumnMetrics = function() {
          var series = this, options = series.options, xAxis = series.xAxis, yAxis = series.yAxis, reversedStacks = xAxis.options.reversedStacks, reverseStacks = xAxis.reversed && !reversedStacks || !xAxis.reversed && reversedStacks, stackGroups = {};
          var stackKey, columnCount = 0;
          if (options.grouping === false) {
            columnCount = 1;
          } else {
            series.chart.series.forEach(function(otherSeries) {
              var otherYAxis = otherSeries.yAxis, otherOptions = otherSeries.options;
              var columnIndex;
              if (otherSeries.type === series.type && (otherSeries.visible || !series.chart.options.chart.ignoreHiddenSeries) && yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {
                if (otherOptions.stacking && otherOptions.stacking !== "group") {
                  stackKey = otherSeries.stackKey;
                  if (typeof stackGroups[stackKey] === "undefined") {
                    stackGroups[stackKey] = columnCount++;
                  }
                  columnIndex = stackGroups[stackKey];
                } else if (otherOptions.grouping !== false) {
                  columnIndex = columnCount++;
                }
                otherSeries.columnIndex = columnIndex;
              }
            });
          }
          var categoryWidth = Math.min(
            Math.abs(xAxis.transA) * (xAxis.ordinal && xAxis.ordinal.slope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1),
            // #2610
            xAxis.len
            // #1535
          ), groupPadding = categoryWidth * options.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / (columnCount || 1), pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick$1a(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))), pointPadding = (pointOffsetWidth - pointWidth) / 2, colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0), pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - categoryWidth / 2) * (reverseStacks ? -1 : 1);
          series.columnMetrics = {
            width: pointWidth,
            offset: pointXOffset,
            paddedWidth: pointOffsetWidth,
            columnCount
          };
          return series.columnMetrics;
        };
        ColumnSeries2.prototype.crispCol = function(x, y, w2, h) {
          var chart = this.chart, borderWidth = this.borderWidth, xCrisp = -(borderWidth % 2 ? 0.5 : 0);
          var right, yCrisp = borderWidth % 2 ? 0.5 : 1;
          if (chart.inverted && chart.renderer.isVML) {
            yCrisp += 1;
          }
          if (this.options.crisp) {
            right = Math.round(x + w2) + xCrisp;
            x = Math.round(x) + xCrisp;
            w2 = right - x;
          }
          var bottom = Math.round(y + h) + yCrisp, fromTop = Math.abs(y) <= 0.5 && bottom > 0.5;
          y = Math.round(y) + yCrisp;
          h = bottom - y;
          if (fromTop && h) {
            y -= 1;
            h += 1;
          }
          return {
            x,
            y,
            width: w2,
            height: h
          };
        };
        ColumnSeries2.prototype.adjustForMissingColumns = function(x, pointWidth, point, metrics) {
          var _this = this;
          var stacking = this.options.stacking;
          if (!point.isNull && metrics.columnCount > 1) {
            var indexInCategory_1 = 0;
            var totalInCategory_1 = 0;
            objectEach$i(this.yAxis.stacking && this.yAxis.stacking.stacks, function(stack) {
              if (typeof point.x === "number") {
                var stackItem = stack[point.x.toString()];
                if (stackItem) {
                  var pointValues = stackItem.points[_this.index], total = stackItem.total;
                  if (stacking) {
                    if (pointValues) {
                      indexInCategory_1 = totalInCategory_1;
                    }
                    if (stackItem.hasValidPoints) {
                      totalInCategory_1++;
                    }
                  } else if (isArray$d(pointValues)) {
                    indexInCategory_1 = pointValues[1];
                    totalInCategory_1 = total || 0;
                  }
                }
              }
            });
            var boxWidth = (totalInCategory_1 - 1) * metrics.paddedWidth + pointWidth;
            x = (point.plotX || 0) + boxWidth / 2 - pointWidth - indexInCategory_1 * metrics.paddedWidth;
          }
          return x;
        };
        ColumnSeries2.prototype.translate = function() {
          var series = this, chart = series.chart, options = series.options, dense = series.dense = series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick$1a(
            options.borderWidth,
            dense ? 0 : 1
            // #3635
          ), xAxis = series.xAxis, yAxis = series.yAxis, threshold = options.threshold, translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold), minPointLength = pick$1a(options.minPointLength, 5), metrics = series.getColumnMetrics(), seriesPointWidth = metrics.width, seriesXOffset = series.pointXOffset = metrics.offset, dataMin = series.dataMin, dataMax = series.dataMax;
          var seriesBarW = series.barW = Math.max(seriesPointWidth, 1 + 2 * borderWidth);
          if (chart.inverted) {
            translatedThreshold -= 0.5;
          }
          if (options.pointPadding) {
            seriesBarW = Math.ceil(seriesBarW);
          }
          Series$e.prototype.translate.apply(series);
          series.points.forEach(function(point) {
            var yBottom = pick$1a(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotX = point.plotX || 0, plotY = clamp$d(point.plotY, -safeDistance, yAxis.len + safeDistance);
            var up, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, pointWidth = seriesPointWidth, barX = plotX + seriesXOffset, barW = seriesBarW;
            if (minPointLength && Math.abs(barH) < minPointLength) {
              barH = minPointLength;
              up = !yAxis.reversed && !point.negative || yAxis.reversed && point.negative;
              if (isNumber$x(threshold) && isNumber$x(dataMax) && point.y === threshold && dataMax <= threshold && // and if there's room for it (#7311)
              (yAxis.min || 0) < threshold && // if all points are the same value (i.e zero) not draw
              // as negative points (#10646), but only if there's room
              // for it (#14876)
              (dataMin !== dataMax || (yAxis.max || 0) <= threshold)) {
                up = !up;
              }
              barY = Math.abs(barY - translatedThreshold) > minPointLength ? (
                // ...keep position
                yBottom - minPointLength
              ) : (
                // #1485, #4051
                translatedThreshold - (up ? minPointLength : 0)
              );
            }
            if (defined$D(point.options.pointWidth)) {
              pointWidth = barW = Math.ceil(point.options.pointWidth);
              barX -= Math.round((pointWidth - seriesPointWidth) / 2);
            }
            if (options.centerInCategory) {
              barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);
            }
            point.barX = barX;
            point.pointWidth = pointWidth;
            point.tooltipPos = chart.inverted ? [
              clamp$d(yAxis.len + yAxis.pos - chart.plotLeft - plotY, yAxis.pos - chart.plotLeft, yAxis.len + yAxis.pos - chart.plotLeft),
              xAxis.len + xAxis.pos - chart.plotTop - barX - barW / 2,
              barH
            ] : [
              xAxis.left - chart.plotLeft + barX + barW / 2,
              clamp$d(plotY + yAxis.pos - chart.plotTop, yAxis.pos - chart.plotTop, yAxis.len + yAxis.pos - chart.plotTop),
              barH
            ];
            point.shapeType = series.pointClass.prototype.shapeType || "rect";
            point.shapeArgs = series.crispCol.apply(series, point.isNull ? (
              // #3169, drilldown from null must have a position to work
              // from #6585, dataLabel should be placed on xAxis, not
              // floating in the middle of the chart
              [barX, translatedThreshold, barW, 0]
            ) : [barX, barY, barW, barH]);
          });
        };
        ColumnSeries2.prototype.drawGraph = function() {
          this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
        };
        ColumnSeries2.prototype.pointAttribs = function(point, state) {
          var options = this.options, p2o = this.pointAttrToOptions || {}, strokeOption = p2o.stroke || "borderColor", strokeWidthOption = p2o["stroke-width"] || "borderWidth";
          var stateOptions, zone, brightness, fill = point && point.color || this.color, stroke = point && point[strokeOption] || options[strokeOption] || fill, dashstyle = point && point.options.dashStyle || options.dashStyle, strokeWidth = point && point[strokeWidthOption] || options[strokeWidthOption] || this[strokeWidthOption] || 0, opacity = pick$1a(point && point.opacity, options.opacity, 1);
          if (point && this.zones.length) {
            zone = point.getZone();
            fill = point.options.color || zone && (zone.color || point.nonZonedColor) || this.color;
            if (zone) {
              stroke = zone.borderColor || stroke;
              dashstyle = zone.dashStyle || dashstyle;
              strokeWidth = zone.borderWidth || strokeWidth;
            }
          }
          if (state && point) {
            stateOptions = merge$12(
              options.states[state],
              // #6401
              point.options.states && point.options.states[state] || {}
            );
            brightness = stateOptions.brightness;
            fill = stateOptions.color || typeof brightness !== "undefined" && color$c(fill).brighten(stateOptions.brightness).get() || fill;
            stroke = stateOptions[strokeOption] || stroke;
            strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
            dashstyle = stateOptions.dashStyle || dashstyle;
            opacity = pick$1a(stateOptions.opacity, opacity);
          }
          var ret = {
            fill,
            stroke,
            "stroke-width": strokeWidth,
            opacity
          };
          if (dashstyle) {
            ret.dashstyle = dashstyle;
          }
          return ret;
        };
        ColumnSeries2.prototype.drawPoints = function() {
          var series = this, chart = this.chart, options = series.options, renderer = chart.renderer, animationLimit = options.animationLimit || 250;
          var shapeArgs;
          series.points.forEach(function(point) {
            var plotY = point.plotY;
            var graphic = point.graphic, hasGraphic = !!graphic, verb = graphic && chart.pointCount < animationLimit ? "animate" : "attr";
            if (isNumber$x(plotY) && point.y !== null) {
              shapeArgs = point.shapeArgs;
              if (graphic && point.hasNewShapeType()) {
                graphic = graphic.destroy();
              }
              if (series.enabledDataSorting) {
                point.startXPos = series.xAxis.reversed ? -(shapeArgs ? shapeArgs.width || 0 : 0) : series.xAxis.width;
              }
              if (!graphic) {
                point.graphic = graphic = renderer[point.shapeType](shapeArgs).add(point.group || series.group);
                if (graphic && series.enabledDataSorting && chart.hasRendered && chart.pointCount < animationLimit) {
                  graphic.attr({
                    x: point.startXPos
                  });
                  hasGraphic = true;
                  verb = "animate";
                }
              }
              if (graphic && hasGraphic) {
                graphic[verb](merge$12(shapeArgs));
              }
              if (options.borderRadius) {
                graphic[verb]({
                  r: options.borderRadius
                });
              }
              if (!chart.styledMode) {
                graphic[verb](series.pointAttribs(point, point.selected && "select")).shadow(point.allowShadow !== false && options.shadow, null, options.stacking && !options.borderRadius);
              }
              if (graphic) {
                graphic.addClass(point.getClassName(), true);
                graphic.attr({
                  visibility: point.visible ? "inherit" : "hidden"
                });
              }
            } else if (graphic) {
              point.graphic = graphic.destroy();
            }
          });
        };
        ColumnSeries2.prototype.drawTracker = function() {
          var series = this, chart = series.chart, pointer = chart.pointer, onMouseOver = function(e2) {
            var point = pointer.getPointFromEvent(e2);
            if (typeof point !== "undefined") {
              pointer.isDirectTouch = true;
              point.onMouseOver(e2);
            }
          };
          var dataLabels;
          series.points.forEach(function(point) {
            dataLabels = isArray$d(point.dataLabels) ? point.dataLabels : point.dataLabel ? [point.dataLabel] : [];
            if (point.graphic) {
              point.graphic.element.point = point;
            }
            dataLabels.forEach(function(dataLabel) {
              if (dataLabel.div) {
                dataLabel.div.point = point;
              } else {
                dataLabel.element.point = point;
              }
            });
          });
          if (!series._hasTracking) {
            series.trackerGroups.forEach(function(key) {
              if (series[key]) {
                series[key].addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", function(e2) {
                  pointer.onTrackerMouseOut(e2);
                });
                if (hasTouch$1) {
                  series[key].on("touchstart", onMouseOver);
                }
                if (!chart.styledMode && series.options.cursor) {
                  series[key].css(css$4).css({ cursor: series.options.cursor });
                }
              }
            });
            series._hasTracking = true;
          }
          fireEvent$p(this, "afterDrawTracker");
        };
        ColumnSeries2.prototype.remove = function() {
          var series = this, chart = series.chart;
          if (chart.hasRendered) {
            chart.series.forEach(function(otherSeries) {
              if (otherSeries.type === series.type) {
                otherSeries.isDirty = true;
              }
            });
          }
          Series$e.prototype.remove.apply(series, arguments);
        };
        ColumnSeries2.defaultOptions = merge$12(Series$e.defaultOptions, {
          /**
           * The corner radius of the border surrounding each column or bar.
           *
           * @sample {highcharts} highcharts/plotoptions/column-borderradius/
           *         Rounded columns
           *
           * @product highcharts highstock gantt
           *
           * @private
           */
          borderRadius: 0,
          /**
           * When using automatic point colors pulled from the global
           * [colors](colors) or series-specific
           * [plotOptions.column.colors](series.colors) collections, this option
           * determines whether the chart should receive one color per series or
           * one color per point.
           *
           * In styled mode, the `colors` or `series.colors` arrays are not
           * supported, and instead this option gives the points individual color
           * class names on the form `highcharts-color-{n}`.
           *
           * @see [series colors](#plotOptions.column.colors)
           *
           * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-false/
           *         False by default
           * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-true/
           *         True
           *
           * @type      {boolean}
           * @default   false
           * @since     2.0
           * @product   highcharts highstock gantt
           * @apioption plotOptions.column.colorByPoint
           */
          /**
           * A series specific or series type specific color set to apply instead
           * of the global [colors](#colors) when [colorByPoint](
           * #plotOptions.column.colorByPoint) is true.
           *
           * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
           * @since     3.0
           * @product   highcharts highstock gantt
           * @apioption plotOptions.column.colors
           */
          /**
           * When `true`, the columns will center in the category, ignoring null
           * or missing points. When `false`, space will be reserved for null or
           * missing points.
           *
           * @sample {highcharts} highcharts/series-column/centerincategory/
           *         Center in category
           *
           * @since   8.0.1
           * @product highcharts highstock gantt
           *
           * @private
           */
          centerInCategory: false,
          /**
           * Padding between each value groups, in x axis units.
           *
           * @sample {highcharts} highcharts/plotoptions/column-grouppadding-default/
           *         0.2 by default
           * @sample {highcharts} highcharts/plotoptions/column-grouppadding-none/
           *         No group padding - all columns are evenly spaced
           *
           * @product highcharts highstock gantt
           *
           * @private
           */
          groupPadding: 0.2,
          /**
           * Whether to group non-stacked columns or to let them render
           * independent of each other. Non-grouped columns will be laid out
           * individually and overlap each other.
           *
           * @sample {highcharts} highcharts/plotoptions/column-grouping-false/
           *         Grouping disabled
           * @sample {highstock} highcharts/plotoptions/column-grouping-false/
           *         Grouping disabled
           *
           * @type      {boolean}
           * @default   true
           * @since     2.3.0
           * @product   highcharts highstock gantt
           * @apioption plotOptions.column.grouping
           */
          /**
           * @ignore-option
           * @private
           */
          marker: null,
          /**
           * The maximum allowed pixel width for a column, translated to the
           * height of a bar in a bar chart. This prevents the columns from
           * becoming too wide when there is a small number of points in the
           * chart.
           *
           * @see [pointWidth](#plotOptions.column.pointWidth)
           *
           * @sample {highcharts} highcharts/plotoptions/column-maxpointwidth-20/
           *         Limited to 50
           * @sample {highstock} highcharts/plotoptions/column-maxpointwidth-20/
           *         Limited to 50
           *
           * @type      {number}
           * @since     4.1.8
           * @product   highcharts highstock gantt
           * @apioption plotOptions.column.maxPointWidth
           */
          /**
           * Padding between each column or bar, in x axis units.
           *
           * @sample {highcharts} highcharts/plotoptions/column-pointpadding-default/
           *         0.1 by default
           * @sample {highcharts} highcharts/plotoptions/column-pointpadding-025/
           *          0.25
           * @sample {highcharts} highcharts/plotoptions/column-pointpadding-none/
           *         0 for tightly packed columns
           *
           * @product highcharts highstock gantt
           *
           * @private
           */
          pointPadding: 0.1,
          /**
           * A pixel value specifying a fixed width for each column or bar point.
           * When set to `undefined`, the width is calculated from the
           * `pointPadding` and `groupPadding`. The width effects the dimension
           * that is not based on the point value. For column series it is the
           * hoizontal length and for bar series it is the vertical length.
           *
           * @see [maxPointWidth](#plotOptions.column.maxPointWidth)
           *
           * @sample {highcharts} highcharts/plotoptions/column-pointwidth-20/
           *         20px wide columns regardless of chart width or the amount of
           *         data points
           *
           * @type      {number}
           * @since     1.2.5
           * @product   highcharts highstock gantt
           * @apioption plotOptions.column.pointWidth
           */
          /**
           * A pixel value specifying a fixed width for the column or bar.
           * Overrides pointWidth on the series.
           *
           * @see [series.pointWidth](#plotOptions.column.pointWidth)
           *
           * @type      {number}
           * @default   undefined
           * @since     7.0.0
           * @product   highcharts highstock gantt
           * @apioption series.column.data.pointWidth
           */
          /**
           * The minimal height for a column or width for a bar. By default,
           * 0 values are not shown. To visualize a 0 (or close to zero) point,
           * set the minimal point length to a pixel value like 3\. In stacked
           * column charts, minPointLength might not be respected for tightly
           * packed values.
           *
           * @sample {highcharts} highcharts/plotoptions/column-minpointlength/
           *         Zero base value
           * @sample {highcharts} highcharts/plotoptions/column-minpointlength-pos-and-neg/
           *         Positive and negative close to zero values
           *
           * @product highcharts highstock gantt
           *
           * @private
           */
          minPointLength: 0,
          /**
           * When the series contains less points than the crop threshold, all
           * points are drawn, event if the points fall outside the visible plot
           * area at the current zoom. The advantage of drawing all points
           * (including markers and columns), is that animation is performed on
           * updates. On the other hand, when the series contains more points than
           * the crop threshold, the series data is cropped to only contain points
           * that fall within the plot area. The advantage of cropping away
           * invisible points is to increase performance on large series.
           *
           * @product highcharts highstock gantt
           *
           * @private
           */
          cropThreshold: 50,
          /**
           * The X axis range that each point is valid for. This determines the
           * width of the column. On a categorized axis, the range will be 1
           * by default (one category unit). On linear and datetime axes, the
           * range will be computed as the distance between the two closest data
           * points.
           *
           * The default `null` means it is computed automatically, but this
           * option can be used to override the automatic value.
           *
           * This option is set by default to 1 if data sorting is enabled.
           *
           * @sample {highcharts} highcharts/plotoptions/column-pointrange/
           *         Set the point range to one day on a data set with one week
           *         between the points
           *
           * @type    {number|null}
           * @since   2.3
           * @product highcharts highstock gantt
           *
           * @private
           */
          pointRange: null,
          states: {
            /**
             * Options for the hovered point. These settings override the normal
             * state options when a point is moused over or touched.
             *
             * @extends   plotOptions.series.states.hover
             * @excluding halo, lineWidth, lineWidthPlus, marker
             * @product   highcharts highstock gantt
             */
            hover: {
              /** @ignore-option */
              halo: false,
              /**
               * A specific border color for the hovered point. Defaults to
               * inherit the normal state border color.
               *
               * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @product   highcharts gantt
               * @apioption plotOptions.column.states.hover.borderColor
               */
              /**
               * A specific color for the hovered point.
               *
               * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @product   highcharts gantt
               * @apioption plotOptions.column.states.hover.color
               */
              /**
               * How much to brighten the point on interaction. Requires the
               * main color to be defined in hex or rgb(a) format.
               *
               * In styled mode, the hover brightening is by default replaced
               * with a fill-opacity set in the `.highcharts-point:hover`
               * rule.
               *
               * @sample {highcharts} highcharts/plotoptions/column-states-hover-brightness/
               *         Brighten by 0.5
               *
               * @product highcharts highstock gantt
               */
              brightness: 0.1
            },
            /**
             * Options for the selected point. These settings override the
             * normal state options when a point is selected.
             *
             * @extends   plotOptions.series.states.select
             * @excluding halo, lineWidth, lineWidthPlus, marker
             * @product   highcharts highstock gantt
             */
            select: {
              /**
               * A specific color for the selected point.
               *
               * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @default #cccccc
               * @product highcharts highstock gantt
               */
              color: palette.neutralColor20,
              /**
               * A specific border color for the selected point.
               *
               * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @default #000000
               * @product highcharts highstock gantt
               */
              borderColor: palette.neutralColor100
            }
          },
          dataLabels: {
            align: void 0,
            verticalAlign: void 0,
            /**
             * The y position offset of the label relative to the point in
             * pixels.
             *
             * @type {number}
             */
            y: void 0
          },
          // false doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/
          /**
           * @ignore-option
           * @private
           */
          startFromThreshold: true,
          stickyTracking: false,
          tooltip: {
            distance: 6
          },
          /**
           * The Y axis value to serve as the base for the columns, for
           * distinguishing between values above and below a threshold. If `null`,
           * the columns extend from the padding Y axis minimum.
           *
           * @type    {number|null}
           * @since   2.0
           * @product highcharts
           *
           * @private
           */
          threshold: 0,
          /**
           * The width of the border surrounding each column or bar. Defaults to
           * `1` when there is room for a border, but to `0` when the columns are
           * so dense that a border would cover the next column.
           *
           * In styled mode, the stroke width can be set with the
           * `.highcharts-point` rule.
           *
           * @sample {highcharts} highcharts/plotoptions/column-borderwidth/
           *         2px black border
           *
           * @type      {number}
           * @default   undefined
           * @product   highcharts highstock gantt
           * @apioption plotOptions.column.borderWidth
           */
          /**
           * The color of the border surrounding each column or bar.
           *
           * In styled mode, the border stroke can be set with the
           * `.highcharts-point` rule.
           *
           * @sample {highcharts} highcharts/plotoptions/column-bordercolor/
           *         Dark gray border
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default   #ffffff
           * @product   highcharts highstock gantt
           *
           * @private
           */
          borderColor: palette.backgroundColor
        });
        return ColumnSeries2;
      }(Series$e)
    );
    extend$19(ColumnSeries$h.prototype, {
      cropShoulder: 0,
      // When tooltip is not shared, this series (and derivatives) requires
      // direct touch/hover. KD-tree does not apply.
      directTouch: true,
      /**
       * Use a solid rectangle like the area series types
       *
       * @private
       * @function Highcharts.seriesTypes.column#drawLegendSymbol
       *
       * @param {Highcharts.Legend} legend
       *        The legend object
       *
       * @param {Highcharts.Series|Highcharts.Point} item
       *        The series (this) or point
       */
      drawLegendSymbol: LegendSymbol$1.drawRectangle,
      getSymbol: noop$h,
      // use separate negative stacks, unlike area stacks where a negative
      // point is substracted from previous (#1910)
      negStacks: true,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    SeriesRegistry$1.registerSeriesType("column", ColumnSeries$h);
    var getDeferredAnimation$1 = animationExports.getDeferredAnimation;
    var format$9 = FormatUtilities.format;
    var defined$C = Utilities.defined, extend$18 = Utilities.extend, fireEvent$o = Utilities.fireEvent, isArray$c = Utilities.isArray, merge$11 = Utilities.merge, objectEach$h = Utilities.objectEach, pick$19 = Utilities.pick, splat$b = Utilities.splat;
    var DataLabel;
    (function(DataLabel2) {
      var composedClasses2 = [];
      function alignDataLabel(point, dataLabel, options, alignTo, isNew) {
        var series = this, chart = this.chart, inverted = this.isCartesian && chart.inverted, enabledDataSorting = this.enabledDataSorting, plotX = pick$19(point.dlBox && point.dlBox.centerX, point.plotX, -9999), plotY = pick$19(point.plotY, -9999), bBox = dataLabel.getBBox(), rotation = options.rotation, align = options.align, isInsidePlot = chart.isInsidePlot(plotX, Math.round(plotY), {
          inverted,
          paneCoordinates: true,
          series
        }), setStartPos = function(alignOptions) {
          if (enabledDataSorting && series.xAxis && !justify) {
            series.setDataLabelStartPos(point, dataLabel, isNew, isInsidePlot, alignOptions);
          }
        };
        var baseline, normRotation, negRotation, rotCorr, alignAttr, justify = pick$19(options.overflow, enabledDataSorting ? "none" : "justify") === "justify", visible = this.visible && point.visible !== false && (point.series.forceDL || enabledDataSorting && !justify || isInsidePlot || // If the data label is inside the align box, it is
        // enough that parts of the align box is inside the
        // plot area (#12370). When stacking, it is always
        // inside regardless of the option (#15148).
        pick$19(options.inside, !!this.options.stacking) && alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, {
          inverted,
          paneCoordinates: true,
          series
        }));
        if (visible) {
          baseline = chart.renderer.fontMetrics(chart.styledMode ? void 0 : options.style.fontSize, dataLabel).b;
          alignTo = extend$18({
            x: inverted ? this.yAxis.len - plotY : plotX,
            y: Math.round(inverted ? this.xAxis.len - plotX : plotY),
            width: 0,
            height: 0
          }, alignTo);
          extend$18(options, {
            width: bBox.width,
            height: bBox.height
          });
          if (rotation) {
            justify = false;
            rotCorr = chart.renderer.rotCorr(baseline, rotation);
            alignAttr = {
              x: alignTo.x + (options.x || 0) + alignTo.width / 2 + rotCorr.x,
              y: alignTo.y + (options.y || 0) + { top: 0, middle: 0.5, bottom: 1 }[options.verticalAlign] * alignTo.height
            };
            setStartPos(alignAttr);
            dataLabel[isNew ? "attr" : "animate"](alignAttr).attr({
              align
            });
            normRotation = (rotation + 720) % 360;
            negRotation = normRotation > 180 && normRotation < 360;
            if (align === "left") {
              alignAttr.y -= negRotation ? bBox.height : 0;
            } else if (align === "center") {
              alignAttr.x -= bBox.width / 2;
              alignAttr.y -= bBox.height / 2;
            } else if (align === "right") {
              alignAttr.x -= bBox.width;
              alignAttr.y -= negRotation ? 0 : bBox.height;
            }
            dataLabel.placed = true;
            dataLabel.alignAttr = alignAttr;
          } else {
            setStartPos(alignTo);
            dataLabel.align(options, void 0, alignTo);
            alignAttr = dataLabel.alignAttr;
          }
          if (justify && alignTo.height >= 0) {
            this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);
          } else if (pick$19(options.crop, true)) {
            visible = chart.isInsidePlot(alignAttr.x, alignAttr.y, {
              paneCoordinates: true,
              series
            }) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height, {
              paneCoordinates: true,
              series
            });
          }
          if (options.shape && !rotation) {
            dataLabel[isNew ? "attr" : "animate"]({
              anchorX: inverted ? chart.plotWidth - point.plotY : point.plotX,
              anchorY: inverted ? chart.plotHeight - point.plotX : point.plotY
            });
          }
        }
        if (isNew && enabledDataSorting) {
          dataLabel.placed = false;
        }
        if (!visible && (!enabledDataSorting || justify)) {
          dataLabel.hide(true);
          dataLabel.placed = false;
        }
      }
      function applyFilter(point, options) {
        var filter = options.filter;
        if (filter) {
          var op = filter.operator;
          var prop = point[filter.property];
          var val = filter.value;
          if (op === ">" && prop > val || op === "<" && prop < val || op === ">=" && prop >= val || op === "<=" && prop <= val || op === "==" && prop == val || // eslint-disable-line eqeqeq
          op === "===" && prop === val) {
            return true;
          }
          return false;
        }
        return true;
      }
      function compose(SeriesClass) {
        if (composedClasses2.indexOf(SeriesClass) === -1) {
          var seriesProto2 = SeriesClass.prototype;
          composedClasses2.push(SeriesClass);
          seriesProto2.alignDataLabel = alignDataLabel;
          seriesProto2.drawDataLabels = drawDataLabels;
          seriesProto2.justifyDataLabel = justifyDataLabel;
          seriesProto2.setDataLabelStartPos = setDataLabelStartPos;
        }
      }
      DataLabel2.compose = compose;
      function drawDataLabels() {
        var series = this, chart = series.chart, seriesOptions = series.options, points = series.points, hasRendered = series.hasRendered || 0, renderer = chart.renderer;
        var seriesDlOptions = seriesOptions.dataLabels, pointOptions, dataLabelsGroup;
        var dataLabelAnim = seriesDlOptions.animation, animationConfig = seriesDlOptions.defer ? getDeferredAnimation$1(chart, dataLabelAnim, series) : { defer: 0, duration: 0 };
        seriesDlOptions = mergeArrays(mergeArrays(chart.options.plotOptions && chart.options.plotOptions.series && chart.options.plotOptions.series.dataLabels, chart.options.plotOptions && chart.options.plotOptions[series.type] && chart.options.plotOptions[series.type].dataLabels), seriesDlOptions);
        fireEvent$o(this, "drawDataLabels");
        if (isArray$c(seriesDlOptions) || seriesDlOptions.enabled || series._hasPointLabels) {
          dataLabelsGroup = series.plotGroup(
            "dataLabelsGroup",
            "data-labels",
            !hasRendered ? "hidden" : "inherit",
            // #5133, #10220
            seriesDlOptions.zIndex || 6
          );
          dataLabelsGroup.attr({ opacity: +hasRendered });
          if (!hasRendered) {
            var group = series.dataLabelsGroup;
            if (group) {
              if (series.visible) {
                dataLabelsGroup.show(true);
              }
              group[seriesOptions.animation ? "animate" : "attr"]({ opacity: 1 }, animationConfig);
            }
          }
          points.forEach(function(point) {
            pointOptions = splat$b(mergeArrays(seriesDlOptions, point.dlOptions || // dlOptions is used in treemaps
            point.options && point.options.dataLabels));
            pointOptions.forEach(function(labelOptions, i) {
              var labelEnabled = labelOptions.enabled && // #2282, #4641, #7112, #10049
              (!point.isNull || point.dataLabelOnNull) && applyFilter(point, labelOptions), connector = point.connectors ? point.connectors[i] : point.connector;
              var labelConfig, formatString, labelText, style, rotation, attr2, dataLabel = point.dataLabels ? point.dataLabels[i] : point.dataLabel;
              var labelDistance = pick$19(labelOptions.distance, point.labelDistance), isNew = !dataLabel;
              if (labelEnabled) {
                labelConfig = point.getLabelConfig();
                formatString = pick$19(labelOptions[point.formatPrefix + "Format"], labelOptions.format);
                labelText = defined$C(formatString) ? format$9(formatString, labelConfig, chart) : (labelOptions[point.formatPrefix + "Formatter"] || labelOptions.formatter).call(labelConfig, labelOptions);
                style = labelOptions.style;
                rotation = labelOptions.rotation;
                if (!chart.styledMode) {
                  style.color = pick$19(labelOptions.color, style.color, series.color, palette.neutralColor100);
                  if (style.color === "contrast") {
                    point.contrastColor = renderer.getContrast(point.color || series.color);
                    style.color = !defined$C(labelDistance) && labelOptions.inside || labelDistance < 0 || !!seriesOptions.stacking ? point.contrastColor : palette.neutralColor100;
                  } else {
                    delete point.contrastColor;
                  }
                  if (seriesOptions.cursor) {
                    style.cursor = seriesOptions.cursor;
                  }
                }
                attr2 = {
                  r: labelOptions.borderRadius || 0,
                  rotation,
                  padding: labelOptions.padding,
                  zIndex: 1
                };
                if (!chart.styledMode) {
                  attr2.fill = labelOptions.backgroundColor;
                  attr2.stroke = labelOptions.borderColor;
                  attr2["stroke-width"] = labelOptions.borderWidth;
                }
                objectEach$h(attr2, function(val, name) {
                  if (typeof val === "undefined") {
                    delete attr2[name];
                  }
                });
              }
              if (dataLabel && (!labelEnabled || !defined$C(labelText))) {
                point.dataLabel = point.dataLabel && point.dataLabel.destroy();
                if (point.dataLabels) {
                  if (point.dataLabels.length === 1) {
                    delete point.dataLabels;
                  } else {
                    delete point.dataLabels[i];
                  }
                }
                if (!i) {
                  delete point.dataLabel;
                }
                if (connector) {
                  point.connector = point.connector.destroy();
                  if (point.connectors) {
                    if (point.connectors.length === 1) {
                      delete point.connectors;
                    } else {
                      delete point.connectors[i];
                    }
                  }
                }
              } else if (labelEnabled && defined$C(labelText)) {
                if (!dataLabel) {
                  point.dataLabels = point.dataLabels || [];
                  dataLabel = point.dataLabels[i] = rotation ? (
                    // Labels don't rotate, use text element
                    renderer.text(labelText, 0, -9999, labelOptions.useHTML).addClass("highcharts-data-label")
                  ) : (
                    // We can use label
                    renderer.label(labelText, 0, -9999, labelOptions.shape, null, null, labelOptions.useHTML, null, "data-label")
                  );
                  if (!i) {
                    point.dataLabel = dataLabel;
                  }
                  dataLabel.addClass(" highcharts-data-label-color-" + point.colorIndex + " " + (labelOptions.className || "") + // #3398
                  (labelOptions.useHTML ? " highcharts-tracker" : ""));
                } else {
                  attr2.text = labelText;
                }
                dataLabel.options = labelOptions;
                dataLabel.attr(attr2);
                if (!chart.styledMode) {
                  dataLabel.css(style).shadow(labelOptions.shadow);
                }
                if (!dataLabel.added) {
                  dataLabel.add(dataLabelsGroup);
                }
                if (labelOptions.textPath && !labelOptions.useHTML) {
                  dataLabel.setTextPath(point.getDataLabelPath && point.getDataLabelPath(dataLabel) || point.graphic, labelOptions.textPath);
                  if (point.dataLabelPath && !labelOptions.textPath.enabled) {
                    point.dataLabelPath = point.dataLabelPath.destroy();
                  }
                }
                series.alignDataLabel(point, dataLabel, labelOptions, null, isNew);
              }
            });
          });
        }
        fireEvent$o(this, "afterDrawDataLabels");
      }
      function justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew) {
        var chart = this.chart, align = options.align, verticalAlign = options.verticalAlign, padding = dataLabel.box ? 0 : dataLabel.padding || 0;
        var _a2 = options.x, x = _a2 === void 0 ? 0 : _a2, _b = options.y, y = _b === void 0 ? 0 : _b, off, justified;
        off = (alignAttr.x || 0) + padding;
        if (off < 0) {
          if (align === "right" && x >= 0) {
            options.align = "left";
            options.inside = true;
          } else {
            x -= off;
          }
          justified = true;
        }
        off = (alignAttr.x || 0) + bBox.width - padding;
        if (off > chart.plotWidth) {
          if (align === "left" && x <= 0) {
            options.align = "right";
            options.inside = true;
          } else {
            x += chart.plotWidth - off;
          }
          justified = true;
        }
        off = alignAttr.y + padding;
        if (off < 0) {
          if (verticalAlign === "bottom" && y >= 0) {
            options.verticalAlign = "top";
            options.inside = true;
          } else {
            y -= off;
          }
          justified = true;
        }
        off = (alignAttr.y || 0) + bBox.height - padding;
        if (off > chart.plotHeight) {
          if (verticalAlign === "top" && y <= 0) {
            options.verticalAlign = "bottom";
            options.inside = true;
          } else {
            y += chart.plotHeight - off;
          }
          justified = true;
        }
        if (justified) {
          options.x = x;
          options.y = y;
          dataLabel.placed = !isNew;
          dataLabel.align(options, void 0, alignTo);
        }
        return justified;
      }
      function mergeArrays(one, two) {
        var res = [], i;
        if (isArray$c(one) && !isArray$c(two)) {
          res = one.map(function(el) {
            return merge$11(el, two);
          });
        } else if (isArray$c(two) && !isArray$c(one)) {
          res = two.map(function(el) {
            return merge$11(one, el);
          });
        } else if (!isArray$c(one) && !isArray$c(two)) {
          res = merge$11(one, two);
        } else {
          i = Math.max(one.length, two.length);
          while (i--) {
            res[i] = merge$11(one[i], two[i]);
          }
        }
        return res;
      }
      function setDataLabelStartPos(point, dataLabel, isNew, isInside, alignOptions) {
        var chart = this.chart, inverted = chart.inverted, xAxis = this.xAxis, reversed = xAxis.reversed, labelCenter = inverted ? dataLabel.height / 2 : dataLabel.width / 2, pointWidth = point.pointWidth, halfWidth = pointWidth ? pointWidth / 2 : 0;
        dataLabel.startXPos = inverted ? alignOptions.x : reversed ? -labelCenter - halfWidth : xAxis.width - labelCenter + halfWidth;
        dataLabel.startYPos = inverted ? reversed ? this.yAxis.height - labelCenter + halfWidth : -labelCenter - halfWidth : alignOptions.y;
        if (!isInside) {
          dataLabel.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, dataLabel.hide);
        } else if (dataLabel.visibility === "hidden") {
          dataLabel.show();
          dataLabel.attr({ opacity: 0 }).animate({ opacity: 1 });
        }
        if (!chart.hasRendered) {
          return;
        }
        if (isNew) {
          dataLabel.attr({ x: dataLabel.startXPos, y: dataLabel.startYPos });
        }
        dataLabel.placed = true;
      }
    })(DataLabel || (DataLabel = {}));
    const DataLabel$1 = DataLabel;
    var Series$d = SeriesRegistry$1.series;
    var merge$10 = Utilities.merge, pick$18 = Utilities.pick;
    var ColumnDataLabel$1;
    (function(ColumnDataLabel2) {
      var composedClasses2 = [];
      function alignDataLabel(point, dataLabel, options, alignTo, isNew) {
        var inverted = this.chart.inverted, series = point.series, dlBox = point.dlBox || point.shapeArgs, below = pick$18(
          point.below,
          // range series
          point.plotY > pick$18(this.translatedThreshold, series.yAxis.len)
        ), inside = pick$18(options.inside, !!this.options.stacking), overshoot;
        if (dlBox) {
          alignTo = merge$10(dlBox);
          if (alignTo.y < 0) {
            alignTo.height += alignTo.y;
            alignTo.y = 0;
          }
          overshoot = alignTo.y + alignTo.height - series.yAxis.len;
          if (overshoot > 0 && overshoot < alignTo.height) {
            alignTo.height -= overshoot;
          }
          if (inverted) {
            alignTo = {
              x: series.yAxis.len - alignTo.y - alignTo.height,
              y: series.xAxis.len - alignTo.x - alignTo.width,
              width: alignTo.height,
              height: alignTo.width
            };
          }
          if (!inside) {
            if (inverted) {
              alignTo.x += below ? 0 : alignTo.width;
              alignTo.width = 0;
            } else {
              alignTo.y += below ? alignTo.height : 0;
              alignTo.height = 0;
            }
          }
        }
        options.align = pick$18(options.align, !inverted || inside ? "center" : below ? "right" : "left");
        options.verticalAlign = pick$18(options.verticalAlign, inverted || inside ? "middle" : below ? "top" : "bottom");
        Series$d.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
        if (options.inside && point.contrastColor) {
          dataLabel.css({
            color: point.contrastColor
          });
        }
      }
      function compose(ColumnSeriesClass) {
        DataLabel$1.compose(Series$d);
        if (composedClasses2.indexOf(ColumnSeriesClass) === -1) {
          composedClasses2.push(ColumnSeriesClass);
          ColumnSeriesClass.prototype.alignDataLabel = alignDataLabel;
        }
      }
      ColumnDataLabel2.compose = compose;
    })(ColumnDataLabel$1 || (ColumnDataLabel$1 = {}));
    const ColumnDataLabel$2 = ColumnDataLabel$1;
    var __extends$P = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var extend$17 = Utilities.extend, merge$$ = Utilities.merge;
    var BarSeries = (
      /** @class */
      function(_super) {
        __extends$P(BarSeries2, _super);
        function BarSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        BarSeries2.defaultOptions = merge$$(ColumnSeries$h.defaultOptions, {
          // nothing here yet
        });
        return BarSeries2;
      }(ColumnSeries$h)
    );
    extend$17(BarSeries.prototype, {
      inverted: true
    });
    SeriesRegistry$1.registerSeriesType("bar", BarSeries);
    var __extends$O = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var addEvent$P = Utilities.addEvent, extend$16 = Utilities.extend, merge$_ = Utilities.merge;
    var ScatterSeries$4 = (
      /** @class */
      function(_super) {
        __extends$O(ScatterSeries2, _super);
        function ScatterSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        ScatterSeries2.prototype.applyJitter = function() {
          var series = this, jitter = this.options.jitter, len = this.points.length;
          function unrandom(seed) {
            var rand = Math.sin(seed) * 1e4;
            return rand - Math.floor(rand);
          }
          if (jitter) {
            this.points.forEach(function(point, i) {
              ["x", "y"].forEach(function(dim, j) {
                var axis, plotProp = "plot" + dim.toUpperCase(), min, max, translatedJitter;
                if (jitter[dim] && !point.isNull) {
                  axis = series[dim + "Axis"];
                  translatedJitter = jitter[dim] * axis.transA;
                  if (axis && !axis.isLog) {
                    min = Math.max(0, point[plotProp] - translatedJitter);
                    max = Math.min(axis.len, point[plotProp] + translatedJitter);
                    point[plotProp] = min + (max - min) * unrandom(i + j * len);
                    if (dim === "x") {
                      point.clientX = point.plotX;
                    }
                  }
                }
              });
            });
          }
        };
        ScatterSeries2.prototype.drawGraph = function() {
          if (this.options.lineWidth) {
            _super.prototype.drawGraph.call(this);
          } else if (this.graph) {
            this.graph = this.graph.destroy();
          }
        };
        ScatterSeries2.defaultOptions = merge$_(LineSeries$5.defaultOptions, {
          /**
           * The width of the line connecting the data points.
           *
           * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-none/
           *         0 by default
           * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-1/
           *         1px
           *
           * @product highcharts highstock
           */
          lineWidth: 0,
          findNearestPointBy: "xy",
          /**
           * Apply a jitter effect for the rendered markers. When plotting
           * discrete values, a little random noise may help telling the points
           * apart. The jitter setting applies a random displacement of up to `n`
           * axis units in either direction. So for example on a horizontal X
           * axis, setting the `jitter.x` to 0.24 will render the point in a
           * random position between 0.24 units to the left and 0.24 units to the
           * right of the true axis position. On a category axis, setting it to
           * 0.5 will fill up the bin and make the data appear continuous.
           *
           * When rendered on top of a box plot or a column series, a jitter value
           * of 0.24 will correspond to the underlying series' default
           * [groupPadding](
           * https://api.highcharts.com/highcharts/plotOptions.column.groupPadding)
           * and [pointPadding](
           * https://api.highcharts.com/highcharts/plotOptions.column.pointPadding)
           * settings.
           *
           * @sample {highcharts} highcharts/series-scatter/jitter
           *         Jitter on a scatter plot
           *
           * @sample {highcharts} highcharts/series-scatter/jitter-boxplot
           *         Jittered scatter plot on top of a box plot
           *
           * @product highcharts highstock
           * @since 7.0.2
           */
          jitter: {
            /**
             * The maximal X offset for the random jitter effect.
             */
            x: 0,
            /**
             * The maximal Y offset for the random jitter effect.
             */
            y: 0
          },
          marker: {
            enabled: true
            // Overrides auto-enabling in line series (#3647)
          },
          /**
           * Sticky tracking of mouse events. When true, the `mouseOut` event
           * on a series isn't triggered until the mouse moves over another
           * series, or out of the plot area. When false, the `mouseOut` event on
           * a series is triggered when the mouse leaves the area around the
           * series' graph or markers. This also implies the tooltip. When
           * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
           * will be hidden when moving the mouse between series.
           *
           * @type      {boolean}
           * @default   false
           * @product   highcharts highstock
           * @apioption plotOptions.scatter.stickyTracking
           */
          /**
           * A configuration object for the tooltip rendering of each single
           * series. Properties are inherited from [tooltip](#tooltip).
           * Overridable properties are `headerFormat`, `pointFormat`,
           * `yDecimals`, `xDateFormat`, `yPrefix` and `ySuffix`. Unlike other
           * series, in a scatter plot the series.name by default shows in the
           * headerFormat and point.x and point.y in the pointFormat.
           *
           * @product highcharts highstock
           */
          tooltip: {
            headerFormat: '<span style="color:{point.color}"></span> <span style="font-size: 10px"> {series.name}</span><br/>',
            pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
          }
        });
        return ScatterSeries2;
      }(LineSeries$5)
    );
    extend$16(ScatterSeries$4.prototype, {
      drawTracker: ColumnSeries$h.prototype.drawTracker,
      sorted: false,
      requireSorting: false,
      noSharedTooltip: true,
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      takeOrdinalPosition: false
      // #2342
    });
    addEvent$P(ScatterSeries$4, "afterTranslate", function() {
      this.applyJitter();
    });
    SeriesRegistry$1.registerSeriesType("scatter", ScatterSeries$4);
    var isNumber$w = Utilities.isNumber, pick$17 = Utilities.pick, relativeLength$6 = Utilities.relativeLength;
    var deg2rad$4 = H.deg2rad;
    var centeredSeriesMixin = H.CenteredSeriesMixin = {
      /**
       * Get the center of the pie based on the size and center options relative
       * to the plot area. Borrowed by the polar and gauge series types.
       *
       * @private
       * @function Highcharts.CenteredSeriesMixin.getCenter
       *
       * @return {Array<number>}
       */
      getCenter: function() {
        var options = this.options, chart = this.chart, slicingRoom = 2 * (options.slicedOffset || 0), handleSlicingRoom, plotWidth = chart.plotWidth - 2 * slicingRoom, plotHeight = chart.plotHeight - 2 * slicingRoom, centerOption = options.center, smallestSize = Math.min(plotWidth, plotHeight), size = options.size, innerSize = options.innerSize || 0, positions, i, value;
        if (typeof size === "string") {
          size = parseFloat(size);
        }
        if (typeof innerSize === "string") {
          innerSize = parseFloat(innerSize);
        }
        positions = [
          pick$17(centerOption[0], "50%"),
          pick$17(centerOption[1], "50%"),
          // Prevent from negative values
          pick$17(size && size < 0 ? void 0 : options.size, "100%"),
          pick$17(innerSize && innerSize < 0 ? void 0 : options.innerSize || 0, "0%")
        ];
        if (chart.angular && !(this instanceof Series$e)) {
          positions[3] = 0;
        }
        for (i = 0; i < 4; ++i) {
          value = positions[i];
          handleSlicingRoom = i < 2 || i === 2 && /%$/.test(value);
          positions[i] = relativeLength$6(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) + (handleSlicingRoom ? slicingRoom : 0);
        }
        if (positions[3] > positions[2]) {
          positions[3] = positions[2];
        }
        return positions;
      },
      /**
       * getStartAndEndRadians - Calculates start and end angles in radians.
       * Used in series types such as pie and sunburst.
       *
       * @private
       * @function Highcharts.CenteredSeriesMixin.getStartAndEndRadians
       *
       * @param {number} [start]
       *        Start angle in degrees.
       *
       * @param {number} [end]
       *        Start angle in degrees.
       *
       * @return {Highcharts.RadianAngles}
       *         Returns an object containing start and end angles as radians.
       */
      getStartAndEndRadians: function(start, end) {
        var startAngle = isNumber$w(start) ? start : 0, endAngle = isNumber$w(end) && // must be a number
        end > startAngle && // must be larger than the start angle
        // difference must be less than 360 degrees
        end - startAngle < 360 ? end : startAngle + 360, correction = -90;
        return {
          start: deg2rad$4 * (startAngle + correction),
          end: deg2rad$4 * (endAngle + correction)
        };
      }
    };
    var __extends$N = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var setAnimation$1 = animationExports.setAnimation;
    var addEvent$O = Utilities.addEvent, defined$B = Utilities.defined, extend$15 = Utilities.extend, isNumber$v = Utilities.isNumber, pick$16 = Utilities.pick, relativeLength$5 = Utilities.relativeLength;
    var PiePoint$3 = (
      /** @class */
      function(_super) {
        __extends$N(PiePoint2, _super);
        function PiePoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.labelDistance = void 0;
          _this.options = void 0;
          _this.series = void 0;
          return _this;
        }
        PiePoint2.prototype.getConnectorPath = function() {
          var labelPosition = this.labelPosition, options = this.series.options.dataLabels, predefinedShapes = this.connectorShapes;
          var connectorShape = options.connectorShape;
          if (predefinedShapes[connectorShape]) {
            connectorShape = predefinedShapes[connectorShape];
          }
          return connectorShape.call(this, {
            // pass simplified label position object for user's convenience
            x: labelPosition.final.x,
            y: labelPosition.final.y,
            alignment: labelPosition.alignment
          }, labelPosition.connectorPosition, options);
        };
        PiePoint2.prototype.getTranslate = function() {
          return this.sliced ? this.slicedTranslation : {
            translateX: 0,
            translateY: 0
          };
        };
        PiePoint2.prototype.haloPath = function(size) {
          var shapeArgs = this.shapeArgs;
          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(shapeArgs.x, shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
            // Substract 1px to ensure the background is not bleeding
            // through between the halo and the slice (#7495).
            innerR: shapeArgs.r - 1,
            start: shapeArgs.start,
            end: shapeArgs.end
          });
        };
        PiePoint2.prototype.init = function() {
          var _this = this;
          _super.prototype.init.apply(this, arguments);
          this.name = pick$16(this.name, "Slice");
          var toggleSlice = function(e2) {
            _this.slice(e2.type === "select");
          };
          addEvent$O(this, "select", toggleSlice);
          addEvent$O(this, "unselect", toggleSlice);
          return this;
        };
        PiePoint2.prototype.isValid = function() {
          return isNumber$v(this.y) && this.y >= 0;
        };
        PiePoint2.prototype.setVisible = function(vis, redraw) {
          var _this = this;
          var series = this.series, chart = series.chart, ignoreHiddenPoint = series.options.ignoreHiddenPoint;
          redraw = pick$16(redraw, ignoreHiddenPoint);
          if (vis !== this.visible) {
            this.visible = this.options.visible = vis = typeof vis === "undefined" ? !this.visible : vis;
            series.options.data[series.data.indexOf(this)] = this.options;
            ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function(key) {
              if (_this[key]) {
                _this[key][vis ? "show" : "hide"](vis);
              }
            });
            if (this.legendItem) {
              chart.legend.colorizeItem(this, vis);
            }
            if (!vis && this.state === "hover") {
              this.setState("");
            }
            if (ignoreHiddenPoint) {
              series.isDirty = true;
            }
            if (redraw) {
              chart.redraw();
            }
          }
        };
        PiePoint2.prototype.slice = function(sliced, redraw, animation) {
          var series = this.series, chart = series.chart;
          setAnimation$1(animation, chart);
          redraw = pick$16(redraw, true);
          this.sliced = this.options.sliced = sliced = defined$B(sliced) ? sliced : !this.sliced;
          series.options.data[series.data.indexOf(this)] = this.options;
          if (this.graphic) {
            this.graphic.animate(this.getTranslate());
          }
          if (this.shadowGroup) {
            this.shadowGroup.animate(this.getTranslate());
          }
        };
        return PiePoint2;
      }(Point$2)
    );
    extend$15(PiePoint$3.prototype, {
      connectorShapes: {
        // only one available before v7.0.0
        fixedOffset: function(labelPosition, connectorPosition, options) {
          var breakAt = connectorPosition.breakAt, touchingSliceAt = connectorPosition.touchingSliceAt, lineSegment = options.softConnector ? [
            "C",
            // 1st control point (of the curve)
            labelPosition.x + // 5 gives the connector a little horizontal bend
            (labelPosition.alignment === "left" ? -5 : 5),
            labelPosition.y,
            2 * breakAt.x - touchingSliceAt.x,
            2 * breakAt.y - touchingSliceAt.y,
            breakAt.x,
            breakAt.y
            //
          ] : [
            "L",
            breakAt.x,
            breakAt.y
          ];
          return [
            ["M", labelPosition.x, labelPosition.y],
            lineSegment,
            ["L", touchingSliceAt.x, touchingSliceAt.y]
          ];
        },
        straight: function(labelPosition, connectorPosition) {
          var touchingSliceAt = connectorPosition.touchingSliceAt;
          return [
            ["M", labelPosition.x, labelPosition.y],
            ["L", touchingSliceAt.x, touchingSliceAt.y]
          ];
        },
        crookedLine: function(labelPosition, connectorPosition, options) {
          var touchingSliceAt = connectorPosition.touchingSliceAt, series = this.series, pieCenterX = series.center[0], plotWidth = series.chart.plotWidth, plotLeft = series.chart.plotLeft, alignment = labelPosition.alignment, radius = this.shapeArgs.r, crookDistance = relativeLength$5(
            // % to fraction
            options.crookDistance,
            1
          ), crookX = alignment === "left" ? pieCenterX + radius + (plotWidth + plotLeft - pieCenterX - radius) * (1 - crookDistance) : plotLeft + (pieCenterX - radius) * crookDistance, segmentWithCrook = [
            "L",
            crookX,
            labelPosition.y
          ];
          var useCrook = true;
          if (alignment === "left" ? crookX > labelPosition.x || crookX < touchingSliceAt.x : crookX < labelPosition.x || crookX > touchingSliceAt.x) {
            useCrook = false;
          }
          var path = [["M", labelPosition.x, labelPosition.y]];
          if (useCrook) {
            path.push(segmentWithCrook);
          }
          path.push(["L", touchingSliceAt.x, touchingSliceAt.y]);
          return path;
        }
      }
    });
    var __extends$M = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var getStartAndEndRadians = centeredSeriesMixin.getStartAndEndRadians;
    var noop$g = H.noop;
    var clamp$c = Utilities.clamp, extend$14 = Utilities.extend, fireEvent$n = Utilities.fireEvent, merge$Z = Utilities.merge, pick$15 = Utilities.pick, relativeLength$4 = Utilities.relativeLength;
    var PieSeries$3 = (
      /** @class */
      function(_super) {
        __extends$M(PieSeries2, _super);
        function PieSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.center = void 0;
          _this.data = void 0;
          _this.maxLabelDistance = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        PieSeries2.prototype.animate = function(init) {
          var series = this, points = series.points, startAngleRad = series.startAngleRad;
          if (!init) {
            points.forEach(function(point) {
              var graphic = point.graphic, args = point.shapeArgs;
              if (graphic && args) {
                graphic.attr({
                  // animate from inner radius (#779)
                  r: pick$15(point.startR, series.center && series.center[3] / 2),
                  start: startAngleRad,
                  end: startAngleRad
                });
                graphic.animate({
                  r: args.r,
                  start: args.start,
                  end: args.end
                }, series.options.animation);
              }
            });
          }
        };
        PieSeries2.prototype.drawEmpty = function() {
          var start = this.startAngleRad, end = this.endAngleRad, options = this.options;
          var centerX, centerY;
          if (this.total === 0 && this.center) {
            centerX = this.center[0];
            centerY = this.center[1];
            if (!this.graph) {
              this.graph = this.chart.renderer.arc(centerX, centerY, this.center[1] / 2, 0, start, end).addClass("highcharts-empty-series").add(this.group);
            }
            this.graph.attr({
              d: Symbols.arc(centerX, centerY, this.center[2] / 2, 0, {
                start,
                end,
                innerR: this.center[3] / 2
              })
            });
            if (!this.chart.styledMode) {
              this.graph.attr({
                "stroke-width": options.borderWidth,
                fill: options.fillColor || "none",
                stroke: options.color || palette.neutralColor20
              });
            }
          } else if (this.graph) {
            this.graph = this.graph.destroy();
          }
        };
        PieSeries2.prototype.drawPoints = function() {
          var renderer = this.chart.renderer;
          this.points.forEach(function(point) {
            if (point.graphic && point.hasNewShapeType()) {
              point.graphic = point.graphic.destroy();
            }
            if (!point.graphic) {
              point.graphic = renderer[point.shapeType](point.shapeArgs).add(point.series.group);
              point.delayedRendering = true;
            }
          });
        };
        PieSeries2.prototype.generatePoints = function() {
          _super.prototype.generatePoints.call(this);
          this.updateTotals();
        };
        PieSeries2.prototype.getX = function(y, left, point) {
          var center = this.center, radius = this.radii ? this.radii[point.index] || 0 : center[2] / 2;
          var angle = Math.asin(clamp$c((y - center[1]) / (radius + point.labelDistance), -1, 1));
          var x = center[0] + (left ? -1 : 1) * (Math.cos(angle) * (radius + point.labelDistance)) + (point.labelDistance > 0 ? (left ? -1 : 1) * this.options.dataLabels.padding : 0);
          return x;
        };
        PieSeries2.prototype.hasData = function() {
          return !!this.processedXData.length;
        };
        PieSeries2.prototype.redrawPoints = function() {
          var series = this, chart = series.chart, renderer = chart.renderer, shadow = series.options.shadow;
          var groupTranslation, graphic, pointAttr, shapeArgs;
          this.drawEmpty();
          if (shadow && !series.shadowGroup && !chart.styledMode) {
            series.shadowGroup = renderer.g("shadow").attr({ zIndex: -1 }).add(series.group);
          }
          series.points.forEach(function(point) {
            var animateTo = {};
            graphic = point.graphic;
            if (!point.isNull && graphic) {
              var shadowGroup = void 0;
              shapeArgs = point.shapeArgs;
              groupTranslation = point.getTranslate();
              if (!chart.styledMode) {
                shadowGroup = point.shadowGroup;
                if (shadow && !shadowGroup) {
                  shadowGroup = point.shadowGroup = renderer.g("shadow").add(series.shadowGroup);
                }
                if (shadowGroup) {
                  shadowGroup.attr(groupTranslation);
                }
                pointAttr = series.pointAttribs(point, point.selected && "select");
              }
              if (!point.delayedRendering) {
                graphic.setRadialReference(series.center);
                if (!chart.styledMode) {
                  merge$Z(true, animateTo, pointAttr);
                }
                merge$Z(true, animateTo, shapeArgs, groupTranslation);
                graphic.animate(animateTo);
              } else {
                graphic.setRadialReference(series.center).attr(shapeArgs).attr(groupTranslation);
                if (!chart.styledMode) {
                  graphic.attr(pointAttr).attr({ "stroke-linejoin": "round" }).shadow(shadow, shadowGroup);
                }
                point.delayedRendering = false;
              }
              graphic.attr({
                visibility: point.visible ? "inherit" : "hidden"
              });
              graphic.addClass(point.getClassName(), true);
            } else if (graphic) {
              point.graphic = graphic.destroy();
            }
          });
        };
        PieSeries2.prototype.sortByAngle = function(points, sign) {
          points.sort(function(a, b) {
            return typeof a.angle !== "undefined" && (b.angle - a.angle) * sign;
          });
        };
        PieSeries2.prototype.translate = function(positions) {
          this.generatePoints();
          var series = this, precision = 1e3, options = series.options, slicedOffset = options.slicedOffset, connectorOffset = slicedOffset + (options.borderWidth || 0), radians = getStartAndEndRadians(options.startAngle, options.endAngle), startAngleRad = series.startAngleRad = radians.start, endAngleRad = series.endAngleRad = radians.end, circ = endAngleRad - startAngleRad, points = series.points, labelDistance = options.dataLabels.distance, ignoreHiddenPoint = options.ignoreHiddenPoint, len = points.length;
          var finalConnectorOffset, start, end, angle, radiusX, radiusY, i, point, cumulative = 0;
          if (!positions) {
            series.center = positions = series.getCenter();
          }
          for (i = 0; i < len; i++) {
            point = points[i];
            start = startAngleRad + cumulative * circ;
            if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
              cumulative += point.percentage / 100;
            }
            end = startAngleRad + cumulative * circ;
            var shapeArgs = {
              x: positions[0],
              y: positions[1],
              r: positions[2] / 2,
              innerR: positions[3] / 2,
              start: Math.round(start * precision) / precision,
              end: Math.round(end * precision) / precision
            };
            point.shapeType = "arc";
            point.shapeArgs = shapeArgs;
            point.labelDistance = pick$15(point.options.dataLabels && point.options.dataLabels.distance, labelDistance);
            point.labelDistance = relativeLength$4(point.labelDistance, shapeArgs.r);
            series.maxLabelDistance = Math.max(series.maxLabelDistance || 0, point.labelDistance);
            angle = (end + start) / 2;
            if (angle > 1.5 * Math.PI) {
              angle -= 2 * Math.PI;
            } else if (angle < -Math.PI / 2) {
              angle += 2 * Math.PI;
            }
            point.slicedTranslation = {
              translateX: Math.round(Math.cos(angle) * slicedOffset),
              translateY: Math.round(Math.sin(angle) * slicedOffset)
            };
            radiusX = Math.cos(angle) * positions[2] / 2;
            radiusY = Math.sin(angle) * positions[2] / 2;
            point.tooltipPos = [
              positions[0] + radiusX * 0.7,
              positions[1] + radiusY * 0.7
            ];
            point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
            point.angle = angle;
            finalConnectorOffset = Math.min(connectorOffset, point.labelDistance / 5);
            point.labelPosition = {
              natural: {
                // initial position of the data label - it's utilized for
                // finding the final position for the label
                x: positions[0] + radiusX + Math.cos(angle) * point.labelDistance,
                y: positions[1] + radiusY + Math.sin(angle) * point.labelDistance
              },
              "final": {
                // used for generating connector path -
                // initialized later in drawDataLabels function
                // x: undefined,
                // y: undefined
              },
              // left - pie on the left side of the data label
              // right - pie on the right side of the data label
              // center - data label overlaps the pie
              alignment: point.labelDistance < 0 ? "center" : point.half ? "right" : "left",
              connectorPosition: {
                breakAt: {
                  x: positions[0] + radiusX + Math.cos(angle) * finalConnectorOffset,
                  y: positions[1] + radiusY + Math.sin(angle) * finalConnectorOffset
                },
                touchingSliceAt: {
                  x: positions[0] + radiusX,
                  y: positions[1] + radiusY
                }
              }
            };
          }
          fireEvent$n(series, "afterTranslate");
        };
        PieSeries2.prototype.updateTotals = function() {
          var points = this.points, len = points.length, ignoreHiddenPoint = this.options.ignoreHiddenPoint;
          var i, point, total = 0;
          for (i = 0; i < len; i++) {
            point = points[i];
            if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
              total += point.y;
            }
          }
          this.total = total;
          for (i = 0; i < len; i++) {
            point = points[i];
            point.percentage = total > 0 && (point.visible || !ignoreHiddenPoint) ? point.y / total * 100 : 0;
            point.total = total;
          }
        };
        PieSeries2.defaultOptions = merge$Z(Series$e.defaultOptions, {
          /**
           * @excluding legendItemClick
           * @apioption plotOptions.pie.events
           */
          /**
           * Fires when the checkbox next to the point name in the legend is
           * clicked. One parameter, event, is passed to the function. The state
           * of the checkbox is found by event.checked. The checked item is found
           * by event.item. Return false to prevent the default action which is to
           * toggle the select state of the series.
           *
           * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
           *         Alert checkbox status
           *
           * @type      {Function}
           * @since     1.2.0
           * @product   highcharts
           * @context   Highcharts.Point
           * @apioption plotOptions.pie.events.checkboxClick
           */
          /**
           * Fires when the legend item belonging to the pie point (slice) is
           * clicked. The `this` keyword refers to the point itself. One
           * parameter, `event`, is passed to the function, containing common
           * event information. The default action is to toggle the visibility of
           * the point. This can be prevented by calling `event.preventDefault()`.
           *
           * @sample {highcharts} highcharts/plotoptions/pie-point-events-legenditemclick/
           *         Confirm toggle visibility
           *
           * @type      {Highcharts.PointLegendItemClickCallbackFunction}
           * @since     1.2.0
           * @product   highcharts
           * @apioption plotOptions.pie.point.events.legendItemClick
           */
          /**
           * The center of the pie chart relative to the plot area. Can be
           * percentages or pixel values. The default behaviour (as of 3.0) is to
           * center the pie so that all slices and data labels are within the plot
           * area. As a consequence, the pie may actually jump around in a chart
           * with dynamic values, as the data labels move. In that case, the
           * center should be explicitly set, for example to `["50%", "50%"]`.
           *
           * @sample {highcharts} highcharts/plotoptions/pie-center/
           *         Centered at 100, 100
           *
           * @type    {Array<(number|string|null),(number|string|null)>}
           * @default [null, null]
           * @product highcharts
           *
           * @private
           */
          center: [null, null],
          /**
           * The color of the pie series. A pie series is represented as an empty
           * circle if the total sum of its values is 0. Use this property to
           * define the color of its border.
           *
           * In styled mode, the color can be defined by the
           * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
           * color can be set with the `.highcharts-series`,
           * `.highcharts-color-{n}`, `.highcharts-{type}-series` or
           * `.highcharts-series-{n}` class, or individual classes given by the
           * `className` option.
           *
           * @sample {highcharts} highcharts/plotoptions/pie-emptyseries/
           *         Empty pie series
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default   ${palette.neutralColor20}
           * @apioption plotOptions.pie.color
           */
          /**
           * @product highcharts
           *
           * @private
           */
          clip: false,
          /**
           * @ignore-option
           *
           * @private
           */
          colorByPoint: true,
          /**
           * A series specific or series type specific color set to use instead
           * of the global [colors](#colors).
           *
           * @sample {highcharts} highcharts/demo/pie-monochrome/
           *         Set default colors for all pies
           *
           * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
           * @since     3.0
           * @product   highcharts
           * @apioption plotOptions.pie.colors
           */
          /**
           * @declare   Highcharts.SeriesPieDataLabelsOptionsObject
           * @extends   plotOptions.series.dataLabels
           * @excluding align, allowOverlap, inside, staggerLines, step
           * @private
           */
          dataLabels: {
            /**
             * Alignment method for data labels. Possible values are:
             *
             * - `toPlotEdges`: Each label touches the nearest vertical edge of
             *   the plot area.
             *
             * - `connectors`: Connectors have the same x position and the
             *   widest label of each half (left & right) touches the nearest
             *   vertical edge of the plot area.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-alignto-connectors/
             *         alignTo: connectors
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-alignto-plotedges/
             *         alignTo: plotEdges
             *
             * @type      {string}
             * @since     7.0.0
             * @product   highcharts
             * @apioption plotOptions.pie.dataLabels.alignTo
             */
            allowOverlap: true,
            /**
             * The color of the line connecting the data label to the pie slice.
             * The default color is the same as the point's color.
             *
             * In styled mode, the connector stroke is given in the
             * `.highcharts-data-label-connector` class.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorcolor/
             *         Blue connectors
             * @sample {highcharts} highcharts/css/pie-point/
             *         Styled connectors
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @since     2.1
             * @product   highcharts
             * @apioption plotOptions.pie.dataLabels.connectorColor
             */
            /**
             * The distance from the data label to the connector. Note that
             * data labels also have a default `padding`, so in order for the
             * connector to touch the text, the `padding` must also be 0.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorpadding/
             *         No padding
             *
             * @since   2.1
             * @product highcharts
             */
            connectorPadding: 5,
            /**
             * Specifies the method that is used to generate the connector path.
             * Highcharts provides 3 built-in connector shapes: `'fixedOffset'`
             * (default), `'straight'` and `'crookedLine'`. Using
             * `'crookedLine'` has the most sense (in most of the cases) when
             * `'alignTo'` is set.
             *
             * Users can provide their own method by passing a function instead
             * of a String. 3 arguments are passed to the callback:
             *
             * - Object that holds the information about the coordinates of the
             *   label (`x` & `y` properties) and how the label is located in
             *   relation to the pie (`alignment` property). `alignment` can by
             *   one of the following:
             *   `'left'` (pie on the left side of the data label),
             *   `'right'` (pie on the right side of the data label) or
             *   `'center'` (data label overlaps the pie).
             *
             * - Object that holds the information about the position of the
             *   connector. Its `touchingSliceAt`  porperty tells the position
             *   of the place where the connector touches the slice.
             *
             * - Data label options
             *
             * The function has to return an SVG path definition in array form
             * (see the example).
             *
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorshape-string/
             *         connectorShape is a String
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorshape-function/
             *         connectorShape is a function
             *
             * @type    {string|Function}
             * @since   7.0.0
             * @product highcharts
             */
            connectorShape: "fixedOffset",
            /**
             * The width of the line connecting the data label to the pie slice.
             *
             * In styled mode, the connector stroke width is given in the
             * `.highcharts-data-label-connector` class.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorwidth-disabled/
             *         Disable the connector
             * @sample {highcharts} highcharts/css/pie-point/
             *         Styled connectors
             *
             * @type      {number}
             * @default   1
             * @since     2.1
             * @product   highcharts
             * @apioption plotOptions.pie.dataLabels.connectorWidth
             */
            /**
             * Works only if `connectorShape` is `'crookedLine'`. It defines how
             * far from the vertical plot edge the coonnector path should be
             * crooked.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-crookdistance/
             *         crookDistance set to 90%
             *
             * @since   7.0.0
             * @product highcharts
             */
            crookDistance: "70%",
            /**
             * The distance of the data label from the pie's edge. Negative
             * numbers put the data label on top of the pie slices. Can also be
             * defined as a percentage of pie's radius. Connectors are only
             * shown for data labels outside the pie.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-distance/
             *         Data labels on top of the pie
             *
             * @type    {number|string}
             * @since   2.1
             * @product highcharts
             */
            distance: 30,
            enabled: true,
            /**
             * A
             * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
             * for the data label. Available variables are the same as for
             * `formatter`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
             *         Add a unit
             *
             * @type      {string}
             * @default   undefined
             * @since     3.0
             * @apioption plotOptions.pie.dataLabels.format
             */
            // eslint-disable-next-line valid-jsdoc
            /**
             * Callback JavaScript function to format the data label. Note that
             * if a `format` is defined, the format takes precedence and the
             * formatter is ignored.
             *
             * @type {Highcharts.DataLabelsFormatterCallbackFunction}
             * @default function () { return this.point.isNull ? void 0 : this.point.name; }
             */
            formatter: function() {
              return this.point.isNull ? void 0 : this.point.name;
            },
            /**
             * Whether to render the connector as a soft arc or a line with
             * sharp break. Works only if `connectorShape` equals to
             * `fixedOffset`.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-softconnector-true/
             *         Soft
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-softconnector-false/
             *         Non soft
             *
             * @since   2.1.7
             * @product highcharts
             */
            softConnector: true,
            /**
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow
             *         Long labels truncated with an ellipsis
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow-wrap
             *         Long labels are wrapped
             *
             * @type      {Highcharts.CSSObject}
             * @apioption plotOptions.pie.dataLabels.style
             */
            x: 0
          },
          /**
           * If the total sum of the pie's values is 0, the series is represented
           * as an empty circle . The `fillColor` option defines the color of that
           * circle. Use [pie.borderWidth](#plotOptions.pie.borderWidth) to set
           * the border thickness.
           *
           * @sample {highcharts} highcharts/plotoptions/pie-emptyseries/
           *         Empty pie series
           *
           * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @private
           */
          fillColor: void 0,
          /**
           * The end angle of the pie in degrees where 0 is top and 90 is right.
           * Defaults to `startAngle` plus 360.
           *
           * @sample {highcharts} highcharts/demo/pie-semi-circle/
           *         Semi-circle donut
           *
           * @type      {number}
           * @since     1.3.6
           * @product   highcharts
           * @apioption plotOptions.pie.endAngle
           */
          /**
           * Equivalent to [chart.ignoreHiddenSeries](#chart.ignoreHiddenSeries),
           * this option tells whether the series shall be redrawn as if the
           * hidden point were `null`.
           *
           * The default value changed from `false` to `true` with Highcharts
           * 3.0.
           *
           * @sample {highcharts} highcharts/plotoptions/pie-ignorehiddenpoint/
           *         True, the hiddden point is ignored
           *
           * @since   2.3.0
           * @product highcharts
           *
           * @private
           */
          ignoreHiddenPoint: true,
          /**
           * @ignore-option
           *
           * @private
           */
          inactiveOtherPoints: true,
          /**
           * The size of the inner diameter for the pie. A size greater than 0
           * renders a donut chart. Can be a percentage or pixel value.
           * Percentages are relative to the pie size. Pixel values are given as
           * integers.
           *
           *
           * Note: in Highcharts < 4.1.2, the percentage was relative to the plot
           * area, not the pie size.
           *
           * @sample {highcharts} highcharts/plotoptions/pie-innersize-80px/
           *         80px inner size
           * @sample {highcharts} highcharts/plotoptions/pie-innersize-50percent/
           *         50% of the plot area
           * @sample {highcharts} highcharts/demo/3d-pie-donut/
           *         3D donut
           *
           * @type      {number|string}
           * @default   0
           * @since     2.0
           * @product   highcharts
           * @apioption plotOptions.pie.innerSize
           */
          /**
           * @ignore-option
           *
           * @private
           */
          legendType: "point",
          /**
           * @ignore-option
           *
           * @private
           */
          marker: null,
          /**
           * The minimum size for a pie in response to auto margins. The pie will
           * try to shrink to make room for data labels in side the plot area,
           *  but only to this size.
           *
           * @type      {number|string}
           * @default   80
           * @since     3.0
           * @product   highcharts
           * @apioption plotOptions.pie.minSize
           */
          /**
           * The diameter of the pie relative to the plot area. Can be a
           * percentage or pixel value. Pixel values are given as integers. The
           * default behaviour (as of 3.0) is to scale to the plot area and give
           * room for data labels within the plot area.
           * [slicedOffset](#plotOptions.pie.slicedOffset) is also included in the
           * default size calculation. As a consequence, the size of the pie may
           * vary when points are updated and data labels more around. In that
           * case it is best to set a fixed value, for example `"75%"`.
           *
           * @sample {highcharts} highcharts/plotoptions/pie-size/
           *         Smaller pie
           *
           * @type    {number|string|null}
           * @product highcharts
           *
           * @private
           */
          size: null,
          /**
           * Whether to display this particular series or series type in the
           * legend. Since 2.1, pies are not shown in the legend by default.
           *
           * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
           *         One series in the legend, one hidden
           *
           * @product highcharts
           *
           * @private
           */
          showInLegend: false,
          /**
           * If a point is sliced, moved out from the center, how many pixels
           * should it be moved?.
           *
           * @sample {highcharts} highcharts/plotoptions/pie-slicedoffset-20/
           *         20px offset
           *
           * @product highcharts
           *
           * @private
           */
          slicedOffset: 10,
          /**
           * The start angle of the pie slices in degrees where 0 is top and 90
           * right.
           *
           * @sample {highcharts} highcharts/plotoptions/pie-startangle-90/
           *         Start from right
           *
           * @type      {number}
           * @default   0
           * @since     2.3.4
           * @product   highcharts
           * @apioption plotOptions.pie.startAngle
           */
          /**
           * Sticky tracking of mouse events. When true, the `mouseOut` event
           * on a series isn't triggered until the mouse moves over another
           * series, or out of the plot area. When false, the `mouseOut` event on
           * a series is triggered when the mouse leaves the area around the
           * series'  graph or markers. This also implies the tooltip. When
           * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
           * will be hidden when moving the mouse between series.
           *
           * @product highcharts
           *
           * @private
           */
          stickyTracking: false,
          tooltip: {
            followPointer: true
          },
          /**
           * The color of the border surrounding each slice. When `null`, the
           * border takes the same color as the slice fill. This can be used
           * together with a `borderWidth` to fill drawing gaps created by
           * antialiazing artefacts in borderless pies.
           *
           * In styled mode, the border stroke is given in the `.highcharts-point`
           * class.
           *
           * @sample {highcharts} highcharts/plotoptions/pie-bordercolor-black/
           *         Black border
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default #ffffff
           * @product highcharts
           *
           * @private
           */
          borderColor: palette.backgroundColor,
          /**
           * The width of the border surrounding each slice.
           *
           * When setting the border width to 0, there may be small gaps between
           * the slices due to SVG antialiasing artefacts. To work around this,
           * keep the border width at 0.5 or 1, but set the `borderColor` to
           * `null` instead.
           *
           * In styled mode, the border stroke width is given in the
           * `.highcharts-point` class.
           *
           * @sample {highcharts} highcharts/plotoptions/pie-borderwidth/
           *         3px border
           *
           * @product highcharts
           *
           * @private
           */
          borderWidth: 1,
          /**
           * @ignore-options
           * @private
           */
          lineWidth: void 0,
          states: {
            /**
             * @extends   plotOptions.series.states.hover
             * @excluding marker, lineWidth, lineWidthPlus
             * @product   highcharts
             */
            hover: {
              /**
               * How much to brighten the point on interaction. Requires the
               * main color to be defined in hex or rgb(a) format.
               *
               * In styled mode, the hover brightness is by default replaced
               * by a fill-opacity given in the `.highcharts-point-hover`
               * class.
               *
               * @sample {highcharts} highcharts/plotoptions/pie-states-hover-brightness/
               *         Brightened by 0.5
               *
               * @product highcharts
               */
              brightness: 0.1
            }
          }
        });
        return PieSeries2;
      }(Series$e)
    );
    extend$14(PieSeries$3.prototype, {
      axisTypes: [],
      directTouch: true,
      drawGraph: void 0,
      drawLegendSymbol: LegendSymbol$1.drawRectangle,
      drawTracker: ColumnSeries$h.prototype.drawTracker,
      getCenter: centeredSeriesMixin.getCenter,
      getSymbol: noop$g,
      isCartesian: false,
      noSharedTooltip: true,
      pointAttribs: ColumnSeries$h.prototype.pointAttribs,
      pointClass: PiePoint$3,
      requireSorting: false,
      searchPoint: noop$g,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    SeriesRegistry$1.registerSeriesType("pie", PieSeries$3);
    var noop$f = H.noop;
    var distribute$1 = R.distribute;
    var Series$c = SeriesRegistry$1.series;
    var arrayMax$6 = Utilities.arrayMax, clamp$b = Utilities.clamp, defined$A = Utilities.defined, merge$Y = Utilities.merge, pick$14 = Utilities.pick, relativeLength$3 = Utilities.relativeLength;
    var ColumnDataLabel;
    (function(ColumnDataLabel2) {
      var composedClasses2 = [];
      var dataLabelPositioners = {
        // Based on the value computed in Highcharts' distribute algorithm.
        radialDistributionY: function(point) {
          return point.top + point.distributeBox.pos;
        },
        // get the x - use the natural x position for labels near the
        // top and bottom, to prevent the top and botton slice
        // connectors from touching each other on either side
        // Based on the value computed in Highcharts' distribute algorithm.
        radialDistributionX: function(series, point, y, naturalY) {
          return series.getX(y < point.top + 2 || y > point.bottom - 2 ? naturalY : y, point.half, point);
        },
        // dataLabels.distance determines the x position of the label
        justify: function(point, radius, seriesCenter) {
          return seriesCenter[0] + (point.half ? -1 : 1) * (radius + point.labelDistance);
        },
        // Left edges of the left-half labels touch the left edge of the plot
        // area. Right edges of the right-half labels touch the right edge of
        // the plot area.
        alignToPlotEdges: function(dataLabel, half, plotWidth, plotLeft) {
          var dataLabelWidth = dataLabel.getBBox().width;
          return half ? dataLabelWidth + plotLeft : plotWidth - dataLabelWidth - plotLeft;
        },
        // Connectors of each side end in the same x position. Labels are
        // aligned to them. Left edge of the widest left-half label touches the
        // left edge of the plot area. Right edge of the widest right-half label
        // touches the right edge of the plot area.
        alignToConnectors: function(points, half, plotWidth, plotLeft) {
          var maxDataLabelWidth = 0, dataLabelWidth;
          points.forEach(function(point) {
            dataLabelWidth = point.dataLabel.getBBox().width;
            if (dataLabelWidth > maxDataLabelWidth) {
              maxDataLabelWidth = dataLabelWidth;
            }
          });
          return half ? maxDataLabelWidth + plotLeft : plotWidth - maxDataLabelWidth - plotLeft;
        }
      };
      function compose(PieSeriesClass) {
        DataLabel$1.compose(Series$c);
        if (composedClasses2.indexOf(PieSeriesClass) === -1) {
          composedClasses2.push(PieSeriesClass);
          var pieProto2 = PieSeriesClass.prototype;
          pieProto2.dataLabelPositioners = dataLabelPositioners;
          pieProto2.alignDataLabel = noop$f;
          pieProto2.drawDataLabels = drawDataLabels;
          pieProto2.placeDataLabels = placeDataLabels;
          pieProto2.verifyDataLabelOverflow = verifyDataLabelOverflow;
        }
      }
      ColumnDataLabel2.compose = compose;
      function drawDataLabels() {
        var series = this, data = series.data, chart = series.chart, options = series.options.dataLabels || {}, connectorPadding = options.connectorPadding, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotLeft = chart.plotLeft, maxWidth = Math.round(chart.chartWidth / 3), seriesCenter = series.center, radius = seriesCenter[2] / 2, centerY = seriesCenter[1], halves = [
          [],
          []
          // left
        ], overflow = [0, 0, 0, 0], dataLabelPositioners2 = series.dataLabelPositioners;
        var point, connectorWidth, connector, dataLabel, dataLabelWidth, labelPosition, labelHeight, x, y, visibility, j, pointDataLabelsOptions;
        if (!series.visible || !options.enabled && !series._hasPointLabels) {
          return;
        }
        data.forEach(function(point2) {
          if (point2.dataLabel && point2.visible && point2.dataLabel.shortened) {
            point2.dataLabel.attr({
              width: "auto"
            }).css({
              width: "auto",
              textOverflow: "clip"
            });
            point2.dataLabel.shortened = false;
          }
        });
        Series$c.prototype.drawDataLabels.apply(series);
        data.forEach(function(point2) {
          if (point2.dataLabel) {
            if (point2.visible) {
              halves[point2.half].push(point2);
              point2.dataLabel._pos = null;
              if (!defined$A(options.style.width) && !defined$A(point2.options.dataLabels && point2.options.dataLabels.style && point2.options.dataLabels.style.width)) {
                if (point2.dataLabel.getBBox().width > maxWidth) {
                  point2.dataLabel.css({
                    // Use a fraction of the maxWidth to avoid
                    // wrapping close to the end of the string.
                    width: Math.round(maxWidth * 0.7) + "px"
                  });
                  point2.dataLabel.shortened = true;
                }
              }
            } else {
              point2.dataLabel = point2.dataLabel.destroy();
              if (point2.dataLabels && point2.dataLabels.length === 1) {
                delete point2.dataLabels;
              }
            }
          }
        });
        halves.forEach(function(points, i) {
          var length = points.length, positions = [];
          var top, bottom, naturalY, sideOverflow, size, distributionLength;
          if (!length) {
            return;
          }
          series.sortByAngle(points, i - 0.5);
          if (series.maxLabelDistance > 0) {
            top = Math.max(0, centerY - radius - series.maxLabelDistance);
            bottom = Math.min(centerY + radius + series.maxLabelDistance, chart.plotHeight);
            points.forEach(function(point2) {
              if (point2.labelDistance > 0 && point2.dataLabel) {
                point2.top = Math.max(0, centerY - radius - point2.labelDistance);
                point2.bottom = Math.min(centerY + radius + point2.labelDistance, chart.plotHeight);
                size = point2.dataLabel.getBBox().height || 21;
                point2.distributeBox = {
                  target: point2.labelPosition.natural.y - point2.top + size / 2,
                  size,
                  rank: point2.y
                };
                positions.push(point2.distributeBox);
              }
            });
            distributionLength = bottom + size - top;
            distribute$1(positions, distributionLength, distributionLength / 5);
          }
          for (j = 0; j < length; j++) {
            point = points[j];
            labelPosition = point.labelPosition;
            dataLabel = point.dataLabel;
            visibility = point.visible === false ? "hidden" : "inherit";
            naturalY = labelPosition.natural.y;
            y = naturalY;
            if (positions && defined$A(point.distributeBox)) {
              if (typeof point.distributeBox.pos === "undefined") {
                visibility = "hidden";
              } else {
                labelHeight = point.distributeBox.size;
                y = dataLabelPositioners2.radialDistributionY(point);
              }
            }
            delete point.positionIndex;
            if (options.justify) {
              x = dataLabelPositioners2.justify(point, radius, seriesCenter);
            } else {
              switch (options.alignTo) {
                case "connectors":
                  x = dataLabelPositioners2.alignToConnectors(points, i, plotWidth, plotLeft);
                  break;
                case "plotEdges":
                  x = dataLabelPositioners2.alignToPlotEdges(dataLabel, i, plotWidth, plotLeft);
                  break;
                default:
                  x = dataLabelPositioners2.radialDistributionX(series, point, y, naturalY);
              }
            }
            dataLabel._attr = {
              visibility,
              align: labelPosition.alignment
            };
            pointDataLabelsOptions = point.options.dataLabels || {};
            dataLabel._pos = {
              x: x + pick$14(pointDataLabelsOptions.x, options.x) + // (#12985)
              ({
                left: connectorPadding,
                right: -connectorPadding
              }[labelPosition.alignment] || 0),
              // 10 is for the baseline (label vs text)
              y: y + pick$14(pointDataLabelsOptions.y, options.y) - // (#12985)
              10
            };
            labelPosition.final.x = x;
            labelPosition.final.y = y;
            if (pick$14(options.crop, true)) {
              dataLabelWidth = dataLabel.getBBox().width;
              sideOverflow = null;
              if (x - dataLabelWidth < connectorPadding && i === 1) {
                sideOverflow = Math.round(dataLabelWidth - x + connectorPadding);
                overflow[3] = Math.max(sideOverflow, overflow[3]);
              } else if (x + dataLabelWidth > plotWidth - connectorPadding && i === 0) {
                sideOverflow = Math.round(x + dataLabelWidth - plotWidth + connectorPadding);
                overflow[1] = Math.max(sideOverflow, overflow[1]);
              }
              if (y - labelHeight / 2 < 0) {
                overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0]);
              } else if (y + labelHeight / 2 > plotHeight) {
                overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2]);
              }
              dataLabel.sideOverflow = sideOverflow;
            }
          }
        });
        if (arrayMax$6(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
          this.placeDataLabels();
          this.points.forEach(function(point2) {
            pointDataLabelsOptions = merge$Y(options, point2.options.dataLabels);
            connectorWidth = pick$14(pointDataLabelsOptions.connectorWidth, 1);
            if (connectorWidth) {
              var isNew = void 0;
              connector = point2.connector;
              dataLabel = point2.dataLabel;
              if (dataLabel && dataLabel._pos && point2.visible && point2.labelDistance > 0) {
                visibility = dataLabel._attr.visibility;
                isNew = !connector;
                if (isNew) {
                  point2.connector = connector = chart.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + point2.colorIndex + (point2.className ? " " + point2.className : "")).add(series.dataLabelsGroup);
                  if (!chart.styledMode) {
                    connector.attr({
                      "stroke-width": connectorWidth,
                      "stroke": pointDataLabelsOptions.connectorColor || point2.color || palette.neutralColor60
                    });
                  }
                }
                connector[isNew ? "attr" : "animate"]({
                  d: point2.getConnectorPath()
                });
                connector.attr("visibility", visibility);
              } else if (connector) {
                point2.connector = connector.destroy();
              }
            }
          });
        }
      }
      function placeDataLabels() {
        this.points.forEach(function(point) {
          var dataLabel = point.dataLabel, _pos;
          if (dataLabel && point.visible) {
            _pos = dataLabel._pos;
            if (_pos) {
              if (dataLabel.sideOverflow) {
                dataLabel._attr.width = Math.max(dataLabel.getBBox().width - dataLabel.sideOverflow, 0);
                dataLabel.css({
                  width: dataLabel._attr.width + "px",
                  textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                });
                dataLabel.shortened = true;
              }
              dataLabel.attr(dataLabel._attr);
              dataLabel[dataLabel.moved ? "animate" : "attr"](_pos);
              dataLabel.moved = true;
            } else if (dataLabel) {
              dataLabel.attr({ y: -9999 });
            }
          }
          delete point.distributeBox;
        }, this);
      }
      function verifyDataLabelOverflow(overflow) {
        var center = this.center, options = this.options, centerOption = options.center, minSize = options.minSize || 80, newSize = minSize, ret = options.size !== null;
        if (!ret) {
          if (centerOption[0] !== null) {
            newSize = Math.max(center[2] - Math.max(overflow[1], overflow[3]), minSize);
          } else {
            newSize = Math.max(
              // horizontal overflow
              center[2] - overflow[1] - overflow[3],
              minSize
            );
            center[0] += (overflow[3] - overflow[1]) / 2;
          }
          if (centerOption[1] !== null) {
            newSize = clamp$b(newSize, minSize, center[2] - Math.max(overflow[0], overflow[2]));
          } else {
            newSize = clamp$b(
              newSize,
              minSize,
              // vertical overflow
              center[2] - overflow[0] - overflow[2]
            );
            center[1] += (overflow[0] - overflow[2]) / 2;
          }
          if (newSize < center[2]) {
            center[2] = newSize;
            center[3] = Math.min(
              // #3632
              relativeLength$3(options.innerSize || 0, newSize),
              newSize
            );
            this.translate(center);
            if (this.drawDataLabels) {
              this.drawDataLabels();
            }
          } else {
            ret = true;
          }
        }
        return ret;
      }
    })(ColumnDataLabel || (ColumnDataLabel = {}));
    const PieDataLabel = ColumnDataLabel;
    var addEvent$N = Utilities.addEvent, fireEvent$m = Utilities.fireEvent, isArray$b = Utilities.isArray, isNumber$u = Utilities.isNumber, objectEach$g = Utilities.objectEach, pick$13 = Utilities.pick;
    addEvent$N(Chart$1, "render", function collectAndHide() {
      var chart = this, labels = [];
      (this.labelCollectors || []).forEach(function(collector) {
        labels = labels.concat(collector());
      });
      (this.yAxis || []).forEach(function(yAxis) {
        if (yAxis.stacking && yAxis.options.stackLabels && !yAxis.options.stackLabels.allowOverlap) {
          objectEach$g(yAxis.stacking.stacks, function(stack) {
            objectEach$g(stack, function(stackItem) {
              if (stackItem.label && stackItem.label.visibility !== "hidden") {
                labels.push(stackItem.label);
              }
            });
          });
        }
      });
      (this.series || []).forEach(function(series) {
        var dlOptions = series.options.dataLabels;
        if (series.visible && !(dlOptions.enabled === false && !series._hasPointLabels)) {
          var push = function(points) {
            return points.forEach(function(point) {
              if (point.visible) {
                var dataLabels = isArray$b(point.dataLabels) ? point.dataLabels : point.dataLabel ? [point.dataLabel] : [];
                dataLabels.forEach(function(label) {
                  var options = label.options;
                  label.labelrank = pick$13(options.labelrank, point.labelrank, point.shapeArgs && point.shapeArgs.height);
                  if (!options.allowOverlap) {
                    labels.push(label);
                  } else {
                    label.oldOpacity = label.opacity;
                    label.newOpacity = 1;
                    hideOrShow(label, chart);
                  }
                });
              }
            });
          };
          push(series.nodes || []);
          push(series.points);
        }
      });
      this.hideOverlappingLabels(labels);
    });
    Chart$1.prototype.hideOverlappingLabels = function(labels) {
      var chart = this, len = labels.length, ren = chart.renderer, label, i, j, label1, label2, box1, box2, isLabelAffected = false, isIntersectRect = function(box12, box22) {
        return !(box22.x >= box12.x + box12.width || box22.x + box22.width <= box12.x || box22.y >= box12.y + box12.height || box22.y + box22.height <= box12.y);
      }, getAbsoluteBox = function(label3) {
        var pos, parent, bBox, padding = label3.box ? 0 : label3.padding || 0, lineHeightCorrection = 0, xOffset = 0, boxWidth, alignValue;
        if (label3 && (!label3.alignAttr || label3.placed)) {
          pos = label3.alignAttr || {
            x: label3.attr("x"),
            y: label3.attr("y")
          };
          parent = label3.parentGroup;
          if (!label3.width) {
            bBox = label3.getBBox();
            label3.width = bBox.width;
            label3.height = bBox.height;
            lineHeightCorrection = ren.fontMetrics(null, label3.element).h;
          }
          boxWidth = label3.width - 2 * padding;
          alignValue = {
            left: "0",
            center: "0.5",
            right: "1"
          }[label3.alignValue];
          if (alignValue) {
            xOffset = +alignValue * boxWidth;
          } else if (isNumber$u(label3.x) && Math.round(label3.x) !== label3.translateX) {
            xOffset = label3.x - label3.translateX;
          }
          return {
            x: pos.x + (parent.translateX || 0) + padding - (xOffset || 0),
            y: pos.y + (parent.translateY || 0) + padding - lineHeightCorrection,
            width: label3.width - 2 * padding,
            height: label3.height - 2 * padding
          };
        }
      };
      for (i = 0; i < len; i++) {
        label = labels[i];
        if (label) {
          label.oldOpacity = label.opacity;
          label.newOpacity = 1;
          label.absoluteBox = getAbsoluteBox(label);
        }
      }
      labels.sort(function(a, b) {
        return (b.labelrank || 0) - (a.labelrank || 0);
      });
      for (i = 0; i < len; i++) {
        label1 = labels[i];
        box1 = label1 && label1.absoluteBox;
        for (j = i + 1; j < len; ++j) {
          label2 = labels[j];
          box2 = label2 && label2.absoluteBox;
          if (box1 && box2 && label1 !== label2 && // #6465, polar chart with connectEnds
          label1.newOpacity !== 0 && label2.newOpacity !== 0) {
            if (isIntersectRect(box1, box2)) {
              (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
            }
          }
        }
      }
      labels.forEach(function(label3) {
        if (hideOrShow(label3, chart)) {
          isLabelAffected = true;
        }
      });
      if (isLabelAffected) {
        fireEvent$m(chart, "afterHideAllOverlappingLabels");
      }
    };
    function hideOrShow(label, chart) {
      var complete, newOpacity, isLabelAffected = false;
      if (label) {
        newOpacity = label.newOpacity;
        if (label.oldOpacity !== newOpacity) {
          if (label.alignAttr && label.placed) {
            label[newOpacity ? "removeClass" : "addClass"]("highcharts-data-label-hidden");
            complete = function() {
              if (!chart.styledMode) {
                label.css({ pointerEvents: newOpacity ? "auto" : "none" });
              }
            };
            isLabelAffected = true;
            label.alignAttr.opacity = newOpacity;
            label[label.isOld ? "animate" : "attr"](label.alignAttr, null, complete);
            fireEvent$m(chart, "afterHideOverlappingLabel");
          } else {
            label.attr({
              opacity: newOpacity
            });
          }
        }
        label.isOld = true;
      }
      return isLabelAffected;
    }
    var extend$13 = Utilities.extend, find$e = Utilities.find, isArray$a = Utilities.isArray, isObject$8 = Utilities.isObject, merge$X = Utilities.merge, objectEach$f = Utilities.objectEach, pick$12 = Utilities.pick, splat$a = Utilities.splat, uniqueKey$3 = Utilities.uniqueKey;
    var Responsive;
    (function(Responsive2) {
      var composedClasses2 = [];
      function compose(ChartClass) {
        if (composedClasses2.indexOf(ChartClass) === -1) {
          composedClasses2.push(ChartClass);
          extend$13(ChartClass.prototype, Additions.prototype);
        }
        return ChartClass;
      }
      Responsive2.compose = compose;
      var Additions = (
        /** @class */
        function() {
          function Additions2() {
          }
          Additions2.prototype.currentOptions = function(options) {
            var chart = this, ret = {};
            function getCurrent(options2, curr, ret2, depth) {
              var i;
              objectEach$f(options2, function(val, key) {
                if (!depth && chart.collectionsWithUpdate.indexOf(key) > -1 && curr[key]) {
                  val = splat$a(val);
                  ret2[key] = [];
                  for (i = 0; i < Math.max(val.length, curr[key].length); i++) {
                    if (curr[key][i]) {
                      if (val[i] === void 0) {
                        ret2[key][i] = curr[key][i];
                      } else {
                        ret2[key][i] = {};
                        getCurrent(val[i], curr[key][i], ret2[key][i], depth + 1);
                      }
                    }
                  }
                } else if (isObject$8(val)) {
                  ret2[key] = isArray$a(val) ? [] : {};
                  getCurrent(val, curr[key] || {}, ret2[key], depth + 1);
                } else if (typeof curr[key] === "undefined") {
                  ret2[key] = null;
                } else {
                  ret2[key] = curr[key];
                }
              });
            }
            getCurrent(options, this.options, ret, 0);
            return ret;
          };
          Additions2.prototype.matchResponsiveRule = function(rule, matches2) {
            var condition = rule.condition, fn = condition.callback || function() {
              return this.chartWidth <= pick$12(condition.maxWidth, Number.MAX_VALUE) && this.chartHeight <= pick$12(condition.maxHeight, Number.MAX_VALUE) && this.chartWidth >= pick$12(condition.minWidth, 0) && this.chartHeight >= pick$12(condition.minHeight, 0);
            };
            if (fn.call(this)) {
              matches2.push(rule._id);
            }
          };
          Additions2.prototype.setResponsive = function(redraw, reset) {
            var _this = this;
            var options = this.options.responsive, currentResponsive = this.currentResponsive;
            var ruleIds = [], undoOptions;
            if (!reset && options && options.rules) {
              options.rules.forEach(function(rule) {
                if (typeof rule._id === "undefined") {
                  rule._id = uniqueKey$3();
                }
                _this.matchResponsiveRule(
                  rule,
                  ruleIds
                  /* , redraw */
                );
              }, this);
            }
            var mergedOptions = merge$X.apply(void 0, ruleIds.map(function(ruleId) {
              return find$e((options || {}).rules || [], function(rule) {
                return rule._id === ruleId;
              });
            }).map(function(rule) {
              return rule && rule.chartOptions;
            }));
            mergedOptions.isResponsiveOptions = true;
            ruleIds = ruleIds.toString() || void 0;
            var currentRuleIds = currentResponsive && currentResponsive.ruleIds;
            if (ruleIds !== currentRuleIds) {
              if (currentResponsive) {
                this.update(currentResponsive.undoOptions, redraw, true);
              }
              if (ruleIds) {
                undoOptions = this.currentOptions(mergedOptions);
                undoOptions.isResponsiveOptions = true;
                this.currentResponsive = {
                  ruleIds,
                  mergedOptions,
                  undoOptions
                };
                this.update(mergedOptions, redraw, true);
              } else {
                this.currentResponsive = void 0;
              }
            }
          };
          return Additions2;
        }()
      );
    })(Responsive || (Responsive = {}));
    const Responsive$1 = Responsive;
    /**
     * @license Highcharts JS v9.2.2 (2021-08-24)
     * @module highcharts/highcharts
     *
     * (c) 2009-2021 Torstein Honsi
     *
     * License: www.highcharts.com/license
     */
    var G$7 = H;
    G$7.animate = animationExports.animate;
    G$7.animObject = animationExports.animObject;
    G$7.getDeferredAnimation = animationExports.getDeferredAnimation;
    G$7.setAnimation = animationExports.setAnimation;
    G$7.stop = animationExports.stop;
    G$7.timers = Fx.timers;
    G$7.AST = AST;
    G$7.Axis = Axis;
    G$7.Chart = Chart$1;
    G$7.chart = Chart$1.chart;
    G$7.Fx = Fx;
    G$7.Legend = Legend;
    G$7.PlotLineOrBand = PlotLineOrBand;
    G$7.Point = Point$2;
    G$7.Pointer = MSPointer.isRequired() ? MSPointer : Pointer;
    G$7.Series = Series$e;
    G$7.SVGElement = SVGElement;
    G$7.SVGRenderer = SVGRenderer;
    G$7.Tick = Tick;
    G$7.Time = Time;
    G$7.Tooltip = Tooltip;
    G$7.Color = Color;
    G$7.color = Color.parse;
    HTMLRenderer.compose(SVGRenderer);
    HTMLElement$1.compose(SVGElement);
    G$7.defaultOptions = DefaultOptions.defaultOptions;
    G$7.getOptions = DefaultOptions.getOptions;
    G$7.time = DefaultOptions.defaultTime;
    G$7.setOptions = DefaultOptions.setOptions;
    G$7.dateFormat = FormatUtilities.dateFormat;
    G$7.format = FormatUtilities.format;
    G$7.numberFormat = FormatUtilities.numberFormat;
    G$7.addEvent = Utilities.addEvent;
    G$7.arrayMax = Utilities.arrayMax;
    G$7.arrayMin = Utilities.arrayMin;
    G$7.attr = Utilities.attr;
    G$7.clearTimeout = Utilities.clearTimeout;
    G$7.correctFloat = Utilities.correctFloat;
    G$7.createElement = Utilities.createElement;
    G$7.css = Utilities.css;
    G$7.defined = Utilities.defined;
    G$7.destroyObjectProperties = Utilities.destroyObjectProperties;
    G$7.discardElement = Utilities.discardElement;
    G$7.distribute = R.distribute;
    G$7.erase = Utilities.erase;
    G$7.error = Utilities.error;
    G$7.extend = Utilities.extend;
    G$7.extendClass = Utilities.extendClass;
    G$7.find = Utilities.find;
    G$7.fireEvent = Utilities.fireEvent;
    G$7.getMagnitude = Utilities.getMagnitude;
    G$7.getStyle = Utilities.getStyle;
    G$7.inArray = Utilities.inArray;
    G$7.isArray = Utilities.isArray;
    G$7.isClass = Utilities.isClass;
    G$7.isDOMElement = Utilities.isDOMElement;
    G$7.isFunction = Utilities.isFunction;
    G$7.isNumber = Utilities.isNumber;
    G$7.isObject = Utilities.isObject;
    G$7.isString = Utilities.isString;
    G$7.keys = Utilities.keys;
    G$7.merge = Utilities.merge;
    G$7.normalizeTickInterval = Utilities.normalizeTickInterval;
    G$7.objectEach = Utilities.objectEach;
    G$7.offset = Utilities.offset;
    G$7.pad = Utilities.pad;
    G$7.pick = Utilities.pick;
    G$7.pInt = Utilities.pInt;
    G$7.relativeLength = Utilities.relativeLength;
    G$7.removeEvent = Utilities.removeEvent;
    G$7.seriesType = SeriesRegistry$1.seriesType;
    G$7.splat = Utilities.splat;
    G$7.stableSort = Utilities.stableSort;
    G$7.syncTimeout = Utilities.syncTimeout;
    G$7.timeUnits = Utilities.timeUnits;
    G$7.uniqueKey = Utilities.uniqueKey;
    G$7.useSerialIds = Utilities.useSerialIds;
    G$7.wrap = Utilities.wrap;
    ColumnDataLabel$2.compose(ColumnSeries$h);
    DataLabel$1.compose(Series$e);
    DateTimeAxis$1.compose(Axis);
    LogarithmicAxis$1.compose(Axis);
    PieDataLabel.compose(PieSeries$3);
    PlotLineOrBand.compose(Axis);
    Responsive$1.compose(Chart$1);
    var addEvent$M = Utilities.addEvent, correctFloat$8 = Utilities.correctFloat, css$3 = Utilities.css, defined$z = Utilities.defined, error$3 = Utilities.error, pick$11 = Utilities.pick, timeUnits = Utilities.timeUnits;
    var composedClasses = [];
    var OrdinalAxis;
    (function(OrdinalAxis2) {
      function compose(AxisClass, SeriesClass, ChartClass) {
        if (composedClasses.indexOf(AxisClass) === -1) {
          composedClasses.push(AxisClass);
          var axisProto = AxisClass.prototype;
          axisProto.getTimeTicks = getTimeTicks;
          axisProto.index2val = index2val;
          axisProto.lin2val = lin2val;
          axisProto.val2lin = val2lin;
          axisProto.ordinal2lin = axisProto.val2lin;
          addEvent$M(AxisClass, "afterInit", onAxisAfterInit);
          addEvent$M(AxisClass, "foundExtremes", onAxisFoundExtremes);
          addEvent$M(AxisClass, "afterSetScale", onAxisAfterSetScale);
          addEvent$M(AxisClass, "initialAxisTranslation", onAxisInitialAxisTranslation);
        }
        if (composedClasses.indexOf(ChartClass) === -1) {
          composedClasses.push(ChartClass);
          addEvent$M(ChartClass, "pan", onChartPan);
        }
        if (composedClasses.indexOf(SeriesClass) === -1) {
          composedClasses.push(SeriesClass);
          addEvent$M(SeriesClass, "updatedData", onSeriesUpdatedData);
        }
        return AxisClass;
      }
      OrdinalAxis2.compose = compose;
      function getTimeTicks(normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks) {
        if (positions === void 0) {
          positions = [];
        }
        if (closestDistance === void 0) {
          closestDistance = 0;
        }
        var higherRanks = {}, tickPixelIntervalOption = this.options.tickPixelInterval, time = this.chart.time, segmentStarts = [];
        var end, segmentPositions, hasCrossedHigherRank, info, outsideMax, start = 0, groupPositions = [], lastGroupPosition = -Number.MAX_VALUE;
        if (!this.options.ordinal && !this.options.breaks || !positions || positions.length < 3 || typeof min === "undefined") {
          return time.getTimeTicks.apply(time, arguments);
        }
        var posLength = positions.length;
        for (end = 0; end < posLength; end++) {
          outsideMax = end && positions[end - 1] > max;
          if (positions[end] < min) {
            start = end;
          }
          if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {
            if (positions[end] > lastGroupPosition) {
              segmentPositions = time.getTimeTicks(normalizedInterval, positions[start], positions[end], startOfWeek);
              while (segmentPositions.length && segmentPositions[0] <= lastGroupPosition) {
                segmentPositions.shift();
              }
              if (segmentPositions.length) {
                lastGroupPosition = segmentPositions[segmentPositions.length - 1];
              }
              segmentStarts.push(groupPositions.length);
              groupPositions = groupPositions.concat(segmentPositions);
            }
            start = end + 1;
          }
          if (outsideMax) {
            break;
          }
        }
        if (segmentPositions) {
          info = segmentPositions.info;
          if (findHigherRanks && info.unitRange <= timeUnits.hour) {
            end = groupPositions.length - 1;
            for (start = 1; start < end; start++) {
              if (time.dateFormat("%d", groupPositions[start]) !== time.dateFormat("%d", groupPositions[start - 1])) {
                higherRanks[groupPositions[start]] = "day";
                hasCrossedHigherRank = true;
              }
            }
            if (hasCrossedHigherRank) {
              higherRanks[groupPositions[0]] = "day";
            }
            info.higherRanks = higherRanks;
          }
          info.segmentStarts = segmentStarts;
          groupPositions.info = info;
        } else {
          error$3(12, false, this.chart);
        }
        if (findHigherRanks && defined$z(tickPixelIntervalOption)) {
          var length_1 = groupPositions.length, translatedArr = [], distances = [];
          var itemToRemove = void 0, translated = void 0, lastTranslated = void 0, medianDistance = void 0, distance = void 0, i = length_1;
          while (i--) {
            translated = this.translate(groupPositions[i]);
            if (lastTranslated) {
              distances[i] = lastTranslated - translated;
            }
            translatedArr[i] = lastTranslated = translated;
          }
          distances.sort();
          medianDistance = distances[Math.floor(distances.length / 2)];
          if (medianDistance < tickPixelIntervalOption * 0.6) {
            medianDistance = null;
          }
          i = groupPositions[length_1 - 1] > max ? length_1 - 1 : length_1;
          lastTranslated = void 0;
          while (i--) {
            translated = translatedArr[i];
            distance = Math.abs(lastTranslated - translated);
            if (lastTranslated && distance < tickPixelIntervalOption * 0.8 && (medianDistance === null || distance < medianDistance * 0.8)) {
              if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {
                itemToRemove = i + 1;
                lastTranslated = translated;
              } else {
                itemToRemove = i;
              }
              groupPositions.splice(itemToRemove, 1);
            } else {
              lastTranslated = translated;
            }
          }
        }
        return groupPositions;
      }
      function index2val(index) {
        var axis = this, ordinal = axis.ordinal, ordinalPositions = ordinal.positions;
        if (!ordinalPositions) {
          return index;
        }
        var i = ordinalPositions.length - 1, distance;
        if (index < 0) {
          index = ordinalPositions[0];
        } else if (index > i) {
          index = ordinalPositions[i];
        } else {
          i = Math.floor(index);
          distance = index - i;
        }
        if (typeof distance !== "undefined" && typeof ordinalPositions[i] !== "undefined") {
          return ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0);
        }
        return index;
      }
      function lin2val(val) {
        var axis = this, ordinal = axis.ordinal, localMin = axis.old ? axis.old.min : axis.min, localA = axis.old ? axis.old.transA : axis.transA;
        var positions = ordinal.positions;
        if (!positions) {
          return val;
        }
        var pixelVal = (val - localMin) * localA + axis.minPixelPadding, isInside = pixelVal > 0 && pixelVal < axis.left + axis.len;
        if (!isInside) {
          if (!ordinal.extendedOrdinalPositions) {
            ordinal.extendedOrdinalPositions = ordinal.getExtendedPositions();
          }
          positions = ordinal.extendedOrdinalPositions;
        }
        if (positions && positions.length) {
          var index = ordinal.getIndexOfPoint(pixelVal, positions), mantissa = correctFloat$8(index % 1);
          if (index >= 0 && index < positions.length) {
            var leftNeighbour = positions[Math.floor(index)], rightNeighbour = positions[Math.ceil(index)], distance = rightNeighbour - leftNeighbour;
            return positions[Math.floor(index)] + mantissa * distance;
          }
          var positionsLength = positions.length, firstPositionsValue = positions[0], lastPositionsValue = positions[positionsLength - 1], slope = (lastPositionsValue - firstPositionsValue) / (positionsLength - 1);
          if (index < 0) {
            return firstPositionsValue + slope * index;
          }
          return lastPositionsValue + slope * (index - positionsLength);
        }
        return val;
      }
      function getIndexInArray(ordinalPositions, val) {
        var index = OrdinalAxis2.Additions.findIndexOf(ordinalPositions, val, true);
        if (ordinalPositions[index] === val) {
          return index;
        }
        var percent = (val - ordinalPositions[index]) / (ordinalPositions[index + 1] - ordinalPositions[index]);
        return index + percent;
      }
      function onAxisAfterInit() {
        var axis = this;
        if (!axis.ordinal) {
          axis.ordinal = new OrdinalAxis2.Additions(axis);
        }
      }
      function onAxisFoundExtremes() {
        var axis = this;
        if (axis.isXAxis && defined$z(axis.options.overscroll) && axis.max === axis.dataMax && // Panning is an execption. We don't want to apply
        // overscroll when panning over the dataMax
        (!axis.chart.mouseIsDown || axis.isInternal) && // Scrollbar buttons are the other execption:
        (!axis.eventArgs || axis.eventArgs && axis.eventArgs.trigger !== "navigator")) {
          axis.max += axis.options.overscroll;
          if (!axis.isInternal && defined$z(axis.userMin)) {
            axis.min += axis.options.overscroll;
          }
        }
      }
      function onAxisAfterSetScale() {
        var axis = this;
        if (axis.horiz && !axis.isDirty) {
          axis.isDirty = axis.isOrdinal && axis.chart.navigator && !axis.chart.navigator.adaptToUpdatedData;
        }
      }
      function onAxisInitialAxisTranslation() {
        var axis = this;
        if (axis.ordinal) {
          axis.ordinal.beforeSetTickPositions();
          axis.tickInterval = axis.ordinal.postProcessTickInterval(axis.tickInterval);
        }
      }
      function onChartPan(e2) {
        var chart = this, xAxis = chart.xAxis[0], overscroll = xAxis.options.overscroll, chartX = e2.originalEvent.chartX, panning = chart.options.chart.panning;
        var runBase = false;
        if (panning && panning.type !== "y" && xAxis.options.ordinal && xAxis.series.length) {
          var mouseDownX = chart.mouseDownX, extremes = xAxis.getExtremes(), dataMax = extremes.dataMax, min = extremes.min, max = extremes.max, hoverPoints = chart.hoverPoints, closestPointRange = xAxis.closestPointRange || xAxis.ordinal && xAxis.ordinal.overscrollPointsRange, pointPixelWidth = xAxis.translationSlope * (xAxis.ordinal.slope || closestPointRange), movedUnits = (mouseDownX - chartX) / pointPixelWidth, extendedAxis = { ordinal: { positions: xAxis.ordinal.getExtendedPositions() } }, index2val_1 = xAxis.index2val, val2lin_1 = xAxis.val2lin;
          var trimmedRange = void 0, ordinalPositions = void 0, searchAxisLeft = void 0, searchAxisRight = void 0;
          if (!extendedAxis.ordinal.positions) {
            runBase = true;
          } else if (Math.abs(movedUnits) > 1) {
            if (hoverPoints) {
              hoverPoints.forEach(function(point) {
                point.setState();
              });
            }
            if (movedUnits < 0) {
              searchAxisLeft = extendedAxis;
              searchAxisRight = xAxis.ordinal.positions ? xAxis : extendedAxis;
            } else {
              searchAxisLeft = xAxis.ordinal.positions ? xAxis : extendedAxis;
              searchAxisRight = extendedAxis;
            }
            ordinalPositions = searchAxisRight.ordinal.positions;
            if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {
              ordinalPositions.push(dataMax);
            }
            chart.fixedRange = max - min;
            trimmedRange = xAxis.navigatorAxis.toFixedRange(null, null, index2val_1.apply(searchAxisLeft, [
              val2lin_1.apply(searchAxisLeft, [min, true]) + movedUnits
            ]), index2val_1.apply(searchAxisRight, [
              val2lin_1.apply(searchAxisRight, [max, true]) + movedUnits
            ]));
            if (trimmedRange.min >= Math.min(extremes.dataMin, min) && trimmedRange.max <= Math.max(dataMax, max) + overscroll) {
              xAxis.setExtremes(trimmedRange.min, trimmedRange.max, true, false, { trigger: "pan" });
            }
            chart.mouseDownX = chartX;
            css$3(chart.container, { cursor: "move" });
          }
        } else {
          runBase = true;
        }
        if (runBase || panning && /y/.test(panning.type)) {
          if (overscroll) {
            xAxis.max = xAxis.dataMax + overscroll;
          }
        } else {
          e2.preventDefault();
        }
      }
      function onSeriesUpdatedData() {
        var xAxis = this.xAxis;
        if (xAxis && xAxis.options.ordinal) {
          delete xAxis.ordinal.index;
          delete xAxis.ordinal.extendedOrdinalPositions;
        }
      }
      function val2lin(val, toIndex) {
        var axis = this, ordinal = axis.ordinal, ordinalPositions = ordinal.positions;
        var slope = ordinal.slope, extendedOrdinalPositions = ordinal.extendedOrdinalPositions;
        if (!ordinalPositions) {
          return val;
        }
        var ordinalLength = ordinalPositions.length;
        var ordinalIndex;
        if (ordinalPositions[0] <= val && ordinalPositions[ordinalLength - 1] >= val) {
          ordinalIndex = getIndexInArray(ordinalPositions, val);
        } else {
          if (!extendedOrdinalPositions) {
            extendedOrdinalPositions = ordinal.getExtendedPositions && ordinal.getExtendedPositions();
            ordinal.extendedOrdinalPositions = extendedOrdinalPositions;
          }
          if (!(extendedOrdinalPositions && extendedOrdinalPositions.length)) {
            return val;
          }
          var length_2 = extendedOrdinalPositions.length;
          if (!slope) {
            slope = (extendedOrdinalPositions[length_2 - 1] - extendedOrdinalPositions[0]) / length_2;
          }
          var originalPositionsReference = getIndexInArray(extendedOrdinalPositions, ordinalPositions[0]);
          if (val >= extendedOrdinalPositions[0] && val <= extendedOrdinalPositions[length_2 - 1]) {
            ordinalIndex = getIndexInArray(extendedOrdinalPositions, val) - originalPositionsReference;
          } else {
            if (val < extendedOrdinalPositions[0]) {
              var diff = extendedOrdinalPositions[0] - val, approximateIndexOffset = diff / slope;
              ordinalIndex = -originalPositionsReference - approximateIndexOffset;
            } else {
              var diff = val - extendedOrdinalPositions[length_2 - 1], approximateIndexOffset = diff / slope;
              ordinalIndex = approximateIndexOffset + length_2 - originalPositionsReference;
            }
          }
        }
        return toIndex ? ordinalIndex : slope * (ordinalIndex || 0) + ordinal.offset;
      }
      var Additions = (
        /** @class */
        function() {
          function Additions2(axis) {
            this.index = {};
            this.axis = axis;
          }
          Additions2.prototype.beforeSetTickPositions = function() {
            var axis = this.axis, ordinal = axis.ordinal, extremes = axis.getExtremes(), min = extremes.min, max = extremes.max, hasBreaks = axis.isXAxis && !!axis.options.breaks, isOrdinal = axis.options.ordinal, ignoreHiddenSeries = axis.chart.options.chart.ignoreHiddenSeries;
            var len, uniqueOrdinalPositions, dist, minIndex, maxIndex, slope, i, hasBoostedSeries, ordinalPositions = [], overscrollPointsRange = Number.MAX_VALUE, useOrdinal = false;
            if (isOrdinal || hasBreaks) {
              axis.series.forEach(function(series, i2) {
                uniqueOrdinalPositions = [];
                if ((!ignoreHiddenSeries || series.visible !== false) && (series.takeOrdinalPosition !== false || hasBreaks)) {
                  ordinalPositions = ordinalPositions.concat(series.processedXData);
                  len = ordinalPositions.length;
                  ordinalPositions.sort(function(a, b) {
                    return a - b;
                  });
                  overscrollPointsRange = Math.min(overscrollPointsRange, pick$11(
                    // Check for a single-point series:
                    series.closestPointRange,
                    overscrollPointsRange
                  ));
                  if (len) {
                    i2 = 0;
                    while (i2 < len - 1) {
                      if (ordinalPositions[i2] !== ordinalPositions[i2 + 1]) {
                        uniqueOrdinalPositions.push(ordinalPositions[i2 + 1]);
                      }
                      i2++;
                    }
                    if (uniqueOrdinalPositions[0] !== ordinalPositions[0]) {
                      uniqueOrdinalPositions.unshift(ordinalPositions[0]);
                    }
                    ordinalPositions = uniqueOrdinalPositions;
                  }
                }
                if (series.isSeriesBoosting) {
                  hasBoostedSeries = true;
                }
              });
              if (hasBoostedSeries) {
                ordinalPositions.length = 0;
              }
              len = ordinalPositions.length;
              if (len > 2) {
                dist = ordinalPositions[1] - ordinalPositions[0];
                i = len - 1;
                while (i-- && !useOrdinal) {
                  if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {
                    useOrdinal = true;
                  }
                }
                if (!axis.options.keepOrdinalPadding && (ordinalPositions[0] - min > dist || max - ordinalPositions[ordinalPositions.length - 1] > dist)) {
                  useOrdinal = true;
                }
              } else if (axis.options.overscroll) {
                if (len === 2) {
                  overscrollPointsRange = ordinalPositions[1] - ordinalPositions[0];
                } else if (len === 1) {
                  overscrollPointsRange = axis.options.overscroll;
                  ordinalPositions = [
                    ordinalPositions[0],
                    ordinalPositions[0] + overscrollPointsRange
                  ];
                } else {
                  overscrollPointsRange = ordinal.overscrollPointsRange;
                }
              }
              if (useOrdinal || axis.forceOrdinal) {
                if (axis.options.overscroll) {
                  ordinal.overscrollPointsRange = overscrollPointsRange;
                  ordinalPositions = ordinalPositions.concat(ordinal.getOverscrollPositions());
                }
                ordinal.positions = ordinalPositions;
                minIndex = axis.ordinal2lin(
                  // #5979
                  Math.max(min, ordinalPositions[0]),
                  true
                );
                maxIndex = Math.max(axis.ordinal2lin(Math.min(max, ordinalPositions[ordinalPositions.length - 1]), true), 1);
                ordinal.slope = slope = (max - min) / (maxIndex - minIndex);
                ordinal.offset = min - minIndex * slope;
              } else {
                ordinal.overscrollPointsRange = pick$11(axis.closestPointRange, ordinal.overscrollPointsRange);
                ordinal.positions = axis.ordinal.slope = ordinal.offset = void 0;
              }
            }
            axis.isOrdinal = isOrdinal && useOrdinal;
            ordinal.groupIntervalFactor = null;
          };
          Additions2.findIndexOf = function(sortedArray, key, indirectSearch) {
            var start = 0, end = sortedArray.length - 1, middle;
            while (start < end) {
              middle = Math.ceil((start + end) / 2);
              if (sortedArray[middle] <= key) {
                start = middle;
              } else {
                end = middle - 1;
              }
            }
            if (sortedArray[start] === key) {
              return start;
            }
            return !indirectSearch ? -1 : start;
          };
          Additions2.prototype.getExtendedPositions = function() {
            var ordinal = this, axis = ordinal.axis, axisProto = axis.constructor.prototype, chart = axis.chart, grouping = axis.series[0].currentDataGrouping, key = grouping ? grouping.count + grouping.unitName : "raw", overscroll = axis.options.overscroll, extremes = axis.getExtremes();
            var fakeAxis, fakeSeries = void 0, ordinalIndex = ordinal.index;
            if (!ordinalIndex) {
              ordinalIndex = ordinal.index = {};
            }
            if (!ordinalIndex[key]) {
              fakeAxis = {
                series: [],
                chart,
                forceOrdinal: false,
                getExtremes: function() {
                  return {
                    min: extremes.dataMin,
                    max: extremes.dataMax + overscroll
                  };
                },
                getGroupPixelWidth: axisProto.getGroupPixelWidth,
                getTimeTicks: axisProto.getTimeTicks,
                options: {
                  ordinal: true
                },
                ordinal: {
                  getGroupIntervalFactor: this.getGroupIntervalFactor
                },
                ordinal2lin: axisProto.ordinal2lin,
                getIndexOfPoint: axisProto.getIndexOfPoint,
                val2lin: axisProto.val2lin
                // #2590
              };
              fakeAxis.ordinal.axis = fakeAxis;
              axis.series.forEach(function(series) {
                fakeSeries = {
                  xAxis: fakeAxis,
                  xData: series.xData.slice(),
                  chart,
                  destroyGroupedData: H.noop,
                  getProcessedData: Series$e.prototype.getProcessedData,
                  applyGrouping: Series$e.prototype.applyGrouping
                };
                fakeSeries.xData = fakeSeries.xData.concat(ordinal.getOverscrollPositions());
                fakeSeries.options = {
                  dataGrouping: grouping ? {
                    firstAnchor: "firstPoint",
                    anchor: "middle",
                    lastAnchor: "lastPoint",
                    enabled: true,
                    forced: true,
                    // doesn't matter which, use the fastest
                    approximation: "open",
                    units: [[
                      grouping.unitName,
                      [grouping.count]
                    ]]
                  } : {
                    enabled: false
                  }
                };
                fakeAxis.series.push(fakeSeries);
                series.processData.apply(fakeSeries);
              });
              axis.applyGrouping.call(fakeAxis);
              if (fakeSeries.closestPointRange !== fakeSeries.basePointRange && fakeSeries.currentDataGrouping) {
                fakeAxis.forceOrdinal = true;
              }
              axis.ordinal.beforeSetTickPositions.apply({ axis: fakeAxis });
              ordinalIndex[key] = fakeAxis.ordinal.positions;
            }
            return ordinalIndex[key];
          };
          Additions2.prototype.getGroupIntervalFactor = function(xMin, xMax, series) {
            var ordinal = this;
            ordinal.axis;
            var processedXData = series.processedXData, len = processedXData.length, distances = [];
            var median, i, groupIntervalFactor = ordinal.groupIntervalFactor;
            if (!groupIntervalFactor) {
              for (i = 0; i < len - 1; i++) {
                distances[i] = processedXData[i + 1] - processedXData[i];
              }
              distances.sort(function(a, b) {
                return a - b;
              });
              median = distances[Math.floor(len / 2)];
              xMin = Math.max(xMin, processedXData[0]);
              xMax = Math.min(xMax, processedXData[len - 1]);
              ordinal.groupIntervalFactor = groupIntervalFactor = len * median / (xMax - xMin);
            }
            return groupIntervalFactor;
          };
          Additions2.prototype.getIndexOfPoint = function(val, ordinalArray) {
            var ordinal = this, axis = ordinal.axis, firstPointVal = ordinal.positions ? ordinal.positions[0] : 0;
            var firstPointX = axis.series[0].points && axis.series[0].points[0] && axis.series[0].points[0].plotX || axis.minPixelPadding;
            if (axis.series.length > 1) {
              axis.series.forEach(function(series) {
                if (defined$z(series.points[0]) && defined$z(series.points[0].plotX) && series.points[0].plotX < firstPointX) {
                  firstPointX = series.points[0].plotX;
                }
              });
            }
            var ordinalPointPixelInterval = axis.translationSlope * (ordinal.slope || axis.closestPointRange || ordinal.overscrollPointsRange), shiftIndex = (val - firstPointX) / ordinalPointPixelInterval;
            return Additions2.findIndexOf(ordinalArray, firstPointVal) + shiftIndex;
          };
          Additions2.prototype.getOverscrollPositions = function() {
            var ordinal = this, axis = ordinal.axis, extraRange = axis.options.overscroll, distance = ordinal.overscrollPointsRange, positions = [], max = axis.dataMax;
            if (defined$z(distance)) {
              while (max <= axis.dataMax + extraRange) {
                max += distance;
                positions.push(max);
              }
            }
            return positions;
          };
          Additions2.prototype.postProcessTickInterval = function(tickInterval) {
            var ordinal = this, axis = ordinal.axis, ordinalSlope = ordinal.slope;
            var ret;
            if (ordinalSlope) {
              if (!axis.options.breaks) {
                ret = tickInterval / (ordinalSlope / axis.closestPointRange);
              } else {
                ret = axis.closestPointRange || tickInterval;
              }
            } else {
              ret = tickInterval;
            }
            return ret;
          };
          return Additions2;
        }()
      );
      OrdinalAxis2.Additions = Additions;
    })(OrdinalAxis || (OrdinalAxis = {}));
    const OrdinalAxis$1 = OrdinalAxis;
    var addEvent$L = Utilities.addEvent, find$d = Utilities.find, fireEvent$l = Utilities.fireEvent, isArray$9 = Utilities.isArray, isNumber$t = Utilities.isNumber, pick$10 = Utilities.pick;
    var BrokenAxis;
    (function(BrokenAxis2) {
      var composedClasses2 = [];
      function compose(AxisClass, SeriesClass) {
        if (composedClasses2.indexOf(AxisClass) === -1) {
          composedClasses2.push(AxisClass);
          AxisClass.keepProps.push("brokenAxis");
          addEvent$L(AxisClass, "init", onAxisInit);
          addEvent$L(AxisClass, "afterInit", onAxisAfterInit);
          addEvent$L(AxisClass, "afterSetTickPositions", onAxisAfterSetTickPositions);
          addEvent$L(AxisClass, "afterSetOptions", onAxisAfterSetOptions);
        }
        if (composedClasses2.indexOf(SeriesClass) === -1) {
          composedClasses2.push(SeriesClass);
          var seriesProto2 = SeriesClass.prototype;
          seriesProto2.drawBreaks = seriesDrawBreaks;
          seriesProto2.gappedPath = seriesGappedPath;
          addEvent$L(SeriesClass, "afterGeneratePoints", onSeriesAfterGeneratePoints);
          addEvent$L(SeriesClass, "afterRender", onSeriesAfterRender);
        }
        return AxisClass;
      }
      BrokenAxis2.compose = compose;
      function onAxisAfterInit() {
        if (typeof this.brokenAxis !== "undefined") {
          this.brokenAxis.setBreaks(this.options.breaks, false);
        }
      }
      function onAxisAfterSetOptions() {
        var axis = this;
        if (axis.brokenAxis && axis.brokenAxis.hasBreaks) {
          axis.options.ordinal = false;
        }
      }
      function onAxisAfterSetTickPositions() {
        var axis = this, brokenAxis = axis.brokenAxis;
        if (brokenAxis && brokenAxis.hasBreaks) {
          var tickPositions = axis.tickPositions, info = axis.tickPositions.info, newPositions = [];
          for (var i = 0; i < tickPositions.length; i++) {
            if (!brokenAxis.isInAnyBreak(tickPositions[i])) {
              newPositions.push(tickPositions[i]);
            }
          }
          axis.tickPositions = newPositions;
          axis.tickPositions.info = info;
        }
      }
      function onAxisInit() {
        var axis = this;
        if (!axis.brokenAxis) {
          axis.brokenAxis = new Additions(axis);
        }
      }
      function onSeriesAfterGeneratePoints() {
        var _a2 = this, isDirty = _a2.isDirty, connectNulls = _a2.options.connectNulls, points = _a2.points, xAxis = _a2.xAxis, yAxis = _a2.yAxis;
        if (isDirty) {
          var i = points.length;
          while (i--) {
            var point = points[i];
            var nullGap = point.y === null && connectNulls === false;
            var isPointInBreak = !nullGap && (xAxis && xAxis.brokenAxis && xAxis.brokenAxis.isInAnyBreak(point.x, true) || yAxis && yAxis.brokenAxis && yAxis.brokenAxis.isInAnyBreak(point.y, true));
            point.visible = isPointInBreak ? false : point.options.visible !== false;
          }
        }
      }
      function onSeriesAfterRender() {
        this.drawBreaks(this.xAxis, ["x"]);
        this.drawBreaks(this.yAxis, pick$10(this.pointArrayMap, ["y"]));
      }
      function seriesDrawBreaks(axis, keys2) {
        var series = this, points = series.points;
        var breaks, threshold, eventName, y;
        if (axis && // #5950
        axis.brokenAxis && axis.brokenAxis.hasBreaks) {
          var brokenAxis_1 = axis.brokenAxis;
          keys2.forEach(function(key) {
            breaks = brokenAxis_1 && brokenAxis_1.breakArray || [];
            threshold = axis.isXAxis ? axis.min : pick$10(series.options.threshold, axis.min);
            points.forEach(function(point) {
              y = pick$10(point["stack" + key.toUpperCase()], point[key]);
              breaks.forEach(function(brk) {
                if (isNumber$t(threshold) && isNumber$t(y)) {
                  eventName = false;
                  if (threshold < brk.from && y > brk.to || threshold > brk.from && y < brk.from) {
                    eventName = "pointBreak";
                  } else if (threshold < brk.from && y > brk.from && y < brk.to || threshold > brk.from && y > brk.to && y < brk.from) {
                    eventName = "pointInBreak";
                  }
                  if (eventName) {
                    fireEvent$l(axis, eventName, { point, brk });
                  }
                }
              });
            });
          });
        }
      }
      function seriesGappedPath() {
        var currentDataGrouping = this.currentDataGrouping, groupingSize = currentDataGrouping && currentDataGrouping.gapSize, points = this.points.slice(), yAxis = this.yAxis;
        var gapSize = this.options.gapSize, i = points.length - 1, stack;
        if (gapSize && i > 0) {
          if (this.options.gapUnit !== "value") {
            gapSize *= this.basePointRange;
          }
          if (groupingSize && groupingSize > gapSize && // Except when DG is forced (e.g. from other series)
          // and has lower granularity than actual points (#11351)
          groupingSize >= this.basePointRange) {
            gapSize = groupingSize;
          }
          var current = void 0, next = void 0;
          while (i--) {
            if (!(next && next.visible !== false)) {
              next = points[i + 1];
            }
            current = points[i];
            if (next.visible === false || current.visible === false) {
              continue;
            }
            if (next.x - current.x > gapSize) {
              var xRange = (current.x + next.x) / 2;
              points.splice(
                // insert after this one
                i + 1,
                0,
                {
                  isNull: true,
                  x: xRange
                }
              );
              if (yAxis.stacking && this.options.stacking) {
                stack = yAxis.stacking.stacks[this.stackKey][xRange] = new StackItem$1(yAxis, yAxis.options.stackLabels, false, xRange, this.stack);
                stack.total = 0;
              }
            }
            next = current;
          }
        }
        return this.getGraphPath(points);
      }
      var Additions = (
        /** @class */
        function() {
          function Additions2(axis) {
            this.hasBreaks = false;
            this.axis = axis;
          }
          Additions2.isInBreak = function(brk, val) {
            var repeat = brk.repeat || Infinity, from = brk.from, length = brk.to - brk.from, test = val >= from ? (val - from) % repeat : repeat - (from - val) % repeat;
            var ret;
            if (!brk.inclusive) {
              ret = test < length && test !== 0;
            } else {
              ret = test <= length;
            }
            return ret;
          };
          Additions2.lin2Val = function(val) {
            var axis = this;
            var brokenAxis = axis.brokenAxis;
            var breakArray = brokenAxis && brokenAxis.breakArray;
            if (!breakArray || !isNumber$t(val)) {
              return val;
            }
            var nval = val, brk, i;
            for (i = 0; i < breakArray.length; i++) {
              brk = breakArray[i];
              if (brk.from >= nval) {
                break;
              } else if (brk.to < nval) {
                nval += brk.len;
              } else if (Additions2.isInBreak(brk, nval)) {
                nval += brk.len;
              }
            }
            return nval;
          };
          Additions2.val2Lin = function(val) {
            var axis = this;
            var brokenAxis = axis.brokenAxis;
            var breakArray = brokenAxis && brokenAxis.breakArray;
            if (!breakArray || !isNumber$t(val)) {
              return val;
            }
            var nval = val, brk, i;
            for (i = 0; i < breakArray.length; i++) {
              brk = breakArray[i];
              if (brk.to <= val) {
                nval -= brk.len;
              } else if (brk.from >= val) {
                break;
              } else if (Additions2.isInBreak(brk, val)) {
                nval -= val - brk.from;
                break;
              }
            }
            return nval;
          };
          Additions2.prototype.findBreakAt = function(x, breaks) {
            return find$d(breaks, function(b) {
              return b.from < x && x < b.to;
            });
          };
          Additions2.prototype.isInAnyBreak = function(val, testKeep) {
            var brokenAxis = this, axis = brokenAxis.axis, breaks = axis.options.breaks || [];
            var i = breaks.length, inbrk, keep, ret;
            if (i && isNumber$t(val)) {
              while (i--) {
                if (Additions2.isInBreak(breaks[i], val)) {
                  inbrk = true;
                  if (!keep) {
                    keep = pick$10(breaks[i].showPoints, !axis.isXAxis);
                  }
                }
              }
              if (inbrk && testKeep) {
                ret = inbrk && !keep;
              } else {
                ret = inbrk;
              }
            }
            return ret;
          };
          Additions2.prototype.setBreaks = function(breaks, redraw) {
            var brokenAxis = this;
            var axis = brokenAxis.axis;
            var hasBreaks = isArray$9(breaks) && !!breaks.length;
            axis.isDirty = brokenAxis.hasBreaks !== hasBreaks;
            brokenAxis.hasBreaks = hasBreaks;
            axis.options.breaks = axis.userOptions.breaks = breaks;
            axis.forceRedraw = true;
            axis.series.forEach(function(series) {
              series.isDirty = true;
            });
            if (!hasBreaks && axis.val2lin === Additions2.val2Lin) {
              delete axis.val2lin;
              delete axis.lin2val;
            }
            if (hasBreaks) {
              axis.userOptions.ordinal = false;
              axis.lin2val = Additions2.lin2Val;
              axis.val2lin = Additions2.val2Lin;
              axis.setExtremes = function(newMin, newMax, redraw2, animation, eventArguments) {
                if (brokenAxis.hasBreaks) {
                  var breaks_1 = this.options.breaks || [];
                  var axisBreak = void 0;
                  while (axisBreak = brokenAxis.findBreakAt(newMin, breaks_1)) {
                    newMin = axisBreak.to;
                  }
                  while (axisBreak = brokenAxis.findBreakAt(newMax, breaks_1)) {
                    newMax = axisBreak.from;
                  }
                  if (newMax < newMin) {
                    newMax = newMin;
                  }
                }
                axis.constructor.prototype.setExtremes.call(this, newMin, newMax, redraw2, animation, eventArguments);
              };
              axis.setAxisTranslation = function() {
                axis.constructor.prototype.setAxisTranslation.call(this);
                brokenAxis.unitLength = void 0;
                if (brokenAxis.hasBreaks) {
                  var breaks_2 = axis.options.breaks || [], breakArrayT_1 = [], breakArray_1 = [], pointRangePadding = pick$10(axis.pointRangePadding, 0);
                  var length_1 = 0, inBrk_1, repeat_1, min_1 = axis.userMin || axis.min, max_1 = axis.userMax || axis.max, start_1, i_1;
                  breaks_2.forEach(function(brk) {
                    repeat_1 = brk.repeat || Infinity;
                    if (isNumber$t(min_1) && isNumber$t(max_1)) {
                      if (Additions2.isInBreak(brk, min_1)) {
                        min_1 += brk.to % repeat_1 - min_1 % repeat_1;
                      }
                      if (Additions2.isInBreak(brk, max_1)) {
                        max_1 -= max_1 % repeat_1 - brk.from % repeat_1;
                      }
                    }
                  });
                  breaks_2.forEach(function(brk) {
                    start_1 = brk.from;
                    repeat_1 = brk.repeat || Infinity;
                    if (isNumber$t(min_1) && isNumber$t(max_1)) {
                      while (start_1 - repeat_1 > min_1) {
                        start_1 -= repeat_1;
                      }
                      while (start_1 < min_1) {
                        start_1 += repeat_1;
                      }
                      for (i_1 = start_1; i_1 < max_1; i_1 += repeat_1) {
                        breakArrayT_1.push({
                          value: i_1,
                          move: "in"
                        });
                        breakArrayT_1.push({
                          value: i_1 + brk.to - brk.from,
                          move: "out",
                          size: brk.breakSize
                        });
                      }
                    }
                  });
                  breakArrayT_1.sort(function(a, b) {
                    return a.value === b.value ? (a.move === "in" ? 0 : 1) - (b.move === "in" ? 0 : 1) : a.value - b.value;
                  });
                  inBrk_1 = 0;
                  start_1 = min_1;
                  breakArrayT_1.forEach(function(brk) {
                    inBrk_1 += brk.move === "in" ? 1 : -1;
                    if (inBrk_1 === 1 && brk.move === "in") {
                      start_1 = brk.value;
                    }
                    if (inBrk_1 === 0 && isNumber$t(start_1)) {
                      breakArray_1.push({
                        from: start_1,
                        to: brk.value,
                        len: brk.value - start_1 - (brk.size || 0)
                      });
                      length_1 += brk.value - start_1 - (brk.size || 0);
                    }
                  });
                  brokenAxis.breakArray = breakArray_1;
                  if (isNumber$t(min_1) && isNumber$t(max_1) && isNumber$t(axis.min)) {
                    brokenAxis.unitLength = max_1 - min_1 - length_1 + pointRangePadding;
                    fireEvent$l(axis, "afterBreaks");
                    if (axis.staticScale) {
                      axis.transA = axis.staticScale;
                    } else if (brokenAxis.unitLength) {
                      axis.transA *= (max_1 - axis.min + pointRangePadding) / brokenAxis.unitLength;
                    }
                    if (pointRangePadding) {
                      axis.minPixelPadding = axis.transA * (axis.minPointOffset || 0);
                    }
                    axis.min = min_1;
                    axis.max = max_1;
                  }
                }
              };
            }
            if (pick$10(redraw, true)) {
              axis.chart.redraw();
            }
          };
          return Additions2;
        }()
      );
      BrokenAxis2.Additions = Additions;
    })(BrokenAxis || (BrokenAxis = {}));
    const BrokenAxis$1 = BrokenAxis;
    /**
     * @license Highcharts JS v9.2.2 (2021-08-24)
     * @module highcharts/modules/broken-axis
     * @requires highcharts
     *
     * (c) 2009-2021 Torstein Honsi
     *
     * License: www.highcharts.com/license
     */
    var G$6 = H;
    BrokenAxis$1.compose(G$6.Axis, G$6.Series);
    var format$8 = FormatUtilities.format;
    var seriesProto$3 = Series$e.prototype;
    var addEvent$K = Utilities.addEvent, arrayMax$5 = Utilities.arrayMax, arrayMin$5 = Utilities.arrayMin, correctFloat$7 = Utilities.correctFloat, defined$y = Utilities.defined, error$2 = Utilities.error, extend$12 = Utilities.extend, isNumber$s = Utilities.isNumber, merge$W = Utilities.merge, pick$$ = Utilities.pick;
    var approximations = H.approximations = {
      sum: function(arr) {
        var len = arr.length, ret;
        if (!len && arr.hasNulls) {
          ret = null;
        } else if (len) {
          ret = 0;
          while (len--) {
            ret += arr[len];
          }
        }
        return ret;
      },
      average: function(arr) {
        var len = arr.length, ret = approximations.sum(arr);
        if (isNumber$s(ret) && len) {
          ret = correctFloat$7(ret / len);
        }
        return ret;
      },
      // The same as average, but for series with multiple values, like area
      // ranges.
      averages: function() {
        var ret = [];
        [].forEach.call(arguments, function(arr) {
          ret.push(approximations.average(arr));
        });
        return typeof ret[0] === "undefined" ? void 0 : ret;
      },
      open: function(arr) {
        return arr.length ? arr[0] : arr.hasNulls ? null : void 0;
      },
      high: function(arr) {
        return arr.length ? arrayMax$5(arr) : arr.hasNulls ? null : void 0;
      },
      low: function(arr) {
        return arr.length ? arrayMin$5(arr) : arr.hasNulls ? null : void 0;
      },
      close: function(arr) {
        return arr.length ? arr[arr.length - 1] : arr.hasNulls ? null : void 0;
      },
      // ohlc and range are special cases where a multidimensional array is
      // input and an array is output
      ohlc: function(open, high, low, close) {
        open = approximations.open(open);
        high = approximations.high(high);
        low = approximations.low(low);
        close = approximations.close(close);
        if (isNumber$s(open) || isNumber$s(high) || isNumber$s(low) || isNumber$s(close)) {
          return [open, high, low, close];
        }
      },
      range: function(low, high) {
        low = approximations.low(low);
        high = approximations.high(high);
        if (isNumber$s(low) || isNumber$s(high)) {
          return [low, high];
        }
        if (low === null && high === null) {
          return null;
        }
      }
    };
    var applyGrouping = function() {
      var series = this, chart = series.chart, options = series.options, dataGroupingOptions = options.dataGrouping, groupingEnabled = series.allowDG !== false && dataGroupingOptions && pick$$(dataGroupingOptions.enabled, chart.options.isStock), visible = series.visible || !chart.options.chart.ignoreHiddenSeries, hasGroupedData, skip, lastDataGrouping = this.currentDataGrouping, currentDataGrouping, croppedData, revertRequireSorting = false;
      if (groupingEnabled && !series.requireSorting) {
        series.requireSorting = revertRequireSorting = true;
      }
      skip = skipDataGrouping(series) || !groupingEnabled;
      if (revertRequireSorting) {
        series.requireSorting = false;
      }
      if (!skip) {
        series.destroyGroupedData();
        var i = void 0, processedXData = dataGroupingOptions.groupAll ? series.xData : series.processedXData, processedYData = dataGroupingOptions.groupAll ? series.yData : series.processedYData, plotSizeX = chart.plotSizeX, xAxis = series.xAxis, ordinal = xAxis.options.ordinal, groupPixelWidth = series.groupPixelWidth;
        if (groupPixelWidth && processedXData && processedXData.length) {
          hasGroupedData = true;
          series.isDirty = true;
          series.points = null;
          var extremes = xAxis.getExtremes(), xMin = extremes.min, xMax = extremes.max, groupIntervalFactor = ordinal && xAxis.ordinal && xAxis.ordinal.getGroupIntervalFactor(xMin, xMax, series) || 1, interval = groupPixelWidth * (xMax - xMin) / plotSizeX * groupIntervalFactor, groupPositions = xAxis.getTimeTicks(
            DateTimeAxis$1.Additions.prototype.normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits),
            // Processed data may extend beyond axis (#4907)
            Math.min(xMin, processedXData[0]),
            Math.max(xMax, processedXData[processedXData.length - 1]),
            xAxis.options.startOfWeek,
            processedXData,
            series.closestPointRange
          ), groupedData = seriesProto$3.groupData.apply(series, [
            processedXData,
            processedYData,
            groupPositions,
            dataGroupingOptions.approximation
          ]), groupedXData = groupedData.groupedXData, groupedYData = groupedData.groupedYData, gapSize = 0;
          if (dataGroupingOptions && dataGroupingOptions.smoothed && groupedXData.length) {
            dataGroupingOptions.firstAnchor = "firstPoint";
            dataGroupingOptions.anchor = "middle";
            dataGroupingOptions.lastAnchor = "lastPoint";
            error$2(32, false, chart, { "dataGrouping.smoothed": "use dataGrouping.anchor" });
          }
          anchorPoints(series, groupedXData, xMax);
          for (i = 1; i < groupPositions.length; i++) {
            if (!groupPositions.info.segmentStarts || groupPositions.info.segmentStarts.indexOf(i) === -1) {
              gapSize = Math.max(groupPositions[i] - groupPositions[i - 1], gapSize);
            }
          }
          currentDataGrouping = groupPositions.info;
          currentDataGrouping.gapSize = gapSize;
          series.closestPointRange = groupPositions.info.totalRange;
          series.groupMap = groupedData.groupMap;
          if (visible) {
            adjustExtremes(xAxis, groupedXData);
          }
          if (dataGroupingOptions.groupAll) {
            series.allGroupedData = groupedYData;
            croppedData = series.cropData(
              groupedXData,
              groupedYData,
              xAxis.min,
              xAxis.max,
              1
              // Ordinal xAxis will remove left-most points otherwise
            );
            groupedXData = croppedData.xData;
            groupedYData = croppedData.yData;
            series.cropStart = croppedData.start;
          }
          series.processedXData = groupedXData;
          series.processedYData = groupedYData;
        } else {
          series.groupMap = null;
        }
        series.hasGroupedData = hasGroupedData;
        series.currentDataGrouping = currentDataGrouping;
        series.preventGraphAnimation = (lastDataGrouping && lastDataGrouping.totalRange) !== (currentDataGrouping && currentDataGrouping.totalRange);
      }
    };
    var skipDataGrouping = function(series) {
      if (series.isCartesian && !series.isDirty && !series.xAxis.isDirty && !series.yAxis.isDirty) {
        return false;
      }
    };
    var groupData = function(xData, yData, groupPositions, approximation) {
      var series = this, data = series.data, dataOptions = series.options && series.options.data, groupedXData = [], groupedYData = [], groupMap = [], dataLength = xData.length, pointX, pointY, groupedY, handleYData = !!yData, values = [], approximationFn, pointArrayMap = series.pointArrayMap, pointArrayMapLength = pointArrayMap && pointArrayMap.length, extendedPointArrayMap = ["x"].concat(pointArrayMap || ["y"]), groupAll = this.options.dataGrouping && this.options.dataGrouping.groupAll, pos = 0, start = 0, valuesLen, i, j;
      function getApproximation(approx) {
        if (typeof approx === "function") {
          return approx;
        }
        if (approximations[approx]) {
          return approximations[approx];
        }
        return approximations[series.getDGApproximation && series.getDGApproximation() || "average"];
      }
      approximationFn = getApproximation(approximation);
      if (pointArrayMapLength) {
        pointArrayMap.forEach(function() {
          values.push([]);
        });
      } else {
        values.push([]);
      }
      valuesLen = pointArrayMapLength || 1;
      for (i = 0; i <= dataLength; i++) {
        if (xData[i] >= groupPositions[0]) {
          break;
        }
      }
      for (i; i <= dataLength; i++) {
        while (typeof groupPositions[pos + 1] !== "undefined" && xData[i] >= groupPositions[pos + 1] || i === dataLength) {
          pointX = groupPositions[pos];
          series.dataGroupInfo = {
            start: groupAll ? start : series.cropStart + start,
            length: values[0].length
          };
          groupedY = approximationFn.apply(series, values);
          if (series.pointClass && !defined$y(series.dataGroupInfo.options)) {
            series.dataGroupInfo.options = merge$W(series.pointClass.prototype.optionsToObject.call({ series }, series.options.data[series.cropStart + start]));
            extendedPointArrayMap.forEach(function(key) {
              delete series.dataGroupInfo.options[key];
            });
          }
          if (typeof groupedY !== "undefined") {
            groupedXData.push(pointX);
            groupedYData.push(groupedY);
            groupMap.push(series.dataGroupInfo);
          }
          start = i;
          for (j = 0; j < valuesLen; j++) {
            values[j].length = 0;
            values[j].hasNulls = false;
          }
          pos += 1;
          if (i === dataLength) {
            break;
          }
        }
        if (i === dataLength) {
          break;
        }
        if (pointArrayMap) {
          var index = series.options.dataGrouping && series.options.dataGrouping.groupAll ? i : series.cropStart + i, point = data && data[index] || series.pointClass.prototype.applyOptions.apply({
            series
          }, [dataOptions[index]]), val = void 0;
          for (j = 0; j < pointArrayMapLength; j++) {
            val = point[pointArrayMap[j]];
            if (isNumber$s(val)) {
              values[j].push(val);
            } else if (val === null) {
              values[j].hasNulls = true;
            }
          }
        } else {
          pointY = handleYData ? yData[i] : null;
          if (isNumber$s(pointY)) {
            values[0].push(pointY);
          } else if (pointY === null) {
            values[0].hasNulls = true;
          }
        }
      }
      return {
        groupedXData,
        groupedYData,
        groupMap
      };
    };
    var anchorPoints = function(series, groupedXData, xMax) {
      var options = series.options, dataGroupingOptions = options.dataGrouping, totalRange = series.currentDataGrouping && series.currentDataGrouping.gapSize;
      var i;
      if (dataGroupingOptions && series.xData && totalRange && series.groupMap) {
        var groupedDataLength = groupedXData.length - 1, anchor = dataGroupingOptions.anchor, firstAnchor = pick$$(dataGroupingOptions.firstAnchor, anchor), lastAnchor = pick$$(dataGroupingOptions.lastAnchor, anchor);
        if (anchor && anchor !== "start") {
          var shiftInterval = totalRange * { middle: 0.5, end: 1 }[anchor];
          i = groupedXData.length - 1;
          while (i-- && i > 0) {
            groupedXData[i] += shiftInterval;
          }
        }
        if (firstAnchor && firstAnchor !== "start" && series.xData[0] >= groupedXData[0]) {
          var groupStart = series.groupMap[0].start, groupLength = series.groupMap[0].length;
          var firstGroupstEnd = void 0;
          if (isNumber$s(groupStart) && isNumber$s(groupLength)) {
            firstGroupstEnd = groupStart + (groupLength - 1);
          }
          groupedXData[0] = {
            middle: groupedXData[0] + 0.5 * totalRange,
            end: groupedXData[0] + totalRange,
            firstPoint: series.xData[0],
            lastPoint: firstGroupstEnd && series.xData[firstGroupstEnd]
          }[firstAnchor];
        }
        if (lastAnchor && lastAnchor !== "start" && totalRange && groupedXData[groupedDataLength] >= xMax - totalRange) {
          var lastGroupStart = series.groupMap[series.groupMap.length - 1].start;
          groupedXData[groupedDataLength] = {
            middle: groupedXData[groupedDataLength] + 0.5 * totalRange,
            end: groupedXData[groupedDataLength] + totalRange,
            firstPoint: lastGroupStart && series.xData[lastGroupStart],
            lastPoint: series.xData[series.xData.length - 1]
          }[lastAnchor];
        }
      }
    };
    var adjustExtremes = function(xAxis, groupedXData) {
      if (defined$y(groupedXData[0]) && isNumber$s(xAxis.min) && isNumber$s(xAxis.dataMin) && groupedXData[0] < xAxis.min) {
        if (!defined$y(xAxis.options.min) && xAxis.min <= xAxis.dataMin || xAxis.min === xAxis.dataMin) {
          xAxis.min = Math.min(groupedXData[0], xAxis.min);
        }
        xAxis.dataMin = Math.min(groupedXData[0], xAxis.dataMin);
      }
      if (defined$y(groupedXData[groupedXData.length - 1]) && isNumber$s(xAxis.max) && isNumber$s(xAxis.dataMax) && groupedXData[groupedXData.length - 1] > xAxis.max) {
        if (!defined$y(xAxis.options.max) && isNumber$s(xAxis.dataMax) && xAxis.max >= xAxis.dataMax || xAxis.max === xAxis.dataMax) {
          xAxis.max = Math.max(groupedXData[groupedXData.length - 1], xAxis.max);
        }
        xAxis.dataMax = Math.max(groupedXData[groupedXData.length - 1], xAxis.dataMax);
      }
    };
    var dataGrouping = {
      approximations,
      groupData
    };
    seriesProto$3.processData;
    var baseGeneratePoints = seriesProto$3.generatePoints, commonOptions = {
      // enabled: null, // (true for stock charts, false for basic),
      // forced: undefined,
      groupPixelWidth: 2,
      // the first one is the point or start value, the second is the start
      // value if we're dealing with range, the third one is the end value if
      // dealing with a range
      dateTimeLabelFormats: {
        millisecond: [
          "%A, %b %e, %H:%M:%S.%L",
          "%A, %b %e, %H:%M:%S.%L",
          "-%H:%M:%S.%L"
        ],
        second: [
          "%A, %b %e, %H:%M:%S",
          "%A, %b %e, %H:%M:%S",
          "-%H:%M:%S"
        ],
        minute: [
          "%A, %b %e, %H:%M",
          "%A, %b %e, %H:%M",
          "-%H:%M"
        ],
        hour: [
          "%A, %b %e, %H:%M",
          "%A, %b %e, %H:%M",
          "-%H:%M"
        ],
        day: [
          "%A, %b %e, %Y",
          "%A, %b %e",
          "-%A, %b %e, %Y"
        ],
        week: [
          "Week from %A, %b %e, %Y",
          "%A, %b %e",
          "-%A, %b %e, %Y"
        ],
        month: [
          "%B %Y",
          "%B",
          "-%B %Y"
        ],
        year: [
          "%Y",
          "%Y",
          "-%Y"
        ]
      }
      // smoothed = false, // enable this for navigator series only
    }, specificOptions = {
      line: {},
      spline: {},
      area: {},
      areaspline: {},
      arearange: {},
      column: {
        groupPixelWidth: 10
      },
      columnrange: {
        groupPixelWidth: 10
      },
      candlestick: {
        groupPixelWidth: 10
      },
      ohlc: {
        groupPixelWidth: 5
      },
      // Move to HeikinAshiSeries.ts aftre refactoring data grouping.
      heikinashi: {
        groupPixelWidth: 10
      }
    }, defaultDataGroupingUnits = H.defaultDataGroupingUnits = [
      [
        "millisecond",
        [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]
        // allowed multiples
      ],
      [
        "second",
        [1, 2, 5, 10, 15, 30]
      ],
      [
        "minute",
        [1, 2, 5, 10, 15, 30]
      ],
      [
        "hour",
        [1, 2, 3, 4, 6, 8, 12]
      ],
      [
        "day",
        [1]
      ],
      [
        "week",
        [1]
      ],
      [
        "month",
        [1, 3, 6]
      ],
      [
        "year",
        null
      ]
    ];
    seriesProto$3.getDGApproximation = function() {
      if (this.is("arearange")) {
        return "range";
      }
      if (this.is("ohlc")) {
        return "ohlc";
      }
      if (this.is("column")) {
        return "sum";
      }
      return "average";
    };
    seriesProto$3.groupData = groupData;
    seriesProto$3.applyGrouping = applyGrouping;
    seriesProto$3.destroyGroupedData = function() {
      if (this.groupedData) {
        this.groupedData.forEach(function(point, i) {
          if (point) {
            this.groupedData[i] = point.destroy ? point.destroy() : null;
          }
        }, this);
        this.groupedData.length = 0;
      }
    };
    seriesProto$3.generatePoints = function() {
      baseGeneratePoints.apply(this);
      this.destroyGroupedData();
      this.groupedData = this.hasGroupedData ? this.points : null;
    };
    Axis.prototype.applyGrouping = function() {
      var axis = this, series = axis.series;
      series.forEach(function(series2) {
        series2.groupPixelWidth = void 0;
        series2.groupPixelWidth = axis.getGroupPixelWidth && axis.getGroupPixelWidth();
        if (series2.groupPixelWidth) {
          series2.hasProcessed = true;
        }
        series2.applyGrouping();
      });
    };
    Axis.prototype.getGroupPixelWidth = function() {
      var series = this.series, len = series.length, i, groupPixelWidth = 0, doGrouping = false, dataLength, dgOptions;
      i = len;
      while (i--) {
        dgOptions = series[i].options.dataGrouping;
        if (dgOptions) {
          groupPixelWidth = Math.max(
            groupPixelWidth,
            // Fallback to commonOptions (#9693)
            pick$$(dgOptions.groupPixelWidth, commonOptions.groupPixelWidth)
          );
        }
      }
      i = len;
      while (i--) {
        dgOptions = series[i].options.dataGrouping;
        if (dgOptions) {
          dataLength = (series[i].processedXData || series[i].data).length;
          if (series[i].groupPixelWidth || dataLength > this.chart.plotSizeX / groupPixelWidth || dataLength && dgOptions.forced) {
            doGrouping = true;
          }
        }
      }
      return doGrouping ? groupPixelWidth : 0;
    };
    Axis.prototype.setDataGrouping = function(dataGrouping2, redraw) {
      var axis = this;
      var i;
      redraw = pick$$(redraw, true);
      if (!dataGrouping2) {
        dataGrouping2 = {
          forced: false,
          units: null
        };
      }
      if (this instanceof Axis) {
        i = this.series.length;
        while (i--) {
          this.series[i].update({
            dataGrouping: dataGrouping2
          }, false);
        }
      } else {
        this.chart.options.series.forEach(function(seriesOptions) {
          seriesOptions.dataGrouping = dataGrouping2;
        }, false);
      }
      if (axis.ordinal) {
        axis.ordinal.slope = void 0;
      }
      if (redraw) {
        this.chart.redraw();
      }
    };
    addEvent$K(Axis, "postProcessData", Axis.prototype.applyGrouping);
    addEvent$K(Point$2, "update", function() {
      if (this.dataGroup) {
        error$2(24, false, this.series.chart);
        return false;
      }
    });
    addEvent$K(Tooltip, "headerFormatter", function(e2) {
      var chart = this.chart, time = chart.time, labelConfig = e2.labelConfig, series = labelConfig.series, options = series.options, tooltipOptions = series.tooltipOptions, dataGroupingOptions = options.dataGrouping, xDateFormat = tooltipOptions.xDateFormat, xDateFormatEnd, xAxis = series.xAxis, currentDataGrouping, dateTimeLabelFormats, labelFormats, formattedKey, formatString = tooltipOptions[e2.isFooter ? "footerFormat" : "headerFormat"];
      if (xAxis && xAxis.options.type === "datetime" && dataGroupingOptions && isNumber$s(labelConfig.key)) {
        currentDataGrouping = series.currentDataGrouping;
        dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats || // Fallback to commonOptions (#9693)
        commonOptions.dateTimeLabelFormats;
        if (currentDataGrouping) {
          labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];
          if (currentDataGrouping.count === 1) {
            xDateFormat = labelFormats[0];
          } else {
            xDateFormat = labelFormats[1];
            xDateFormatEnd = labelFormats[2];
          }
        } else if (!xDateFormat && dateTimeLabelFormats && xAxis.dateTime) {
          xDateFormat = xAxis.dateTime.getXDateFormat(labelConfig.x, tooltipOptions.dateTimeLabelFormats);
        }
        formattedKey = time.dateFormat(xDateFormat, labelConfig.key);
        if (xDateFormatEnd) {
          formattedKey += time.dateFormat(xDateFormatEnd, labelConfig.key + currentDataGrouping.totalRange - 1);
        }
        if (series.chart.styledMode) {
          formatString = this.styledModeFormat(formatString);
        }
        e2.text = format$8(formatString, {
          point: extend$12(labelConfig.point, { key: formattedKey }),
          series
        }, chart);
        e2.preventDefault();
      }
    });
    addEvent$K(Series$e, "destroy", seriesProto$3.destroyGroupedData);
    addEvent$K(Series$e, "afterSetOptions", function(e2) {
      var options = e2.options, type = this.type, plotOptions = this.chart.options.plotOptions, defaultOptions2 = DefaultOptions.defaultOptions.plotOptions[type].dataGrouping, baseOptions = this.useCommonDataGrouping && commonOptions;
      if (specificOptions[type] || baseOptions) {
        if (!defaultOptions2) {
          defaultOptions2 = merge$W(commonOptions, specificOptions[type]);
        }
        var rangeSelector = this.chart.rangeSelector;
        options.dataGrouping = merge$W(
          baseOptions,
          defaultOptions2,
          plotOptions.series && plotOptions.series.dataGrouping,
          // #1228
          // Set by the StockChart constructor:
          plotOptions[type].dataGrouping,
          this.userOptions.dataGrouping,
          !options.isInternal && rangeSelector && isNumber$s(rangeSelector.selected) && rangeSelector.buttonOptions[rangeSelector.selected].dataGrouping
        );
      }
    });
    addEvent$K(Axis, "afterSetScale", function() {
      this.series.forEach(function(series) {
        series.hasProcessed = false;
      });
    });
    H.dataGrouping = dataGrouping;
    var __extends$L = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var ColumnSeries$g = SeriesRegistry$1.seriesTypes.column;
    var OHLCPoint = (
      /** @class */
      function(_super) {
        __extends$L(OHLCPoint2, _super);
        function OHLCPoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.close = void 0;
          _this.high = void 0;
          _this.low = void 0;
          _this.open = void 0;
          _this.options = void 0;
          _this.plotClose = void 0;
          _this.plotOpen = void 0;
          _this.series = void 0;
          return _this;
        }
        OHLCPoint2.prototype.getClassName = function() {
          return _super.prototype.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
        };
        OHLCPoint2.prototype.resolveUpColor = function() {
          if (this.open < this.close && !this.options.color && this.series.options.upColor) {
            this.color = this.series.options.upColor;
          }
        };
        OHLCPoint2.prototype.resolveColor = function() {
          _super.prototype.resolveColor.call(this);
          this.resolveUpColor();
        };
        OHLCPoint2.prototype.getZone = function() {
          var zone = _super.prototype.getZone.call(this);
          this.resolveUpColor();
          return zone;
        };
        OHLCPoint2.prototype.applyOptions = function() {
          _super.prototype.applyOptions.apply(this, arguments);
          if (this.resolveColor) {
            this.resolveColor();
          }
          return this;
        };
        return OHLCPoint2;
      }(ColumnSeries$g.prototype.pointClass)
    );
    var __extends$K = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var ColumnSeries$f = SeriesRegistry$1.seriesTypes.column;
    var extend$11 = Utilities.extend, merge$V = Utilities.merge;
    var OHLCSeries$1 = (
      /** @class */
      function(_super) {
        __extends$K(OHLCSeries2, _super);
        function OHLCSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          _this.yData = void 0;
          return _this;
        }
        OHLCSeries2.prototype.drawPoints = function() {
          var series = this, points = series.points, chart = series.chart, extendStem = function(path, halfStrokeWidth, openOrClose) {
            var start = path[0];
            var end = path[1];
            if (typeof start[2] === "number") {
              start[2] = Math.max(openOrClose + halfStrokeWidth, start[2]);
            }
            if (typeof end[2] === "number") {
              end[2] = Math.min(openOrClose - halfStrokeWidth, end[2]);
            }
          };
          points.forEach(function(point) {
            var plotOpen, plotClose, crispCorr, halfWidth, path, graphic = point.graphic, crispX, isNew = !graphic, strokeWidth;
            if (typeof point.plotY !== "undefined") {
              if (!graphic) {
                point.graphic = graphic = chart.renderer.path().add(series.group);
              }
              if (!chart.styledMode) {
                graphic.attr(series.pointAttribs(point, point.selected && "select"));
              }
              strokeWidth = graphic.strokeWidth();
              crispCorr = strokeWidth % 2 / 2;
              crispX = Math.round(point.plotX) - crispCorr;
              halfWidth = Math.round(point.shapeArgs.width / 2);
              path = [
                ["M", crispX, Math.round(point.yBottom)],
                ["L", crispX, Math.round(point.plotHigh)]
              ];
              if (point.open !== null) {
                plotOpen = Math.round(point.plotOpen) + crispCorr;
                path.push(["M", crispX, plotOpen], ["L", crispX - halfWidth, plotOpen]);
                extendStem(path, strokeWidth / 2, plotOpen);
              }
              if (point.close !== null) {
                plotClose = Math.round(point.plotClose) + crispCorr;
                path.push(["M", crispX, plotClose], ["L", crispX + halfWidth, plotClose]);
                extendStem(path, strokeWidth / 2, plotClose);
              }
              graphic[isNew ? "attr" : "animate"]({ d: path }).addClass(point.getClassName(), true);
            }
          });
        };
        OHLCSeries2.prototype.init = function() {
          _super.prototype.init.apply(this, arguments);
          this.options.stacking = void 0;
        };
        OHLCSeries2.prototype.pointAttribs = function(point, state) {
          var attribs = _super.prototype.pointAttribs.call(this, point, state), options = this.options;
          delete attribs.fill;
          if (!point.options.color && options.upColor && point.open < point.close) {
            attribs.stroke = options.upColor;
          }
          return attribs;
        };
        OHLCSeries2.prototype.toYData = function(point) {
          return [point.open, point.high, point.low, point.close];
        };
        OHLCSeries2.prototype.translate = function() {
          var series = this, yAxis = series.yAxis, hasModifyValue = !!series.modifyValue, translated = [
            "plotOpen",
            "plotHigh",
            "plotLow",
            "plotClose",
            "yBottom"
          ];
          _super.prototype.translate.apply(series);
          series.points.forEach(function(point) {
            [point.open, point.high, point.low, point.close, point.low].forEach(function(value, i) {
              if (value !== null) {
                if (hasModifyValue) {
                  value = series.modifyValue(value);
                }
                point[translated[i]] = yAxis.toPixels(value, true);
              }
            });
            point.tooltipPos[1] = point.plotHigh + yAxis.pos - series.chart.plotTop;
          });
        };
        OHLCSeries2.defaultOptions = merge$V(ColumnSeries$f.defaultOptions, {
          /**
           * The approximate pixel width of each group. If for example a series
           * with 30 points is displayed over a 600 pixel wide plot area, no
           * grouping is performed. If however the series contains so many points
           * that the spacing is less than the groupPixelWidth, Highcharts will
           * try to group it into appropriate groups so that each is more or less
           * two pixels wide. Defaults to `5`.
           *
           * @type      {number}
           * @default   5
           * @product   highstock
           * @apioption plotOptions.ohlc.dataGrouping.groupPixelWidth
           */
          /**
           * The pixel width of the line/border. Defaults to `1`.
           *
           * @sample {highstock} stock/plotoptions/ohlc-linewidth/
           *         A greater line width
           *
           * @type    {number}
           * @default 1
           * @product highstock
           *
           * @private
           */
          lineWidth: 1,
          tooltip: {
            pointFormat: '<span style="color:{point.color}"></span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'
          },
          threshold: null,
          states: {
            /**
             * @extends plotOptions.column.states.hover
             * @product highstock
             */
            hover: {
              /**
               * The pixel width of the line representing the OHLC point.
               *
               * @type    {number}
               * @default 3
               * @product highstock
               */
              lineWidth: 3
            }
          },
          /**
           * Determines which one of `open`, `high`, `low`, `close` values should
           * be represented as `point.y`, which is later used to set dataLabel
           * position and [compare](#plotOptions.series.compare).
           *
           * @sample {highstock} stock/plotoptions/ohlc-pointvalkey/
           *         Possible values
           *
           * @type       {string}
           * @default    close
           * @validvalue ["open", "high", "low", "close"]
           * @product    highstock
           * @apioption  plotOptions.ohlc.pointValKey
           */
          /**
           * @default   close
           * @apioption plotOptions.ohlc.colorKey
           */
          /**
           * Line color for up points.
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @product   highstock
           * @apioption plotOptions.ohlc.upColor
           */
          stickyTracking: true
        });
        return OHLCSeries2;
      }(ColumnSeries$f)
    );
    extend$11(OHLCSeries$1.prototype, {
      animate: null,
      directTouch: false,
      pointArrayMap: ["open", "high", "low", "close"],
      pointAttrToOptions: {
        stroke: "color",
        "stroke-width": "lineWidth"
      },
      pointValKey: "close"
    });
    OHLCSeries$1.prototype.pointClass = OHLCPoint;
    SeriesRegistry$1.registerSeriesType("ohlc", OHLCSeries$1);
    var __extends$J = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var defaultOptions$9 = DefaultOptions.defaultOptions;
    var _a$d = SeriesRegistry$1.seriesTypes, ColumnSeries$e = _a$d.column, OHLCSeries = _a$d.ohlc;
    var merge$U = Utilities.merge;
    var CandlestickSeries = (
      /** @class */
      function(_super) {
        __extends$J(CandlestickSeries2, _super);
        function CandlestickSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        CandlestickSeries2.prototype.pointAttribs = function(point, state) {
          var attribs = ColumnSeries$e.prototype.pointAttribs.call(this, point, state), options = this.options, isUp = point.open < point.close, stroke = options.lineColor || this.color, color2 = point.color || this.color, stateOptions;
          attribs["stroke-width"] = options.lineWidth;
          attribs.fill = point.options.color || (isUp ? options.upColor || color2 : color2);
          attribs.stroke = point.options.lineColor || (isUp ? options.upLineColor || stroke : stroke);
          if (state) {
            stateOptions = options.states[state];
            attribs.fill = stateOptions.color || attribs.fill;
            attribs.stroke = stateOptions.lineColor || attribs.stroke;
            attribs["stroke-width"] = stateOptions.lineWidth || attribs["stroke-width"];
          }
          return attribs;
        };
        CandlestickSeries2.prototype.drawPoints = function() {
          var series = this, points = series.points, chart = series.chart, reversedYAxis = series.yAxis.reversed;
          points.forEach(function(point) {
            var graphic = point.graphic, plotOpen, plotClose, topBox, bottomBox, hasTopWhisker, hasBottomWhisker, crispCorr, crispX, path, halfWidth, isNew = !graphic;
            if (typeof point.plotY !== "undefined") {
              if (!graphic) {
                point.graphic = graphic = chart.renderer.path().add(series.group);
              }
              if (!series.chart.styledMode) {
                graphic.attr(series.pointAttribs(point, point.selected && "select")).shadow(series.options.shadow);
              }
              crispCorr = graphic.strokeWidth() % 2 / 2;
              crispX = Math.round(point.plotX) - crispCorr;
              plotOpen = point.plotOpen;
              plotClose = point.plotClose;
              topBox = Math.min(plotOpen, plotClose);
              bottomBox = Math.max(plotOpen, plotClose);
              halfWidth = Math.round(point.shapeArgs.width / 2);
              hasTopWhisker = reversedYAxis ? bottomBox !== point.yBottom : Math.round(topBox) !== Math.round(point.plotHigh);
              hasBottomWhisker = reversedYAxis ? Math.round(topBox) !== Math.round(point.plotHigh) : bottomBox !== point.yBottom;
              topBox = Math.round(topBox) + crispCorr;
              bottomBox = Math.round(bottomBox) + crispCorr;
              path = [];
              path.push(
                ["M", crispX - halfWidth, bottomBox],
                ["L", crispX - halfWidth, topBox],
                ["L", crispX + halfWidth, topBox],
                ["L", crispX + halfWidth, bottomBox],
                ["Z"],
                // Ensure a nice rectangle #2602
                ["M", crispX, topBox],
                [
                  "L",
                  // #460, #2094
                  crispX,
                  hasTopWhisker ? Math.round(reversedYAxis ? point.yBottom : point.plotHigh) : topBox
                ],
                ["M", crispX, bottomBox],
                [
                  "L",
                  // #460, #2094
                  crispX,
                  hasBottomWhisker ? Math.round(reversedYAxis ? point.plotHigh : point.yBottom) : bottomBox
                ]
              );
              graphic[isNew ? "attr" : "animate"]({ d: path }).addClass(point.getClassName(), true);
            }
          });
        };
        CandlestickSeries2.defaultOptions = merge$U(OHLCSeries.defaultOptions, defaultOptions$9.plotOptions, {
          /**
           * The specific line color for up candle sticks. The default is to
           * inherit the general `lineColor` setting.
           *
           * @sample {highstock} stock/plotoptions/candlestick-linecolor/
           *         Candlestick line colors
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @since     1.3.6
           * @product   highstock
           * @apioption plotOptions.candlestick.upLineColor
           */
          /**
           * @type      {Highcharts.DataGroupingApproximationValue|Function}
           * @default   ohlc
           * @product   highstock
           * @apioption plotOptions.candlestick.dataGrouping.approximation
           */
          states: {
            /**
             * @extends plotOptions.column.states.hover
             * @product highstock
             */
            hover: {
              /**
               * The pixel width of the line/border around the candlestick.
               *
               * @product highstock
               */
              lineWidth: 2
            }
          },
          /**
           * @extends plotOptions.ohlc.tooltip
           */
          tooltip: defaultOptions$9.plotOptions.ohlc.tooltip,
          /**
           * @type    {number|null}
           * @product highstock
           */
          threshold: null,
          /**
           * The color of the line/border of the candlestick.
           *
           * In styled mode, the line stroke can be set with the
           * `.highcharts-candlestick-series .highcahrts-point` rule.
           *
           * @see [upLineColor](#plotOptions.candlestick.upLineColor)
           *
           * @sample {highstock} stock/plotoptions/candlestick-linecolor/
           *         Candlestick line colors
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default #000000
           * @product highstock
           */
          lineColor: palette.neutralColor100,
          /**
           * The pixel width of the candlestick line/border. Defaults to `1`.
           *
           *
           * In styled mode, the line stroke width can be set with the
           * `.highcharts-candlestick-series .highcahrts-point` rule.
           *
           * @product highstock
           */
          lineWidth: 1,
          /**
           * The fill color of the candlestick when values are rising.
           *
           * In styled mode, the up color can be set with the
           * `.highcharts-candlestick-series .highcharts-point-up` rule.
           *
           * @sample {highstock} stock/plotoptions/candlestick-color/
           *         Custom colors
           * @sample {highstock} highcharts/css/candlestick/
           *         Colors in styled mode
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default #ffffff
           * @product highstock
           */
          upColor: palette.backgroundColor,
          /**
           * @product highstock
           */
          stickyTracking: true
        });
        return CandlestickSeries2;
      }(OHLCSeries)
    );
    SeriesRegistry$1.registerSeriesType("candlestick", CandlestickSeries);
    var __extends$I = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var ColumnSeries$d = SeriesRegistry$1.seriesTypes.column;
    var isNumber$r = Utilities.isNumber;
    var FlagsPoint = (
      /** @class */
      function(_super) {
        __extends$I(FlagsPoint2, _super);
        function FlagsPoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.options = void 0;
          _this.series = void 0;
          return _this;
        }
        FlagsPoint2.prototype.isValid = function() {
          return isNumber$r(this.y) || typeof this.y === "undefined";
        };
        FlagsPoint2.prototype.hasNewShapeType = function() {
          var shape = this.options.shape || this.series.options.shape;
          return this.graphic && shape && shape !== this.graphic.symbolKey;
        };
        return FlagsPoint2;
      }(ColumnSeries$d.prototype.pointClass)
    );
    var columnProto$5 = ColumnSeries$h.prototype;
    var seriesProto$2 = Series$e.prototype;
    var defined$x = Utilities.defined, stableSort$4 = Utilities.stableSort;
    var onSeriesMixin = {
      /* eslint-disable valid-jsdoc */
      /**
       * Override getPlotBox. If the onSeries option is valid, return the plot box
       * of the onSeries, otherwise proceed as usual.
       *
       * @private
       * @function onSeriesMixin.getPlotBox
       * @return {Highcharts.SeriesPlotBoxObject}
       */
      getPlotBox: function() {
        return seriesProto$2.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);
      },
      /**
       * Extend the translate method by placing the point on the related series
       *
       * @private
       * @function onSeriesMixin.translate
       * @return {void}
       */
      translate: function() {
        columnProto$5.translate.apply(this);
        var series = this, options = series.options, chart = series.chart, points = series.points, cursor = points.length - 1, point, lastPoint, optionsOnSeries = options.onSeries, onSeries = optionsOnSeries && chart.get(optionsOnSeries), onKey = options.onKey || "y", step = onSeries && onSeries.options.step, onData = onSeries && onSeries.points, i = onData && onData.length, inverted = chart.inverted, xAxis = series.xAxis, yAxis = series.yAxis, xOffset = 0, leftPoint, lastX, rightPoint, currentDataGrouping, distanceRatio;
        if (onSeries && onSeries.visible && i) {
          xOffset = (onSeries.pointXOffset || 0) + (onSeries.barW || 0) / 2;
          currentDataGrouping = onSeries.currentDataGrouping;
          lastX = onData[i - 1].x + (currentDataGrouping ? currentDataGrouping.totalRange : 0);
          stableSort$4(points, function(a, b) {
            return a.x - b.x;
          });
          onKey = "plot" + onKey[0].toUpperCase() + onKey.substr(1);
          while (i-- && points[cursor]) {
            leftPoint = onData[i];
            point = points[cursor];
            point.y = leftPoint.y;
            if (leftPoint.x <= point.x && typeof leftPoint[onKey] !== "undefined") {
              if (point.x <= lastX) {
                point.plotY = leftPoint[onKey];
                if (leftPoint.x < point.x && !step) {
                  rightPoint = onData[i + 1];
                  if (rightPoint && typeof rightPoint[onKey] !== "undefined") {
                    distanceRatio = (point.x - leftPoint.x) / (rightPoint.x - leftPoint.x);
                    point.plotY += distanceRatio * // the plotY distance
                    (rightPoint[onKey] - leftPoint[onKey]);
                    point.y += distanceRatio * (rightPoint.y - leftPoint.y);
                  }
                }
              }
              cursor--;
              i++;
              if (cursor < 0) {
                break;
              }
            }
          }
        }
        points.forEach(function(point2, i2) {
          var stackIndex;
          point2.plotX += xOffset;
          if (typeof point2.plotY === "undefined" || inverted) {
            if (point2.plotX >= 0 && point2.plotX <= xAxis.len) {
              if (inverted) {
                point2.plotY = xAxis.translate(point2.x, 0, 1, 0, 1);
                point2.plotX = defined$x(point2.y) ? yAxis.translate(point2.y, 0, 0, 0, 1) : 0;
              } else {
                point2.plotY = (xAxis.opposite ? 0 : series.yAxis.len) + xAxis.offset;
              }
            } else {
              point2.shapeArgs = {};
            }
          }
          lastPoint = points[i2 - 1];
          if (lastPoint && lastPoint.plotX === point2.plotX) {
            if (typeof lastPoint.stackIndex === "undefined") {
              lastPoint.stackIndex = 0;
            }
            stackIndex = lastPoint.stackIndex + 1;
          }
          point2.stackIndex = stackIndex;
        });
        this.onSeries = onSeries;
      }
      /* eslint-enable valid-jsdoc */
    };
    var symbols$3 = SVGRenderer.prototype.symbols;
    symbols$3.flag = function(x, y, w2, h, options) {
      var anchorX = options && options.anchorX || x, anchorY = options && options.anchorY || y;
      var path = symbols$3.circle(anchorX - 1, anchorY - 1, 2, 2);
      path.push(["M", anchorX, anchorY], ["L", x, y + h], ["L", x, y], ["L", x + w2, y], ["L", x + w2, y + h], ["L", x, y + h], ["Z"]);
      return path;
    };
    function createPinSymbol(shape) {
      symbols$3[shape + "pin"] = function(x, y, w2, h, options) {
        var anchorX = options && options.anchorX, anchorY = options && options.anchorY;
        var path;
        if (shape === "circle" && h > w2) {
          x -= Math.round((h - w2) / 2);
          w2 = h;
        }
        path = symbols$3[shape](x, y, w2, h);
        if (anchorX && anchorY) {
          var labelX = anchorX;
          if (shape === "circle") {
            labelX = x + w2 / 2;
          } else {
            var startSeg = path[0];
            var endSeg = path[1];
            if (startSeg[0] === "M" && endSeg[0] === "L") {
              labelX = (startSeg[1] + endSeg[1]) / 2;
            }
          }
          var labelY = y > anchorY ? y : y + h;
          path.push([
            "M",
            labelX,
            labelY
          ], [
            "L",
            anchorX,
            anchorY
          ]);
          path = path.concat(symbols$3.circle(anchorX - 1, anchorY - 1, 2, 2));
        }
        return path;
      };
    }
    createPinSymbol("circle");
    createPinSymbol("square");
    var Renderer = RendererRegistry$1.getRendererType();
    if (Renderer !== SVGRenderer) {
      Renderer.prototype.symbols.circlepin = symbols$3.circlepin;
      Renderer.prototype.symbols.flag = symbols$3.flag;
      Renderer.prototype.symbols.squarepin = symbols$3.squarepin;
    }
    var __extends$H = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var noop$e = H.noop;
    var distribute = R.distribute;
    var Series$b = SeriesRegistry$1.series, ColumnSeries$c = SeriesRegistry$1.seriesTypes.column;
    var addEvent$J = Utilities.addEvent, defined$w = Utilities.defined, extend$10 = Utilities.extend, merge$T = Utilities.merge, objectEach$e = Utilities.objectEach, wrap$b = Utilities.wrap;
    var FlagsSeries = (
      /** @class */
      function(_super) {
        __extends$H(FlagsSeries2, _super);
        function FlagsSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        FlagsSeries2.prototype.animate = function(init) {
          if (init) {
            this.setClip();
          }
        };
        FlagsSeries2.prototype.drawPoints = function() {
          var series = this, points = series.points, chart = series.chart, renderer = chart.renderer, plotX, plotY, inverted = chart.inverted, options = series.options, optionsY = options.y, shape, i, point, graphic, stackIndex, anchorY, attribs, outsideRight, yAxis = series.yAxis, boxesMap = {}, boxes = [], centered;
          i = points.length;
          while (i--) {
            point = points[i];
            outsideRight = (inverted ? point.plotY : point.plotX) > series.xAxis.len;
            plotX = point.plotX;
            stackIndex = point.stackIndex;
            shape = point.options.shape || options.shape;
            plotY = point.plotY;
            if (typeof plotY !== "undefined") {
              plotY = point.plotY + optionsY - (typeof stackIndex !== "undefined" && stackIndex * options.stackDistance);
            }
            point.anchorX = stackIndex ? void 0 : point.plotX;
            anchorY = stackIndex ? void 0 : point.plotY;
            centered = shape !== "flag";
            graphic = point.graphic;
            if (typeof plotY !== "undefined" && plotX >= 0 && !outsideRight) {
              if (graphic && point.hasNewShapeType()) {
                graphic = graphic.destroy();
              }
              if (!graphic) {
                graphic = point.graphic = renderer.label("", null, null, shape, null, null, options.useHTML).addClass("highcharts-point").add(series.markerGroup);
                if (point.graphic.div) {
                  point.graphic.div.point = point;
                }
                graphic.isNew = true;
              }
              graphic.attr({
                align: centered ? "center" : "left",
                width: options.width,
                height: options.height,
                "text-align": options.textAlign
              });
              if (!chart.styledMode) {
                graphic.attr(series.pointAttribs(point)).css(merge$T(options.style, point.style)).shadow(options.shadow);
              }
              if (plotX > 0) {
                plotX -= graphic.strokeWidth() % 2;
              }
              attribs = {
                y: plotY,
                anchorY
              };
              if (options.allowOverlapX) {
                attribs.x = plotX;
                attribs.anchorX = point.anchorX;
              }
              graphic.attr({
                text: point.options.title || options.title || "A"
              })[graphic.isNew ? "attr" : "animate"](attribs);
              if (!options.allowOverlapX) {
                if (!boxesMap[point.plotX]) {
                  boxesMap[point.plotX] = {
                    align: centered ? 0.5 : 0,
                    size: graphic.width,
                    target: plotX,
                    anchorX: plotX
                  };
                } else {
                  boxesMap[point.plotX].size = Math.max(boxesMap[point.plotX].size, graphic.width);
                }
              }
              point.tooltipPos = [
                plotX,
                plotY + yAxis.pos - chart.plotTop
              ];
            } else if (graphic) {
              point.graphic = graphic.destroy();
            }
          }
          if (!options.allowOverlapX) {
            objectEach$e(boxesMap, function(box) {
              box.plotX = box.anchorX;
              boxes.push(box);
            });
            distribute(boxes, inverted ? yAxis.len : this.xAxis.len, 100);
            points.forEach(function(point2) {
              var box = point2.graphic && boxesMap[point2.plotX];
              if (box) {
                point2.graphic[point2.graphic.isNew ? "attr" : "animate"]({
                  x: box.pos + box.align * box.size,
                  anchorX: point2.anchorX
                });
                if (!defined$w(box.pos)) {
                  point2.graphic.attr({
                    x: -9999,
                    anchorX: -9999
                  });
                  point2.graphic.isNew = true;
                } else {
                  point2.graphic.isNew = false;
                }
              }
            });
          }
          if (options.useHTML) {
            wrap$b(series.markerGroup, "on", function(proceed) {
              return SVGElement.prototype.on.apply(
                // for HTML
                // eslint-disable-next-line no-invalid-this
                proceed.apply(this, [].slice.call(arguments, 1)),
                // and for SVG
                [].slice.call(arguments, 1)
              );
            });
          }
        };
        FlagsSeries2.prototype.drawTracker = function() {
          var series = this, points = series.points;
          _super.prototype.drawTracker.call(this);
          points.forEach(function(point) {
            var graphic = point.graphic;
            if (graphic) {
              if (point.unbindMouseOver) {
                point.unbindMouseOver();
              }
              point.unbindMouseOver = addEvent$J(graphic.element, "mouseover", function() {
                if (point.stackIndex > 0 && !point.raised) {
                  point._y = graphic.y;
                  graphic.attr({
                    y: point._y - 8
                  });
                  point.raised = true;
                }
                points.forEach(function(otherPoint) {
                  if (otherPoint !== point && otherPoint.raised && otherPoint.graphic) {
                    otherPoint.graphic.attr({
                      y: otherPoint._y
                    });
                    otherPoint.raised = false;
                  }
                });
              });
            }
          });
        };
        FlagsSeries2.prototype.pointAttribs = function(point, state) {
          var options = this.options, color2 = point && point.color || this.color, lineColor = options.lineColor, lineWidth = point && point.lineWidth, fill = point && point.fillColor || options.fillColor;
          if (state) {
            fill = options.states[state].fillColor;
            lineColor = options.states[state].lineColor;
            lineWidth = options.states[state].lineWidth;
          }
          return {
            fill: fill || color2,
            stroke: lineColor || color2,
            "stroke-width": lineWidth || options.lineWidth || 0
          };
        };
        FlagsSeries2.prototype.setClip = function() {
          Series$b.prototype.setClip.apply(this, arguments);
          if (this.options.clip !== false && this.sharedClipKey && this.markerGroup) {
            this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);
          }
        };
        FlagsSeries2.defaultOptions = merge$T(ColumnSeries$c.defaultOptions, {
          /**
           * In case the flag is placed on a series, on what point key to place
           * it. Line and columns have one key, `y`. In range or OHLC-type series,
           * however, the flag can optionally be placed on the `open`, `high`,
           * `low` or `close` key.
           *
           * @sample {highstock} stock/plotoptions/flags-onkey/
           *         Range series, flag on high
           *
           * @type       {string}
           * @default    y
           * @since      4.2.2
           * @product    highstock
           * @validvalue ["y", "open", "high", "low", "close"]
           * @apioption  plotOptions.flags.onKey
           */
          /**
           * The id of the series that the flags should be drawn on. If no id
           * is given, the flags are drawn on the x axis.
           *
           * @sample {highstock} stock/plotoptions/flags/
           *         Flags on series and on x axis
           *
           * @type      {string}
           * @product   highstock
           * @apioption plotOptions.flags.onSeries
           */
          pointRange: 0,
          /**
           * Whether the flags are allowed to overlap sideways. If `false`, the
           * flags are moved sideways using an algorithm that seeks to place every
           * flag as close as possible to its original position.
           *
           * @sample {highstock} stock/plotoptions/flags-allowoverlapx
           *         Allow sideways overlap
           *
           * @since 6.0.4
           */
          allowOverlapX: false,
          /**
           * The shape of the marker. Can be one of "flag", "circlepin",
           * "squarepin", or an image of the format `url(/path-to-image.jpg)`.
           * Individual shapes can also be set for each point.
           *
           * @sample {highstock} stock/plotoptions/flags/
           *         Different shapes
           *
           * @type    {Highcharts.FlagsShapeValue}
           * @product highstock
           */
          shape: "flag",
          /**
           * When multiple flags in the same series fall on the same value, this
           * number determines the vertical offset between them.
           *
           * @sample {highstock} stock/plotoptions/flags-stackdistance/
           *         A greater stack distance
           *
           * @product highstock
           */
          stackDistance: 12,
          /**
           * Text alignment for the text inside the flag.
           *
           * @since      5.0.0
           * @product    highstock
           * @validvalue ["left", "center", "right"]
           */
          textAlign: "center",
          /**
           * Specific tooltip options for flag series. Flag series tooltips are
           * different from most other types in that a flag doesn't have a data
           * value, so the tooltip rather displays the `text` option for each
           * point.
           *
           * @extends   plotOptions.series.tooltip
           * @excluding changeDecimals, valueDecimals, valuePrefix, valueSuffix
           * @product   highstock
           */
          tooltip: {
            pointFormat: "{point.text}"
          },
          threshold: null,
          /**
           * The text to display on each flag. This can be defined on series
           * level, or individually for each point. Defaults to `"A"`.
           *
           * @type      {string}
           * @default   A
           * @product   highstock
           * @apioption plotOptions.flags.title
           */
          /**
           * The y position of the top left corner of the flag relative to either
           * the series (if onSeries is defined), or the x axis. Defaults to
           * `-30`.
           *
           * @product highstock
           */
          y: -30,
          /**
           * Whether to use HTML to render the flag texts. Using HTML allows for
           * advanced formatting, images and reliable bi-directional text
           * rendering. Note that exported images won't respect the HTML, and that
           * HTML won't respect Z-index settings.
           *
           * @type      {boolean}
           * @default   false
           * @since     1.3
           * @product   highstock
           * @apioption plotOptions.flags.useHTML
           */
          /**
           * Fixed width of the flag's shape. By default, width is autocalculated
           * according to the flag's title.
           *
           * @sample {highstock} stock/demo/flags-shapes/
           *         Flags with fixed width
           *
           * @type      {number}
           * @product   highstock
           * @apioption plotOptions.flags.width
           */
          /**
           * Fixed height of the flag's shape. By default, height is
           * autocalculated according to the flag's title.
           *
           * @type      {number}
           * @product   highstock
           * @apioption plotOptions.flags.height
           */
          /**
           * The fill color for the flags.
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @product highstock
           */
          fillColor: palette.backgroundColor,
          /**
           * The color of the line/border of the flag.
           *
           * In styled mode, the stroke is set in the
           * `.highcharts-flag-series.highcharts-point` rule.
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default   #000000
           * @product   highstock
           * @apioption plotOptions.flags.lineColor
           */
          /**
           * The pixel width of the flag's line/border.
           *
           * @product highstock
           */
          lineWidth: 1,
          states: {
            /**
             * @extends plotOptions.column.states.hover
             * @product highstock
             */
            hover: {
              /**
               * The color of the line/border of the flag.
               *
               * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @product highstock
               */
              lineColor: palette.neutralColor100,
              /**
               * The fill or background color of the flag.
               *
               * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @product highstock
               */
              fillColor: palette.highlightColor20
            }
          },
          /**
           * The text styles of the flag.
           *
           * In styled mode, the styles are set in the
           * `.highcharts-flag-series .highcharts-point` rule.
           *
           * @type    {Highcharts.CSSObject}
           * @default {"fontSize": "11px", "fontWeight": "bold"}
           * @product highstock
           */
          style: {
            /** @ignore-option */
            fontSize: "11px",
            /** @ignore-option */
            fontWeight: "bold"
          }
        });
        return FlagsSeries2;
      }(ColumnSeries$c)
    );
    extend$10(FlagsSeries.prototype, {
      allowDG: false,
      /**
       * @private
       * @function Highcharts.seriesTypes.flags#buildKDTree
       */
      buildKDTree: noop$e,
      forceCrop: true,
      getPlotBox: onSeriesMixin.getPlotBox,
      /**
       * Inherit the initialization from base Series.
       *
       * @private
       * @borrows Highcharts.Series#init as Highcharts.seriesTypes.flags#init
       */
      init: Series$b.prototype.init,
      /**
       * Don't invert the flag marker group (#4960).
       *
       * @private
       * @function Highcharts.seriesTypes.flags#invertGroups
       */
      invertGroups: noop$e,
      // Flags series group should not be invertible (#14063).
      invertible: false,
      noSharedTooltip: true,
      pointClass: FlagsPoint,
      sorted: false,
      takeOrdinalPosition: false,
      trackerGroups: ["markerGroup"],
      translate: onSeriesMixin.translate
    });
    SeriesRegistry$1.registerSeriesType("flags", FlagsSeries);
    var addEvent$I = Utilities.addEvent, defined$v = Utilities.defined, pick$_ = Utilities.pick;
    var ScrollbarAxis = (
      /** @class */
      function() {
        function ScrollbarAxis2() {
        }
        ScrollbarAxis2.compose = function(AxisClass, ScrollbarClass) {
          if (ScrollbarAxis2.composed.indexOf(AxisClass) === -1) {
            ScrollbarAxis2.composed.push(AxisClass);
          } else {
            return AxisClass;
          }
          var getExtremes = function(axis) {
            var axisMin = pick$_(axis.options && axis.options.min, axis.min);
            var axisMax = pick$_(axis.options && axis.options.max, axis.max);
            return {
              axisMin,
              axisMax,
              scrollMin: defined$v(axis.dataMin) ? Math.min(axisMin, axis.min, axis.dataMin, pick$_(axis.threshold, Infinity)) : axisMin,
              scrollMax: defined$v(axis.dataMax) ? Math.max(axisMax, axis.max, axis.dataMax, pick$_(axis.threshold, -Infinity)) : axisMax
            };
          };
          addEvent$I(AxisClass, "afterInit", function() {
            var axis = this;
            if (axis.options && axis.options.scrollbar && axis.options.scrollbar.enabled) {
              axis.options.scrollbar.vertical = !axis.horiz;
              axis.options.startOnTick = axis.options.endOnTick = false;
              axis.scrollbar = new ScrollbarClass(axis.chart.renderer, axis.options.scrollbar, axis.chart);
              addEvent$I(axis.scrollbar, "changed", function(e2) {
                var _a2 = getExtremes(axis), axisMin = _a2.axisMin, axisMax = _a2.axisMax, unitedMin = _a2.scrollMin, unitedMax = _a2.scrollMax, range = unitedMax - unitedMin, to, from;
                if (!defined$v(axisMin) || !defined$v(axisMax)) {
                  return;
                }
                if (axis.horiz && !axis.reversed || !axis.horiz && axis.reversed) {
                  to = unitedMin + range * this.to;
                  from = unitedMin + range * this.from;
                } else {
                  to = unitedMin + range * (1 - this.from);
                  from = unitedMin + range * (1 - this.to);
                }
                if (this.shouldUpdateExtremes(e2.DOMType)) {
                  axis.setExtremes(from, to, true, e2.DOMType !== "mousemove" && e2.DOMType !== "touchmove", e2);
                } else {
                  this.setRange(this.from, this.to);
                }
              });
            }
          });
          addEvent$I(AxisClass, "afterRender", function() {
            var axis = this, _a2 = getExtremes(axis), scrollMin = _a2.scrollMin, scrollMax = _a2.scrollMax, scrollbar = axis.scrollbar, offset2 = axis.axisTitleMargin + (axis.titleOffset || 0), scrollbarsOffsets = axis.chart.scrollbarsOffsets, axisMargin = axis.options.margin || 0, offsetsIndex, from, to;
            if (scrollbar) {
              if (axis.horiz) {
                if (!axis.opposite) {
                  scrollbarsOffsets[1] += offset2;
                }
                scrollbar.position(axis.left, axis.top + axis.height + 2 + scrollbarsOffsets[1] - (axis.opposite ? axisMargin : 0), axis.width, axis.height);
                if (!axis.opposite) {
                  scrollbarsOffsets[1] += axisMargin;
                }
                offsetsIndex = 1;
              } else {
                if (axis.opposite) {
                  scrollbarsOffsets[0] += offset2;
                }
                scrollbar.position(axis.left + axis.width + 2 + scrollbarsOffsets[0] - (axis.opposite ? 0 : axisMargin), axis.top, axis.width, axis.height);
                if (axis.opposite) {
                  scrollbarsOffsets[0] += axisMargin;
                }
                offsetsIndex = 0;
              }
              scrollbarsOffsets[offsetsIndex] += scrollbar.size + scrollbar.options.margin;
              if (isNaN(scrollMin) || isNaN(scrollMax) || !defined$v(axis.min) || !defined$v(axis.max) || axis.min === axis.max) {
                scrollbar.setRange(0, 1);
              } else {
                from = (axis.min - scrollMin) / (scrollMax - scrollMin);
                to = (axis.max - scrollMin) / (scrollMax - scrollMin);
                if (axis.horiz && !axis.reversed || !axis.horiz && axis.reversed) {
                  scrollbar.setRange(from, to);
                } else {
                  scrollbar.setRange(1 - to, 1 - from);
                }
              }
            }
          });
          addEvent$I(AxisClass, "afterGetOffset", function() {
            var axis = this, index = axis.horiz ? 2 : 1, scrollbar = axis.scrollbar;
            if (scrollbar) {
              axis.chart.scrollbarsOffsets = [0, 0];
              axis.chart.axisOffset[index] += scrollbar.size + scrollbar.options.margin;
            }
          });
          return AxisClass;
        };
        ScrollbarAxis2.composed = [];
        return ScrollbarAxis2;
      }()
    );
    var isTouchDevice$3 = H.isTouchDevice;
    var ScrollbarDefaults = {
      /**
       * The height of the scrollbar. The height also applies to the width
       * of the scroll arrows so that they are always squares. Defaults to
       * 20 for touch devices and 14 for mouse devices.
       *
       * @sample stock/scrollbar/height/
       *         A 30px scrollbar
       *
       * @type    {number}
       * @default 20/14
       */
      height: isTouchDevice$3 ? 20 : 14,
      /**
       * The border rounding radius of the bar.
       *
       * @sample stock/scrollbar/style/
       *         Scrollbar styling
       */
      barBorderRadius: 0,
      /**
       * The corner radius of the scrollbar buttons.
       *
       * @sample stock/scrollbar/style/
       *         Scrollbar styling
       */
      buttonBorderRadius: 0,
      /**
       * Enable or disable the scrollbar.
       *
       * @sample stock/scrollbar/enabled/
       *         Disable the scrollbar, only use navigator
       *
       * @type      {boolean}
       * @default   true
       * @apioption scrollbar.enabled
       */
      /**
       * Whether to redraw the main chart as the scrollbar or the navigator
       * zoomed window is moved. Defaults to `true` for modern browsers and
       * `false` for legacy IE browsers as well as mobile devices.
       *
       * @sample stock/scrollbar/liveredraw
       *         Setting live redraw to false
       *
       * @type  {boolean}
       * @since 1.3
       */
      liveRedraw: void 0,
      /**
       * The margin between the scrollbar and its axis when the scrollbar is
       * applied directly to an axis.
       */
      margin: 10,
      /**
       * The minimum width of the scrollbar.
       *
       * @since 1.2.5
       */
      minWidth: 6,
      /**
       * Whether to show or hide the scrollbar when the scrolled content is
       * zoomed out to it full extent.
       *
       * @type      {boolean}
       * @default   true
       * @apioption scrollbar.showFull
       */
      step: 0.2,
      /**
       * The z index of the scrollbar group.
       */
      zIndex: 3,
      /**
       * The background color of the scrollbar itself.
       *
       * @sample stock/scrollbar/style/
       *         Scrollbar styling
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      barBackgroundColor: palette.neutralColor20,
      /**
       * The width of the bar's border.
       *
       * @sample stock/scrollbar/style/
       *         Scrollbar styling
       */
      barBorderWidth: 1,
      /**
       * The color of the scrollbar's border.
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      barBorderColor: palette.neutralColor20,
      /**
       * The color of the small arrow inside the scrollbar buttons.
       *
       * @sample stock/scrollbar/style/
       *         Scrollbar styling
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      buttonArrowColor: palette.neutralColor80,
      /**
       * The color of scrollbar buttons.
       *
       * @sample stock/scrollbar/style/
       *         Scrollbar styling
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      buttonBackgroundColor: palette.neutralColor10,
      /**
       * The color of the border of the scrollbar buttons.
       *
       * @sample stock/scrollbar/style/
       *         Scrollbar styling
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      buttonBorderColor: palette.neutralColor20,
      /**
       * The border width of the scrollbar buttons.
       *
       * @sample stock/scrollbar/style/
       *         Scrollbar styling
       */
      buttonBorderWidth: 1,
      /**
       * The color of the small rifles in the middle of the scrollbar.
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      rifleColor: palette.neutralColor80,
      /**
       * The color of the track background.
       *
       * @sample stock/scrollbar/style/
       *         Scrollbar styling
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      trackBackgroundColor: palette.neutralColor5,
      /**
       * The color of the border of the scrollbar track.
       *
       * @sample stock/scrollbar/style/
       *         Scrollbar styling
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      trackBorderColor: palette.neutralColor5,
      /**
       * The corner radius of the border of the scrollbar track.
       *
       * @sample stock/scrollbar/style/
       *         Scrollbar styling
       *
       * @type      {number}
       * @default   0
       * @apioption scrollbar.trackBorderRadius
       */
      /**
       * The width of the border of the scrollbar track.
       *
       * @sample stock/scrollbar/style/
       *         Scrollbar styling
       */
      trackBorderWidth: 1
    };
    var defaultOptions$8 = DefaultOptions.defaultOptions;
    var addEvent$H = Utilities.addEvent, correctFloat$6 = Utilities.correctFloat, defined$u = Utilities.defined, destroyObjectProperties$3 = Utilities.destroyObjectProperties, fireEvent$k = Utilities.fireEvent, merge$S = Utilities.merge, pick$Z = Utilities.pick, removeEvent$4 = Utilities.removeEvent;
    var Scrollbar = (
      /** @class */
      function() {
        function Scrollbar2(renderer, options, chart) {
          this._events = [];
          this.chart = void 0;
          this.chartX = 0;
          this.chartY = 0;
          this.from = 0;
          this.group = void 0;
          this.options = void 0;
          this.renderer = void 0;
          this.scrollbar = void 0;
          this.scrollbarButtons = [];
          this.scrollbarGroup = void 0;
          this.scrollbarLeft = 0;
          this.scrollbarRifles = void 0;
          this.scrollbarStrokeWidth = 1;
          this.scrollbarTop = 0;
          this.size = 0;
          this.to = 0;
          this.track = void 0;
          this.trackBorderWidth = 1;
          this.userOptions = void 0;
          this.x = 0;
          this.y = 0;
          this.init(renderer, options, chart);
        }
        Scrollbar2.compose = function(AxisClass) {
          ScrollbarAxis.compose(AxisClass, Scrollbar2);
        };
        Scrollbar2.swapXY = function(path, vertical) {
          if (vertical) {
            path.forEach(function(seg) {
              var len = seg.length;
              var temp;
              for (var i = 0; i < len; i += 2) {
                temp = seg[i + 1];
                if (typeof temp === "number") {
                  seg[i + 1] = seg[i + 2];
                  seg[i + 2] = temp;
                }
              }
            });
          }
          return path;
        };
        Scrollbar2.prototype.addEvents = function() {
          var buttonsOrder = this.options.inverted ? [1, 0] : [0, 1], buttons = this.scrollbarButtons, bar = this.scrollbarGroup.element, track = this.track.element, mouseDownHandler = this.mouseDownHandler.bind(this), mouseMoveHandler = this.mouseMoveHandler.bind(this), mouseUpHandler = this.mouseUpHandler.bind(this);
          var _events = [
            [buttons[buttonsOrder[0]].element, "click", this.buttonToMinClick.bind(this)],
            [buttons[buttonsOrder[1]].element, "click", this.buttonToMaxClick.bind(this)],
            [track, "click", this.trackClick.bind(this)],
            [bar, "mousedown", mouseDownHandler],
            [bar.ownerDocument, "mousemove", mouseMoveHandler],
            [bar.ownerDocument, "mouseup", mouseUpHandler]
          ];
          if (H.hasTouch) {
            _events.push([bar, "touchstart", mouseDownHandler], [bar.ownerDocument, "touchmove", mouseMoveHandler], [bar.ownerDocument, "touchend", mouseUpHandler]);
          }
          _events.forEach(function(args) {
            addEvent$H.apply(null, args);
          });
          this._events = _events;
        };
        Scrollbar2.prototype.buttonToMaxClick = function(e2) {
          var scroller2 = this;
          var range = (scroller2.to - scroller2.from) * pick$Z(scroller2.options.step, 0.2);
          scroller2.updatePosition(scroller2.from + range, scroller2.to + range);
          fireEvent$k(scroller2, "changed", {
            from: scroller2.from,
            to: scroller2.to,
            trigger: "scrollbar",
            DOMEvent: e2
          });
        };
        Scrollbar2.prototype.buttonToMinClick = function(e2) {
          var scroller2 = this;
          var range = correctFloat$6(scroller2.to - scroller2.from) * pick$Z(scroller2.options.step, 0.2);
          scroller2.updatePosition(correctFloat$6(scroller2.from - range), correctFloat$6(scroller2.to - range));
          fireEvent$k(scroller2, "changed", {
            from: scroller2.from,
            to: scroller2.to,
            trigger: "scrollbar",
            DOMEvent: e2
          });
        };
        Scrollbar2.prototype.cursorToScrollbarPosition = function(normalizedEvent) {
          var scroller2 = this, options = scroller2.options, minWidthDifference = options.minWidth > scroller2.calculatedWidth ? options.minWidth : 0;
          return {
            chartX: (normalizedEvent.chartX - scroller2.x - scroller2.xOffset) / (scroller2.barWidth - minWidthDifference),
            chartY: (normalizedEvent.chartY - scroller2.y - scroller2.yOffset) / (scroller2.barWidth - minWidthDifference)
          };
        };
        Scrollbar2.prototype.destroy = function() {
          var scroller2 = this, navigator = scroller2.chart.scroller;
          scroller2.removeEvents();
          [
            "track",
            "scrollbarRifles",
            "scrollbar",
            "scrollbarGroup",
            "group"
          ].forEach(function(prop) {
            if (scroller2[prop] && scroller2[prop].destroy) {
              scroller2[prop] = scroller2[prop].destroy();
            }
          });
          if (navigator && scroller2 === navigator.scrollbar) {
            navigator.scrollbar = null;
            destroyObjectProperties$3(navigator.scrollbarButtons);
          }
        };
        Scrollbar2.prototype.drawScrollbarButton = function(index) {
          var scroller2 = this, renderer = scroller2.renderer, scrollbarButtons = scroller2.scrollbarButtons, options = scroller2.options, size = scroller2.size, group = renderer.g().add(scroller2.group);
          var tempElem;
          scrollbarButtons.push(group);
          tempElem = renderer.rect().addClass("highcharts-scrollbar-button").add(group);
          if (!scroller2.chart.styledMode) {
            tempElem.attr({
              stroke: options.buttonBorderColor,
              "stroke-width": options.buttonBorderWidth,
              fill: options.buttonBackgroundColor
            });
          }
          tempElem.attr(tempElem.crisp({
            x: -0.5,
            y: -0.5,
            width: size + 1,
            height: size + 1,
            r: options.buttonBorderRadius
          }, tempElem.strokeWidth()));
          tempElem = renderer.path(Scrollbar2.swapXY([[
            "M",
            size / 2 + (index ? -1 : 1),
            size / 2 - 3
          ], [
            "L",
            size / 2 + (index ? -1 : 1),
            size / 2 + 3
          ], [
            "L",
            size / 2 + (index ? 2 : -2),
            size / 2
          ]], options.vertical)).addClass("highcharts-scrollbar-arrow").add(scrollbarButtons[index]);
          if (!scroller2.chart.styledMode) {
            tempElem.attr({
              fill: options.buttonArrowColor
            });
          }
        };
        Scrollbar2.prototype.init = function(renderer, options, chart) {
          var scroller2 = this;
          scroller2.scrollbarButtons = [];
          scroller2.renderer = renderer;
          scroller2.userOptions = options;
          scroller2.options = merge$S(ScrollbarDefaults, defaultOptions$8.scrollbar, options);
          scroller2.chart = chart;
          scroller2.size = pick$Z(scroller2.options.size, scroller2.options.height);
          if (options.enabled) {
            scroller2.render();
            scroller2.addEvents();
          }
        };
        Scrollbar2.prototype.mouseDownHandler = function(e2) {
          var scroller2 = this, normalizedEvent = scroller2.chart.pointer.normalize(e2), mousePosition = scroller2.cursorToScrollbarPosition(normalizedEvent);
          scroller2.chartX = mousePosition.chartX;
          scroller2.chartY = mousePosition.chartY;
          scroller2.initPositions = [scroller2.from, scroller2.to];
          scroller2.grabbedCenter = true;
        };
        Scrollbar2.prototype.mouseMoveHandler = function(e2) {
          var scroller2 = this, normalizedEvent = scroller2.chart.pointer.normalize(e2), options = scroller2.options, direction = options.vertical ? "chartY" : "chartX", initPositions = scroller2.initPositions || [];
          var scrollPosition, chartPosition, change;
          if (scroller2.grabbedCenter && // #4696, scrollbar failed on Android
          (!e2.touches || e2.touches[0][direction] !== 0)) {
            chartPosition = scroller2.cursorToScrollbarPosition(normalizedEvent)[direction];
            scrollPosition = scroller2[direction];
            change = chartPosition - scrollPosition;
            scroller2.hasDragged = true;
            scroller2.updatePosition(initPositions[0] + change, initPositions[1] + change);
            if (scroller2.hasDragged) {
              fireEvent$k(scroller2, "changed", {
                from: scroller2.from,
                to: scroller2.to,
                trigger: "scrollbar",
                DOMType: e2.type,
                DOMEvent: e2
              });
            }
          }
        };
        Scrollbar2.prototype.mouseUpHandler = function(e2) {
          var scroller2 = this;
          if (scroller2.hasDragged) {
            fireEvent$k(scroller2, "changed", {
              from: scroller2.from,
              to: scroller2.to,
              trigger: "scrollbar",
              DOMType: e2.type,
              DOMEvent: e2
            });
          }
          scroller2.grabbedCenter = scroller2.hasDragged = scroller2.chartX = scroller2.chartY = null;
        };
        Scrollbar2.prototype.position = function(x, y, width, height) {
          var scroller2 = this, options = scroller2.options, vertical = options.vertical, method = scroller2.rendered ? "animate" : "attr";
          var xOffset = height, yOffset = 0;
          scroller2.x = x;
          scroller2.y = y + this.trackBorderWidth;
          scroller2.width = width;
          scroller2.height = height;
          scroller2.xOffset = xOffset;
          scroller2.yOffset = yOffset;
          if (vertical) {
            scroller2.width = scroller2.yOffset = width = yOffset = scroller2.size;
            scroller2.xOffset = xOffset = 0;
            scroller2.barWidth = height - width * 2;
            scroller2.x = x = x + scroller2.options.margin;
          } else {
            scroller2.height = scroller2.xOffset = height = xOffset = scroller2.size;
            scroller2.barWidth = width - height * 2;
            scroller2.y = scroller2.y + scroller2.options.margin;
          }
          scroller2.group[method]({
            translateX: x,
            translateY: scroller2.y
          });
          scroller2.track[method]({
            width,
            height
          });
          scroller2.scrollbarButtons[1][method]({
            translateX: vertical ? 0 : width - xOffset,
            translateY: vertical ? height - yOffset : 0
          });
        };
        Scrollbar2.prototype.removeEvents = function() {
          this._events.forEach(function(args) {
            removeEvent$4.apply(null, args);
          });
          this._events.length = 0;
        };
        Scrollbar2.prototype.render = function() {
          var scroller2 = this, renderer = scroller2.renderer, options = scroller2.options, size = scroller2.size, styledMode = scroller2.chart.styledMode, group = renderer.g("scrollbar").attr({
            zIndex: options.zIndex,
            translateY: -99999
          }).add();
          scroller2.group = group;
          scroller2.track = renderer.rect().addClass("highcharts-scrollbar-track").attr({
            x: 0,
            r: options.trackBorderRadius || 0,
            height: size,
            width: size
          }).add(group);
          if (!styledMode) {
            scroller2.track.attr({
              fill: options.trackBackgroundColor,
              stroke: options.trackBorderColor,
              "stroke-width": options.trackBorderWidth
            });
          }
          scroller2.trackBorderWidth = scroller2.track.strokeWidth();
          scroller2.track.attr({
            y: -this.trackBorderWidth % 2 / 2
          });
          scroller2.scrollbarGroup = renderer.g().add(group);
          scroller2.scrollbar = renderer.rect().addClass("highcharts-scrollbar-thumb").attr({
            height: size,
            width: size,
            r: options.barBorderRadius || 0
          }).add(scroller2.scrollbarGroup);
          scroller2.scrollbarRifles = renderer.path(Scrollbar2.swapXY([
            ["M", -3, size / 4],
            ["L", -3, 2 * size / 3],
            ["M", 0, size / 4],
            ["L", 0, 2 * size / 3],
            ["M", 3, size / 4],
            ["L", 3, 2 * size / 3]
          ], options.vertical)).addClass("highcharts-scrollbar-rifles").add(scroller2.scrollbarGroup);
          if (!styledMode) {
            scroller2.scrollbar.attr({
              fill: options.barBackgroundColor,
              stroke: options.barBorderColor,
              "stroke-width": options.barBorderWidth
            });
            scroller2.scrollbarRifles.attr({
              stroke: options.rifleColor,
              "stroke-width": 1
            });
          }
          scroller2.scrollbarStrokeWidth = scroller2.scrollbar.strokeWidth();
          scroller2.scrollbarGroup.translate(-scroller2.scrollbarStrokeWidth % 2 / 2, -scroller2.scrollbarStrokeWidth % 2 / 2);
          scroller2.drawScrollbarButton(0);
          scroller2.drawScrollbarButton(1);
        };
        Scrollbar2.prototype.setRange = function(from, to) {
          var scroller2 = this, options = scroller2.options, vertical = options.vertical, minWidth = options.minWidth, fullWidth = scroller2.barWidth, method = this.rendered && !this.hasDragged && !(this.chart.navigator && this.chart.navigator.hasDragged) ? "animate" : "attr";
          if (!defined$u(fullWidth)) {
            return;
          }
          var toPX = fullWidth * Math.min(to, 1);
          var fromPX, newSize;
          from = Math.max(from, 0);
          fromPX = Math.ceil(fullWidth * from);
          scroller2.calculatedWidth = newSize = correctFloat$6(toPX - fromPX);
          if (newSize < minWidth) {
            fromPX = (fullWidth - minWidth + newSize) * from;
            newSize = minWidth;
          }
          var newPos = Math.floor(fromPX + scroller2.xOffset + scroller2.yOffset);
          var newRiflesPos = newSize / 2 - 0.5;
          scroller2.from = from;
          scroller2.to = to;
          if (!vertical) {
            scroller2.scrollbarGroup[method]({
              translateX: newPos
            });
            scroller2.scrollbar[method]({
              width: newSize
            });
            scroller2.scrollbarRifles[method]({
              translateX: newRiflesPos
            });
            scroller2.scrollbarLeft = newPos;
            scroller2.scrollbarTop = 0;
          } else {
            scroller2.scrollbarGroup[method]({
              translateY: newPos
            });
            scroller2.scrollbar[method]({
              height: newSize
            });
            scroller2.scrollbarRifles[method]({
              translateY: newRiflesPos
            });
            scroller2.scrollbarTop = newPos;
            scroller2.scrollbarLeft = 0;
          }
          if (newSize <= 12) {
            scroller2.scrollbarRifles.hide();
          } else {
            scroller2.scrollbarRifles.show(true);
          }
          if (options.showFull === false) {
            if (from <= 0 && to >= 1) {
              scroller2.group.hide();
            } else {
              scroller2.group.show();
            }
          }
          scroller2.rendered = true;
        };
        Scrollbar2.prototype.shouldUpdateExtremes = function(eventType) {
          return pick$Z(this.options.liveRedraw, H.svg && !H.isTouchDevice && !this.chart.isBoosting) || // Mouseup always should change extremes
          eventType === "mouseup" || eventType === "touchend" || // Internal events
          !defined$u(eventType);
        };
        Scrollbar2.prototype.trackClick = function(e2) {
          var scroller2 = this;
          var normalizedEvent = scroller2.chart.pointer.normalize(e2), range = scroller2.to - scroller2.from, top = scroller2.y + scroller2.scrollbarTop, left = scroller2.x + scroller2.scrollbarLeft;
          if (scroller2.options.vertical && normalizedEvent.chartY > top || !scroller2.options.vertical && normalizedEvent.chartX > left) {
            scroller2.updatePosition(scroller2.from + range, scroller2.to + range);
          } else {
            scroller2.updatePosition(scroller2.from - range, scroller2.to - range);
          }
          fireEvent$k(scroller2, "changed", {
            from: scroller2.from,
            to: scroller2.to,
            trigger: "scrollbar",
            DOMEvent: e2
          });
        };
        Scrollbar2.prototype.update = function(options) {
          this.destroy();
          this.init(this.chart.renderer, merge$S(true, this.options, options), this.chart);
        };
        Scrollbar2.prototype.updatePosition = function(from, to) {
          if (to > 1) {
            from = correctFloat$6(1 - correctFloat$6(to - from));
            to = 1;
          }
          if (from < 0) {
            to = correctFloat$6(to - from);
            from = 0;
          }
          this.from = from;
          this.to = to;
        };
        Scrollbar2.defaultOptions = ScrollbarDefaults;
        return Scrollbar2;
      }()
    );
    defaultOptions$8.scrollbar = merge$S(true, Scrollbar.defaultOptions, defaultOptions$8.scrollbar);
    var isTouchDevice$2 = H.isTouchDevice;
    var addEvent$G = Utilities.addEvent, correctFloat$5 = Utilities.correctFloat, defined$t = Utilities.defined, isNumber$q = Utilities.isNumber, pick$Y = Utilities.pick;
    var NavigatorAxisAdditions = (
      /** @class */
      function() {
        function NavigatorAxisAdditions2(axis) {
          this.axis = axis;
        }
        NavigatorAxisAdditions2.prototype.destroy = function() {
          this.axis = void 0;
        };
        NavigatorAxisAdditions2.prototype.toFixedRange = function(pxMin, pxMax, fixedMin, fixedMax) {
          var navigator = this;
          var axis = navigator.axis;
          var chart = axis.chart;
          var fixedRange = chart && chart.fixedRange, halfPointRange = (axis.pointRange || 0) / 2, newMin = pick$Y(fixedMin, axis.translate(pxMin, true, !axis.horiz)), newMax = pick$Y(fixedMax, axis.translate(pxMax, true, !axis.horiz)), changeRatio = fixedRange && (newMax - newMin) / fixedRange;
          if (!defined$t(fixedMin)) {
            newMin = correctFloat$5(newMin + halfPointRange);
          }
          if (!defined$t(fixedMax)) {
            newMax = correctFloat$5(newMax - halfPointRange);
          }
          if (changeRatio > 0.7 && changeRatio < 1.3) {
            if (fixedMax) {
              newMin = newMax - fixedRange;
            } else {
              newMax = newMin + fixedRange;
            }
          }
          if (!isNumber$q(newMin) || !isNumber$q(newMax)) {
            newMin = newMax = void 0;
          }
          return {
            min: newMin,
            max: newMax
          };
        };
        return NavigatorAxisAdditions2;
      }()
    );
    var NavigatorAxis = (
      /** @class */
      function() {
        function NavigatorAxis2() {
        }
        NavigatorAxis2.compose = function(AxisClass) {
          AxisClass.keepProps.push("navigatorAxis");
          addEvent$G(AxisClass, "init", function() {
            var axis = this;
            if (!axis.navigatorAxis) {
              axis.navigatorAxis = new NavigatorAxisAdditions(axis);
            }
          });
          addEvent$G(AxisClass, "zoom", function(e2) {
            var axis = this;
            var chart = axis.chart;
            var chartOptions = chart.options;
            var navigator = chartOptions.navigator;
            var navigatorAxis = axis.navigatorAxis;
            var pinchType = chartOptions.chart.pinchType;
            var rangeSelector = chartOptions.rangeSelector;
            var zoomType = chartOptions.chart.zoomType;
            var previousZoom;
            if (axis.isXAxis && (navigator && navigator.enabled || rangeSelector && rangeSelector.enabled)) {
              if (zoomType === "y") {
                e2.zoomed = false;
              } else if ((!isTouchDevice$2 && zoomType === "xy" || isTouchDevice$2 && pinchType === "xy") && axis.options.range) {
                previousZoom = navigatorAxis.previousZoom;
                if (defined$t(e2.newMin)) {
                  navigatorAxis.previousZoom = [axis.min, axis.max];
                } else if (previousZoom) {
                  e2.newMin = previousZoom[0];
                  e2.newMax = previousZoom[1];
                  navigatorAxis.previousZoom = void 0;
                }
              }
            }
            if (typeof e2.zoomed !== "undefined") {
              e2.preventDefault();
            }
          });
        };
        NavigatorAxis2.AdditionsClass = NavigatorAxisAdditions;
        return NavigatorAxis2;
      }()
    );
    var color$b = Color.parse;
    var hasTouch = H.hasTouch, isTouchDevice$1 = H.isTouchDevice;
    var defaultOptions$7 = DefaultOptions.defaultOptions;
    var seriesTypes$5 = SeriesRegistry$1.seriesTypes;
    var addEvent$F = Utilities.addEvent, clamp$a = Utilities.clamp, correctFloat$4 = Utilities.correctFloat, defined$s = Utilities.defined, destroyObjectProperties$2 = Utilities.destroyObjectProperties, erase$1 = Utilities.erase, extend$$ = Utilities.extend, find$c = Utilities.find, isArray$8 = Utilities.isArray, isNumber$p = Utilities.isNumber, merge$R = Utilities.merge, pick$X = Utilities.pick, removeEvent$3 = Utilities.removeEvent, splat$9 = Utilities.splat;
    var defaultSeriesType, numExt = function(extreme) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var numbers = [].filter.call(args, isNumber$p);
      if (numbers.length) {
        return Math[extreme].apply(0, numbers);
      }
    };
    defaultSeriesType = typeof seriesTypes$5.areaspline === "undefined" ? "line" : "areaspline";
    extend$$(defaultOptions$7, {
      /**
       * Maximum range which can be set using the navigator's handles.
       * Opposite of [xAxis.minRange](#xAxis.minRange).
       *
       * @sample {highstock} stock/navigator/maxrange/
       *         Defined max and min range
       *
       * @type      {number}
       * @since     6.0.0
       * @product   highstock gantt
       * @apioption xAxis.maxRange
       */
      /**
       * The navigator is a small series below the main series, displaying
       * a view of the entire data set. It provides tools to zoom in and
       * out on parts of the data as well as panning across the dataset.
       *
       * @product      highstock gantt
       * @optionparent navigator
       */
      navigator: {
        /**
         * Whether the navigator and scrollbar should adapt to updated data
         * in the base X axis. When loading data async, as in the demo below,
         * this should be `false`. Otherwise new data will trigger navigator
         * redraw, which will cause unwanted looping. In the demo below, the
         * data in the navigator is set only once. On navigating, only the main
         * chart content is updated.
         *
         * @sample {highstock} stock/demo/lazy-loading/
         *         Set to false with async data loading
         *
         * @type      {boolean}
         * @default   true
         * @apioption navigator.adaptToUpdatedData
         */
        /**
         * An integer identifying the index to use for the base series, or a
         * string representing the id of the series.
         *
         * **Note**: As of Highcharts 5.0, this is now a deprecated option.
         * Prefer [series.showInNavigator](#plotOptions.series.showInNavigator).
         *
         * @see [series.showInNavigator](#plotOptions.series.showInNavigator)
         *
         * @deprecated
         * @type      {number|string}
         * @default   0
         * @apioption navigator.baseSeries
         */
        /**
         * Enable or disable the navigator.
         *
         * @sample {highstock} stock/navigator/enabled/
         *         Disable the navigator
         *
         * @type      {boolean}
         * @default   true
         * @apioption navigator.enabled
         */
        /**
         * When the chart is inverted, whether to draw the navigator on the
         * opposite side.
         *
         * @type      {boolean}
         * @default   false
         * @since     5.0.8
         * @apioption navigator.opposite
         */
        /**
         * The height of the navigator.
         *
         * @sample {highstock} stock/navigator/height/
         *         A higher navigator
         */
        height: 40,
        /**
         * The distance from the nearest element, the X axis or X axis labels.
         *
         * @sample {highstock} stock/navigator/margin/
         *         A margin of 2 draws the navigator closer to the X axis labels
         */
        margin: 25,
        /**
         * Whether the mask should be inside the range marking the zoomed
         * range, or outside. In Highcharts Stock 1.x it was always `false`.
         *
         * @sample {highstock} stock/navigator/maskinside-false/
         *         False, mask outside
         *
         * @since   2.0
         */
        maskInside: true,
        /**
         * Options for the handles for dragging the zoomed area.
         *
         * @sample {highstock} stock/navigator/handles/
         *         Colored handles
         */
        handles: {
          /**
           * Width for handles.
           *
           * @sample {highstock} stock/navigator/styled-handles/
           *         Styled handles
           *
           * @since   6.0.0
           */
          width: 7,
          /**
           * Height for handles.
           *
           * @sample {highstock} stock/navigator/styled-handles/
           *         Styled handles
           *
           * @since   6.0.0
           */
          height: 15,
          /**
           * Array to define shapes of handles. 0-index for left, 1-index for
           * right.
           *
           * Additionally, the URL to a graphic can be given on this form:
           * `url(graphic.png)`. Note that for the image to be applied to
           * exported charts, its URL needs to be accessible by the export
           * server.
           *
           * Custom callbacks for symbol path generation can also be added to
           * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
           * used by its method name, as shown in the demo.
           *
           * @sample {highstock} stock/navigator/styled-handles/
           *         Styled handles
           *
           * @type    {Array<string>}
           * @default ["navigator-handle", "navigator-handle"]
           * @since   6.0.0
           */
          symbols: ["navigator-handle", "navigator-handle"],
          /**
           * Allows to enable/disable handles.
           *
           * @since   6.0.0
           */
          enabled: true,
          /**
           * The width for the handle border and the stripes inside.
           *
           * @sample {highstock} stock/navigator/styled-handles/
           *         Styled handles
           *
           * @since     6.0.0
           * @apioption navigator.handles.lineWidth
           */
          lineWidth: 1,
          /**
           * The fill for the handle.
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           */
          backgroundColor: palette.neutralColor5,
          /**
           * The stroke for the handle border and the stripes inside.
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           */
          borderColor: palette.neutralColor40
        },
        /**
         * The color of the mask covering the areas of the navigator series
         * that are currently not visible in the main series. The default
         * color is bluish with an opacity of 0.3 to see the series below.
         *
         * @see In styled mode, the mask is styled with the
         *      `.highcharts-navigator-mask` and
         *      `.highcharts-navigator-mask-inside` classes.
         *
         * @sample {highstock} stock/navigator/maskfill/
         *         Blue, semi transparent mask
         *
         * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @default rgba(102,133,194,0.3)
         */
        maskFill: color$b(palette.highlightColor60).setOpacity(0.3).get(),
        /**
         * The color of the line marking the currently zoomed area in the
         * navigator.
         *
         * @sample {highstock} stock/navigator/outline/
         *         2px blue outline
         *
         * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @default #cccccc
         */
        outlineColor: palette.neutralColor20,
        /**
         * The width of the line marking the currently zoomed area in the
         * navigator.
         *
         * @see In styled mode, the outline stroke width is set with the
         *      `.highcharts-navigator-outline` class.
         *
         * @sample {highstock} stock/navigator/outline/
         *         2px blue outline
         *
         * @type    {number}
         */
        outlineWidth: 1,
        /**
         * Options for the navigator series. Available options are the same
         * as any series, documented at [plotOptions](#plotOptions.series)
         * and [series](#series).
         *
         * Unless data is explicitly defined on navigator.series, the data
         * is borrowed from the first series in the chart.
         *
         * Default series options for the navigator series are:
         * ```js
         * series: {
         *     type: 'areaspline',
         *     fillOpacity: 0.05,
         *     dataGrouping: {
         *         smoothed: true
         *     },
         *     lineWidth: 1,
         *     marker: {
         *         enabled: false
         *     }
         * }
         * ```
         *
         * @see In styled mode, the navigator series is styled with the
         *      `.highcharts-navigator-series` class.
         *
         * @sample {highstock} stock/navigator/series-data/
         *         Using a separate data set for the navigator
         * @sample {highstock} stock/navigator/series/
         *         A green navigator series
         *
         * @type {*|Array<*>|Highcharts.SeriesOptionsType|Array<Highcharts.SeriesOptionsType>}
         */
        series: {
          /**
           * The type of the navigator series.
           *
           * Heads up:
           * In column-type navigator, zooming is limited to at least one
           * point with its `pointRange`.
           *
           * @sample {highstock} stock/navigator/column/
           *         Column type navigator
           *
           * @type    {string}
           * @default {highstock} `areaspline` if defined, otherwise `line`
           * @default {gantt} gantt
           */
          type: defaultSeriesType,
          /**
           * The fill opacity of the navigator series.
           */
          fillOpacity: 0.05,
          /**
           * The pixel line width of the navigator series.
           */
          lineWidth: 1,
          /**
           * @ignore-option
           */
          compare: null,
          /**
           * Unless data is explicitly defined, the data is borrowed from the
           * first series in the chart.
           *
           * @type      {Array<number|Array<number|string|null>|object|null>}
           * @product   highstock
           * @apioption navigator.series.data
           */
          /**
           * Data grouping options for the navigator series.
           *
           * @extends plotOptions.series.dataGrouping
           */
          dataGrouping: {
            approximation: "average",
            enabled: true,
            groupPixelWidth: 2,
            // Replace smoothed property by anchors, #12455.
            firstAnchor: "firstPoint",
            anchor: "middle",
            lastAnchor: "lastPoint",
            // Day and week differs from plotOptions.series.dataGrouping
            units: [
              ["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
              ["second", [1, 2, 5, 10, 15, 30]],
              ["minute", [1, 2, 5, 10, 15, 30]],
              ["hour", [1, 2, 3, 4, 6, 8, 12]],
              ["day", [1, 2, 3, 4]],
              ["week", [1, 2, 3]],
              ["month", [1, 3, 6]],
              ["year", null]
            ]
          },
          /**
           * Data label options for the navigator series. Data labels are
           * disabled by default on the navigator series.
           *
           * @extends plotOptions.series.dataLabels
           */
          dataLabels: {
            enabled: false,
            zIndex: 2
            // #1839
          },
          id: "highcharts-navigator-series",
          className: "highcharts-navigator-series",
          /**
           * Sets the fill color of the navigator series.
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @apioption navigator.series.color
           */
          /**
           * Line color for the navigator series. Allows setting the color
           * while disallowing the default candlestick setting.
           *
           * @type {Highcharts.ColorString|null}
           */
          lineColor: null,
          marker: {
            enabled: false
          },
          /**
           * Since Highcharts Stock v8, default value is the same as default
           * `pointRange` defined for a specific type (e.g. `null` for
           * column type).
           *
           * In Highcharts Stock version < 8, defaults to 0.
           *
           * @extends plotOptions.series.pointRange
           * @type {number|null}
           * @apioption navigator.series.pointRange
           */
          /**
           * The threshold option. Setting it to 0 will make the default
           * navigator area series draw its area from the 0 value and up.
           *
           * @type {number|null}
           */
          threshold: null
        },
        /**
         * Options for the navigator X axis. Default series options for the
         * navigator xAxis are:
         * ```js
         * xAxis: {
         *     tickWidth: 0,
         *     lineWidth: 0,
         *     gridLineWidth: 1,
         *     tickPixelInterval: 200,
         *     labels: {
         *            align: 'left',
         *         style: {
         *             color: '#888'
         *         },
         *         x: 3,
         *         y: -4
         *     }
         * }
         * ```
         *
         * @extends   xAxis
         * @excluding linkedTo, maxZoom, minRange, opposite, range, scrollbar,
         *            showEmpty, maxRange
         */
        xAxis: {
          /**
           * Additional range on the right side of the xAxis. Works similar to
           * xAxis.maxPadding, but value is set in milliseconds.
           * Can be set for both, main xAxis and navigator's xAxis.
           *
           * @since   6.0.0
           */
          overscroll: 0,
          className: "highcharts-navigator-xaxis",
          tickLength: 0,
          lineWidth: 0,
          gridLineColor: palette.neutralColor10,
          gridLineWidth: 1,
          tickPixelInterval: 200,
          labels: {
            align: "left",
            /**
             * @type {Highcharts.CSSObject}
             */
            style: {
              /** @ignore */
              color: palette.neutralColor40
            },
            x: 3,
            y: -4
          },
          crosshair: false
        },
        /**
         * Options for the navigator Y axis. Default series options for the
         * navigator yAxis are:
         * ```js
         * yAxis: {
         *     gridLineWidth: 0,
         *     startOnTick: false,
         *     endOnTick: false,
         *     minPadding: 0.1,
         *     maxPadding: 0.1,
         *     labels: {
         *         enabled: false
         *     },
         *     title: {
         *         text: null
         *     },
         *     tickWidth: 0
         * }
         * ```
         *
         * @extends   yAxis
         * @excluding height, linkedTo, maxZoom, minRange, ordinal, range,
         *            showEmpty, scrollbar, top, units, maxRange, minLength,
         *            maxLength, resize
         */
        yAxis: {
          className: "highcharts-navigator-yaxis",
          gridLineWidth: 0,
          startOnTick: false,
          endOnTick: false,
          minPadding: 0.1,
          maxPadding: 0.1,
          labels: {
            enabled: false
          },
          crosshair: false,
          title: {
            text: null
          },
          tickLength: 0,
          tickWidth: 0
        }
      }
    });
    RendererRegistry$1.getRendererType().prototype.symbols["navigator-handle"] = function(_x, _y, _w, _h, options) {
      var halfWidth = (options && options.width || 0) / 2, markerPosition = Math.round(halfWidth / 3) + 0.5, height = options && options.height || 0;
      return [
        ["M", -halfWidth - 1, 0.5],
        ["L", halfWidth, 0.5],
        ["L", halfWidth, height + 0.5],
        ["L", -halfWidth - 1, height + 0.5],
        ["L", -halfWidth - 1, 0.5],
        ["M", -markerPosition, 4],
        ["L", -markerPosition, height - 3],
        ["M", markerPosition - 1, 4],
        ["L", markerPosition - 1, height - 3]
      ];
    };
    var Navigator = (
      /** @class */
      function() {
        function Navigator2(chart) {
          this.baseSeries = void 0;
          this.chart = void 0;
          this.handles = void 0;
          this.height = void 0;
          this.left = void 0;
          this.navigatorEnabled = void 0;
          this.navigatorGroup = void 0;
          this.navigatorOptions = void 0;
          this.navigatorSeries = void 0;
          this.navigatorSize = void 0;
          this.opposite = void 0;
          this.outline = void 0;
          this.outlineHeight = void 0;
          this.range = void 0;
          this.rendered = void 0;
          this.shades = void 0;
          this.size = void 0;
          this.top = void 0;
          this.xAxis = void 0;
          this.yAxis = void 0;
          this.zoomedMax = void 0;
          this.zoomedMin = void 0;
          this.init(chart);
        }
        Navigator2.prototype.drawHandle = function(x, index, inverted, verb) {
          var navigator = this, height = navigator.navigatorOptions.handles.height;
          navigator.handles[index][verb](inverted ? {
            translateX: Math.round(navigator.left + navigator.height / 2),
            translateY: Math.round(navigator.top + parseInt(x, 10) + 0.5 - height)
          } : {
            translateX: Math.round(navigator.left + parseInt(x, 10)),
            translateY: Math.round(navigator.top + navigator.height / 2 - height / 2 - 1)
          });
        };
        Navigator2.prototype.drawOutline = function(zoomedMin, zoomedMax, inverted, verb) {
          var navigator = this, maskInside = navigator.navigatorOptions.maskInside, outlineWidth = navigator.outline.strokeWidth(), halfOutline = outlineWidth / 2, outlineCorrection = outlineWidth % 2 / 2, outlineHeight = navigator.outlineHeight, scrollbarHeight = navigator.scrollbarHeight || 0, navigatorSize = navigator.size, left = navigator.left - scrollbarHeight, navigatorTop = navigator.top, verticalMin, path;
          if (inverted) {
            left -= halfOutline;
            verticalMin = navigatorTop + zoomedMax + outlineCorrection;
            zoomedMax = navigatorTop + zoomedMin + outlineCorrection;
            path = [
              ["M", left + outlineHeight, navigatorTop - scrollbarHeight - outlineCorrection],
              ["L", left + outlineHeight, verticalMin],
              ["L", left, verticalMin],
              ["L", left, zoomedMax],
              ["L", left + outlineHeight, zoomedMax],
              ["L", left + outlineHeight, navigatorTop + navigatorSize + scrollbarHeight]
            ];
            if (maskInside) {
              path.push(
                ["M", left + outlineHeight, verticalMin - halfOutline],
                // upper left of zoomed range
                ["L", left + outlineHeight, zoomedMax + halfOutline]
                // upper right of z.r.
              );
            }
          } else {
            zoomedMin += left + scrollbarHeight - outlineCorrection;
            zoomedMax += left + scrollbarHeight - outlineCorrection;
            navigatorTop += halfOutline;
            path = [
              ["M", left, navigatorTop],
              ["L", zoomedMin, navigatorTop],
              ["L", zoomedMin, navigatorTop + outlineHeight],
              ["L", zoomedMax, navigatorTop + outlineHeight],
              ["L", zoomedMax, navigatorTop],
              ["L", left + navigatorSize + scrollbarHeight * 2, navigatorTop]
              // right
            ];
            if (maskInside) {
              path.push(
                ["M", zoomedMin - halfOutline, navigatorTop],
                // upper left of zoomed range
                ["L", zoomedMax + halfOutline, navigatorTop]
                // upper right of z.r.
              );
            }
          }
          navigator.outline[verb]({
            d: path
          });
        };
        Navigator2.prototype.drawMasks = function(zoomedMin, zoomedMax, inverted, verb) {
          var navigator = this, left = navigator.left, top = navigator.top, navigatorHeight = navigator.height, height, width, x, y;
          if (inverted) {
            x = [left, left, left];
            y = [top, top + zoomedMin, top + zoomedMax];
            width = [navigatorHeight, navigatorHeight, navigatorHeight];
            height = [
              zoomedMin,
              zoomedMax - zoomedMin,
              navigator.size - zoomedMax
            ];
          } else {
            x = [left, left + zoomedMin, left + zoomedMax];
            y = [top, top, top];
            width = [
              zoomedMin,
              zoomedMax - zoomedMin,
              navigator.size - zoomedMax
            ];
            height = [navigatorHeight, navigatorHeight, navigatorHeight];
          }
          navigator.shades.forEach(function(shade, i) {
            shade[verb]({
              x: x[i],
              y: y[i],
              width: width[i],
              height: height[i]
            });
          });
        };
        Navigator2.prototype.renderElements = function() {
          var navigator = this, navigatorOptions = navigator.navigatorOptions, maskInside = navigatorOptions.maskInside, chart = navigator.chart, inverted = chart.inverted, renderer = chart.renderer, navigatorGroup, mouseCursor = {
            cursor: inverted ? "ns-resize" : "ew-resize"
          };
          navigator.navigatorGroup = navigatorGroup = renderer.g("navigator").attr({
            zIndex: 8,
            visibility: "hidden"
          }).add();
          [
            !maskInside,
            maskInside,
            !maskInside
          ].forEach(function(hasMask, index) {
            navigator.shades[index] = renderer.rect().addClass("highcharts-navigator-mask" + (index === 1 ? "-inside" : "-outside")).add(navigatorGroup);
            if (!chart.styledMode) {
              navigator.shades[index].attr({
                fill: hasMask ? navigatorOptions.maskFill : "rgba(0,0,0,0)"
              }).css(index === 1 && mouseCursor);
            }
          });
          navigator.outline = renderer.path().addClass("highcharts-navigator-outline").add(navigatorGroup);
          if (!chart.styledMode) {
            navigator.outline.attr({
              "stroke-width": navigatorOptions.outlineWidth,
              stroke: navigatorOptions.outlineColor
            });
          }
          if (navigatorOptions.handles.enabled) {
            [0, 1].forEach(function(index) {
              navigatorOptions.handles.inverted = chart.inverted;
              navigator.handles[index] = renderer.symbol(navigatorOptions.handles.symbols[index], -navigatorOptions.handles.width / 2 - 1, 0, navigatorOptions.handles.width, navigatorOptions.handles.height, navigatorOptions.handles);
              navigator.handles[index].attr({ zIndex: 7 - index }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][index]).add(navigatorGroup);
              if (!chart.styledMode) {
                var handlesOptions = navigatorOptions.handles;
                navigator.handles[index].attr({
                  fill: handlesOptions.backgroundColor,
                  stroke: handlesOptions.borderColor,
                  "stroke-width": handlesOptions.lineWidth
                }).css(mouseCursor);
              }
            });
          }
        };
        Navigator2.prototype.update = function(options) {
          (this.series || []).forEach(function(series) {
            if (series.baseSeries) {
              delete series.baseSeries.navigatorSeries;
            }
          });
          this.destroy();
          var chartOptions = this.chart.options;
          merge$R(true, chartOptions.navigator, this.options, options);
          this.init(this.chart);
        };
        Navigator2.prototype.render = function(min, max, pxMin, pxMax) {
          var navigator = this, chart = navigator.chart, navigatorWidth, scrollbarLeft, scrollbarTop, scrollbarHeight = navigator.scrollbarHeight, navigatorSize, xAxis = navigator.xAxis, pointRange = xAxis.pointRange || 0, scrollbarXAxis = xAxis.navigatorAxis.fake ? chart.xAxis[0] : xAxis, navigatorEnabled = navigator.navigatorEnabled, zoomedMin, zoomedMax, rendered = navigator.rendered, inverted = chart.inverted, verb, newMin, newMax, currentRange, minRange = chart.xAxis[0].minRange, maxRange = chart.xAxis[0].options.maxRange;
          if (this.hasDragged && !defined$s(pxMin)) {
            return;
          }
          min = correctFloat$4(min - pointRange / 2);
          max = correctFloat$4(max + pointRange / 2);
          if (!isNumber$p(min) || !isNumber$p(max)) {
            if (rendered) {
              pxMin = 0;
              pxMax = pick$X(xAxis.width, scrollbarXAxis.width);
            } else {
              return;
            }
          }
          navigator.left = pick$X(
            xAxis.left,
            // in case of scrollbar only, without navigator
            chart.plotLeft + scrollbarHeight + (inverted ? chart.plotWidth : 0)
          );
          navigator.size = zoomedMax = navigatorSize = pick$X(xAxis.len, (inverted ? chart.plotHeight : chart.plotWidth) - 2 * scrollbarHeight);
          if (inverted) {
            navigatorWidth = scrollbarHeight;
          } else {
            navigatorWidth = navigatorSize + 2 * scrollbarHeight;
          }
          pxMin = pick$X(pxMin, xAxis.toPixels(min, true));
          pxMax = pick$X(pxMax, xAxis.toPixels(max, true));
          if (!isNumber$p(pxMin) || Math.abs(pxMin) === Infinity) {
            pxMin = 0;
            pxMax = navigatorWidth;
          }
          newMin = xAxis.toValue(pxMin, true);
          newMax = xAxis.toValue(pxMax, true);
          currentRange = Math.abs(correctFloat$4(newMax - newMin));
          if (currentRange < minRange) {
            if (this.grabbedLeft) {
              pxMin = xAxis.toPixels(newMax - minRange - pointRange, true);
            } else if (this.grabbedRight) {
              pxMax = xAxis.toPixels(newMin + minRange + pointRange, true);
            }
          } else if (defined$s(maxRange) && correctFloat$4(currentRange - pointRange) > maxRange) {
            if (this.grabbedLeft) {
              pxMin = xAxis.toPixels(newMax - maxRange - pointRange, true);
            } else if (this.grabbedRight) {
              pxMax = xAxis.toPixels(newMin + maxRange + pointRange, true);
            }
          }
          navigator.zoomedMax = clamp$a(Math.max(pxMin, pxMax), 0, zoomedMax);
          navigator.zoomedMin = clamp$a(navigator.fixedWidth ? navigator.zoomedMax - navigator.fixedWidth : Math.min(pxMin, pxMax), 0, zoomedMax);
          navigator.range = navigator.zoomedMax - navigator.zoomedMin;
          zoomedMax = Math.round(navigator.zoomedMax);
          zoomedMin = Math.round(navigator.zoomedMin);
          if (navigatorEnabled) {
            navigator.navigatorGroup.attr({
              visibility: "visible"
            });
            verb = rendered && !navigator.hasDragged ? "animate" : "attr";
            navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
            navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);
            if (navigator.navigatorOptions.handles.enabled) {
              navigator.drawHandle(zoomedMin, 0, inverted, verb);
              navigator.drawHandle(zoomedMax, 1, inverted, verb);
            }
          }
          if (navigator.scrollbar) {
            if (inverted) {
              scrollbarTop = navigator.top - scrollbarHeight;
              scrollbarLeft = navigator.left - scrollbarHeight + (navigatorEnabled || !scrollbarXAxis.opposite ? 0 : (
                // Multiple axes has offsets:
                (scrollbarXAxis.titleOffset || 0) + // Self margin from the axis.title
                scrollbarXAxis.axisTitleMargin
              ));
              scrollbarHeight = navigatorSize + 2 * scrollbarHeight;
            } else {
              scrollbarTop = navigator.top + (navigatorEnabled ? navigator.height : -scrollbarHeight);
              scrollbarLeft = navigator.left - scrollbarHeight;
            }
            navigator.scrollbar.position(scrollbarLeft, scrollbarTop, navigatorWidth, scrollbarHeight);
            navigator.scrollbar.setRange(
              // Use real value, not rounded because range can be very small
              // (#1716)
              navigator.zoomedMin / (navigatorSize || 1),
              navigator.zoomedMax / (navigatorSize || 1)
            );
          }
          navigator.rendered = true;
        };
        Navigator2.prototype.addMouseEvents = function() {
          var navigator = this, chart = navigator.chart, container = chart.container, eventsToUnbind = [], mouseMoveHandler, mouseUpHandler;
          navigator.mouseMoveHandler = mouseMoveHandler = function(e2) {
            navigator.onMouseMove(e2);
          };
          navigator.mouseUpHandler = mouseUpHandler = function(e2) {
            navigator.onMouseUp(e2);
          };
          eventsToUnbind = navigator.getPartsEvents("mousedown");
          eventsToUnbind.push(addEvent$F(chart.renderTo, "mousemove", mouseMoveHandler), addEvent$F(container.ownerDocument, "mouseup", mouseUpHandler));
          if (hasTouch) {
            eventsToUnbind.push(addEvent$F(chart.renderTo, "touchmove", mouseMoveHandler), addEvent$F(container.ownerDocument, "touchend", mouseUpHandler));
            eventsToUnbind.concat(navigator.getPartsEvents("touchstart"));
          }
          navigator.eventsToUnbind = eventsToUnbind;
          if (navigator.series && navigator.series[0]) {
            eventsToUnbind.push(addEvent$F(navigator.series[0].xAxis, "foundExtremes", function() {
              chart.navigator.modifyNavigatorAxisExtremes();
            }));
          }
        };
        Navigator2.prototype.getPartsEvents = function(eventName) {
          var navigator = this, events = [];
          ["shades", "handles"].forEach(function(name) {
            navigator[name].forEach(function(navigatorItem, index) {
              events.push(addEvent$F(navigatorItem.element, eventName, function(e2) {
                navigator[name + "Mousedown"](e2, index);
              }));
            });
          });
          return events;
        };
        Navigator2.prototype.shadesMousedown = function(e2, index) {
          e2 = this.chart.pointer.normalize(e2);
          var navigator = this, chart = navigator.chart, xAxis = navigator.xAxis, zoomedMin = navigator.zoomedMin, navigatorPosition = navigator.left, navigatorSize = navigator.size, range = navigator.range, chartX = e2.chartX, fixedMax, fixedMin, ext, left;
          if (chart.inverted) {
            chartX = e2.chartY;
            navigatorPosition = navigator.top;
          }
          if (index === 1) {
            navigator.grabbedCenter = chartX;
            navigator.fixedWidth = range;
            navigator.dragOffset = chartX - zoomedMin;
          } else {
            left = chartX - navigatorPosition - range / 2;
            if (index === 0) {
              left = Math.max(0, left);
            } else if (index === 2 && left + range >= navigatorSize) {
              left = navigatorSize - range;
              if (navigator.reversedExtremes) {
                left -= range;
                fixedMin = navigator.getUnionExtremes().dataMin;
              } else {
                fixedMax = navigator.getUnionExtremes().dataMax;
              }
            }
            if (left !== zoomedMin) {
              navigator.fixedWidth = range;
              ext = xAxis.navigatorAxis.toFixedRange(left, left + range, fixedMin, fixedMax);
              if (defined$s(ext.min)) {
                chart.xAxis[0].setExtremes(
                  Math.min(ext.min, ext.max),
                  Math.max(ext.min, ext.max),
                  true,
                  null,
                  // auto animation
                  { trigger: "navigator" }
                );
              }
            }
          }
        };
        Navigator2.prototype.handlesMousedown = function(e2, index) {
          e2 = this.chart.pointer.normalize(e2);
          var navigator = this, chart = navigator.chart, baseXAxis = chart.xAxis[0], reverse = navigator.reversedExtremes;
          if (index === 0) {
            navigator.grabbedLeft = true;
            navigator.otherHandlePos = navigator.zoomedMax;
            navigator.fixedExtreme = reverse ? baseXAxis.min : baseXAxis.max;
          } else {
            navigator.grabbedRight = true;
            navigator.otherHandlePos = navigator.zoomedMin;
            navigator.fixedExtreme = reverse ? baseXAxis.max : baseXAxis.min;
          }
          chart.fixedRange = null;
        };
        Navigator2.prototype.onMouseMove = function(e2) {
          var navigator = this, chart = navigator.chart, left = navigator.left, navigatorSize = navigator.navigatorSize, range = navigator.range, dragOffset = navigator.dragOffset, inverted = chart.inverted, chartX;
          if (!e2.touches || e2.touches[0].pageX !== 0) {
            e2 = chart.pointer.normalize(e2);
            chartX = e2.chartX;
            if (inverted) {
              left = navigator.top;
              chartX = e2.chartY;
            }
            if (navigator.grabbedLeft) {
              navigator.hasDragged = true;
              navigator.render(0, 0, chartX - left, navigator.otherHandlePos);
            } else if (navigator.grabbedRight) {
              navigator.hasDragged = true;
              navigator.render(0, 0, navigator.otherHandlePos, chartX - left);
            } else if (navigator.grabbedCenter) {
              navigator.hasDragged = true;
              if (chartX < dragOffset) {
                chartX = dragOffset;
              } else if (chartX > navigatorSize + dragOffset - range) {
                chartX = navigatorSize + dragOffset - range;
              }
              navigator.render(0, 0, chartX - dragOffset, chartX - dragOffset + range);
            }
            if (navigator.hasDragged && navigator.scrollbar && pick$X(
              navigator.scrollbar.options.liveRedraw,
              // By default, don't run live redraw on VML, on touch
              // devices or if the chart is in boost.
              H.svg && !isTouchDevice$1 && !this.chart.isBoosting
            )) {
              e2.DOMType = e2.type;
              setTimeout(function() {
                navigator.onMouseUp(e2);
              }, 0);
            }
          }
        };
        Navigator2.prototype.onMouseUp = function(e2) {
          var navigator = this, chart = navigator.chart, xAxis = navigator.xAxis, scrollbar = navigator.scrollbar, DOMEvent = e2.DOMEvent || e2, inverted = chart.inverted, verb = navigator.rendered && !navigator.hasDragged ? "animate" : "attr", zoomedMax, zoomedMin, unionExtremes, fixedMin, fixedMax, ext;
          if (
            // MouseUp is called for both, navigator and scrollbar (that order),
            // which causes calling afterSetExtremes twice. Prevent first call
            // by checking if scrollbar is going to set new extremes (#6334)
            navigator.hasDragged && (!scrollbar || !scrollbar.hasDragged) || e2.trigger === "scrollbar"
          ) {
            unionExtremes = navigator.getUnionExtremes();
            if (navigator.zoomedMin === navigator.otherHandlePos) {
              fixedMin = navigator.fixedExtreme;
            } else if (navigator.zoomedMax === navigator.otherHandlePos) {
              fixedMax = navigator.fixedExtreme;
            }
            if (navigator.zoomedMax === navigator.size) {
              fixedMax = navigator.reversedExtremes ? unionExtremes.dataMin : unionExtremes.dataMax;
            }
            if (navigator.zoomedMin === 0) {
              fixedMin = navigator.reversedExtremes ? unionExtremes.dataMax : unionExtremes.dataMin;
            }
            ext = xAxis.navigatorAxis.toFixedRange(navigator.zoomedMin, navigator.zoomedMax, fixedMin, fixedMax);
            if (defined$s(ext.min)) {
              chart.xAxis[0].setExtremes(
                Math.min(ext.min, ext.max),
                Math.max(ext.min, ext.max),
                true,
                // Run animation when clicking buttons, scrollbar track etc,
                // but not when dragging handles or scrollbar
                navigator.hasDragged ? false : null,
                {
                  trigger: "navigator",
                  triggerOp: "navigator-drag",
                  DOMEvent
                  // #1838
                }
              );
            }
          }
          if (e2.DOMType !== "mousemove" && e2.DOMType !== "touchmove") {
            navigator.grabbedLeft = navigator.grabbedRight = navigator.grabbedCenter = navigator.fixedWidth = navigator.fixedExtreme = navigator.otherHandlePos = navigator.hasDragged = navigator.dragOffset = null;
          }
          if (navigator.navigatorEnabled && isNumber$p(navigator.zoomedMin) && isNumber$p(navigator.zoomedMax)) {
            zoomedMin = Math.round(navigator.zoomedMin);
            zoomedMax = Math.round(navigator.zoomedMax);
            if (navigator.shades) {
              navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
            }
            if (navigator.outline) {
              navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);
            }
            if (navigator.navigatorOptions.handles.enabled && Object.keys(navigator.handles).length === navigator.handles.length) {
              navigator.drawHandle(zoomedMin, 0, inverted, verb);
              navigator.drawHandle(zoomedMax, 1, inverted, verb);
            }
          }
        };
        Navigator2.prototype.removeEvents = function() {
          if (this.eventsToUnbind) {
            this.eventsToUnbind.forEach(function(unbind) {
              unbind();
            });
            this.eventsToUnbind = void 0;
          }
          this.removeBaseSeriesEvents();
        };
        Navigator2.prototype.removeBaseSeriesEvents = function() {
          var baseSeries = this.baseSeries || [];
          if (this.navigatorEnabled && baseSeries[0]) {
            if (this.navigatorOptions.adaptToUpdatedData !== false) {
              baseSeries.forEach(function(series) {
                removeEvent$3(series, "updatedData", this.updatedDataHandler);
              }, this);
            }
            if (baseSeries[0].xAxis) {
              removeEvent$3(baseSeries[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes);
            }
          }
        };
        Navigator2.prototype.init = function(chart) {
          var chartOptions = chart.options, navigatorOptions = chartOptions.navigator, navigatorEnabled = navigatorOptions.enabled, scrollbarOptions = chartOptions.scrollbar, scrollbarEnabled = scrollbarOptions.enabled, height = navigatorEnabled ? navigatorOptions.height : 0, scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0;
          this.handles = [];
          this.shades = [];
          this.chart = chart;
          this.setBaseSeries();
          this.height = height;
          this.scrollbarHeight = scrollbarHeight;
          this.scrollbarEnabled = scrollbarEnabled;
          this.navigatorEnabled = navigatorEnabled;
          this.navigatorOptions = navigatorOptions;
          this.scrollbarOptions = scrollbarOptions;
          this.outlineHeight = height + scrollbarHeight;
          this.opposite = pick$X(navigatorOptions.opposite, Boolean(!navigatorEnabled && chart.inverted));
          var navigator = this, baseSeries = navigator.baseSeries, xAxisIndex = chart.xAxis.length, yAxisIndex = chart.yAxis.length, baseXaxis = baseSeries && baseSeries[0] && baseSeries[0].xAxis || chart.xAxis[0] || { options: {} };
          chart.isDirtyBox = true;
          if (navigator.navigatorEnabled) {
            navigator.xAxis = new Axis(chart, merge$R({
              // inherit base xAxis' break and ordinal options
              breaks: baseXaxis.options.breaks,
              ordinal: baseXaxis.options.ordinal
            }, navigatorOptions.xAxis, {
              id: "navigator-x-axis",
              yAxis: "navigator-y-axis",
              isX: true,
              type: "datetime",
              index: xAxisIndex,
              isInternal: true,
              offset: 0,
              keepOrdinalPadding: true,
              startOnTick: false,
              endOnTick: false,
              minPadding: 0,
              maxPadding: 0,
              zoomEnabled: false
            }, chart.inverted ? {
              offsets: [scrollbarHeight, 0, -scrollbarHeight, 0],
              width: height
            } : {
              offsets: [0, -scrollbarHeight, 0, scrollbarHeight],
              height
            }));
            navigator.yAxis = new Axis(chart, merge$R(navigatorOptions.yAxis, {
              id: "navigator-y-axis",
              alignTicks: false,
              offset: 0,
              index: yAxisIndex,
              isInternal: true,
              reversed: pick$X(navigatorOptions.yAxis && navigatorOptions.yAxis.reversed, chart.yAxis[0] && chart.yAxis[0].reversed, false),
              zoomEnabled: false
            }, chart.inverted ? {
              width: height
            } : {
              height
            }));
            if (baseSeries || navigatorOptions.series.data) {
              navigator.updateNavigatorSeries(false);
            } else if (chart.series.length === 0) {
              navigator.unbindRedraw = addEvent$F(chart, "beforeRedraw", function() {
                if (chart.series.length > 0 && !navigator.series) {
                  navigator.setBaseSeries();
                  navigator.unbindRedraw();
                }
              });
            }
            navigator.reversedExtremes = chart.inverted && !navigator.xAxis.reversed || !chart.inverted && navigator.xAxis.reversed;
            navigator.renderElements();
            navigator.addMouseEvents();
          } else {
            navigator.xAxis = {
              chart,
              navigatorAxis: {
                fake: true
              },
              translate: function(value, reverse) {
                var axis = chart.xAxis[0], ext = axis.getExtremes(), scrollTrackWidth = axis.len - 2 * scrollbarHeight, min = numExt("min", axis.options.min, ext.dataMin), valueRange = numExt("max", axis.options.max, ext.dataMax) - min;
                return reverse ? (
                  // from pixel to value
                  value * valueRange / scrollTrackWidth + min
                ) : (
                  // from value to pixel
                  scrollTrackWidth * (value - min) / valueRange
                );
              },
              toPixels: function(value) {
                return this.translate(value);
              },
              toValue: function(value) {
                return this.translate(value, true);
              }
            };
            navigator.xAxis.navigatorAxis.axis = navigator.xAxis;
            navigator.xAxis.navigatorAxis.toFixedRange = NavigatorAxis.AdditionsClass.prototype.toFixedRange.bind(navigator.xAxis.navigatorAxis);
          }
          if (chart.options.scrollbar.enabled) {
            chart.scrollbar = navigator.scrollbar = new Scrollbar(chart.renderer, merge$R(chart.options.scrollbar, {
              margin: navigator.navigatorEnabled ? 0 : 10,
              vertical: chart.inverted
            }), chart);
            addEvent$F(navigator.scrollbar, "changed", function(e2) {
              var range = navigator.size, to = range * this.to, from = range * this.from;
              navigator.hasDragged = navigator.scrollbar.hasDragged;
              navigator.render(0, 0, from, to);
              if (this.shouldUpdateExtremes(e2.DOMType)) {
                setTimeout(function() {
                  navigator.onMouseUp(e2);
                });
              }
            });
          }
          navigator.addBaseSeriesEvents();
          navigator.addChartEvents();
        };
        Navigator2.prototype.getUnionExtremes = function(returnFalseOnNoBaseSeries) {
          var baseAxis = this.chart.xAxis[0], navAxis = this.xAxis, navAxisOptions = navAxis.options, baseAxisOptions = baseAxis.options, ret;
          if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {
            ret = {
              dataMin: pick$X(
                // #4053
                navAxisOptions && navAxisOptions.min,
                numExt("min", baseAxisOptions.min, baseAxis.dataMin, navAxis.dataMin, navAxis.min)
              ),
              dataMax: pick$X(navAxisOptions && navAxisOptions.max, numExt("max", baseAxisOptions.max, baseAxis.dataMax, navAxis.dataMax, navAxis.max))
            };
          }
          return ret;
        };
        Navigator2.prototype.setBaseSeries = function(baseSeriesOptions, redraw) {
          var chart = this.chart, baseSeries = this.baseSeries = [];
          baseSeriesOptions = baseSeriesOptions || chart.options && chart.options.navigator.baseSeries || (chart.series.length ? (
            // Find the first non-navigator series (#8430)
            find$c(chart.series, function(s) {
              return !s.options.isInternal;
            }).index
          ) : 0);
          (chart.series || []).forEach(function(series, i) {
            if (
              // Don't include existing nav series
              !series.options.isInternal && (series.options.showInNavigator || (i === baseSeriesOptions || series.options.id === baseSeriesOptions) && series.options.showInNavigator !== false)
            ) {
              baseSeries.push(series);
            }
          });
          if (this.xAxis && !this.xAxis.navigatorAxis.fake) {
            this.updateNavigatorSeries(true, redraw);
          }
        };
        Navigator2.prototype.updateNavigatorSeries = function(addEvents, redraw) {
          var navigator = this, chart = navigator.chart, baseSeries = navigator.baseSeries, baseOptions, mergedNavSeriesOptions, chartNavigatorSeriesOptions = navigator.navigatorOptions.series, baseNavigatorOptions, navSeriesMixin = {
            enableMouseTracking: false,
            index: null,
            linkedTo: null,
            group: "nav",
            padXAxis: false,
            xAxis: "navigator-x-axis",
            yAxis: "navigator-y-axis",
            showInLegend: false,
            stacking: void 0,
            isInternal: true,
            states: {
              inactive: {
                opacity: 1
              }
            }
          }, navigatorSeries = navigator.series = (navigator.series || []).filter(function(navSeries) {
            var base = navSeries.baseSeries;
            if (baseSeries.indexOf(base) < 0) {
              if (base) {
                removeEvent$3(base, "updatedData", navigator.updatedDataHandler);
                delete base.navigatorSeries;
              }
              if (navSeries.chart) {
                navSeries.destroy();
              }
              return false;
            }
            return true;
          });
          if (baseSeries && baseSeries.length) {
            baseSeries.forEach(function eachBaseSeries(base) {
              var linkedNavSeries = base.navigatorSeries, userNavOptions = extend$$(
                // Grab color and visibility from base as default
                {
                  color: base.color,
                  visible: base.visible
                },
                !isArray$8(chartNavigatorSeriesOptions) ? chartNavigatorSeriesOptions : defaultOptions$7.navigator.series
              );
              if (linkedNavSeries && navigator.navigatorOptions.adaptToUpdatedData === false) {
                return;
              }
              navSeriesMixin.name = "Navigator " + baseSeries.length;
              baseOptions = base.options || {};
              baseNavigatorOptions = baseOptions.navigatorOptions || {};
              userNavOptions.dataLabels = splat$9(userNavOptions.dataLabels);
              mergedNavSeriesOptions = merge$R(baseOptions, navSeriesMixin, userNavOptions, baseNavigatorOptions);
              mergedNavSeriesOptions.pointRange = pick$X(
                // Stricte set pointRange in options
                userNavOptions.pointRange,
                baseNavigatorOptions.pointRange,
                // Fallback to default values, e.g. `null` for column
                defaultOptions$7.plotOptions[mergedNavSeriesOptions.type || "line"].pointRange
              );
              var navigatorSeriesData = baseNavigatorOptions.data || userNavOptions.data;
              navigator.hasNavigatorData = navigator.hasNavigatorData || !!navigatorSeriesData;
              mergedNavSeriesOptions.data = navigatorSeriesData || baseOptions.data && baseOptions.data.slice(0);
              if (linkedNavSeries && linkedNavSeries.options) {
                linkedNavSeries.update(mergedNavSeriesOptions, redraw);
              } else {
                base.navigatorSeries = chart.initSeries(mergedNavSeriesOptions);
                base.navigatorSeries.baseSeries = base;
                navigatorSeries.push(base.navigatorSeries);
              }
            });
          }
          if (chartNavigatorSeriesOptions.data && !(baseSeries && baseSeries.length) || isArray$8(chartNavigatorSeriesOptions)) {
            navigator.hasNavigatorData = false;
            chartNavigatorSeriesOptions = splat$9(chartNavigatorSeriesOptions);
            chartNavigatorSeriesOptions.forEach(function(userSeriesOptions, i) {
              navSeriesMixin.name = "Navigator " + (navigatorSeries.length + 1);
              mergedNavSeriesOptions = merge$R(defaultOptions$7.navigator.series, {
                // Since we don't have a base series to pull color from,
                // try to fake it by using color from series with same
                // index. Otherwise pull from the colors array. We need
                // an explicit color as otherwise updates will increment
                // color counter and we'll get a new color for each
                // update of the nav series.
                color: chart.series[i] && !chart.series[i].options.isInternal && chart.series[i].color || chart.options.colors[i] || chart.options.colors[0]
              }, navSeriesMixin, userSeriesOptions);
              mergedNavSeriesOptions.data = userSeriesOptions.data;
              if (mergedNavSeriesOptions.data) {
                navigator.hasNavigatorData = true;
                navigatorSeries.push(chart.initSeries(mergedNavSeriesOptions));
              }
            });
          }
          if (addEvents) {
            this.addBaseSeriesEvents();
          }
        };
        Navigator2.prototype.addBaseSeriesEvents = function() {
          var navigator = this, baseSeries = navigator.baseSeries || [];
          if (baseSeries[0] && baseSeries[0].xAxis) {
            baseSeries[0].eventsToUnbind.push(addEvent$F(baseSeries[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
          }
          baseSeries.forEach(function(base) {
            base.eventsToUnbind.push(addEvent$F(base, "show", function() {
              if (this.navigatorSeries) {
                this.navigatorSeries.setVisible(true, false);
              }
            }));
            base.eventsToUnbind.push(addEvent$F(base, "hide", function() {
              if (this.navigatorSeries) {
                this.navigatorSeries.setVisible(false, false);
              }
            }));
            if (this.navigatorOptions.adaptToUpdatedData !== false) {
              if (base.xAxis) {
                base.eventsToUnbind.push(addEvent$F(base, "updatedData", this.updatedDataHandler));
              }
            }
            base.eventsToUnbind.push(addEvent$F(base, "remove", function() {
              if (this.navigatorSeries) {
                erase$1(navigator.series, this.navigatorSeries);
                if (defined$s(this.navigatorSeries.options)) {
                  this.navigatorSeries.remove(false);
                }
                delete this.navigatorSeries;
              }
            }));
          }, this);
        };
        Navigator2.prototype.getBaseSeriesMin = function(currentSeriesMin) {
          return this.baseSeries.reduce(function(min, series) {
            return Math.min(min, series.xData ? series.xData[0] : min);
          }, currentSeriesMin);
        };
        Navigator2.prototype.modifyNavigatorAxisExtremes = function() {
          var xAxis = this.xAxis, unionExtremes;
          if (typeof xAxis.getExtremes !== "undefined") {
            unionExtremes = this.getUnionExtremes(true);
            if (unionExtremes && (unionExtremes.dataMin !== xAxis.min || unionExtremes.dataMax !== xAxis.max)) {
              xAxis.min = unionExtremes.dataMin;
              xAxis.max = unionExtremes.dataMax;
            }
          }
        };
        Navigator2.prototype.modifyBaseAxisExtremes = function() {
          var baseXAxis = this, navigator = baseXAxis.chart.navigator, baseExtremes = baseXAxis.getExtremes(), baseMin = baseExtremes.min, baseMax = baseExtremes.max, baseDataMin = baseExtremes.dataMin, baseDataMax = baseExtremes.dataMax, range = baseMax - baseMin, stickToMin = navigator.stickToMin, stickToMax = navigator.stickToMax, overscroll = pick$X(baseXAxis.options.overscroll, 0), newMax, newMin, navigatorSeries = navigator.series && navigator.series[0], hasSetExtremes = !!baseXAxis.setExtremes, unmutable = baseXAxis.eventArgs && baseXAxis.eventArgs.trigger === "rangeSelectorButton";
          if (!unmutable) {
            if (stickToMin) {
              newMin = baseDataMin;
              newMax = newMin + range;
            }
            if (stickToMax) {
              newMax = baseDataMax + overscroll;
              if (!stickToMin) {
                newMin = Math.max(
                  baseDataMin,
                  // don't go below data extremes (#13184)
                  newMax - range,
                  navigator.getBaseSeriesMin(navigatorSeries && navigatorSeries.xData ? navigatorSeries.xData[0] : -Number.MAX_VALUE)
                );
              }
            }
            if (hasSetExtremes && (stickToMin || stickToMax)) {
              if (isNumber$p(newMin)) {
                baseXAxis.min = baseXAxis.userMin = newMin;
                baseXAxis.max = baseXAxis.userMax = newMax;
              }
            }
          }
          navigator.stickToMin = navigator.stickToMax = null;
        };
        Navigator2.prototype.updatedDataHandler = function() {
          var navigator = this.chart.navigator, baseSeries = this, navigatorSeries = this.navigatorSeries;
          navigator.stickToMax = navigator.reversedExtremes ? Math.round(navigator.zoomedMin) === 0 : Math.round(navigator.zoomedMax) >= Math.round(navigator.size);
          navigator.stickToMin = navigator.shouldStickToMin(baseSeries, navigator);
          if (navigatorSeries && !navigator.hasNavigatorData) {
            navigatorSeries.options.pointStart = baseSeries.xData[0];
            navigatorSeries.setData(baseSeries.options.data, false, null, false);
          }
        };
        Navigator2.prototype.shouldStickToMin = function(baseSeries, navigator) {
          var xDataMin = navigator.getBaseSeriesMin(baseSeries.xData[0]), xAxis = baseSeries.xAxis, max = xAxis.max, min = xAxis.min, range = xAxis.options.range;
          var stickToMin = true;
          if (isNumber$p(max) && isNumber$p(min)) {
            if (range && max - xDataMin > 0) {
              stickToMin = max - xDataMin < range && !this.chart.fixedRange;
            } else {
              stickToMin = min <= xDataMin;
            }
          } else {
            stickToMin = false;
          }
          return stickToMin;
        };
        Navigator2.prototype.addChartEvents = function() {
          if (!this.eventsToUnbind) {
            this.eventsToUnbind = [];
          }
          this.eventsToUnbind.push(
            // Move the scrollbar after redraw, like after data updata even if
            // axes don't redraw
            addEvent$F(this.chart, "redraw", function() {
              var navigator = this.navigator, xAxis = navigator && (navigator.baseSeries && navigator.baseSeries[0] && navigator.baseSeries[0].xAxis || this.xAxis[0]);
              if (xAxis) {
                navigator.render(xAxis.min, xAxis.max);
              }
            }),
            // Make room for the navigator, can be placed around the chart:
            addEvent$F(this.chart, "getMargins", function() {
              var chart = this, navigator = chart.navigator, marginName = navigator.opposite ? "plotTop" : "marginBottom";
              if (chart.inverted) {
                marginName = navigator.opposite ? "marginRight" : "plotLeft";
              }
              chart[marginName] = (chart[marginName] || 0) + (navigator.navigatorEnabled || !chart.inverted ? navigator.outlineHeight : 0) + navigator.navigatorOptions.margin;
            })
          );
        };
        Navigator2.prototype.destroy = function() {
          this.removeEvents();
          if (this.xAxis) {
            erase$1(this.chart.xAxis, this.xAxis);
            erase$1(this.chart.axes, this.xAxis);
          }
          if (this.yAxis) {
            erase$1(this.chart.yAxis, this.yAxis);
            erase$1(this.chart.axes, this.yAxis);
          }
          (this.series || []).forEach(function(s) {
            if (s.destroy) {
              s.destroy();
            }
          });
          [
            "series",
            "xAxis",
            "yAxis",
            "shades",
            "outline",
            "scrollbarTrack",
            "scrollbarRifles",
            "scrollbarGroup",
            "scrollbar",
            "navigatorGroup",
            "rendered"
          ].forEach(function(prop) {
            if (this[prop] && this[prop].destroy) {
              this[prop].destroy();
            }
            this[prop] = null;
          }, this);
          [this.handles].forEach(function(coll) {
            destroyObjectProperties$2(coll);
          }, this);
        };
        return Navigator2;
      }()
    );
    if (!H.Navigator) {
      H.Navigator = Navigator;
      NavigatorAxis.compose(Axis);
      addEvent$F(Chart$1, "beforeShowResetZoom", function() {
        var chartOptions = this.options, navigator = chartOptions.navigator, rangeSelector = chartOptions.rangeSelector;
        if ((navigator && navigator.enabled || rangeSelector && rangeSelector.enabled) && (!isTouchDevice$1 && chartOptions.chart.zoomType === "x" || isTouchDevice$1 && chartOptions.chart.pinchType === "x")) {
          return false;
        }
      });
      addEvent$F(Chart$1, "beforeRender", function() {
        var options = this.options;
        if (options.navigator.enabled || options.scrollbar.enabled) {
          this.scroller = this.navigator = new Navigator(this);
        }
      });
      addEvent$F(Chart$1, "afterSetChartSize", function() {
        var legend = this.legend, navigator = this.navigator, scrollbarHeight, legendOptions, xAxis, yAxis;
        if (navigator) {
          legendOptions = legend && legend.options;
          xAxis = navigator.xAxis;
          yAxis = navigator.yAxis;
          scrollbarHeight = navigator.scrollbarHeight;
          if (this.inverted) {
            navigator.left = navigator.opposite ? this.chartWidth - scrollbarHeight - navigator.height : this.spacing[3] + scrollbarHeight;
            navigator.top = this.plotTop + scrollbarHeight;
          } else {
            navigator.left = pick$X(xAxis.left, this.plotLeft + scrollbarHeight);
            navigator.top = navigator.navigatorOptions.top || this.chartHeight - navigator.height - scrollbarHeight - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (legendOptions && legendOptions.verticalAlign === "bottom" && legendOptions.layout !== "proximate" && // #13392
            legendOptions.enabled && !legendOptions.floating ? legend.legendHeight + pick$X(legendOptions.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0);
          }
          if (xAxis && yAxis) {
            if (this.inverted) {
              xAxis.options.left = yAxis.options.left = navigator.left;
            } else {
              xAxis.options.top = yAxis.options.top = navigator.top;
            }
            xAxis.setAxisSize();
            yAxis.setAxisSize();
          }
        }
      });
      addEvent$F(Chart$1, "update", function(e2) {
        var navigatorOptions = e2.options.navigator || {}, scrollbarOptions = e2.options.scrollbar || {};
        if (!this.navigator && !this.scroller && (navigatorOptions.enabled || scrollbarOptions.enabled)) {
          merge$R(true, this.options.navigator, navigatorOptions);
          merge$R(true, this.options.scrollbar, scrollbarOptions);
          delete e2.options.navigator;
          delete e2.options.scrollbar;
        }
      });
      addEvent$F(Chart$1, "afterUpdate", function(event) {
        if (!this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled)) {
          this.scroller = this.navigator = new Navigator(this);
          if (pick$X(event.redraw, true)) {
            this.redraw(event.animation);
          }
        }
      });
      addEvent$F(Chart$1, "afterAddSeries", function() {
        if (this.navigator) {
          this.navigator.setBaseSeries(null, false);
        }
      });
      addEvent$F(Series$e, "afterUpdate", function() {
        if (this.chart.navigator && !this.options.isInternal) {
          this.chart.navigator.setBaseSeries(null, false);
        }
      });
      Chart$1.prototype.callbacks.push(function(chart) {
        var extremes, navigator = chart.navigator;
        if (navigator && chart.xAxis[0]) {
          extremes = chart.xAxis[0].getExtremes();
          navigator.render(extremes.min, extremes.max);
        }
      });
    }
    H.Navigator = Navigator;
    H.Navigator;
    var defaultOptions$6 = DefaultOptions.defaultOptions;
    var addEvent$E = Utilities.addEvent, createElement$3 = Utilities.createElement, css$2 = Utilities.css, defined$r = Utilities.defined, destroyObjectProperties$1 = Utilities.destroyObjectProperties, discardElement$2 = Utilities.discardElement, extend$_ = Utilities.extend, find$b = Utilities.find, fireEvent$j = Utilities.fireEvent, isNumber$o = Utilities.isNumber, merge$Q = Utilities.merge, objectEach$d = Utilities.objectEach, pad = Utilities.pad, pick$W = Utilities.pick, pInt$3 = Utilities.pInt, splat$8 = Utilities.splat;
    extend$_(defaultOptions$6, {
      /**
       * The range selector is a tool for selecting ranges to display within
       * the chart. It provides buttons to select preconfigured ranges in
       * the chart, like 1 day, 1 week, 1 month etc. It also provides input
       * boxes where min and max dates can be manually input.
       *
       * @product      highstock gantt
       * @optionparent rangeSelector
       */
      rangeSelector: {
        /**
         * Whether to enable all buttons from the start. By default buttons are
         * only enabled if the corresponding time range exists on the X axis,
         * but enabling all buttons allows for dynamically loading different
         * time ranges.
         *
         * @sample {highstock} stock/rangeselector/allbuttonsenabled-true/
         *         All buttons enabled
         *
         * @since     2.0.3
         */
        allButtonsEnabled: false,
        /**
         * An array of configuration objects for the buttons.
         *
         * Defaults to:
         * ```js
         * buttons: [{
         *     type: 'month',
         *     count: 1,
         *     text: '1m',
         *     title: 'View 1 month'
         * }, {
         *     type: 'month',
         *     count: 3,
         *     text: '3m',
         *     title: 'View 3 months'
         * }, {
         *     type: 'month',
         *     count: 6,
         *     text: '6m',
         *     title: 'View 6 months'
         * }, {
         *     type: 'ytd',
         *     text: 'YTD',
         *     title: 'View year to date'
         * }, {
         *     type: 'year',
         *     count: 1,
         *     text: '1y',
         *     title: 'View 1 year'
         * }, {
         *     type: 'all',
         *     text: 'All',
         *     title: 'View all'
         * }]
         * ```
         *
         * @sample {highstock} stock/rangeselector/datagrouping/
         *         Data grouping by buttons
         *
         * @type      {Array<*>}
         */
        buttons: void 0,
        /**
         * How many units of the defined type the button should span. If `type`
         * is "month" and `count` is 3, the button spans three months.
         *
         * @type      {number}
         * @default   1
         * @apioption rangeSelector.buttons.count
         */
        /**
         * Fires when clicking on the rangeSelector button. One parameter,
         * event, is passed to the function, containing common event
         * information.
         *
         * ```js
         * click: function(e) {
         *   console.log(this);
         * }
         * ```
         *
         * Return false to stop default button's click action.
         *
         * @sample {highstock} stock/rangeselector/button-click/
         *         Click event on the button
         *
         * @type      {Highcharts.RangeSelectorClickCallbackFunction}
         * @apioption rangeSelector.buttons.events.click
         */
        /**
         * Additional range (in milliseconds) added to the end of the calculated
         * time span.
         *
         * @sample {highstock} stock/rangeselector/min-max-offsets/
         *         Button offsets
         *
         * @type      {number}
         * @default   0
         * @since     6.0.0
         * @apioption rangeSelector.buttons.offsetMax
         */
        /**
         * Additional range (in milliseconds) added to the start of the
         * calculated time span.
         *
         * @sample {highstock} stock/rangeselector/min-max-offsets/
         *         Button offsets
         *
         * @type      {number}
         * @default   0
         * @since     6.0.0
         * @apioption rangeSelector.buttons.offsetMin
         */
        /**
         * When buttons apply dataGrouping on a series, by default zooming
         * in/out will deselect buttons and unset dataGrouping. Enable this
         * option to keep buttons selected when extremes change.
         *
         * @sample {highstock} stock/rangeselector/preserve-datagrouping/
         *         Different preserveDataGrouping settings
         *
         * @type      {boolean}
         * @default   false
         * @since     6.1.2
         * @apioption rangeSelector.buttons.preserveDataGrouping
         */
        /**
         * A custom data grouping object for each button.
         *
         * @see [series.dataGrouping](#plotOptions.series.dataGrouping)
         *
         * @sample {highstock} stock/rangeselector/datagrouping/
         *         Data grouping by range selector buttons
         *
         * @type      {*}
         * @extends   plotOptions.series.dataGrouping
         * @apioption rangeSelector.buttons.dataGrouping
         */
        /**
         * The text for the button itself.
         *
         * @type      {string}
         * @apioption rangeSelector.buttons.text
         */
        /**
         * Explanation for the button, shown as a tooltip on hover, and used by
         * assistive technology.
         *
         * @type      {string}
         * @apioption rangeSelector.buttons.title
         */
        /**
         * Defined the time span for the button. Can be one of `millisecond`,
         * `second`, `minute`, `hour`, `day`, `week`, `month`, `year`, `ytd`,
         * and `all`.
         *
         * @type       {Highcharts.RangeSelectorButtonTypeValue}
         * @apioption  rangeSelector.buttons.type
         */
        /**
         * The space in pixels between the buttons in the range selector.
         */
        buttonSpacing: 5,
        /**
         * Whether to collapse the range selector buttons into a dropdown when
         * there is not enough room to show everything in a single row, instead
         * of dividing the range selector into multiple rows.
         * Can be one of the following:
         *  - `always`: Always collapse
         *  - `responsive`: Only collapse when there is not enough room
         *  - `never`: Never collapse
         *
         * @sample {highstock} stock/rangeselector/dropdown/
         *         Dropdown option
         *
         * @validvalue ["always", "responsive", "never"]
         * @since 9.0.0
         */
        dropdown: "responsive",
        /**
         * Enable or disable the range selector. Default to `true` for stock
         * charts, using the `stockChart` factory.
         *
         * @sample {highstock} stock/rangeselector/enabled/
         *         Disable the range selector
         *
         * @type {boolean|undefined}
         * @default {highstock} true
         */
        enabled: void 0,
        /**
         * The vertical alignment of the rangeselector box. Allowed properties
         * are `top`, `middle`, `bottom`.
         *
         * @sample {highstock} stock/rangeselector/vertical-align-middle/
         *         Middle
         * @sample {highstock} stock/rangeselector/vertical-align-bottom/
         *         Bottom
         *
         * @type  {Highcharts.VerticalAlignValue}
         * @since 6.0.0
         */
        verticalAlign: "top",
        /**
         * A collection of attributes for the buttons. The object takes SVG
         * attributes like `fill`, `stroke`, `stroke-width`, as well as `style`,
         * a collection of CSS properties for the text.
         *
         * The object can also be extended with states, so you can set
         * presentational options for `hover`, `select` or `disabled` button
         * states.
         *
         * CSS styles for the text label.
         *
         * In styled mode, the buttons are styled by the
         * `.highcharts-range-selector-buttons .highcharts-button` rule with its
         * different states.
         *
         * @sample {highstock} stock/rangeselector/styling/
         *         Styling the buttons and inputs
         *
         * @type {Highcharts.SVGAttributes}
         */
        buttonTheme: {
          /** @ignore */
          width: 28,
          /** @ignore */
          height: 18,
          /** @ignore */
          padding: 2,
          /** @ignore */
          zIndex: 7
          // #484, #852
        },
        /**
         * When the rangeselector is floating, the plot area does not reserve
         * space for it. This opens for positioning anywhere on the chart.
         *
         * @sample {highstock} stock/rangeselector/floating/
         *         Placing the range selector between the plot area and the
         *         navigator
         *
         * @since 6.0.0
         */
        floating: false,
        /**
         * The x offset of the range selector relative to its horizontal
         * alignment within `chart.spacingLeft` and `chart.spacingRight`.
         *
         * @since 6.0.0
         */
        x: 0,
        /**
         * The y offset of the range selector relative to its horizontal
         * alignment within `chart.spacingLeft` and `chart.spacingRight`.
         *
         * @since 6.0.0
         */
        y: 0,
        /**
         * Deprecated. The height of the range selector. Currently it is
         * calculated dynamically.
         *
         * @deprecated
         * @type  {number|undefined}
         * @since 2.1.9
         */
        height: void 0,
        /**
         * The border color of the date input boxes.
         *
         * @sample {highstock} stock/rangeselector/styling/
         *         Styling the buttons and inputs
         *
         * @type      {Highcharts.ColorString}
         * @since     1.3.7
         */
        inputBoxBorderColor: "none",
        /**
         * The pixel height of the date input boxes.
         *
         * @sample {highstock} stock/rangeselector/styling/
         *         Styling the buttons and inputs
         *
         * @since     1.3.7
         */
        inputBoxHeight: 17,
        /**
         * The pixel width of the date input boxes. When `undefined`, the width
         * is fitted to the rendered content.
         *
         * @sample {highstock} stock/rangeselector/styling/
         *         Styling the buttons and inputs
         *
         * @type   {number|undefined}
         * @since  1.3.7
         */
        inputBoxWidth: void 0,
        /**
         * The date format in the input boxes when not selected for editing.
         * Defaults to `%b %e, %Y`.
         *
         * This is used to determine which type of input to show,
         * `datetime-local`, `date` or `time` and falling back to `text` when
         * the browser does not support the input type or the format contains
         * milliseconds.
         *
         * @sample {highstock} stock/rangeselector/input-type/
         *         Input types
         * @sample {highstock} stock/rangeselector/input-format/
         *         Milliseconds in the range selector
         *
         */
        inputDateFormat: "%b %e, %Y",
        /**
         * A custom callback function to parse values entered in the input boxes
         * and return a valid JavaScript time as milliseconds since 1970.
         * The first argument passed is a value to parse,
         * second is a boolean indicating use of the UTC time.
         *
         * This will only get called for inputs of type `text`. Since v8.2.3,
         * the input type is dynamically determined based on the granularity
         * of the `inputDateFormat` and the browser support.
         *
         * @sample {highstock} stock/rangeselector/input-format/
         *         Milliseconds in the range selector
         *
         * @type      {Highcharts.RangeSelectorParseCallbackFunction}
         * @since     1.3.3
         */
        inputDateParser: void 0,
        /**
         * The date format in the input boxes when they are selected for
         * editing. This must be a format that is recognized by JavaScript
         * Date.parse.
         *
         * This will only be used for inputs of type `text`. Since v8.2.3,
         * the input type is dynamically determined based on the granularity
         * of the `inputDateFormat` and the browser support.
         *
         * @sample {highstock} stock/rangeselector/input-format/
         *         Milliseconds in the range selector
         *
         */
        inputEditDateFormat: "%Y-%m-%d",
        /**
         * Enable or disable the date input boxes.
         */
        inputEnabled: true,
        /**
         * Positioning for the input boxes. Allowed properties are `align`,
         *  `x` and `y`.
         *
         * @since 1.2.4
         */
        inputPosition: {
          /**
           * The alignment of the input box. Allowed properties are `left`,
           * `center`, `right`.
           *
           * @sample {highstock} stock/rangeselector/input-button-position/
           *         Alignment
           *
           * @type  {Highcharts.AlignValue}
           * @since 6.0.0
           */
          align: "right",
          /**
           * X offset of the input row.
           */
          x: 0,
          /**
           * Y offset of the input row.
           */
          y: 0
        },
        /**
         * The space in pixels between the labels and the date input boxes in
         * the range selector.
         *
         * @since 9.0.0
         */
        inputSpacing: 5,
        /**
         * The index of the button to appear pre-selected.
         *
         * @type      {number}
         */
        selected: void 0,
        /**
         * Positioning for the button row.
         *
         * @since 1.2.4
         */
        buttonPosition: {
          /**
           * The alignment of the input box. Allowed properties are `left`,
           * `center`, `right`.
           *
           * @sample {highstock} stock/rangeselector/input-button-position/
           *         Alignment
           *
           * @type  {Highcharts.AlignValue}
           * @since 6.0.0
           */
          align: "left",
          /**
           * X offset of the button row.
           */
          x: 0,
          /**
           * Y offset of the button row.
           */
          y: 0
        },
        /**
         * CSS for the HTML inputs in the range selector.
         *
         * In styled mode, the inputs are styled by the
         * `.highcharts-range-input text` rule in SVG mode, and
         * `input.highcharts-range-selector` when active.
         *
         * @sample {highstock} stock/rangeselector/styling/
         *         Styling the buttons and inputs
         *
         * @type      {Highcharts.CSSObject}
         * @apioption rangeSelector.inputStyle
         */
        inputStyle: {
          /** @ignore */
          color: palette.highlightColor80,
          /** @ignore */
          cursor: "pointer"
        },
        /**
         * CSS styles for the labels - the Zoom, From and To texts.
         *
         * In styled mode, the labels are styled by the
         * `.highcharts-range-label` class.
         *
         * @sample {highstock} stock/rangeselector/styling/
         *         Styling the buttons and inputs
         *
         * @type {Highcharts.CSSObject}
         */
        labelStyle: {
          /** @ignore */
          color: palette.neutralColor60
        }
      }
    });
    extend$_(
      defaultOptions$6.lang,
      /**
       * Language object. The language object is global and it can't be set
       * on each chart initialization. Instead, use `Highcharts.setOptions` to
       * set it before any chart is initialized.
       *
       * ```js
       * Highcharts.setOptions({
       *     lang: {
       *         months: [
       *             'Janvier', 'Fvrier', 'Mars', 'Avril',
       *             'Mai', 'Juin', 'Juillet', 'Aot',
       *             'Septembre', 'Octobre', 'Novembre', 'Dcembre'
       *         ],
       *         weekdays: [
       *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',
       *             'Jeudi', 'Vendredi', 'Samedi'
       *         ]
       *     }
       * });
       * ```
       *
       * @optionparent lang
       */
      {
        /**
         * The text for the label for the range selector buttons.
         *
         * @product highstock gantt
         */
        rangeSelectorZoom: "Zoom",
        /**
         * The text for the label for the "from" input box in the range
         * selector. Since v9.0, this string is empty as the label is not
         * rendered by default.
         *
         * @product highstock gantt
         */
        rangeSelectorFrom: "",
        /**
         * The text for the label for the "to" input box in the range selector.
         *
         * @product highstock gantt
         */
        rangeSelectorTo: ""
      }
    );
    var RangeSelector = (
      /** @class */
      function() {
        function RangeSelector2(chart) {
          this.buttons = void 0;
          this.buttonOptions = RangeSelector2.prototype.defaultButtons;
          this.initialButtonGroupWidth = 0;
          this.options = void 0;
          this.chart = chart;
          this.init(chart);
        }
        RangeSelector2.prototype.clickButton = function(i, redraw) {
          var rangeSelector = this, chart = rangeSelector.chart, rangeOptions = rangeSelector.buttonOptions[i], baseAxis = chart.xAxis[0], unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || baseAxis || {}, dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, newMin, newMax = baseAxis && Math.round(Math.min(baseAxis.max, pick$W(dataMax, baseAxis.max))), type = rangeOptions.type, baseXAxisOptions, range = rangeOptions._range, rangeMin, minSetting, rangeSetting, ctx, ytdExtremes, dataGrouping2 = rangeOptions.dataGrouping;
          if (dataMin === null || dataMax === null) {
            return;
          }
          chart.fixedRange = range;
          rangeSelector.setSelected(i);
          if (dataGrouping2) {
            this.forcedDataGrouping = true;
            Axis.prototype.setDataGrouping.call(baseAxis || { chart: this.chart }, dataGrouping2, false);
            this.frozenStates = rangeOptions.preserveDataGrouping;
          }
          if (type === "month" || type === "year") {
            if (!baseAxis) {
              range = rangeOptions;
            } else {
              ctx = {
                range: rangeOptions,
                max: newMax,
                chart,
                dataMin,
                dataMax
              };
              newMin = baseAxis.minFromRange.call(ctx);
              if (isNumber$o(ctx.newMax)) {
                newMax = ctx.newMax;
              }
            }
          } else if (range) {
            newMin = Math.max(newMax - range, dataMin);
            newMax = Math.min(newMin + range, dataMax);
          } else if (type === "ytd") {
            if (baseAxis) {
              if (typeof dataMax === "undefined") {
                dataMin = Number.MAX_VALUE;
                dataMax = Number.MIN_VALUE;
                chart.series.forEach(function(series) {
                  var xData = series.xData;
                  dataMin = Math.min(xData[0], dataMin);
                  dataMax = Math.max(xData[xData.length - 1], dataMax);
                });
                redraw = false;
              }
              ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC);
              newMin = rangeMin = ytdExtremes.min;
              newMax = ytdExtremes.max;
            } else {
              rangeSelector.deferredYTDClick = i;
              return;
            }
          } else if (type === "all" && baseAxis) {
            if (chart.navigator && chart.navigator.baseSeries[0]) {
              chart.navigator.baseSeries[0].xAxis.options.range = void 0;
            }
            newMin = dataMin;
            newMax = dataMax;
          }
          if (defined$r(newMin)) {
            newMin += rangeOptions._offsetMin;
          }
          if (defined$r(newMax)) {
            newMax += rangeOptions._offsetMax;
          }
          if (this.dropdown) {
            this.dropdown.selectedIndex = i + 1;
          }
          if (!baseAxis) {
            baseXAxisOptions = splat$8(chart.options.xAxis)[0];
            rangeSetting = baseXAxisOptions.range;
            baseXAxisOptions.range = range;
            minSetting = baseXAxisOptions.min;
            baseXAxisOptions.min = rangeMin;
            addEvent$E(chart, "load", function resetMinAndRange() {
              baseXAxisOptions.range = rangeSetting;
              baseXAxisOptions.min = minSetting;
            });
          } else {
            baseAxis.setExtremes(
              newMin,
              newMax,
              pick$W(redraw, true),
              void 0,
              // auto animation
              {
                trigger: "rangeSelectorButton",
                rangeSelectorButton: rangeOptions
              }
            );
          }
          fireEvent$j(this, "afterBtnClick");
        };
        RangeSelector2.prototype.setSelected = function(selected) {
          this.selected = this.options.selected = selected;
        };
        RangeSelector2.prototype.init = function(chart) {
          var rangeSelector = this, options = chart.options.rangeSelector, buttonOptions = options.buttons || rangeSelector.defaultButtons.slice(), selectedOption = options.selected, blurInputs = function() {
            var minInput = rangeSelector.minInput, maxInput = rangeSelector.maxInput;
            if (minInput && minInput.blur) {
              fireEvent$j(minInput, "blur");
            }
            if (maxInput && maxInput.blur) {
              fireEvent$j(maxInput, "blur");
            }
          };
          rangeSelector.chart = chart;
          rangeSelector.options = options;
          rangeSelector.buttons = [];
          rangeSelector.buttonOptions = buttonOptions;
          this.eventsToUnbind = [];
          this.eventsToUnbind.push(addEvent$E(chart.container, "mousedown", blurInputs));
          this.eventsToUnbind.push(addEvent$E(chart, "resize", blurInputs));
          buttonOptions.forEach(rangeSelector.computeButtonRange);
          if (typeof selectedOption !== "undefined" && buttonOptions[selectedOption]) {
            this.clickButton(selectedOption, false);
          }
          this.eventsToUnbind.push(addEvent$E(chart, "load", function() {
            if (chart.xAxis && chart.xAxis[0]) {
              addEvent$E(chart.xAxis[0], "setExtremes", function(e2) {
                if (this.max - this.min !== chart.fixedRange && e2.trigger !== "rangeSelectorButton" && e2.trigger !== "updatedData" && rangeSelector.forcedDataGrouping && !rangeSelector.frozenStates) {
                  this.setDataGrouping(false, false);
                }
              });
            }
          }));
        };
        RangeSelector2.prototype.updateButtonStates = function() {
          var rangeSelector = this, chart = this.chart, dropdown = this.dropdown, baseAxis = chart.xAxis[0], actualRange = Math.round(baseAxis.max - baseAxis.min), hasNoData = !baseAxis.hasVisibleSeries, day = 24 * 36e5, unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || baseAxis, dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC), ytdMin = ytdExtremes.min, ytdMax = ytdExtremes.max, selected = rangeSelector.selected, selectedExists = isNumber$o(selected), allButtonsEnabled = rangeSelector.options.allButtonsEnabled, buttons = rangeSelector.buttons;
          rangeSelector.buttonOptions.forEach(function(rangeOptions, i) {
            var range = rangeOptions._range, type = rangeOptions.type, count = rangeOptions.count || 1, button2 = buttons[i], state = 0, disable, select, offsetRange = rangeOptions._offsetMax - rangeOptions._offsetMin, isSelected = i === selected, isTooGreatRange = range > dataMax - dataMin, isTooSmallRange = range < baseAxis.minRange, isYTDButNotSelected = false, isAllButAlreadyShowingAll = false, isSameRange = range === actualRange;
            if ((type === "month" || type === "year") && actualRange + 36e5 >= { month: 28, year: 365 }[type] * day * count - offsetRange && actualRange - 36e5 <= { month: 31, year: 366 }[type] * day * count + offsetRange) {
              isSameRange = true;
            } else if (type === "ytd") {
              isSameRange = ytdMax - ytdMin + offsetRange === actualRange;
              isYTDButNotSelected = !isSelected;
            } else if (type === "all") {
              isSameRange = baseAxis.max - baseAxis.min >= dataMax - dataMin;
              isAllButAlreadyShowingAll = !isSelected && selectedExists && isSameRange;
            }
            disable = !allButtonsEnabled && (isTooGreatRange || isTooSmallRange || isAllButAlreadyShowingAll || hasNoData);
            select = isSelected && isSameRange || isSameRange && !selectedExists && !isYTDButNotSelected || isSelected && rangeSelector.frozenStates;
            if (disable) {
              state = 3;
            } else if (select) {
              selectedExists = true;
              state = 2;
            }
            if (button2.state !== state) {
              button2.setState(state);
              if (dropdown) {
                dropdown.options[i + 1].disabled = disable;
                if (state === 2) {
                  dropdown.selectedIndex = i + 1;
                }
              }
              if (state === 0 && selected === i) {
                rangeSelector.setSelected();
              }
            }
          });
        };
        RangeSelector2.prototype.computeButtonRange = function(rangeOptions) {
          var type = rangeOptions.type, count = rangeOptions.count || 1, fixedTimes = {
            millisecond: 1,
            second: 1e3,
            minute: 60 * 1e3,
            hour: 3600 * 1e3,
            day: 24 * 3600 * 1e3,
            week: 7 * 24 * 3600 * 1e3
          };
          if (fixedTimes[type]) {
            rangeOptions._range = fixedTimes[type] * count;
          } else if (type === "month" || type === "year") {
            rangeOptions._range = {
              month: 30,
              year: 365
            }[type] * 24 * 36e5 * count;
          }
          rangeOptions._offsetMin = pick$W(rangeOptions.offsetMin, 0);
          rangeOptions._offsetMax = pick$W(rangeOptions.offsetMax, 0);
          rangeOptions._range += rangeOptions._offsetMax - rangeOptions._offsetMin;
        };
        RangeSelector2.prototype.getInputValue = function(name) {
          var input = name === "min" ? this.minInput : this.maxInput;
          var options = this.chart.options.rangeSelector;
          var time = this.chart.time;
          if (input) {
            return (input.type === "text" && options.inputDateParser || this.defaultInputDateParser)(input.value, time.useUTC, time);
          }
          return 0;
        };
        RangeSelector2.prototype.setInputValue = function(name, inputTime) {
          var options = this.options, time = this.chart.time, input = name === "min" ? this.minInput : this.maxInput, dateBox = name === "min" ? this.minDateBox : this.maxDateBox;
          if (input) {
            var hcTimeAttr = input.getAttribute("data-hc-time");
            var updatedTime = defined$r(hcTimeAttr) ? Number(hcTimeAttr) : void 0;
            if (defined$r(inputTime)) {
              var previousTime = updatedTime;
              if (defined$r(previousTime)) {
                input.setAttribute("data-hc-time-previous", previousTime);
              }
              input.setAttribute("data-hc-time", inputTime);
              updatedTime = inputTime;
            }
            input.value = time.dateFormat(this.inputTypeFormats[input.type] || options.inputEditDateFormat, updatedTime);
            if (dateBox) {
              dateBox.attr({
                text: time.dateFormat(options.inputDateFormat, updatedTime)
              });
            }
          }
        };
        RangeSelector2.prototype.setInputExtremes = function(name, min, max) {
          var input = name === "min" ? this.minInput : this.maxInput;
          if (input) {
            var format2 = this.inputTypeFormats[input.type];
            var time = this.chart.time;
            if (format2) {
              var newMin = time.dateFormat(format2, min);
              if (input.min !== newMin) {
                input.min = newMin;
              }
              var newMax = time.dateFormat(format2, max);
              if (input.max !== newMax) {
                input.max = newMax;
              }
            }
          }
        };
        RangeSelector2.prototype.showInput = function(name) {
          var dateBox = name === "min" ? this.minDateBox : this.maxDateBox;
          var input = name === "min" ? this.minInput : this.maxInput;
          if (input && dateBox && this.inputGroup) {
            var isTextInput = input.type === "text";
            var _a2 = this.inputGroup, translateX = _a2.translateX, translateY = _a2.translateY;
            var inputBoxWidth = this.options.inputBoxWidth;
            css$2(input, {
              width: isTextInput ? dateBox.width + (inputBoxWidth ? -2 : 20) + "px" : "auto",
              height: isTextInput ? dateBox.height - 2 + "px" : "auto",
              border: "2px solid silver"
            });
            if (isTextInput && inputBoxWidth) {
              css$2(input, {
                left: translateX + dateBox.x + "px",
                top: translateY + "px"
              });
            } else {
              css$2(input, {
                left: Math.min(Math.round(dateBox.x + translateX - (input.offsetWidth - dateBox.width) / 2), this.chart.chartWidth - input.offsetWidth) + "px",
                top: translateY - (input.offsetHeight - dateBox.height) / 2 + "px"
              });
            }
          }
        };
        RangeSelector2.prototype.hideInput = function(name) {
          var input = name === "min" ? this.minInput : this.maxInput;
          if (input) {
            css$2(input, {
              top: "-9999em",
              border: 0,
              width: "1px",
              height: "1px"
            });
          }
        };
        RangeSelector2.prototype.defaultInputDateParser = function(inputDate, useUTC, time) {
          var hasTimezone = function(str) {
            return str.length > 6 && (str.lastIndexOf("-") === str.length - 6 || str.lastIndexOf("+") === str.length - 6);
          };
          var input = inputDate.split("/").join("-").split(" ").join("T");
          if (input.indexOf("T") === -1) {
            input += "T00:00";
          }
          if (useUTC) {
            input += "Z";
          } else if (H.isSafari && !hasTimezone(input)) {
            var offset2 = new Date(input).getTimezoneOffset() / 60;
            input += offset2 <= 0 ? "+" + pad(-offset2) + ":00" : "-" + pad(offset2) + ":00";
          }
          var date = Date.parse(input);
          if (!isNumber$o(date)) {
            var parts = inputDate.split("-");
            date = Date.UTC(pInt$3(parts[0]), pInt$3(parts[1]) - 1, pInt$3(parts[2]));
          }
          if (time && useUTC && isNumber$o(date)) {
            date += time.getTimezoneOffset(date);
          }
          return date;
        };
        RangeSelector2.prototype.drawInput = function(name) {
          var _a2 = this, chart = _a2.chart, div = _a2.div, inputGroup = _a2.inputGroup;
          var rangeSelector = this, chartStyle = chart.renderer.style || {}, renderer = chart.renderer, options = chart.options.rangeSelector, lang2 = defaultOptions$6.lang, isMin = name === "min";
          function updateExtremes() {
            var value = rangeSelector.getInputValue(name), chartAxis = chart.xAxis[0], dataAxis = chart.scroller && chart.scroller.xAxis ? chart.scroller.xAxis : chartAxis, dataMin = dataAxis.dataMin, dataMax = dataAxis.dataMax;
            var maxInput = rangeSelector.maxInput, minInput = rangeSelector.minInput;
            if (value !== Number(input.getAttribute("data-hc-time-previous")) && isNumber$o(value)) {
              input.setAttribute("data-hc-time-previous", value);
              if (isMin && maxInput && isNumber$o(dataMin)) {
                if (value > Number(maxInput.getAttribute("data-hc-time"))) {
                  value = void 0;
                } else if (value < dataMin) {
                  value = dataMin;
                }
              } else if (minInput && isNumber$o(dataMax)) {
                if (value < Number(minInput.getAttribute("data-hc-time"))) {
                  value = void 0;
                } else if (value > dataMax) {
                  value = dataMax;
                }
              }
              if (typeof value !== "undefined") {
                chartAxis.setExtremes(isMin ? value : chartAxis.min, isMin ? chartAxis.max : value, void 0, void 0, { trigger: "rangeSelectorInput" });
              }
            }
          }
          var text = lang2[isMin ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
          var label = renderer.label(text, 0).addClass("highcharts-range-label").attr({
            padding: text ? 2 : 0,
            height: text ? options.inputBoxHeight : 0
          }).add(inputGroup);
          var dateBox = renderer.label("", 0).addClass("highcharts-range-input").attr({
            padding: 2,
            width: options.inputBoxWidth,
            height: options.inputBoxHeight,
            "text-align": "center"
          }).on("click", function() {
            rangeSelector.showInput(name);
            rangeSelector[name + "Input"].focus();
          });
          if (!chart.styledMode) {
            dateBox.attr({
              stroke: options.inputBoxBorderColor,
              "stroke-width": 1
            });
          }
          dateBox.add(inputGroup);
          var input = createElement$3("input", {
            name,
            className: "highcharts-range-selector"
          }, void 0, div);
          input.setAttribute("type", preferredInputType(options.inputDateFormat || "%b %e, %Y"));
          if (!chart.styledMode) {
            label.css(merge$Q(chartStyle, options.labelStyle));
            dateBox.css(merge$Q({
              color: palette.neutralColor80
            }, chartStyle, options.inputStyle));
            css$2(input, extend$_({
              position: "absolute",
              border: 0,
              boxShadow: "0 0 15px rgba(0,0,0,0.3)",
              width: "1px",
              height: "1px",
              padding: 0,
              textAlign: "center",
              fontSize: chartStyle.fontSize,
              fontFamily: chartStyle.fontFamily,
              top: "-9999em"
              // #4798
            }, options.inputStyle));
          }
          input.onfocus = function() {
            rangeSelector.showInput(name);
          };
          input.onblur = function() {
            if (input === H.doc.activeElement) {
              updateExtremes();
            }
            rangeSelector.hideInput(name);
            rangeSelector.setInputValue(name);
            input.blur();
          };
          var keyDown = false;
          input.onchange = function() {
            if (!keyDown) {
              updateExtremes();
              rangeSelector.hideInput(name);
              input.blur();
            }
          };
          input.onkeypress = function(event) {
            if (event.keyCode === 13) {
              updateExtremes();
            }
          };
          input.onkeydown = function(event) {
            keyDown = true;
            if (event.keyCode === 38 || event.keyCode === 40) {
              updateExtremes();
            }
          };
          input.onkeyup = function() {
            keyDown = false;
          };
          return { dateBox, input, label };
        };
        RangeSelector2.prototype.getPosition = function() {
          var chart = this.chart, options = chart.options.rangeSelector, top = options.verticalAlign === "top" ? chart.plotTop - chart.axisOffset[0] : 0;
          return {
            buttonTop: top + options.buttonPosition.y,
            inputTop: top + options.inputPosition.y - 10
          };
        };
        RangeSelector2.prototype.getYTDExtremes = function(dataMax, dataMin, useUTC) {
          var time = this.chart.time, min, now = new time.Date(dataMax), year = time.get("FullYear", now), startOfYear = useUTC ? time.Date.UTC(year, 0, 1) : (
            // eslint-disable-line new-cap
            +new time.Date(year, 0, 1)
          );
          min = Math.max(dataMin, startOfYear);
          var ts = now.getTime();
          return {
            max: Math.min(dataMax || ts, ts),
            min
          };
        };
        RangeSelector2.prototype.render = function(min, max) {
          var chart = this.chart, renderer = chart.renderer, container = chart.container, chartOptions = chart.options, options = chartOptions.rangeSelector, inputsZIndex = pick$W(chartOptions.chart.style && chartOptions.chart.style.zIndex, 0) + 1, inputEnabled = options.inputEnabled, rendered = this.rendered;
          if (options.enabled === false) {
            return;
          }
          if (!rendered) {
            this.group = renderer.g("range-selector-group").attr({
              zIndex: 7
            }).add();
            this.div = createElement$3("div", void 0, {
              position: "relative",
              height: 0,
              zIndex: inputsZIndex
            });
            if (this.buttonOptions.length) {
              this.renderButtons();
            }
            if (container.parentNode) {
              container.parentNode.insertBefore(this.div, container);
            }
            if (inputEnabled) {
              this.inputGroup = renderer.g("input-group").add(this.group);
              var minElems = this.drawInput("min");
              this.minDateBox = minElems.dateBox;
              this.minLabel = minElems.label;
              this.minInput = minElems.input;
              var maxElems = this.drawInput("max");
              this.maxDateBox = maxElems.dateBox;
              this.maxLabel = maxElems.label;
              this.maxInput = maxElems.input;
            }
          }
          if (inputEnabled) {
            this.setInputValue("min", min);
            this.setInputValue("max", max);
            var unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || chart.xAxis[0] || {};
            if (defined$r(unionExtremes.dataMin) && defined$r(unionExtremes.dataMax)) {
              var minRange = chart.xAxis[0].minRange || 0;
              this.setInputExtremes("min", unionExtremes.dataMin, Math.min(unionExtremes.dataMax, this.getInputValue("max")) - minRange);
              this.setInputExtremes("max", Math.max(unionExtremes.dataMin, this.getInputValue("min")) + minRange, unionExtremes.dataMax);
            }
            if (this.inputGroup) {
              var x_1 = 0;
              [
                this.minLabel,
                this.minDateBox,
                this.maxLabel,
                this.maxDateBox
              ].forEach(function(label) {
                if (label) {
                  var width = label.getBBox().width;
                  if (width) {
                    label.attr({ x: x_1 });
                    x_1 += width + options.inputSpacing;
                  }
                }
              });
            }
          }
          this.alignElements();
          this.rendered = true;
        };
        RangeSelector2.prototype.renderButtons = function() {
          var _this = this;
          var _a2 = this, buttons = _a2.buttons, chart = _a2.chart, options = _a2.options;
          var lang2 = defaultOptions$6.lang;
          var renderer = chart.renderer;
          var buttonTheme = merge$Q(options.buttonTheme);
          var states = buttonTheme && buttonTheme.states;
          var width = buttonTheme.width || 28;
          delete buttonTheme.width;
          delete buttonTheme.states;
          this.buttonGroup = renderer.g("range-selector-buttons").add(this.group);
          var dropdown = this.dropdown = createElement$3("select", void 0, {
            position: "absolute",
            width: "1px",
            height: "1px",
            padding: 0,
            border: 0,
            top: "-9999em",
            cursor: "pointer",
            opacity: 1e-4
          }, this.div);
          addEvent$E(dropdown, "touchstart", function() {
            dropdown.style.fontSize = "16px";
          });
          [
            [H.isMS ? "mouseover" : "mouseenter"],
            [H.isMS ? "mouseout" : "mouseleave"],
            ["change", "click"]
          ].forEach(function(_a3) {
            var from = _a3[0], to = _a3[1];
            addEvent$E(dropdown, from, function() {
              var button2 = buttons[_this.currentButtonIndex()];
              if (button2) {
                fireEvent$j(button2.element, to || from);
              }
            });
          });
          this.zoomText = renderer.label(lang2 && lang2.rangeSelectorZoom || "", 0).attr({
            padding: options.buttonTheme.padding,
            height: options.buttonTheme.height,
            paddingLeft: 0,
            paddingRight: 0
          }).add(this.buttonGroup);
          if (!this.chart.styledMode) {
            this.zoomText.css(options.labelStyle);
            buttonTheme["stroke-width"] = pick$W(buttonTheme["stroke-width"], 0);
          }
          createElement$3("option", {
            textContent: this.zoomText.textStr,
            disabled: true
          }, void 0, dropdown);
          this.buttonOptions.forEach(function(rangeOptions, i) {
            createElement$3("option", {
              textContent: rangeOptions.title || rangeOptions.text
            }, void 0, dropdown);
            buttons[i] = renderer.button(rangeOptions.text, 0, 0, function(e2) {
              var buttonEvents = rangeOptions.events && rangeOptions.events.click, callDefaultEvent;
              if (buttonEvents) {
                callDefaultEvent = buttonEvents.call(rangeOptions, e2);
              }
              if (callDefaultEvent !== false) {
                _this.clickButton(i);
              }
              _this.isActive = true;
            }, buttonTheme, states && states.hover, states && states.select, states && states.disabled).attr({
              "text-align": "center",
              width
            }).add(_this.buttonGroup);
            if (rangeOptions.title) {
              buttons[i].attr("title", rangeOptions.title);
            }
          });
        };
        RangeSelector2.prototype.alignElements = function() {
          var _this = this;
          var _a2 = this, buttonGroup = _a2.buttonGroup, buttons = _a2.buttons, chart = _a2.chart, group = _a2.group, inputGroup = _a2.inputGroup, options = _a2.options, zoomText = _a2.zoomText;
          var chartOptions = chart.options;
          var navButtonOptions = chartOptions.exporting && chartOptions.exporting.enabled !== false && chartOptions.navigation && chartOptions.navigation.buttonOptions;
          var buttonPosition = options.buttonPosition, inputPosition = options.inputPosition, verticalAlign = options.verticalAlign;
          var getXOffsetForExportButton = function(group2, position) {
            if (navButtonOptions && _this.titleCollision(chart) && verticalAlign === "top" && position.align === "right" && position.y - group2.getBBox().height - 12 < (navButtonOptions.y || 0) + (navButtonOptions.height || 0) + chart.spacing[0]) {
              return -40;
            }
            return 0;
          };
          var plotLeft = chart.plotLeft;
          if (group && buttonPosition && inputPosition) {
            var translateX = buttonPosition.x - chart.spacing[3];
            if (buttonGroup) {
              this.positionButtons();
              if (!this.initialButtonGroupWidth) {
                var width_1 = 0;
                if (zoomText) {
                  width_1 += zoomText.getBBox().width + 5;
                }
                buttons.forEach(function(button2, i) {
                  width_1 += button2.width;
                  if (i !== buttons.length - 1) {
                    width_1 += options.buttonSpacing;
                  }
                });
                this.initialButtonGroupWidth = width_1;
              }
              plotLeft -= chart.spacing[3];
              this.updateButtonStates();
              var xOffsetForExportButton_1 = getXOffsetForExportButton(buttonGroup, buttonPosition);
              this.alignButtonGroup(xOffsetForExportButton_1);
              group.placed = buttonGroup.placed = chart.hasLoaded;
            }
            var xOffsetForExportButton = 0;
            if (inputGroup) {
              xOffsetForExportButton = getXOffsetForExportButton(inputGroup, inputPosition);
              if (inputPosition.align === "left") {
                translateX = plotLeft;
              } else if (inputPosition.align === "right") {
                translateX = -Math.max(chart.axisOffset[1], -xOffsetForExportButton);
              }
              inputGroup.align({
                y: inputPosition.y,
                width: inputGroup.getBBox().width,
                align: inputPosition.align,
                // fix wrong getBBox() value on right align
                x: inputPosition.x + translateX - 2
              }, true, chart.spacingBox);
              inputGroup.placed = chart.hasLoaded;
            }
            this.handleCollision(xOffsetForExportButton);
            group.align({
              verticalAlign
            }, true, chart.spacingBox);
            var alignTranslateY = group.alignAttr.translateY;
            var groupHeight = group.getBBox().height + 20;
            var translateY = 0;
            if (verticalAlign === "bottom") {
              var legendOptions = chart.legend && chart.legend.options;
              var legendHeight = legendOptions && legendOptions.verticalAlign === "bottom" && legendOptions.enabled && !legendOptions.floating ? chart.legend.legendHeight + pick$W(legendOptions.margin, 10) : 0;
              groupHeight = groupHeight + legendHeight - 20;
              translateY = alignTranslateY - groupHeight - (options.floating ? 0 : options.y) - (chart.titleOffset ? chart.titleOffset[2] : 0) - 10;
            }
            if (verticalAlign === "top") {
              if (options.floating) {
                translateY = 0;
              }
              if (chart.titleOffset && chart.titleOffset[0]) {
                translateY = chart.titleOffset[0];
              }
              translateY += chart.margin[0] - chart.spacing[0] || 0;
            } else if (verticalAlign === "middle") {
              if (inputPosition.y === buttonPosition.y) {
                translateY = alignTranslateY;
              } else if (inputPosition.y || buttonPosition.y) {
                if (inputPosition.y < 0 || buttonPosition.y < 0) {
                  translateY -= Math.min(inputPosition.y, buttonPosition.y);
                } else {
                  translateY = alignTranslateY - groupHeight;
                }
              }
            }
            group.translate(options.x, options.y + Math.floor(translateY));
            var _b = this, minInput = _b.minInput, maxInput = _b.maxInput, dropdown = _b.dropdown;
            if (options.inputEnabled && minInput && maxInput) {
              minInput.style.marginTop = group.translateY + "px";
              maxInput.style.marginTop = group.translateY + "px";
            }
            if (dropdown) {
              dropdown.style.marginTop = group.translateY + "px";
            }
          }
        };
        RangeSelector2.prototype.alignButtonGroup = function(xOffsetForExportButton, width) {
          var _a2 = this, chart = _a2.chart, options = _a2.options, buttonGroup = _a2.buttonGroup;
          _a2.buttons;
          var buttonPosition = options.buttonPosition;
          var plotLeft = chart.plotLeft - chart.spacing[3];
          var translateX = buttonPosition.x - chart.spacing[3];
          if (buttonPosition.align === "right") {
            translateX += xOffsetForExportButton - plotLeft;
          } else if (buttonPosition.align === "center") {
            translateX -= plotLeft / 2;
          }
          if (buttonGroup) {
            buttonGroup.align({
              y: buttonPosition.y,
              width: pick$W(width, this.initialButtonGroupWidth),
              align: buttonPosition.align,
              x: translateX
            }, true, chart.spacingBox);
          }
        };
        RangeSelector2.prototype.positionButtons = function() {
          var _a2 = this, buttons = _a2.buttons, chart = _a2.chart, options = _a2.options, zoomText = _a2.zoomText;
          var verb = chart.hasLoaded ? "animate" : "attr";
          var buttonPosition = options.buttonPosition;
          var plotLeft = chart.plotLeft;
          var buttonLeft = plotLeft;
          if (zoomText && zoomText.visibility !== "hidden") {
            zoomText[verb]({
              x: pick$W(plotLeft + buttonPosition.x, plotLeft)
            });
            buttonLeft += buttonPosition.x + zoomText.getBBox().width + 5;
          }
          this.buttonOptions.forEach(function(rangeOptions, i) {
            if (buttons[i].visibility !== "hidden") {
              buttons[i][verb]({ x: buttonLeft });
              buttonLeft += buttons[i].width + options.buttonSpacing;
            } else {
              buttons[i][verb]({ x: plotLeft });
            }
          });
        };
        RangeSelector2.prototype.handleCollision = function(xOffsetForExportButton) {
          var _this = this;
          var _a2 = this, chart = _a2.chart, buttonGroup = _a2.buttonGroup, inputGroup = _a2.inputGroup;
          var _b = this.options, buttonPosition = _b.buttonPosition, dropdown = _b.dropdown, inputPosition = _b.inputPosition;
          var maxButtonWidth = function() {
            var buttonWidth = 0;
            _this.buttons.forEach(function(button2) {
              var bBox = button2.getBBox();
              if (bBox.width > buttonWidth) {
                buttonWidth = bBox.width;
              }
            });
            return buttonWidth;
          };
          var groupsOverlap = function(buttonGroupWidth) {
            if (inputGroup && buttonGroup) {
              var inputGroupX = inputGroup.alignAttr.translateX + inputGroup.alignOptions.x - xOffsetForExportButton + // getBBox for detecing left margin
              inputGroup.getBBox().x + // 2px padding to not overlap input and label
              2;
              var inputGroupWidth = inputGroup.alignOptions.width;
              var buttonGroupX = buttonGroup.alignAttr.translateX + buttonGroup.getBBox().x;
              return buttonGroupX + buttonGroupWidth > inputGroupX && inputGroupX + inputGroupWidth > buttonGroupX && buttonPosition.y < inputPosition.y + inputGroup.getBBox().height;
            }
            return false;
          };
          var moveInputsDown = function() {
            if (inputGroup && buttonGroup) {
              inputGroup.attr({
                translateX: inputGroup.alignAttr.translateX + (chart.axisOffset[1] >= -xOffsetForExportButton ? 0 : -xOffsetForExportButton),
                translateY: inputGroup.alignAttr.translateY + buttonGroup.getBBox().height + 10
              });
            }
          };
          if (buttonGroup) {
            if (dropdown === "always") {
              this.collapseButtons(xOffsetForExportButton);
              if (groupsOverlap(maxButtonWidth())) {
                moveInputsDown();
              }
              return;
            }
            if (dropdown === "never") {
              this.expandButtons();
            }
          }
          if (inputGroup && buttonGroup) {
            if (inputPosition.align === buttonPosition.align || // 20 is minimal spacing between elements
            groupsOverlap(this.initialButtonGroupWidth + 20)) {
              if (dropdown === "responsive") {
                this.collapseButtons(xOffsetForExportButton);
                if (groupsOverlap(maxButtonWidth())) {
                  moveInputsDown();
                }
              } else {
                moveInputsDown();
              }
            } else if (dropdown === "responsive") {
              this.expandButtons();
            }
          } else if (buttonGroup && dropdown === "responsive") {
            if (this.initialButtonGroupWidth > chart.plotWidth) {
              this.collapseButtons(xOffsetForExportButton);
            } else {
              this.expandButtons();
            }
          }
        };
        RangeSelector2.prototype.collapseButtons = function(xOffsetForExportButton) {
          var _a2 = this, buttons = _a2.buttons, buttonOptions = _a2.buttonOptions, chart = _a2.chart, dropdown = _a2.dropdown, options = _a2.options, zoomText = _a2.zoomText;
          var userButtonTheme = chart.userOptions.rangeSelector && chart.userOptions.rangeSelector.buttonTheme || {};
          var getAttribs = function(text) {
            return {
              text: text ? text + " " : "",
              width: "auto",
              paddingLeft: pick$W(options.buttonTheme.paddingLeft, userButtonTheme.padding, 8),
              paddingRight: pick$W(options.buttonTheme.paddingRight, userButtonTheme.padding, 8)
            };
          };
          if (zoomText) {
            zoomText.hide();
          }
          var hasActiveButton = false;
          buttonOptions.forEach(function(rangeOptions, i) {
            var button2 = buttons[i];
            if (button2.state !== 2) {
              button2.hide();
            } else {
              button2.show();
              button2.attr(getAttribs(rangeOptions.text));
              hasActiveButton = true;
            }
          });
          if (!hasActiveButton) {
            if (dropdown) {
              dropdown.selectedIndex = 0;
            }
            buttons[0].show();
            buttons[0].attr(getAttribs(this.zoomText && this.zoomText.textStr));
          }
          var align = options.buttonPosition.align;
          this.positionButtons();
          if (align === "right" || align === "center") {
            this.alignButtonGroup(xOffsetForExportButton, buttons[this.currentButtonIndex()].getBBox().width);
          }
          this.showDropdown();
        };
        RangeSelector2.prototype.expandButtons = function() {
          var _a2 = this, buttons = _a2.buttons, buttonOptions = _a2.buttonOptions, options = _a2.options, zoomText = _a2.zoomText;
          this.hideDropdown();
          if (zoomText) {
            zoomText.show();
          }
          buttonOptions.forEach(function(rangeOptions, i) {
            var button2 = buttons[i];
            button2.show();
            button2.attr({
              text: rangeOptions.text,
              width: options.buttonTheme.width || 28,
              paddingLeft: pick$W(options.buttonTheme.paddingLeft, "unset"),
              paddingRight: pick$W(options.buttonTheme.paddingRight, "unset")
            });
            if (button2.state < 2) {
              button2.setState(0);
            }
          });
          this.positionButtons();
        };
        RangeSelector2.prototype.currentButtonIndex = function() {
          var dropdown = this.dropdown;
          if (dropdown && dropdown.selectedIndex > 0) {
            return dropdown.selectedIndex - 1;
          }
          return 0;
        };
        RangeSelector2.prototype.showDropdown = function() {
          var _a2 = this, buttonGroup = _a2.buttonGroup, buttons = _a2.buttons, chart = _a2.chart, dropdown = _a2.dropdown;
          if (buttonGroup && dropdown) {
            var translateX = buttonGroup.translateX, translateY = buttonGroup.translateY;
            var bBox = buttons[this.currentButtonIndex()].getBBox();
            css$2(dropdown, {
              left: chart.plotLeft + translateX + "px",
              top: translateY + 0.5 + "px",
              width: bBox.width + "px",
              height: bBox.height + "px"
            });
            this.hasVisibleDropdown = true;
          }
        };
        RangeSelector2.prototype.hideDropdown = function() {
          var dropdown = this.dropdown;
          if (dropdown) {
            css$2(dropdown, {
              top: "-9999em",
              width: "1px",
              height: "1px"
            });
            this.hasVisibleDropdown = false;
          }
        };
        RangeSelector2.prototype.getHeight = function() {
          var rangeSelector = this, options = rangeSelector.options, rangeSelectorGroup = rangeSelector.group, inputPosition = options.inputPosition, buttonPosition = options.buttonPosition, yPosition = options.y, buttonPositionY = buttonPosition.y, inputPositionY = inputPosition.y, rangeSelectorHeight = 0, minPosition;
          if (options.height) {
            return options.height;
          }
          this.alignElements();
          rangeSelectorHeight = rangeSelectorGroup ? (
            // 13px to keep back compatibility
            rangeSelectorGroup.getBBox(true).height + 13 + yPosition
          ) : 0;
          minPosition = Math.min(inputPositionY, buttonPositionY);
          if (inputPositionY < 0 && buttonPositionY < 0 || inputPositionY > 0 && buttonPositionY > 0) {
            rangeSelectorHeight += Math.abs(minPosition);
          }
          return rangeSelectorHeight;
        };
        RangeSelector2.prototype.titleCollision = function(chart) {
          return !(chart.options.title.text || chart.options.subtitle.text);
        };
        RangeSelector2.prototype.update = function(options) {
          var chart = this.chart;
          merge$Q(true, chart.options.rangeSelector, options);
          this.destroy();
          this.init(chart);
          this.render();
        };
        RangeSelector2.prototype.destroy = function() {
          var rSelector = this, minInput = rSelector.minInput, maxInput = rSelector.maxInput;
          if (rSelector.eventsToUnbind) {
            rSelector.eventsToUnbind.forEach(function(unbind) {
              return unbind();
            });
            rSelector.eventsToUnbind = void 0;
          }
          destroyObjectProperties$1(rSelector.buttons);
          if (minInput) {
            minInput.onfocus = minInput.onblur = minInput.onchange = null;
          }
          if (maxInput) {
            maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;
          }
          objectEach$d(rSelector, function(val, key) {
            if (val && key !== "chart") {
              if (val instanceof SVGElement) {
                val.destroy();
              } else if (val instanceof window.HTMLElement) {
                discardElement$2(val);
              }
            }
            if (val !== RangeSelector2.prototype[key]) {
              rSelector[key] = null;
            }
          }, this);
        };
        return RangeSelector2;
      }()
    );
    RangeSelector.prototype.defaultButtons = [{
      type: "month",
      count: 1,
      text: "1m",
      title: "View 1 month"
    }, {
      type: "month",
      count: 3,
      text: "3m",
      title: "View 3 months"
    }, {
      type: "month",
      count: 6,
      text: "6m",
      title: "View 6 months"
    }, {
      type: "ytd",
      text: "YTD",
      title: "View year to date"
    }, {
      type: "year",
      count: 1,
      text: "1y",
      title: "View 1 year"
    }, {
      type: "all",
      text: "All",
      title: "View all"
    }];
    RangeSelector.prototype.inputTypeFormats = {
      "datetime-local": "%Y-%m-%dT%H:%M:%S",
      "date": "%Y-%m-%d",
      "time": "%H:%M:%S"
    };
    function preferredInputType(format2) {
      var ms = format2.indexOf("%L") !== -1;
      if (ms) {
        return "text";
      }
      var date = ["a", "A", "d", "e", "w", "b", "B", "m", "o", "y", "Y"].some(function(char) {
        return format2.indexOf("%" + char) !== -1;
      });
      var time = ["H", "k", "I", "l", "M", "S"].some(function(char) {
        return format2.indexOf("%" + char) !== -1;
      });
      if (date && time) {
        return "datetime-local";
      }
      if (date) {
        return "date";
      }
      if (time) {
        return "time";
      }
      return "text";
    }
    Axis.prototype.minFromRange = function() {
      var rangeOptions = this.range, type = rangeOptions.type, min, max = this.max, dataMin, range, time = this.chart.time, getTrueRange = function(base, count) {
        var timeName = type === "year" ? "FullYear" : "Month";
        var date = new time.Date(base);
        var basePeriod = time.get(timeName, date);
        time.set(timeName, date, basePeriod + count);
        if (basePeriod === time.get(timeName, date)) {
          time.set("Date", date, 0);
        }
        return date.getTime() - base;
      };
      if (isNumber$o(rangeOptions)) {
        min = max - rangeOptions;
        range = rangeOptions;
      } else {
        min = max + getTrueRange(max, -rangeOptions.count);
        if (this.chart) {
          this.chart.fixedRange = max - min;
        }
      }
      dataMin = pick$W(this.dataMin, Number.MIN_VALUE);
      if (!isNumber$o(min)) {
        min = dataMin;
      }
      if (min <= dataMin) {
        min = dataMin;
        if (typeof range === "undefined") {
          range = getTrueRange(min, rangeOptions.count);
        }
        this.newMax = Math.min(min + range, this.dataMax);
      }
      if (!isNumber$o(max)) {
        min = void 0;
      }
      return min;
    };
    if (!H.RangeSelector) {
      var chartDestroyEvents_1 = [];
      var initRangeSelector_1 = function(chart) {
        var extremes, rangeSelector = chart.rangeSelector, legend, alignTo, verticalAlign;
        function render2() {
          if (rangeSelector) {
            extremes = chart.xAxis[0].getExtremes();
            legend = chart.legend;
            verticalAlign = rangeSelector && rangeSelector.options.verticalAlign;
            if (isNumber$o(extremes.min)) {
              rangeSelector.render(extremes.min, extremes.max);
            }
            if (legend.display && verticalAlign === "top" && verticalAlign === legend.options.verticalAlign) {
              alignTo = merge$Q(chart.spacingBox);
              if (legend.options.layout === "vertical") {
                alignTo.y = chart.plotTop;
              } else {
                alignTo.y += rangeSelector.getHeight();
              }
              legend.group.placed = false;
              legend.align(alignTo);
            }
          }
        }
        if (rangeSelector) {
          var events = find$b(chartDestroyEvents_1, function(e2) {
            return e2[0] === chart;
          });
          if (!events) {
            chartDestroyEvents_1.push([chart, [
              // redraw the scroller on setExtremes
              addEvent$E(chart.xAxis[0], "afterSetExtremes", function(e2) {
                if (rangeSelector) {
                  rangeSelector.render(e2.min, e2.max);
                }
              }),
              // redraw the scroller chart resize
              addEvent$E(chart, "redraw", render2)
            ]]);
          }
          render2();
        }
      };
      addEvent$E(Chart$1, "afterGetContainer", function() {
        if (this.options.rangeSelector && this.options.rangeSelector.enabled) {
          this.rangeSelector = new RangeSelector(this);
        }
      });
      addEvent$E(Chart$1, "beforeRender", function() {
        var chart = this, axes = chart.axes, rangeSelector = chart.rangeSelector, verticalAlign;
        if (rangeSelector) {
          if (isNumber$o(rangeSelector.deferredYTDClick)) {
            rangeSelector.clickButton(rangeSelector.deferredYTDClick);
            delete rangeSelector.deferredYTDClick;
          }
          axes.forEach(function(axis) {
            axis.updateNames();
            axis.setScale();
          });
          chart.getAxisMargins();
          rangeSelector.render();
          verticalAlign = rangeSelector.options.verticalAlign;
          if (!rangeSelector.options.floating) {
            if (verticalAlign === "bottom") {
              this.extraBottomMargin = true;
            } else if (verticalAlign !== "middle") {
              this.extraTopMargin = true;
            }
          }
        }
      });
      addEvent$E(Chart$1, "update", function(e2) {
        var chart = this, options = e2.options, optionsRangeSelector = options.rangeSelector, rangeSelector = chart.rangeSelector, verticalAlign, extraBottomMarginWas = this.extraBottomMargin, extraTopMarginWas = this.extraTopMargin;
        if (optionsRangeSelector && optionsRangeSelector.enabled && !defined$r(rangeSelector) && this.options.rangeSelector) {
          this.options.rangeSelector.enabled = true;
          this.rangeSelector = rangeSelector = new RangeSelector(this);
        }
        this.extraBottomMargin = false;
        this.extraTopMargin = false;
        if (rangeSelector) {
          initRangeSelector_1(this);
          verticalAlign = optionsRangeSelector && optionsRangeSelector.verticalAlign || rangeSelector.options && rangeSelector.options.verticalAlign;
          if (!rangeSelector.options.floating) {
            if (verticalAlign === "bottom") {
              this.extraBottomMargin = true;
            } else if (verticalAlign !== "middle") {
              this.extraTopMargin = true;
            }
          }
          if (this.extraBottomMargin !== extraBottomMarginWas || this.extraTopMargin !== extraTopMarginWas) {
            this.isDirtyBox = true;
          }
        }
      });
      addEvent$E(Chart$1, "render", function() {
        var chart = this, rangeSelector = chart.rangeSelector, verticalAlign;
        if (rangeSelector && !rangeSelector.options.floating) {
          rangeSelector.render();
          verticalAlign = rangeSelector.options.verticalAlign;
          if (verticalAlign === "bottom") {
            this.extraBottomMargin = true;
          } else if (verticalAlign !== "middle") {
            this.extraTopMargin = true;
          }
        }
      });
      addEvent$E(Chart$1, "getMargins", function() {
        var rangeSelector = this.rangeSelector, rangeSelectorHeight;
        if (rangeSelector) {
          rangeSelectorHeight = rangeSelector.getHeight();
          if (this.extraTopMargin) {
            this.plotTop += rangeSelectorHeight;
          }
          if (this.extraBottomMargin) {
            this.marginBottom += rangeSelectorHeight;
          }
        }
      });
      Chart$1.prototype.callbacks.push(initRangeSelector_1);
      addEvent$E(Chart$1, "destroy", function destroyEvents() {
        for (var i = 0; i < chartDestroyEvents_1.length; i++) {
          var events = chartDestroyEvents_1[i];
          if (events[0] === this) {
            events[1].forEach(function(unbind) {
              return unbind();
            });
            chartDestroyEvents_1.splice(i, 1);
            return;
          }
        }
      });
      H.RangeSelector = RangeSelector;
    }
    var __extends$G = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var animObject$4 = animationExports.animObject;
    var format$7 = FormatUtilities.format;
    var getOptions$2 = DefaultOptions.getOptions;
    var pointTooltipFormatter = Point$2.prototype.tooltipFormatter;
    var _a$c = Series$e.prototype, seriesInit = _a$c.init, seriesProcessData = _a$c.processData;
    var addEvent$D = Utilities.addEvent, arrayMax$4 = Utilities.arrayMax, arrayMin$4 = Utilities.arrayMin, clamp$9 = Utilities.clamp, defined$q = Utilities.defined, extend$Z = Utilities.extend, find$a = Utilities.find, isNumber$n = Utilities.isNumber, isString$3 = Utilities.isString, merge$P = Utilities.merge, pick$V = Utilities.pick, splat$7 = Utilities.splat;
    var StockChart = (
      /** @class */
      function(_super) {
        __extends$G(StockChart2, _super);
        function StockChart2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        StockChart2.prototype.init = function(userOptions, callback) {
          var defaultOptions2 = getOptions$2(), xAxisOptions = userOptions.xAxis, yAxisOptions = userOptions.yAxis, navigatorEnabled = pick$V(userOptions.navigator && userOptions.navigator.enabled, defaultOptions2.navigator.enabled, true);
          userOptions.xAxis = userOptions.yAxis = void 0;
          var options = merge$P(
            {
              chart: {
                panning: {
                  enabled: true,
                  type: "x"
                },
                pinchType: "x"
              },
              navigator: {
                enabled: navigatorEnabled
              },
              scrollbar: {
                // #4988 - check if setOptions was called
                enabled: pick$V(defaultOptions2.scrollbar && defaultOptions2.scrollbar.enabled, true)
              },
              rangeSelector: {
                // #4988 - check if setOptions was called
                enabled: pick$V(defaultOptions2.rangeSelector.enabled, true)
              },
              title: {
                text: null
              },
              tooltip: {
                split: pick$V(defaultOptions2.tooltip.split, true),
                crosshairs: true
              },
              legend: {
                enabled: false
              }
            },
            userOptions,
            // user's options
            {
              isStock: true
              // internal flag
            }
          );
          userOptions.xAxis = xAxisOptions;
          userOptions.yAxis = yAxisOptions;
          options.xAxis = splat$7(userOptions.xAxis || {}).map(function(xAxisOptions2, i) {
            return merge$P(
              getDefaultAxisOptions("xAxis", xAxisOptions2),
              defaultOptions2.xAxis,
              // #3802
              defaultOptions2.xAxis && defaultOptions2.xAxis[i],
              // #7690
              xAxisOptions2,
              // user options
              getForcedAxisOptions("xAxis", userOptions)
            );
          });
          options.yAxis = splat$7(userOptions.yAxis || {}).map(function(yAxisOptions2, i) {
            return merge$P(
              getDefaultAxisOptions("yAxis", yAxisOptions2),
              defaultOptions2.yAxis,
              // #3802
              defaultOptions2.yAxis && defaultOptions2.yAxis[i],
              // #7690
              yAxisOptions2
              // user options
            );
          });
          _super.prototype.init.call(this, options, callback);
        };
        StockChart2.prototype.createAxis = function(type, options) {
          options.axis = merge$P(getDefaultAxisOptions(type, options.axis), options.axis, getForcedAxisOptions(type, this.userOptions));
          return _super.prototype.createAxis.call(this, type, options);
        };
        return StockChart2;
      }(Chart$1)
    );
    (function(StockChart2) {
      function stockChart(a, b, c) {
        return new StockChart2(a, b, c);
      }
      StockChart2.stockChart = stockChart;
    })(StockChart || (StockChart = {}));
    function getDefaultAxisOptions(type, options) {
      if (type === "xAxis") {
        return {
          minPadding: 0,
          maxPadding: 0,
          overscroll: 0,
          ordinal: true,
          title: {
            text: null
          },
          labels: {
            overflow: "justify"
          },
          showLastLabel: true
        };
      }
      if (type === "yAxis") {
        return {
          labels: {
            y: -2
          },
          opposite: pick$V(options.opposite, true),
          /**
           * @default {highcharts} true
           * @default {highstock} false
           * @apioption yAxis.showLastLabel
           *
           * @private
           */
          showLastLabel: !!// #6104, show last label by default for category axes
          (options.categories || options.type === "category"),
          title: {
            text: null
          }
        };
      }
      return {};
    }
    function getForcedAxisOptions(type, chartOptions) {
      if (type === "xAxis") {
        var defaultOptions2 = getOptions$2(), navigatorEnabled = pick$V(chartOptions.navigator && chartOptions.navigator.enabled, defaultOptions2.navigator.enabled, true);
        var axisOptions = {
          type: "datetime",
          categories: void 0
        };
        if (navigatorEnabled) {
          axisOptions.startOnTick = false;
          axisOptions.endOnTick = false;
        }
        return axisOptions;
      }
      return {};
    }
    addEvent$D(Series$e, "setOptions", function(e2) {
      var overrides;
      if (this.chart.options.isStock) {
        if (this.is("column") || this.is("columnrange")) {
          overrides = {
            borderWidth: 0,
            shadow: false
          };
        } else if (!this.is("scatter") && !this.is("sma")) {
          overrides = {
            marker: {
              enabled: false,
              radius: 2
            }
          };
        }
        if (overrides) {
          e2.plotOptions[this.type] = merge$P(e2.plotOptions[this.type], overrides);
        }
      }
    });
    addEvent$D(Axis, "autoLabelAlign", function(e2) {
      var chart = this.chart, options = this.options, panes = chart._labelPanes = chart._labelPanes || {}, key, labelOptions = this.options.labels;
      if (this.chart.options.isStock && this.coll === "yAxis") {
        key = options.top + "," + options.height;
        if (!panes[key] && labelOptions.enabled) {
          if (labelOptions.x === 15) {
            labelOptions.x = 0;
          }
          if (typeof labelOptions.align === "undefined") {
            labelOptions.align = "right";
          }
          panes[key] = this;
          e2.align = "right";
          e2.preventDefault();
        }
      }
    });
    addEvent$D(Axis, "destroy", function() {
      var chart = this.chart, key = this.options && this.options.top + "," + this.options.height;
      if (key && chart._labelPanes && chart._labelPanes[key] === this) {
        delete chart._labelPanes[key];
      }
    });
    addEvent$D(Axis, "getPlotLinePath", function(e2) {
      var axis = this, series = this.isLinked && !this.series ? this.linkedParent.series : this.series, chart = axis.chart, renderer = chart.renderer, axisLeft = axis.left, axisTop = axis.top, x1, y1, x2, y2, result2 = [], axes = [], axes2, uniqueAxes, translatedValue = e2.translatedValue, value = e2.value, force = e2.force, transVal;
      function getAxis(coll) {
        var otherColl = coll === "xAxis" ? "yAxis" : "xAxis", opt = axis.options[otherColl];
        if (isNumber$n(opt)) {
          return [chart[otherColl][opt]];
        }
        if (isString$3(opt)) {
          return [chart.get(opt)];
        }
        return series.map(function(s) {
          return s[otherColl];
        });
      }
      if (
        // For stock chart, by default render paths across the panes
        // except the case when `acrossPanes` is disabled by user (#6644)
        chart.options.isStock && e2.acrossPanes !== false && // Ignore in case of colorAxis or zAxis. #3360, #3524, #6720
        axis.coll === "xAxis" || axis.coll === "yAxis"
      ) {
        e2.preventDefault();
        axes = getAxis(axis.coll);
        axes2 = axis.isXAxis ? chart.yAxis : chart.xAxis;
        axes2.forEach(function(A) {
          if (defined$q(A.options.id) ? A.options.id.indexOf("navigator") === -1 : true) {
            var a = A.isXAxis ? "yAxis" : "xAxis", rax = defined$q(A.options[a]) ? chart[a][A.options[a]] : chart[a][0];
            if (axis === rax) {
              axes.push(A);
            }
          }
        });
        uniqueAxes = axes.length ? [] : [axis.isXAxis ? chart.yAxis[0] : chart.xAxis[0]];
        axes.forEach(function(axis2) {
          if (uniqueAxes.indexOf(axis2) === -1 && // Do not draw on axis which overlap completely. #5424
          !find$a(uniqueAxes, function(unique) {
            return unique.pos === axis2.pos && unique.len === axis2.len;
          })) {
            uniqueAxes.push(axis2);
          }
        });
        transVal = pick$V(translatedValue, axis.translate(value, null, null, e2.old));
        if (isNumber$n(transVal)) {
          if (axis.horiz) {
            uniqueAxes.forEach(function(axis2) {
              var skip;
              y1 = axis2.pos;
              y2 = y1 + axis2.len;
              x1 = x2 = Math.round(transVal + axis.transB);
              if (force !== "pass" && (x1 < axisLeft || x1 > axisLeft + axis.width)) {
                if (force) {
                  x1 = x2 = clamp$9(x1, axisLeft, axisLeft + axis.width);
                } else {
                  skip = true;
                }
              }
              if (!skip) {
                result2.push(["M", x1, y1], ["L", x2, y2]);
              }
            });
          } else {
            uniqueAxes.forEach(function(axis2) {
              var skip;
              x1 = axis2.pos;
              x2 = x1 + axis2.len;
              y1 = y2 = Math.round(axisTop + axis.height - transVal);
              if (force !== "pass" && (y1 < axisTop || y1 > axisTop + axis.height)) {
                if (force) {
                  y1 = y2 = clamp$9(y1, axisTop, axisTop + axis.height);
                } else {
                  skip = true;
                }
              }
              if (!skip) {
                result2.push(["M", x1, y1], ["L", x2, y2]);
              }
            });
          }
        }
        e2.path = result2.length > 0 ? renderer.crispPolyLine(result2, e2.lineWidth || 1) : (
          // #3557 getPlotLinePath in regular Highcharts also returns null
          null
        );
      }
    });
    SVGRenderer.prototype.crispPolyLine = function(points, width) {
      for (var i = 0; i < points.length; i = i + 2) {
        var start = points[i], end = points[i + 1];
        if (start[1] === end[1]) {
          start[1] = end[1] = Math.round(start[1]) - width % 2 / 2;
        }
        if (start[2] === end[2]) {
          start[2] = end[2] = Math.round(start[2]) + width % 2 / 2;
        }
      }
      return points;
    };
    addEvent$D(Axis, "afterHideCrosshair", function() {
      if (this.crossLabel) {
        this.crossLabel = this.crossLabel.hide();
      }
    });
    addEvent$D(Axis, "afterDrawCrosshair", function(event) {
      if (!this.crosshair || !this.crosshair.label || !this.crosshair.label.enabled || !this.cross || !isNumber$n(this.min) || !isNumber$n(this.max)) {
        return;
      }
      var chart = this.chart, log = this.logarithmic, options = this.crosshair.label, horiz = this.horiz, opposite = this.opposite, left = this.left, top = this.top, crossLabel = this.crossLabel, posx, posy, crossBox, formatOption = options.format, formatFormat = "", limit, align, tickInside = this.options.tickPosition === "inside", snap = this.crosshair.snap !== false, offset2 = 0, e2 = event.e || this.cross && this.cross.e, point = event.point, min = this.min, max = this.max;
      if (log) {
        min = log.lin2log(min);
        max = log.lin2log(max);
      }
      align = horiz ? "center" : opposite ? this.labelAlign === "right" ? "right" : "left" : this.labelAlign === "left" ? "left" : "center";
      if (!crossLabel) {
        crossLabel = this.crossLabel = chart.renderer.label("", 0, void 0, options.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (point ? point.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({
          align: options.align || align,
          padding: pick$V(options.padding, 8),
          r: pick$V(options.borderRadius, 3),
          zIndex: 2
        }).add(this.labelGroup);
        if (!chart.styledMode) {
          crossLabel.attr({
            fill: options.backgroundColor || point && point.series && point.series.color || // #14888
            palette.neutralColor60,
            stroke: options.borderColor || "",
            "stroke-width": options.borderWidth || 0
          }).css(extend$Z({
            color: palette.backgroundColor,
            fontWeight: "normal",
            fontSize: "11px",
            textAlign: "center"
          }, options.style || {}));
        }
      }
      if (horiz) {
        posx = snap ? (point.plotX || 0) + left : e2.chartX;
        posy = top + (opposite ? 0 : this.height);
      } else {
        posx = opposite ? this.width + left : 0;
        posy = snap ? (point.plotY || 0) + top : e2.chartY;
      }
      if (!formatOption && !options.formatter) {
        if (this.dateTime) {
          formatFormat = "%b %d, %Y";
        }
        formatOption = "{value" + (formatFormat ? ":" + formatFormat : "") + "}";
      }
      var value = snap ? this.isXAxis ? point.x : point.y : this.toValue(horiz ? e2.chartX : e2.chartY);
      var isInside = point ? point.series.isPointInside(point) : isNumber$n(value) && value > min && value < max;
      var text = "";
      if (formatOption) {
        text = format$7(formatOption, { value }, chart);
      } else if (options.formatter && isNumber$n(value)) {
        text = options.formatter.call(this, value);
      }
      crossLabel.attr({
        text,
        x: posx,
        y: posy,
        visibility: isInside ? "visible" : "hidden"
      });
      crossBox = crossLabel.getBBox();
      if (isNumber$n(crossLabel.y)) {
        if (horiz) {
          if (tickInside && !opposite || !tickInside && opposite) {
            posy = crossLabel.y - crossBox.height;
          }
        } else {
          posy = crossLabel.y - crossBox.height / 2;
        }
      }
      if (horiz) {
        limit = {
          left: left - crossBox.x,
          right: left + this.width - crossBox.x
        };
      } else {
        limit = {
          left: this.labelAlign === "left" ? left : 0,
          right: this.labelAlign === "right" ? left + this.width : chart.chartWidth
        };
      }
      if (crossLabel.translateX < limit.left) {
        offset2 = limit.left - crossLabel.translateX;
      }
      if (crossLabel.translateX + crossBox.width >= limit.right) {
        offset2 = -(crossLabel.translateX + crossBox.width - limit.right);
      }
      crossLabel.attr({
        x: posx + offset2,
        y: posy,
        // First set x and y, then anchorX and anchorY, when box is actually
        // calculated, #5702
        anchorX: horiz ? posx : this.opposite ? 0 : chart.chartWidth,
        anchorY: horiz ? this.opposite ? chart.chartHeight : 0 : posy + crossBox.height / 2
      });
    });
    Series$e.prototype.init = function() {
      seriesInit.apply(this, arguments);
      this.initCompare(this.options.compare);
    };
    Series$e.prototype.setCompare = function(compare) {
      this.initCompare(compare);
      this.userOptions.compare = compare;
    };
    Series$e.prototype.initCompare = function(compare) {
      this.modifyValue = compare === "value" || compare === "percent" ? function(value, point) {
        var compareValue = this.compareValue;
        if (typeof value !== "undefined" && typeof compareValue !== "undefined") {
          if (compare === "value") {
            value -= compareValue;
          } else {
            value = 100 * (value / compareValue) - (this.options.compareBase === 100 ? 0 : 100);
          }
          if (point) {
            point.change = value;
          }
          return value;
        }
        return 0;
      } : null;
      if (this.chart.hasRendered) {
        this.isDirty = true;
      }
    };
    Series$e.prototype.forceCropping = function() {
      var chart = this.chart, options = this.options, dataGroupingOptions = options.dataGrouping, groupingEnabled = this.allowDG !== false && dataGroupingOptions && pick$V(dataGroupingOptions.enabled, chart.options.isStock);
      return groupingEnabled;
    };
    Series$e.prototype.processData = function(force) {
      var series = this, i, keyIndex = -1, processedXData, processedYData, compareStart = series.options.compareStart === true ? 0 : 1, length, compareValue;
      seriesProcessData.apply(this, arguments);
      if (series.xAxis && series.processedYData) {
        processedXData = series.processedXData;
        processedYData = series.processedYData;
        length = processedYData.length;
        if (series.pointArrayMap) {
          keyIndex = series.pointArrayMap.indexOf(series.options.pointValKey || series.pointValKey || "y");
        }
        for (i = 0; i < length - compareStart; i++) {
          compareValue = processedYData[i] && keyIndex > -1 ? processedYData[i][keyIndex] : processedYData[i];
          if (isNumber$n(compareValue) && processedXData[i + compareStart] >= series.xAxis.min && compareValue !== 0) {
            series.compareValue = compareValue;
            break;
          }
        }
      }
      return;
    };
    addEvent$D(Series$e, "afterGetExtremes", function(e2) {
      var dataExtremes = e2.dataExtremes;
      if (this.modifyValue && dataExtremes) {
        var extremes = [
          this.modifyValue(dataExtremes.dataMin),
          this.modifyValue(dataExtremes.dataMax)
        ];
        dataExtremes.dataMin = arrayMin$4(extremes);
        dataExtremes.dataMax = arrayMax$4(extremes);
      }
    });
    Axis.prototype.setCompare = function(compare, redraw) {
      if (!this.isXAxis) {
        this.series.forEach(function(series) {
          series.setCompare(compare);
        });
        if (pick$V(redraw, true)) {
          this.chart.redraw();
        }
      }
    };
    Point$2.prototype.tooltipFormatter = function(pointFormat) {
      var point = this;
      var numberFormatter = point.series.chart.numberFormatter;
      pointFormat = pointFormat.replace("{point.change}", (point.change > 0 ? "+" : "") + numberFormatter(point.change, pick$V(point.series.tooltipOptions.changeDecimals, 2)));
      return pointTooltipFormatter.apply(this, [pointFormat]);
    };
    addEvent$D(Series$e, "render", function() {
      var chart = this.chart, clipHeight;
      if (!(chart.is3d && chart.is3d()) && !chart.polar && this.xAxis && !this.xAxis.isRadial && // Gauge, #6192
      this.options.clip !== false) {
        clipHeight = this.yAxis.len;
        if (this.xAxis.axisLine) {
          var dist = chart.plotTop + chart.plotHeight - this.yAxis.pos - this.yAxis.len, lineHeightCorrection = Math.floor(this.xAxis.axisLine.strokeWidth() / 2);
          if (dist >= 0) {
            clipHeight -= Math.max(lineHeightCorrection - dist, 0);
          }
        }
        if (!chart.hasLoaded || !this.clipBox && this.isDirty && !this.isDirtyData) {
          this.clipBox = this.clipBox || merge$P(chart.clipBox);
          this.clipBox.width = this.xAxis.len;
          this.clipBox.height = clipHeight;
        }
        if (chart.hasRendered) {
          var animation = animObject$4(this.options.animation);
          var sharedClipKey = this.getSharedClipKey(animation);
          var clipRect = chart.sharedClips[sharedClipKey];
          if (clipRect) {
            clipRect.animate({
              width: this.xAxis.len,
              height: clipHeight
            });
            var markerClipRect = chart.sharedClips[sharedClipKey + "m"];
            if (markerClipRect) {
              markerClipRect.animate({
                width: this.xAxis.len
              });
            }
          }
        }
      }
    });
    addEvent$D(Chart$1, "update", function(e2) {
      var options = e2.options;
      if ("scrollbar" in options && this.navigator) {
        merge$P(true, this.options.scrollbar, options.scrollbar);
        this.navigator.update({}, false);
        delete options.scrollbar;
      }
    });
    const StockChart$1 = StockChart;
    /**
     * @license Highstock JS v9.2.2 (2021-08-24)
     * @module highcharts/modules/stock
     * @requires highcharts
     *
     * Highcharts Stock as a plugin for Highcharts
     *
     * (c) 2010-2021 Torstein Honsi
     *
     * License: www.highcharts.com/license
     */
    var G$5 = H;
    G$5.Scrollbar = Scrollbar;
    G$5.StockChart = G$5.stockChart = StockChart$1.stockChart;
    Scrollbar.compose(G$5.Axis);
    OrdinalAxis$1.compose(G$5.Axis, G$5.Series, G$5.Chart);
    /**
     * @license Highstock JS v9.2.2 (2021-08-24)
     * @module highcharts/highstock
     *
     * (c) 2009-2021 Torstein Honsi
     *
     * License: www.highcharts.com/license
     */
    G$7.product = "Highstock";
    var doc$f = H.doc, win$6 = H.win;
    var merge$O = Utilities.merge;
    function addClass$1(el, className) {
      if (el.classList) {
        el.classList.add(className);
      } else if (el.className.indexOf(className) < 0) {
        el.className += className;
      }
    }
    function escapeStringForHTML$1(str) {
      return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
    }
    function getElement$2(id) {
      return doc$f.getElementById(id);
    }
    function getFakeMouseEvent$2(type) {
      if (typeof win$6.MouseEvent === "function") {
        return new win$6.MouseEvent(type);
      }
      if (doc$f.createEvent) {
        var evt = doc$f.createEvent("MouseEvent");
        if (evt.initMouseEvent) {
          evt.initMouseEvent(
            type,
            true,
            // Bubble
            true,
            // Cancel
            win$6,
            // View
            type === "click" ? 1 : 0,
            // Detail
            // Coords
            0,
            0,
            0,
            0,
            // Pressed keys
            false,
            false,
            false,
            false,
            0,
            // button
            null
            // related target
          );
          return evt;
        }
      }
      return { type };
    }
    function getHeadingTagNameForElement$1(element) {
      var getIncreasedHeadingLevel = function(tagName) {
        var headingLevel = parseInt(tagName.slice(1), 10);
        var newLevel = Math.min(6, headingLevel + 1);
        return "h" + newLevel;
      };
      var isHeading = function(tagName) {
        return /H[1-6]/.test(tagName);
      };
      var getPreviousSiblingsHeading = function(el) {
        var sibling = el;
        while (sibling = sibling.previousSibling) {
          var tagName = sibling.tagName || "";
          if (isHeading(tagName)) {
            return tagName;
          }
        }
        return "";
      };
      var getHeadingRecursive = function(el) {
        var prevSiblingsHeading = getPreviousSiblingsHeading(el);
        if (prevSiblingsHeading) {
          return getIncreasedHeadingLevel(prevSiblingsHeading);
        }
        var parent = el.parentElement;
        if (!parent) {
          return "p";
        }
        var parentTagName = parent.tagName;
        if (isHeading(parentTagName)) {
          return getIncreasedHeadingLevel(parentTagName);
        }
        return getHeadingRecursive(parent);
      };
      return getHeadingRecursive(element);
    }
    function removeElement$5(element) {
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
    }
    function reverseChildNodes$1(node) {
      var i = node.childNodes.length;
      while (i--) {
        node.appendChild(node.childNodes[i]);
      }
    }
    function setElAttrs$4(el, attrs) {
      Object.keys(attrs).forEach(function(attr2) {
        var val = attrs[attr2];
        if (val === null) {
          el.removeAttribute(attr2);
        } else {
          el.setAttribute(attr2, val);
        }
      });
    }
    function stripHTMLTagsFromString$2(str) {
      return typeof str === "string" ? str.replace(/<\/?[^>]+(>|$)/g, "") : str;
    }
    function visuallyHideElement$2(element) {
      var hiddenStyle = {
        position: "absolute",
        width: "1px",
        height: "1px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        clip: "rect(1px, 1px, 1px, 1px)",
        marginTop: "-3px",
        "-ms-filter": "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)",
        filter: "alpha(opacity=1)",
        opacity: "0.01"
      };
      merge$O(true, element.style, hiddenStyle);
    }
    var HTMLUtilities = {
      addClass: addClass$1,
      escapeStringForHTML: escapeStringForHTML$1,
      getElement: getElement$2,
      getFakeMouseEvent: getFakeMouseEvent$2,
      getHeadingTagNameForElement: getHeadingTagNameForElement$1,
      removeElement: removeElement$5,
      reverseChildNodes: reverseChildNodes$1,
      setElAttrs: setElAttrs$4,
      stripHTMLTagsFromString: stripHTMLTagsFromString$2,
      visuallyHideElement: visuallyHideElement$2
    };
    var stripHTMLTags$3 = HTMLUtilities.stripHTMLTagsFromString;
    var doc$e = H.doc;
    var defined$p = Utilities.defined, find$9 = Utilities.find, fireEvent$i = Utilities.fireEvent;
    function getChartTitle$5(chart) {
      return stripHTMLTags$3(chart.options.title.text || chart.langFormat("accessibility.defaultChartTitle", { chart }));
    }
    function getAxisDescription$2(axis) {
      return axis && (axis.userOptions && axis.userOptions.accessibility && axis.userOptions.accessibility.description || axis.axisTitle && axis.axisTitle.textStr || axis.options.id || axis.categories && "categories" || axis.dateTime && "Time" || "values");
    }
    function getAxisRangeDescription$2(axis) {
      var axisOptions = axis.options || {};
      if (axisOptions.accessibility && typeof axisOptions.accessibility.rangeDescription !== "undefined") {
        return axisOptions.accessibility.rangeDescription;
      }
      if (axis.categories) {
        return getCategoryAxisRangeDesc(axis);
      }
      if (axis.dateTime && (axis.min === 0 || axis.dataMin === 0)) {
        return getAxisTimeLengthDesc(axis);
      }
      return getAxisFromToDescription(axis);
    }
    function getCategoryAxisRangeDesc(axis) {
      var chart = axis.chart;
      if (axis.dataMax && axis.dataMin) {
        return chart.langFormat("accessibility.axis.rangeCategories", {
          chart,
          axis,
          numCategories: axis.dataMax - axis.dataMin + 1
        });
      }
      return "";
    }
    function getAxisTimeLengthDesc(axis) {
      var chart = axis.chart;
      var range = {};
      var rangeUnit = "Seconds";
      range.Seconds = ((axis.max || 0) - (axis.min || 0)) / 1e3;
      range.Minutes = range.Seconds / 60;
      range.Hours = range.Minutes / 60;
      range.Days = range.Hours / 24;
      ["Minutes", "Hours", "Days"].forEach(function(unit) {
        if (range[unit] > 2) {
          rangeUnit = unit;
        }
      });
      var rangeValue = range[rangeUnit].toFixed(
        rangeUnit !== "Seconds" && rangeUnit !== "Minutes" ? 1 : 0
        // Use decimals for days/hours
      );
      return chart.langFormat("accessibility.axis.timeRange" + rangeUnit, {
        chart,
        axis,
        range: rangeValue.replace(".0", "")
      });
    }
    function getAxisFromToDescription(axis) {
      var chart = axis.chart;
      var dateRangeFormat = chart.options && chart.options.accessibility && chart.options.accessibility.screenReaderSection.axisRangeDateFormat || "";
      var format2 = function(axisKey) {
        return axis.dateTime ? chart.time.dateFormat(dateRangeFormat, axis[axisKey]) : axis[axisKey];
      };
      return chart.langFormat("accessibility.axis.rangeFromTo", {
        chart,
        axis,
        rangeFrom: format2("min"),
        rangeTo: format2("max")
      });
    }
    function getSeriesFirstPointElement$1(series) {
      if (series.points && series.points.length) {
        var firstPointWithGraphic = find$9(series.points, function(p) {
          return !!p.graphic;
        });
        return firstPointWithGraphic && firstPointWithGraphic.graphic && firstPointWithGraphic.graphic.element;
      }
    }
    function getSeriesA11yElement$1(series) {
      var firstPointEl = getSeriesFirstPointElement$1(series);
      return firstPointEl && firstPointEl.parentNode || series.graph && series.graph.element || series.group && series.group.element;
    }
    function unhideChartElementFromAT$7(chart, element) {
      element.setAttribute("aria-hidden", false);
      if (element === chart.renderTo || !element.parentNode || element.parentNode === doc$e.body) {
        return;
      }
      Array.prototype.forEach.call(element.parentNode.childNodes, function(node) {
        if (!node.hasAttribute("aria-hidden")) {
          node.setAttribute("aria-hidden", true);
        }
      });
      unhideChartElementFromAT$7(chart, element.parentNode);
    }
    function hideSeriesFromAT$1(series) {
      var seriesEl = getSeriesA11yElement$1(series);
      if (seriesEl) {
        seriesEl.setAttribute("aria-hidden", true);
      }
    }
    function getSeriesFromName$1(chart, name) {
      if (!name) {
        return chart.series;
      }
      return (chart.series || []).filter(function(s) {
        return s.name === name;
      });
    }
    function getPointFromXY$1(series, x, y) {
      var i = series.length, res;
      while (i--) {
        res = find$9(series[i].points || [], function(p) {
          return p.x === x && p.y === y;
        });
        if (res) {
          return res;
        }
      }
    }
    function getRelativePointAxisPosition(axis, point) {
      if (!defined$p(axis.dataMin) || !defined$p(axis.dataMax)) {
        return 0;
      }
      var axisStart = axis.toPixels(axis.dataMin);
      var axisEnd = axis.toPixels(axis.dataMax);
      var positionProp = axis.coll === "xAxis" ? "x" : "y";
      var pointPos = axis.toPixels(point[positionProp] || 0);
      return (pointPos - axisStart) / (axisEnd - axisStart);
    }
    function scrollToPoint$1(point) {
      var xAxis = point.series.xAxis;
      var yAxis = point.series.yAxis;
      var axis = xAxis && xAxis.scrollbar ? xAxis : yAxis;
      var scrollbar = axis && axis.scrollbar;
      if (scrollbar && defined$p(scrollbar.to) && defined$p(scrollbar.from)) {
        var range = scrollbar.to - scrollbar.from;
        var pos = getRelativePointAxisPosition(axis, point);
        scrollbar.updatePosition(pos - range / 2, pos + range / 2);
        fireEvent$i(scrollbar, "changed", {
          from: scrollbar.from,
          to: scrollbar.to,
          trigger: "scrollbar",
          DOMEvent: null
        });
      }
    }
    var ChartUtilities = {
      getChartTitle: getChartTitle$5,
      getAxisDescription: getAxisDescription$2,
      getAxisRangeDescription: getAxisRangeDescription$2,
      getPointFromXY: getPointFromXY$1,
      getSeriesFirstPointElement: getSeriesFirstPointElement$1,
      getSeriesFromName: getSeriesFromName$1,
      getSeriesA11yElement: getSeriesA11yElement$1,
      unhideChartElementFromAT: unhideChartElementFromAT$7,
      hideSeriesFromAT: hideSeriesFromAT$1,
      scrollToPoint: scrollToPoint$1
    };
    var find$8 = Utilities.find;
    function KeyboardNavigationHandler(chart, options) {
      this.chart = chart;
      this.keyCodeMap = options.keyCodeMap || [];
      this.validate = options.validate;
      this.init = options.init;
      this.terminate = options.terminate;
      this.response = {
        success: 1,
        prev: 2,
        next: 3,
        noHandler: 4,
        fail: 5
        // Handler failed
      };
    }
    KeyboardNavigationHandler.prototype = {
      /**
       * Find handler function(s) for key code in the keyCodeMap and run it.
       *
       * @function KeyboardNavigationHandler#run
       * @param {global.KeyboardEvent} e
       * @return {number} Returns a response code indicating whether the run was
       *      a success/fail/unhandled, or if we should move to next/prev module.
       */
      run: function(e2) {
        var keyCode = e2.which || e2.keyCode;
        var response = this.response.noHandler;
        var handlerCodeSet = find$8(this.keyCodeMap, function(codeSet) {
          return codeSet[0].indexOf(keyCode) > -1;
        });
        if (handlerCodeSet) {
          response = handlerCodeSet[1].call(this, keyCode, e2);
        } else if (keyCode === 9) {
          response = this.response[e2.shiftKey ? "prev" : "next"];
        }
        return response;
      }
    };
    var doc$d = H.doc;
    var removeElement$4 = HTMLUtilities.removeElement;
    var extend$Y = Utilities.extend;
    var DOMElementProvider = function() {
      this.elements = [];
    };
    extend$Y(DOMElementProvider.prototype, {
      /**
       * Create an element and keep track of it for later removal.
       * Same args as document.createElement
       * @private
       */
      createElement: function() {
        var el = doc$d.createElement.apply(doc$d, arguments);
        this.elements.push(el);
        return el;
      },
      /**
       * Destroy all created elements, removing them from the DOM.
       * @private
       */
      destroyCreatedElements: function() {
        this.elements.forEach(function(element) {
          removeElement$4(element);
        });
        this.elements = [];
      }
    });
    var addEvent$C = Utilities.addEvent, extend$X = Utilities.extend;
    var EventProvider = function() {
      this.eventRemovers = [];
    };
    extend$X(EventProvider.prototype, {
      /**
       * Add an event to an element and keep track of it for later removal.
       * Same args as Highcharts.addEvent.
       * @private
       * @return {Function}
       */
      addEvent: function() {
        var remover = addEvent$C.apply(H, arguments);
        this.eventRemovers.push(remover);
        return remover;
      },
      /**
       * Remove all added events.
       * @private
       * @return {void}
       */
      removeAddedEvents: function() {
        this.eventRemovers.forEach(function(remover) {
          remover();
        });
        this.eventRemovers = [];
      }
    });
    var unhideChartElementFromAT$6 = ChartUtilities.unhideChartElementFromAT;
    var doc$c = H.doc, win$5 = H.win;
    var removeElement$3 = HTMLUtilities.removeElement, getFakeMouseEvent$1 = HTMLUtilities.getFakeMouseEvent;
    var extend$W = Utilities.extend, fireEvent$h = Utilities.fireEvent, merge$N = Utilities.merge;
    var functionsToOverrideByDerivedClasses = {
      /**
       * Called on component initialization.
       */
      init: function() {
      },
      /**
       * Get keyboard navigation handler for this component.
       * @return {Highcharts.KeyboardNavigationHandler}
       */
      getKeyboardNavigation: function() {
      },
      /**
       * Called on updates to the chart, including options changes.
       * Note that this is also called on first render of chart.
       */
      onChartUpdate: function() {
      },
      /**
       * Called on every chart render.
       */
      onChartRender: function() {
      },
      /**
       * Called when accessibility is disabled or chart is destroyed.
       */
      destroy: function() {
      }
    };
    function AccessibilityComponent() {
    }
    AccessibilityComponent.prototype = {
      /**
       * Initialize the class
       * @private
       * @param {Highcharts.Chart} chart
       *        Chart object
       */
      initBase: function(chart) {
        this.chart = chart;
        this.eventProvider = new EventProvider();
        this.domElementProvider = new DOMElementProvider();
        this.keyCodes = {
          left: 37,
          right: 39,
          up: 38,
          down: 40,
          enter: 13,
          space: 32,
          esc: 27,
          tab: 9
        };
      },
      /**
       * Add an event to an element and keep track of it for later removal.
       * See EventProvider for details.
       * @private
       */
      addEvent: function() {
        return this.eventProvider.addEvent.apply(this.eventProvider, arguments);
      },
      /**
       * Create an element and keep track of it for later removal.
       * See DOMElementProvider for details.
       * @private
       */
      createElement: function() {
        return this.domElementProvider.createElement.apply(this.domElementProvider, arguments);
      },
      /**
       * Fire an event on an element that is either wrapped by Highcharts,
       * or a DOM element
       * @private
       * @param {Highcharts.HTMLElement|Highcharts.HTMLDOMElement|
       *  Highcharts.SVGDOMElement|Highcharts.SVGElement} el
       * @param {Event} eventObject
       */
      fireEventOnWrappedOrUnwrappedElement: function(el, eventObject) {
        var type = eventObject.type;
        if (doc$c.createEvent && (el.dispatchEvent || el.fireEvent)) {
          if (el.dispatchEvent) {
            el.dispatchEvent(eventObject);
          } else {
            el.fireEvent(type, eventObject);
          }
        } else {
          fireEvent$h(el, type, eventObject);
        }
      },
      /**
       * Utility function to attempt to fake a click event on an element.
       * @private
       * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} element
       */
      fakeClickEvent: function(element) {
        if (element) {
          var fakeEventObject = getFakeMouseEvent$1("click");
          this.fireEventOnWrappedOrUnwrappedElement(element, fakeEventObject);
        }
      },
      /**
       * Add a new proxy group to the proxy container. Creates the proxy container
       * if it does not exist.
       * @private
       * @param {Highcharts.HTMLAttributes} [attrs]
       * The attributes to set on the new group div.
       * @return {Highcharts.HTMLDOMElement}
       * The new proxy group element.
       */
      addProxyGroup: function(attrs) {
        this.createOrUpdateProxyContainer();
        var groupDiv = this.createElement("div");
        Object.keys(attrs || {}).forEach(function(prop) {
          if (attrs[prop] !== null) {
            groupDiv.setAttribute(prop, attrs[prop]);
          }
        });
        this.chart.a11yProxyContainer.appendChild(groupDiv);
        return groupDiv;
      },
      /**
       * Creates and updates DOM position of proxy container
       * @private
       */
      createOrUpdateProxyContainer: function() {
        var chart = this.chart, rendererSVGEl = chart.renderer.box;
        chart.a11yProxyContainer = chart.a11yProxyContainer || this.createProxyContainerElement();
        if (rendererSVGEl.nextSibling !== chart.a11yProxyContainer) {
          chart.container.insertBefore(chart.a11yProxyContainer, rendererSVGEl.nextSibling);
        }
      },
      /**
       * @private
       * @return {Highcharts.HTMLDOMElement} element
       */
      createProxyContainerElement: function() {
        var pc = doc$c.createElement("div");
        pc.className = "highcharts-a11y-proxy-container";
        return pc;
      },
      /**
       * Create an invisible proxy HTML button in the same position as an SVG
       * element
       * @private
       * @param {Highcharts.SVGElement} svgElement
       * The wrapped svg el to proxy.
       * @param {Highcharts.HTMLDOMElement} parentGroup
       * The proxy group element in the proxy container to add this button to.
       * @param {Highcharts.SVGAttributes} [attributes]
       * Additional attributes to set.
       * @param {Highcharts.SVGElement} [posElement]
       * Element to use for positioning instead of svgElement.
       * @param {Function} [preClickEvent]
       * Function to call before click event fires.
       *
       * @return {Highcharts.HTMLDOMElement} The proxy button.
       */
      createProxyButton: function(svgElement, parentGroup, attributes, posElement, preClickEvent) {
        var svgEl = svgElement.element, proxy = this.createElement("button"), attrs = merge$N({
          "aria-label": svgEl.getAttribute("aria-label")
        }, attributes);
        Object.keys(attrs).forEach(function(prop) {
          if (attrs[prop] !== null) {
            proxy.setAttribute(prop, attrs[prop]);
          }
        });
        proxy.className = "highcharts-a11y-proxy-button";
        if (svgElement.hasClass("highcharts-no-tooltip")) {
          proxy.className += " highcharts-no-tooltip";
        }
        if (preClickEvent) {
          this.addEvent(proxy, "click", preClickEvent);
        }
        this.setProxyButtonStyle(proxy);
        this.updateProxyButtonPosition(proxy, posElement || svgElement);
        this.proxyMouseEventsForButton(svgEl, proxy);
        parentGroup.appendChild(proxy);
        if (!attrs["aria-hidden"]) {
          unhideChartElementFromAT$6(this.chart, proxy);
        }
        return proxy;
      },
      /**
       * Get the position relative to chart container for a wrapped SVG element.
       * @private
       * @param {Highcharts.SVGElement} element
       * The element to calculate position for.
       * @return {Highcharts.BBoxObject}
       * Object with x and y props for the position.
       */
      getElementPosition: function(element) {
        var el = element.element, div = this.chart.renderTo;
        if (div && el && el.getBoundingClientRect) {
          var rectEl = el.getBoundingClientRect(), rectDiv = div.getBoundingClientRect();
          return {
            x: rectEl.left - rectDiv.left,
            y: rectEl.top - rectDiv.top,
            width: rectEl.right - rectEl.left,
            height: rectEl.bottom - rectEl.top
          };
        }
        return { x: 0, y: 0, width: 1, height: 1 };
      },
      /**
       * @private
       * @param {Highcharts.HTMLElement} button The proxy element.
       */
      setProxyButtonStyle: function(button2) {
        merge$N(true, button2.style, {
          borderWidth: "0",
          backgroundColor: "transparent",
          cursor: "pointer",
          outline: "none",
          opacity: "0.001",
          filter: "alpha(opacity=1)",
          zIndex: "999",
          overflow: "hidden",
          padding: "0",
          margin: "0",
          display: "block",
          position: "absolute"
        });
        button2.style["-ms-filter"] = "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)";
      },
      /**
       * @private
       * @param {Highcharts.HTMLElement} proxy The proxy to update position of.
       * @param {Highcharts.SVGElement} posElement The element to overlay and take position from.
       */
      updateProxyButtonPosition: function(proxy, posElement) {
        var bBox = this.getElementPosition(posElement);
        merge$N(true, proxy.style, {
          width: (bBox.width || 1) + "px",
          height: (bBox.height || 1) + "px",
          left: (Math.round(bBox.x) || 0) + "px",
          top: (Math.round(bBox.y) || 0) + "px"
        });
      },
      /**
       * @private
       * @param {Highcharts.HTMLElement|Highcharts.HTMLDOMElement|
       *  Highcharts.SVGDOMElement|Highcharts.SVGElement} source
       * @param {Highcharts.HTMLElement} button
       */
      proxyMouseEventsForButton: function(source, button2) {
        var component = this;
        [
          "click",
          "touchstart",
          "touchend",
          "touchcancel",
          "touchmove",
          "mouseover",
          "mouseenter",
          "mouseleave",
          "mouseout"
        ].forEach(function(evtType) {
          var isTouchEvent = evtType.indexOf("touch") === 0;
          component.addEvent(button2, evtType, function(e2) {
            var clonedEvent = isTouchEvent ? component.cloneTouchEvent(e2) : component.cloneMouseEvent(e2);
            if (source) {
              component.fireEventOnWrappedOrUnwrappedElement(source, clonedEvent);
            }
            e2.stopPropagation();
            if (evtType !== "touchstart" && evtType !== "touchmove" && evtType !== "touchend") {
              e2.preventDefault();
            }
          }, { passive: false });
        });
      },
      /**
       * Utility function to clone a mouse event for re-dispatching.
       * @private
       * @param {global.MouseEvent} e The event to clone.
       * @return {global.MouseEvent} The cloned event
       */
      cloneMouseEvent: function(e2) {
        if (typeof win$5.MouseEvent === "function") {
          return new win$5.MouseEvent(e2.type, e2);
        }
        if (doc$c.createEvent) {
          var evt = doc$c.createEvent("MouseEvent");
          if (evt.initMouseEvent) {
            evt.initMouseEvent(
              e2.type,
              e2.bubbles,
              // #10561, #12161
              e2.cancelable,
              e2.view || win$5,
              e2.detail,
              e2.screenX,
              e2.screenY,
              e2.clientX,
              e2.clientY,
              e2.ctrlKey,
              e2.altKey,
              e2.shiftKey,
              e2.metaKey,
              e2.button,
              e2.relatedTarget
            );
            return evt;
          }
        }
        return getFakeMouseEvent$1(e2.type);
      },
      /**
       * Utility function to clone a touch event for re-dispatching.
       * @private
       * @param {global.TouchEvent} e The event to clone.
       * @return {global.TouchEvent} The cloned event
       */
      cloneTouchEvent: function(e2) {
        var touchListToTouchArray = function(l) {
          var touchArray = [];
          for (var i = 0; i < l.length; ++i) {
            var item2 = l.item(i);
            if (item2) {
              touchArray.push(item2);
            }
          }
          return touchArray;
        };
        if (typeof win$5.TouchEvent === "function") {
          var newEvent = new win$5.TouchEvent(e2.type, {
            touches: touchListToTouchArray(e2.touches),
            targetTouches: touchListToTouchArray(e2.targetTouches),
            changedTouches: touchListToTouchArray(e2.changedTouches),
            ctrlKey: e2.ctrlKey,
            shiftKey: e2.shiftKey,
            altKey: e2.altKey,
            metaKey: e2.metaKey,
            bubbles: e2.bubbles,
            cancelable: e2.cancelable,
            composed: e2.composed,
            detail: e2.detail,
            view: e2.view
          });
          if (e2.defaultPrevented) {
            newEvent.preventDefault();
          }
          return newEvent;
        }
        var fakeEvt = this.cloneMouseEvent(e2);
        fakeEvt.touches = e2.touches;
        fakeEvt.changedTouches = e2.changedTouches;
        fakeEvt.targetTouches = e2.targetTouches;
        return fakeEvt;
      },
      /**
       * Remove traces of the component.
       * @private
       */
      destroyBase: function() {
        removeElement$3(this.chart.a11yProxyContainer);
        this.domElementProvider.destroyCreatedElements();
        this.eventProvider.removeAddedEvents();
      }
    };
    extend$W(AccessibilityComponent.prototype, functionsToOverrideByDerivedClasses);
    var doc$b = H.doc, win$4 = H.win;
    var addEvent$B = Utilities.addEvent, fireEvent$g = Utilities.fireEvent;
    var getElement$1 = HTMLUtilities.getElement;
    addEvent$B(doc$b, "keydown", function(e2) {
      var keycode = e2.which || e2.keyCode;
      var esc = 27;
      if (keycode === esc && H.charts) {
        H.charts.forEach(function(chart) {
          if (chart && chart.dismissPopupContent) {
            chart.dismissPopupContent();
          }
        });
      }
    });
    Chart$1.prototype.dismissPopupContent = function() {
      var chart = this;
      fireEvent$g(this, "dismissPopupContent", {}, function() {
        if (chart.tooltip) {
          chart.tooltip.hide(0);
        }
        chart.hideExportMenu();
      });
    };
    function KeyboardNavigation(chart, components) {
      this.init(chart, components);
    }
    KeyboardNavigation.prototype = {
      /**
       * Initialize the class
       * @private
       * @param {Highcharts.Chart} chart
       *        Chart object
       * @param {object} components
       *        Map of component names to AccessibilityComponent objects.
       */
      init: function(chart, components) {
        var _this = this;
        var ep = this.eventProvider = new EventProvider();
        this.chart = chart;
        this.components = components;
        this.modules = [];
        this.currentModuleIx = 0;
        this.update();
        ep.addEvent(this.tabindexContainer, "keydown", function(e2) {
          return _this.onKeydown(e2);
        });
        ep.addEvent(this.tabindexContainer, "focus", function(e2) {
          return _this.onFocus(e2);
        });
        ["mouseup", "touchend"].forEach(function(eventName) {
          return ep.addEvent(doc$b, eventName, function() {
            return _this.onMouseUp();
          });
        });
        ["mousedown", "touchstart"].forEach(function(eventName) {
          return ep.addEvent(chart.renderTo, eventName, function() {
            _this.isClickingChart = true;
          });
        });
        ep.addEvent(chart.renderTo, "mouseover", function() {
          _this.pointerIsOverChart = true;
        });
        ep.addEvent(chart.renderTo, "mouseout", function() {
          _this.pointerIsOverChart = false;
        });
        if (this.modules.length) {
          this.modules[0].init(1);
        }
      },
      /**
       * Update the modules for the keyboard navigation.
       * @param {Array<string>} [order]
       *        Array specifying the tab order of the components.
       */
      update: function(order) {
        var a11yOptions = this.chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, components = this.components;
        this.updateContainerTabindex();
        if (keyboardOptions && keyboardOptions.enabled && order && order.length) {
          this.modules = order.reduce(function(modules, componentName) {
            var navModules = components[componentName].getKeyboardNavigation();
            return modules.concat(navModules);
          }, []);
          this.updateExitAnchor();
        } else {
          this.modules = [];
          this.currentModuleIx = 0;
          this.removeExitAnchor();
        }
      },
      /**
       * Function to run on container focus
       * @private
       * @param {global.FocusEvent} e Browser focus event.
       */
      onFocus: function(e2) {
        var chart = this.chart;
        var focusComesFromChart = e2.relatedTarget && chart.container.contains(e2.relatedTarget);
        if (!this.exiting && !this.tabbingInBackwards && !this.isClickingChart && !focusComesFromChart && this.modules[0]) {
          this.modules[0].init(1);
        }
        this.exiting = false;
      },
      /**
       * Reset chart navigation state if we click outside the chart and it's
       * not already reset.
       * @private
       */
      onMouseUp: function() {
        delete this.isClickingChart;
        if (!this.keyboardReset && !this.pointerIsOverChart) {
          var chart = this.chart, curMod = this.modules && this.modules[this.currentModuleIx || 0];
          if (curMod && curMod.terminate) {
            curMod.terminate();
          }
          if (chart.focusElement) {
            chart.focusElement.removeFocusBorder();
          }
          this.currentModuleIx = 0;
          this.keyboardReset = true;
        }
      },
      /**
       * Function to run on keydown
       * @private
       * @param {global.KeyboardEvent} ev Browser keydown event.
       */
      onKeydown: function(ev) {
        var e2 = ev || win$4.event, preventDefault, curNavModule = this.modules && this.modules.length && this.modules[this.currentModuleIx];
        this.keyboardReset = false;
        this.exiting = false;
        if (curNavModule) {
          var response = curNavModule.run(e2);
          if (response === curNavModule.response.success) {
            preventDefault = true;
          } else if (response === curNavModule.response.prev) {
            preventDefault = this.prev();
          } else if (response === curNavModule.response.next) {
            preventDefault = this.next();
          }
          if (preventDefault) {
            e2.preventDefault();
            e2.stopPropagation();
          }
        }
      },
      /**
       * Go to previous module.
       * @private
       */
      prev: function() {
        return this.move(-1);
      },
      /**
       * Go to next module.
       * @private
       */
      next: function() {
        return this.move(1);
      },
      /**
       * Move to prev/next module.
       * @private
       * @param {number} direction
       * Direction to move. +1 for next, -1 for prev.
       * @return {boolean}
       * True if there was a valid module in direction.
       */
      move: function(direction) {
        var curModule = this.modules && this.modules[this.currentModuleIx];
        if (curModule && curModule.terminate) {
          curModule.terminate(direction);
        }
        if (this.chart.focusElement) {
          this.chart.focusElement.removeFocusBorder();
        }
        this.currentModuleIx += direction;
        var newModule = this.modules && this.modules[this.currentModuleIx];
        if (newModule) {
          if (newModule.validate && !newModule.validate()) {
            return this.move(direction);
          }
          if (newModule.init) {
            newModule.init(direction);
            return true;
          }
        }
        this.currentModuleIx = 0;
        this.exiting = true;
        if (direction > 0) {
          this.exitAnchor.focus();
        } else {
          this.tabindexContainer.focus();
        }
        return false;
      },
      /**
       * We use an exit anchor to move focus out of chart whenever we want, by
       * setting focus to this div and not preventing the default tab action. We
       * also use this when users come back into the chart by tabbing back, in
       * order to navigate from the end of the chart.
       * @private
       */
      updateExitAnchor: function() {
        var endMarkerId = "highcharts-end-of-chart-marker-" + this.chart.index, endMarker = getElement$1(endMarkerId);
        this.removeExitAnchor();
        if (endMarker) {
          this.makeElementAnExitAnchor(endMarker);
          this.exitAnchor = endMarker;
        } else {
          this.createExitAnchor();
        }
      },
      /**
       * Chart container should have tabindex if navigation is enabled.
       * @private
       */
      updateContainerTabindex: function() {
        var a11yOptions = this.chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, shouldHaveTabindex = !(keyboardOptions && keyboardOptions.enabled === false), chart = this.chart, container = chart.container;
        var tabindexContainer;
        if (chart.renderTo.hasAttribute("tabindex")) {
          container.removeAttribute("tabindex");
          tabindexContainer = chart.renderTo;
        } else {
          tabindexContainer = container;
        }
        this.tabindexContainer = tabindexContainer;
        var curTabindex = tabindexContainer.getAttribute("tabindex");
        if (shouldHaveTabindex && !curTabindex) {
          tabindexContainer.setAttribute("tabindex", "0");
        } else if (!shouldHaveTabindex) {
          chart.container.removeAttribute("tabindex");
        }
      },
      /**
       * @private
       */
      makeElementAnExitAnchor: function(el) {
        var chartTabindex = this.tabindexContainer.getAttribute("tabindex") || 0;
        el.setAttribute("class", "highcharts-exit-anchor");
        el.setAttribute("tabindex", chartTabindex);
        el.setAttribute("aria-hidden", false);
        this.addExitAnchorEventsToEl(el);
      },
      /**
       * Add new exit anchor to the chart.
       *
       * @private
       */
      createExitAnchor: function() {
        var chart = this.chart, exitAnchor = this.exitAnchor = doc$b.createElement("div");
        chart.renderTo.appendChild(exitAnchor);
        this.makeElementAnExitAnchor(exitAnchor);
      },
      /**
       * @private
       */
      removeExitAnchor: function() {
        if (this.exitAnchor && this.exitAnchor.parentNode) {
          this.exitAnchor.parentNode.removeChild(this.exitAnchor);
          delete this.exitAnchor;
        }
      },
      /**
       * @private
       */
      addExitAnchorEventsToEl: function(element) {
        var chart = this.chart, keyboardNavigation = this;
        this.eventProvider.addEvent(element, "focus", function(ev) {
          var e2 = ev || win$4.event, curModule, focusComesFromChart = e2.relatedTarget && chart.container.contains(e2.relatedTarget), comingInBackwards = !(focusComesFromChart || keyboardNavigation.exiting);
          if (comingInBackwards) {
            keyboardNavigation.tabbingInBackwards = true;
            keyboardNavigation.tabindexContainer.focus();
            delete keyboardNavigation.tabbingInBackwards;
            e2.preventDefault();
            if (keyboardNavigation.modules && keyboardNavigation.modules.length) {
              keyboardNavigation.currentModuleIx = keyboardNavigation.modules.length - 1;
              curModule = keyboardNavigation.modules[keyboardNavigation.currentModuleIx];
              if (curModule && curModule.validate && !curModule.validate()) {
                keyboardNavigation.prev();
              } else if (curModule) {
                curModule.init(-1);
              }
            }
          } else {
            keyboardNavigation.exiting = false;
          }
        });
      },
      /**
       * Remove all traces of keyboard navigation.
       * @private
       */
      destroy: function() {
        this.removeExitAnchor();
        this.eventProvider.removeAddedEvents();
        this.chart.container.removeAttribute("tabindex");
      }
    };
    var animObject$3 = animationExports.animObject;
    var addEvent$A = Utilities.addEvent, extend$V = Utilities.extend, find$7 = Utilities.find, fireEvent$f = Utilities.fireEvent, isNumber$m = Utilities.isNumber, pick$U = Utilities.pick, syncTimeout$1 = Utilities.syncTimeout;
    var removeElement$2 = HTMLUtilities.removeElement, stripHTMLTags$2 = HTMLUtilities.stripHTMLTagsFromString;
    var getChartTitle$4 = ChartUtilities.getChartTitle;
    function scrollLegendToItem(legend, itemIx) {
      var itemPage = legend.allItems[itemIx].pageIx, curPage = legend.currentPage;
      if (typeof itemPage !== "undefined" && itemPage + 1 !== curPage) {
        legend.scroll(1 + itemPage - curPage);
      }
    }
    function shouldDoLegendA11y(chart) {
      var items = chart.legend && chart.legend.allItems, legendA11yOptions = chart.options.legend.accessibility || {};
      return !!(items && items.length && !(chart.colorAxis && chart.colorAxis.length) && legendA11yOptions.enabled !== false);
    }
    Chart$1.prototype.highlightLegendItem = function(ix) {
      var items = this.legend.allItems, oldIx = this.accessibility && this.accessibility.components.legend.highlightedLegendItemIx;
      if (items[ix]) {
        if (isNumber$m(oldIx) && items[oldIx]) {
          fireEvent$f(items[oldIx].legendGroup.element, "mouseout");
        }
        scrollLegendToItem(this.legend, ix);
        this.setFocusToElement(items[ix].legendItem, items[ix].a11yProxyElement);
        fireEvent$f(items[ix].legendGroup.element, "mouseover");
        return true;
      }
      return false;
    };
    addEvent$A(Legend, "afterColorizeItem", function(e2) {
      var chart = this.chart, a11yOptions = chart.options.accessibility, legendItem = e2.item;
      if (a11yOptions.enabled && legendItem && legendItem.a11yProxyElement) {
        legendItem.a11yProxyElement.setAttribute("aria-pressed", e2.visible ? "true" : "false");
      }
    });
    var LegendComponent = function() {
    };
    LegendComponent.prototype = new AccessibilityComponent();
    extend$V(
      LegendComponent.prototype,
      /** @lends Highcharts.LegendComponent */
      {
        /**
         * Init the component
         * @private
         */
        init: function() {
          var component = this;
          this.proxyElementsList = [];
          this.recreateProxies();
          this.addEvent(Legend, "afterScroll", function() {
            if (this.chart === component.chart) {
              component.updateProxiesPositions();
              component.updateLegendItemProxyVisibility();
              this.chart.highlightLegendItem(component.highlightedLegendItemIx);
            }
          });
          this.addEvent(Legend, "afterPositionItem", function(e2) {
            if (this.chart === component.chart && this.chart.renderer) {
              component.updateProxyPositionForItem(e2.item);
            }
          });
          this.addEvent(Legend, "afterRender", function() {
            if (this.chart === component.chart && this.chart.renderer && component.recreateProxies()) {
              syncTimeout$1(function() {
                return component.updateProxiesPositions();
              }, animObject$3(pick$U(this.chart.renderer.globalAnimation, true)).duration);
            }
          });
        },
        /**
         * @private
         */
        updateLegendItemProxyVisibility: function() {
          var legend = this.chart.legend, items = legend.allItems || [], curPage = legend.currentPage || 1, clipHeight = legend.clipHeight || 0;
          items.forEach(function(item2) {
            var itemPage = item2.pageIx || 0, y = item2._legendItemPos ? item2._legendItemPos[1] : 0, h = item2.legendItem ? Math.round(item2.legendItem.getBBox().height) : 0, hide = y + h - legend.pages[itemPage] > clipHeight || itemPage !== curPage - 1;
            if (item2.a11yProxyElement) {
              item2.a11yProxyElement.style.visibility = hide ? "hidden" : "visible";
            }
          });
        },
        /**
         * The legend needs updates on every render, in order to update positioning
         * of the proxy overlays.
         */
        onChartRender: function() {
          if (!shouldDoLegendA11y(this.chart)) {
            this.removeProxies();
          }
        },
        /**
         * @private
         */
        onChartUpdate: function() {
          this.updateLegendTitle();
        },
        /**
         * @private
         */
        updateProxiesPositions: function() {
          for (var _i = 0, _a2 = this.proxyElementsList; _i < _a2.length; _i++) {
            var _b = _a2[_i], element = _b.element, posElement = _b.posElement;
            this.updateProxyButtonPosition(element, posElement);
          }
        },
        /**
         * @private
         */
        updateProxyPositionForItem: function(item2) {
          var proxyRef = find$7(this.proxyElementsList, function(ref) {
            return ref.item === item2;
          });
          if (proxyRef) {
            this.updateProxyButtonPosition(proxyRef.element, proxyRef.posElement);
          }
        },
        /**
         * @private
         */
        recreateProxies: function() {
          this.removeProxies();
          if (shouldDoLegendA11y(this.chart)) {
            this.addLegendProxyGroup();
            this.addLegendListContainer();
            this.proxyLegendItems();
            this.updateLegendItemProxyVisibility();
            return true;
          }
          return false;
        },
        /**
         * @private
         */
        removeProxies: function() {
          removeElement$2(this.legendProxyGroup);
          this.proxyElementsList = [];
        },
        /**
         * @private
         */
        updateLegendTitle: function() {
          var chart = this.chart;
          var legendTitle = stripHTMLTags$2((chart.legend && chart.legend.options.title && chart.legend.options.title.text || "").replace(/<br ?\/?>/g, " "));
          var legendLabel = chart.langFormat("accessibility.legend.legendLabel" + (legendTitle ? "" : "NoTitle"), {
            chart,
            legendTitle,
            chartTitle: getChartTitle$4(chart)
          });
          if (this.legendProxyGroup) {
            this.legendProxyGroup.setAttribute("aria-label", legendLabel);
          }
        },
        /**
         * @private
         */
        addLegendProxyGroup: function() {
          var a11yOptions = this.chart.options.accessibility, groupRole = a11yOptions.landmarkVerbosity === "all" ? "region" : null;
          this.legendProxyGroup = this.addProxyGroup({
            "aria-label": "_placeholder_",
            role: groupRole
          });
        },
        /**
         * @private
         */
        addLegendListContainer: function() {
          if (this.legendProxyGroup) {
            var container = this.legendListContainer = this.createElement("ul");
            container.style.listStyle = "none";
            this.legendProxyGroup.appendChild(container);
          }
        },
        /**
         * @private
         */
        proxyLegendItems: function() {
          var component = this, items = this.chart.legend && this.chart.legend.allItems || [];
          items.forEach(function(item2) {
            if (item2.legendItem && item2.legendItem.element) {
              component.proxyLegendItem(item2);
            }
          });
        },
        /**
         * @private
         * @param {Highcharts.BubbleLegendItem|Point|Highcharts.Series} item
         */
        proxyLegendItem: function(item2) {
          if (!item2.legendItem || !item2.legendGroup || !this.legendListContainer) {
            return;
          }
          var itemLabel = this.chart.langFormat("accessibility.legend.legendItem", {
            chart: this.chart,
            itemName: stripHTMLTags$2(item2.name),
            item: item2
          }), attribs = {
            tabindex: -1,
            "aria-pressed": item2.visible,
            "aria-label": itemLabel
          }, proxyPositioningElement = item2.legendGroup.div ? item2.legendItem : item2.legendGroup;
          var listItem = this.createElement("li");
          this.legendListContainer.appendChild(listItem);
          item2.a11yProxyElement = this.createProxyButton(item2.legendItem, listItem, attribs, proxyPositioningElement);
          this.proxyElementsList.push({
            item: item2,
            element: item2.a11yProxyElement,
            posElement: proxyPositioningElement
          });
        },
        /**
         * Get keyboard navigation handler for this component.
         * @return {Highcharts.KeyboardNavigationHandler}
         */
        getKeyboardNavigation: function() {
          var keys2 = this.keyCodes, component = this, chart = this.chart;
          return new KeyboardNavigationHandler(chart, {
            keyCodeMap: [
              [
                [keys2.left, keys2.right, keys2.up, keys2.down],
                function(keyCode) {
                  return component.onKbdArrowKey(this, keyCode);
                }
              ],
              [
                [keys2.enter, keys2.space],
                function(keyCode) {
                  if (H.isFirefox && keyCode === keys2.space) {
                    return this.response.success;
                  }
                  return component.onKbdClick(this);
                }
              ]
            ],
            validate: function() {
              return component.shouldHaveLegendNavigation();
            },
            init: function(direction) {
              return component.onKbdNavigationInit(direction);
            },
            terminate: function() {
              chart.legend.allItems.forEach(function(item2) {
                return item2.setState("", true);
              });
            }
          });
        },
        /**
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
         * @param {number} keyCode
         * @return {number}
         * Response code
         */
        onKbdArrowKey: function(keyboardNavigationHandler, keyCode) {
          var keys2 = this.keyCodes, response = keyboardNavigationHandler.response, chart = this.chart, a11yOptions = chart.options.accessibility, numItems = chart.legend.allItems.length, direction = keyCode === keys2.left || keyCode === keys2.up ? -1 : 1;
          var res = chart.highlightLegendItem(this.highlightedLegendItemIx + direction);
          if (res) {
            this.highlightedLegendItemIx += direction;
            return response.success;
          }
          if (numItems > 1 && a11yOptions.keyboardNavigation.wrapAround) {
            keyboardNavigationHandler.init(direction);
            return response.success;
          }
          return response[direction > 0 ? "next" : "prev"];
        },
        /**
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
         * @return {number}
         * Response code
         */
        onKbdClick: function(keyboardNavigationHandler) {
          var legendItem = this.chart.legend.allItems[this.highlightedLegendItemIx];
          if (legendItem && legendItem.a11yProxyElement) {
            fireEvent$f(legendItem.a11yProxyElement, "click");
          }
          return keyboardNavigationHandler.response.success;
        },
        /**
         * @private
         * @return {boolean|undefined}
         */
        shouldHaveLegendNavigation: function() {
          var chart = this.chart, legendOptions = chart.options.legend || {}, hasLegend = chart.legend && chart.legend.allItems, hasColorAxis = chart.colorAxis && chart.colorAxis.length, legendA11yOptions = legendOptions.accessibility || {};
          return !!(hasLegend && chart.legend.display && !hasColorAxis && legendA11yOptions.enabled && legendA11yOptions.keyboardNavigation && legendA11yOptions.keyboardNavigation.enabled);
        },
        /**
         * @private
         * @param {number} direction
         */
        onKbdNavigationInit: function(direction) {
          var chart = this.chart, lastIx = chart.legend.allItems.length - 1, ixToHighlight = direction > 0 ? 0 : lastIx;
          chart.highlightLegendItem(ixToHighlight);
          this.highlightedLegendItemIx = ixToHighlight;
        }
      }
    );
    var extend$U = Utilities.extend;
    var getChartTitle$3 = ChartUtilities.getChartTitle, unhideChartElementFromAT$5 = ChartUtilities.unhideChartElementFromAT;
    var removeElement$1 = HTMLUtilities.removeElement, getFakeMouseEvent = HTMLUtilities.getFakeMouseEvent;
    function getExportMenuButtonElement(chart) {
      return chart.exportSVGElements && chart.exportSVGElements[0];
    }
    Chart$1.prototype.showExportMenu = function() {
      var exportButton = getExportMenuButtonElement(this);
      if (exportButton) {
        var el = exportButton.element;
        if (el.onclick) {
          el.onclick(getFakeMouseEvent("click"));
        }
      }
    };
    Chart$1.prototype.hideExportMenu = function() {
      var chart = this, exportList = chart.exportDivElements;
      if (exportList && chart.exportContextMenu) {
        exportList.forEach(function(el) {
          if (el && el.className === "highcharts-menu-item" && el.onmouseout) {
            el.onmouseout(getFakeMouseEvent("mouseout"));
          }
        });
        chart.highlightedExportItemIx = 0;
        chart.exportContextMenu.hideMenu();
        chart.container.focus();
      }
    };
    Chart$1.prototype.highlightExportItem = function(ix) {
      var listItem = this.exportDivElements && this.exportDivElements[ix], curHighlighted = this.exportDivElements && this.exportDivElements[this.highlightedExportItemIx], hasSVGFocusSupport;
      if (listItem && listItem.tagName === "LI" && !(listItem.children && listItem.children.length)) {
        hasSVGFocusSupport = !!(this.renderTo.getElementsByTagName("g")[0] || {}).focus;
        if (listItem.focus && hasSVGFocusSupport) {
          listItem.focus();
        }
        if (curHighlighted && curHighlighted.onmouseout) {
          curHighlighted.onmouseout(getFakeMouseEvent("mouseout"));
        }
        if (listItem.onmouseover) {
          listItem.onmouseover(getFakeMouseEvent("mouseover"));
        }
        this.highlightedExportItemIx = ix;
        return true;
      }
      return false;
    };
    Chart$1.prototype.highlightLastExportItem = function() {
      var chart = this, i;
      if (chart.exportDivElements) {
        i = chart.exportDivElements.length;
        while (i--) {
          if (chart.highlightExportItem(i)) {
            return true;
          }
        }
      }
      return false;
    };
    function exportingShouldHaveA11y(chart) {
      var exportingOpts = chart.options.exporting, exportButton = getExportMenuButtonElement(chart);
      return !!(exportingOpts && exportingOpts.enabled !== false && exportingOpts.accessibility && exportingOpts.accessibility.enabled && exportButton && exportButton.element);
    }
    var MenuComponent = function() {
    };
    MenuComponent.prototype = new AccessibilityComponent();
    extend$U(
      MenuComponent.prototype,
      /** @lends Highcharts.MenuComponent */
      {
        /**
         * Init the component
         */
        init: function() {
          var chart = this.chart, component = this;
          this.addEvent(chart, "exportMenuShown", function() {
            component.onMenuShown();
          });
          this.addEvent(chart, "exportMenuHidden", function() {
            component.onMenuHidden();
          });
        },
        /**
         * @private
         */
        onMenuHidden: function() {
          var menu = this.chart.exportContextMenu;
          if (menu) {
            menu.setAttribute("aria-hidden", "true");
          }
          this.isExportMenuShown = false;
          this.setExportButtonExpandedState("false");
        },
        /**
         * @private
         */
        onMenuShown: function() {
          var chart = this.chart, menu = chart.exportContextMenu;
          if (menu) {
            this.addAccessibleContextMenuAttribs();
            unhideChartElementFromAT$5(chart, menu);
          }
          this.isExportMenuShown = true;
          this.setExportButtonExpandedState("true");
        },
        /**
         * @private
         * @param {string} stateStr
         */
        setExportButtonExpandedState: function(stateStr) {
          var button2 = this.exportButtonProxy;
          if (button2) {
            button2.setAttribute("aria-expanded", stateStr);
          }
        },
        /**
         * Called on each render of the chart. We need to update positioning of the
         * proxy overlay.
         */
        onChartRender: function() {
          var chart = this.chart, a11yOptions = chart.options.accessibility;
          removeElement$1(this.exportProxyGroup);
          if (exportingShouldHaveA11y(chart)) {
            this.exportProxyGroup = this.addProxyGroup(
              // Wrap in a region div if verbosity is high
              a11yOptions.landmarkVerbosity === "all" ? {
                "aria-label": chart.langFormat("accessibility.exporting.exportRegionLabel", { chart, chartTitle: getChartTitle$3(chart) }),
                "role": "region"
              } : {}
            );
            var button2 = getExportMenuButtonElement(this.chart);
            this.exportButtonProxy = this.createProxyButton(button2, this.exportProxyGroup, {
              "aria-label": chart.langFormat("accessibility.exporting.menuButtonLabel", { chart }),
              "aria-expanded": false
            });
          }
        },
        /**
         * @private
         */
        addAccessibleContextMenuAttribs: function() {
          var chart = this.chart, exportList = chart.exportDivElements;
          if (exportList && exportList.length) {
            exportList.forEach(function(item2) {
              if (item2) {
                if (item2.tagName === "LI" && !(item2.children && item2.children.length)) {
                  item2.setAttribute("tabindex", -1);
                } else {
                  item2.setAttribute("aria-hidden", "true");
                }
              }
            });
            var parentDiv = exportList[0] && exportList[0].parentNode;
            if (parentDiv) {
              parentDiv.removeAttribute("aria-hidden");
              parentDiv.setAttribute("aria-label", chart.langFormat("accessibility.exporting.chartMenuLabel", { chart }));
            }
          }
        },
        /**
         * Get keyboard navigation handler for this component.
         * @return {Highcharts.KeyboardNavigationHandler}
         */
        getKeyboardNavigation: function() {
          var keys2 = this.keyCodes, chart = this.chart, component = this;
          return new KeyboardNavigationHandler(chart, {
            keyCodeMap: [
              // Arrow prev handler
              [
                [keys2.left, keys2.up],
                function() {
                  return component.onKbdPrevious(this);
                }
              ],
              // Arrow next handler
              [
                [keys2.right, keys2.down],
                function() {
                  return component.onKbdNext(this);
                }
              ],
              // Click handler
              [
                [keys2.enter, keys2.space],
                function() {
                  return component.onKbdClick(this);
                }
              ]
            ],
            // Only run exporting navigation if exporting support exists and is
            // enabled on chart
            validate: function() {
              return !!chart.exporting && chart.options.exporting.enabled !== false && chart.options.exporting.accessibility.enabled !== false;
            },
            // Focus export menu button
            init: function() {
              var exportBtn = component.exportButtonProxy, exportGroup = chart.exportingGroup;
              if (exportGroup && exportBtn) {
                chart.setFocusToElement(exportGroup, exportBtn);
              }
            },
            // Hide the menu
            terminate: function() {
              chart.hideExportMenu();
            }
          });
        },
        /**
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
         * @return {number}
         * Response code
         */
        onKbdPrevious: function(keyboardNavigationHandler) {
          var chart = this.chart, a11yOptions = chart.options.accessibility, response = keyboardNavigationHandler.response, i = chart.highlightedExportItemIx || 0;
          while (i--) {
            if (chart.highlightExportItem(i)) {
              return response.success;
            }
          }
          if (a11yOptions.keyboardNavigation.wrapAround) {
            chart.highlightLastExportItem();
            return response.success;
          }
          return response.prev;
        },
        /**
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
         * @return {number}
         * Response code
         */
        onKbdNext: function(keyboardNavigationHandler) {
          var chart = this.chart, a11yOptions = chart.options.accessibility, response = keyboardNavigationHandler.response, i = (chart.highlightedExportItemIx || 0) + 1;
          for (; i < chart.exportDivElements.length; ++i) {
            if (chart.highlightExportItem(i)) {
              return response.success;
            }
          }
          if (a11yOptions.keyboardNavigation.wrapAround) {
            chart.highlightExportItem(0);
            return response.success;
          }
          return response.next;
        },
        /**
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
         * @return {number}
         * Response code
         */
        onKbdClick: function(keyboardNavigationHandler) {
          var chart = this.chart, curHighlightedItem = chart.exportDivElements[chart.highlightedExportItemIx], exportButtonElement = getExportMenuButtonElement(chart).element;
          if (this.isExportMenuShown) {
            this.fakeClickEvent(curHighlightedItem);
          } else {
            this.fakeClickEvent(exportButtonElement);
            chart.highlightExportItem(0);
          }
          return keyboardNavigationHandler.response.success;
        }
      }
    );
    var seriesTypes$4 = SeriesRegistry$1.seriesTypes;
    var doc$a = H.doc;
    var defined$o = Utilities.defined, extend$T = Utilities.extend, fireEvent$e = Utilities.fireEvent;
    var getPointFromXY = ChartUtilities.getPointFromXY, getSeriesFromName = ChartUtilities.getSeriesFromName, scrollToPoint = ChartUtilities.scrollToPoint;
    Series$e.prototype.keyboardMoveVertical = true;
    ["column", "pie"].forEach(function(type) {
      if (seriesTypes$4[type]) {
        seriesTypes$4[type].prototype.keyboardMoveVertical = false;
      }
    });
    function getPointIndex(point) {
      var index = point.index, points = point.series.points;
      var i = points.length;
      if (points[index] !== point) {
        while (i--) {
          if (points[i] === point) {
            return i;
          }
        }
      } else {
        return index;
      }
    }
    function isSkipSeries(series) {
      var a11yOptions = series.chart.options.accessibility, seriesNavOptions = a11yOptions.keyboardNavigation.seriesNavigation, seriesA11yOptions = series.options.accessibility || {}, seriesKbdNavOptions = seriesA11yOptions.keyboardNavigation;
      return seriesKbdNavOptions && seriesKbdNavOptions.enabled === false || seriesA11yOptions.enabled === false || series.options.enableMouseTracking === false || // #8440
      !series.visible || // Skip all points in a series where pointNavigationEnabledThreshold is
      // reached
      seriesNavOptions.pointNavigationEnabledThreshold && seriesNavOptions.pointNavigationEnabledThreshold <= series.points.length;
    }
    function isSkipPoint(point) {
      var a11yOptions = point.series.chart.options.accessibility;
      var pointA11yDisabled = point.options.accessibility && point.options.accessibility.enabled === false;
      return point.isNull && a11yOptions.keyboardNavigation.seriesNavigation.skipNullPoints || point.visible === false || point.isInside === false || pointA11yDisabled || isSkipSeries(point.series);
    }
    function getClosestPoint(point, series, xWeight, yWeight) {
      var minDistance = Infinity, dPoint, minIx, distance, i = series.points.length;
      var hasUndefinedPosition = function(point2) {
        return !(defined$o(point2.plotX) && defined$o(point2.plotY));
      };
      if (hasUndefinedPosition(point)) {
        return;
      }
      while (i--) {
        dPoint = series.points[i];
        if (hasUndefinedPosition(dPoint)) {
          continue;
        }
        distance = (point.plotX - dPoint.plotX) * (point.plotX - dPoint.plotX) * xWeight + (point.plotY - dPoint.plotY) * (point.plotY - dPoint.plotY) * 1;
        if (distance < minDistance) {
          minDistance = distance;
          minIx = i;
        }
      }
      return defined$o(minIx) ? series.points[minIx] : void 0;
    }
    Point$2.prototype.highlight = function() {
      var chart = this.series.chart;
      if (!this.isNull) {
        this.onMouseOver();
      } else {
        if (chart.tooltip) {
          chart.tooltip.hide(0);
        }
      }
      scrollToPoint(this);
      if (this.graphic) {
        chart.setFocusToElement(this.graphic);
      }
      chart.highlightedPoint = this;
      return this;
    };
    Chart$1.prototype.highlightAdjacentPoint = function(next) {
      var chart = this, series = chart.series, curPoint = chart.highlightedPoint, curPointIndex = curPoint && getPointIndex(curPoint) || 0, curPoints = curPoint && curPoint.series.points, lastSeries = chart.series && chart.series[chart.series.length - 1], lastPoint = lastSeries && lastSeries.points && lastSeries.points[lastSeries.points.length - 1];
      var newSeries, newPoint;
      if (!series[0] || !series[0].points) {
        return false;
      }
      if (!curPoint) {
        newPoint = next ? series[0].points[0] : lastPoint;
      } else {
        newSeries = series[curPoint.series.index + (next ? 1 : -1)];
        newPoint = curPoints[curPointIndex + (next ? 1 : -1)];
        if (!newPoint && newSeries) {
          newPoint = newSeries.points[next ? 0 : newSeries.points.length - 1];
        }
        if (!newPoint) {
          return false;
        }
      }
      if (isSkipPoint(newPoint)) {
        newSeries = newPoint.series;
        if (isSkipSeries(newSeries)) {
          chart.highlightedPoint = next ? newSeries.points[newSeries.points.length - 1] : newSeries.points[0];
        } else {
          chart.highlightedPoint = newPoint;
        }
        return chart.highlightAdjacentPoint(next);
      }
      return newPoint.highlight();
    };
    Series$e.prototype.highlightFirstValidPoint = function() {
      var curPoint = this.chart.highlightedPoint, start = (curPoint && curPoint.series) === this ? getPointIndex(curPoint) : 0, points = this.points, len = points.length;
      if (points && len) {
        for (var i = start; i < len; ++i) {
          if (!isSkipPoint(points[i])) {
            return points[i].highlight();
          }
        }
        for (var j = start; j >= 0; --j) {
          if (!isSkipPoint(points[j])) {
            return points[j].highlight();
          }
        }
      }
      return false;
    };
    Chart$1.prototype.highlightAdjacentSeries = function(down) {
      var chart = this, curPoint = chart.highlightedPoint, lastSeries = chart.series && chart.series[chart.series.length - 1], lastPoint = lastSeries && lastSeries.points && lastSeries.points[lastSeries.points.length - 1];
      var newSeries, newPoint, adjacentNewPoint;
      if (!chart.highlightedPoint) {
        newSeries = down ? chart.series && chart.series[0] : lastSeries;
        newPoint = down ? newSeries && newSeries.points && newSeries.points[0] : lastPoint;
        return newPoint ? newPoint.highlight() : false;
      }
      newSeries = chart.series[curPoint.series.index + (down ? -1 : 1)];
      if (!newSeries) {
        return false;
      }
      newPoint = getClosestPoint(curPoint, newSeries, 4);
      if (!newPoint) {
        return false;
      }
      if (isSkipSeries(newSeries)) {
        newPoint.highlight();
        adjacentNewPoint = chart.highlightAdjacentSeries(down);
        if (!adjacentNewPoint) {
          curPoint.highlight();
          return false;
        }
        return adjacentNewPoint;
      }
      newPoint.highlight();
      return newPoint.series.highlightFirstValidPoint();
    };
    Chart$1.prototype.highlightAdjacentPointVertical = function(down) {
      var curPoint = this.highlightedPoint;
      var minDistance = Infinity, bestPoint;
      if (!defined$o(curPoint.plotX) || !defined$o(curPoint.plotY)) {
        return false;
      }
      this.series.forEach(function(series) {
        if (isSkipSeries(series)) {
          return;
        }
        series.points.forEach(function(point) {
          if (!defined$o(point.plotY) || !defined$o(point.plotX) || point === curPoint) {
            return;
          }
          var yDistance = point.plotY - curPoint.plotY;
          var width = Math.abs(point.plotX - curPoint.plotX), distance = Math.abs(yDistance) * Math.abs(yDistance) + width * width * 4;
          if (series.yAxis && series.yAxis.reversed) {
            yDistance *= -1;
          }
          if (yDistance <= 0 && down || yDistance >= 0 && !down || // Chk dir
          distance < 5 || // Points in same spot => infinite loop
          isSkipPoint(point)) {
            return;
          }
          if (distance < minDistance) {
            minDistance = distance;
            bestPoint = point;
          }
        });
      });
      return bestPoint ? bestPoint.highlight() : false;
    };
    function highlightFirstValidPointInChart(chart) {
      var res = false;
      delete chart.highlightedPoint;
      res = chart.series.reduce(function(acc, cur) {
        return acc || cur.highlightFirstValidPoint();
      }, false);
      return res;
    }
    function highlightLastValidPointInChart(chart) {
      var numSeries = chart.series.length;
      var i = numSeries, res = false;
      while (i--) {
        chart.highlightedPoint = chart.series[i].points[chart.series[i].points.length - 1];
        res = chart.series[i].highlightFirstValidPoint();
        if (res) {
          break;
        }
      }
      return res;
    }
    function updateChartFocusAfterDrilling(chart) {
      highlightFirstValidPointInChart(chart);
      if (chart.focusElement) {
        chart.focusElement.removeFocusBorder();
      }
    }
    function SeriesKeyboardNavigation(chart, keyCodes) {
      this.keyCodes = keyCodes;
      this.chart = chart;
    }
    extend$T(
      SeriesKeyboardNavigation.prototype,
      /** @lends Highcharts.SeriesKeyboardNavigation */
      {
        /**
         * Init the keyboard navigation
         */
        init: function() {
          var keyboardNavigation = this, chart = this.chart, e2 = this.eventProvider = new EventProvider();
          e2.addEvent(Series$e, "destroy", function() {
            return keyboardNavigation.onSeriesDestroy(this);
          });
          e2.addEvent(chart, "afterDrilldown", function() {
            updateChartFocusAfterDrilling(this);
          });
          e2.addEvent(chart, "drilldown", function(e3) {
            var point = e3.point, series = point.series;
            keyboardNavigation.lastDrilledDownPoint = {
              x: point.x,
              y: point.y,
              seriesName: series ? series.name : ""
            };
          });
          e2.addEvent(chart, "drillupall", function() {
            setTimeout(function() {
              keyboardNavigation.onDrillupAll();
            }, 10);
          });
          e2.addEvent(Point$2, "afterSetState", function() {
            var point = this;
            var pointEl = point.graphic && point.graphic.element;
            if (chart.highlightedPoint === point && doc$a.activeElement !== pointEl && pointEl && pointEl.focus) {
              pointEl.focus();
            }
          });
        },
        onDrillupAll: function() {
          var last = this.lastDrilledDownPoint, chart = this.chart, series = last && getSeriesFromName(chart, last.seriesName);
          var point;
          if (last && series && defined$o(last.x) && defined$o(last.y)) {
            point = getPointFromXY(series, last.x, last.y);
          }
          if (chart.container) {
            chart.container.focus();
          }
          if (point && point.highlight) {
            point.highlight();
          }
          if (chart.focusElement) {
            chart.focusElement.removeFocusBorder();
          }
        },
        /**
         * @return {Highcharts.KeyboardNavigationHandler}
         */
        getKeyboardNavigationHandler: function() {
          var keyboardNavigation = this, keys2 = this.keyCodes, chart = this.chart, inverted = chart.inverted;
          return new KeyboardNavigationHandler(chart, {
            keyCodeMap: [
              [inverted ? [keys2.up, keys2.down] : [keys2.left, keys2.right], function(keyCode) {
                return keyboardNavigation.onKbdSideways(this, keyCode);
              }],
              [inverted ? [keys2.left, keys2.right] : [keys2.up, keys2.down], function(keyCode) {
                return keyboardNavigation.onKbdVertical(this, keyCode);
              }],
              [[keys2.enter, keys2.space], function(keyCode, event) {
                var point = chart.highlightedPoint;
                if (point) {
                  event.point = point;
                  fireEvent$e(point.series, "click", event);
                  point.firePointEvent("click");
                }
                return this.response.success;
              }]
            ],
            init: function(dir) {
              return keyboardNavigation.onHandlerInit(this, dir);
            },
            terminate: function() {
              return keyboardNavigation.onHandlerTerminate();
            }
          });
        },
        /**
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} handler
         * @param {number} keyCode
         * @return {number}
         * response
         */
        onKbdSideways: function(handler, keyCode) {
          var keys2 = this.keyCodes, isNext = keyCode === keys2.right || keyCode === keys2.down;
          return this.attemptHighlightAdjacentPoint(handler, isNext);
        },
        /**
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} handler
         * @param {number} keyCode
         * @return {number}
         * response
         */
        onKbdVertical: function(handler, keyCode) {
          var chart = this.chart, keys2 = this.keyCodes, isNext = keyCode === keys2.down || keyCode === keys2.right, navOptions = chart.options.accessibility.keyboardNavigation.seriesNavigation;
          if (navOptions.mode && navOptions.mode === "serialize") {
            return this.attemptHighlightAdjacentPoint(handler, isNext);
          }
          var highlightMethod = chart.highlightedPoint && chart.highlightedPoint.series.keyboardMoveVertical ? "highlightAdjacentPointVertical" : "highlightAdjacentSeries";
          chart[highlightMethod](isNext);
          return handler.response.success;
        },
        /**
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} handler
         * @param {number} initDirection
         * @return {number}
         * response
         */
        onHandlerInit: function(handler, initDirection) {
          var chart = this.chart;
          if (initDirection > 0) {
            highlightFirstValidPointInChart(chart);
          } else {
            highlightLastValidPointInChart(chart);
          }
          return handler.response.success;
        },
        /**
         * @private
         */
        onHandlerTerminate: function() {
          var chart = this.chart;
          if (chart.tooltip) {
            chart.tooltip.hide(0);
          }
          var hoverSeries = chart.highlightedPoint && chart.highlightedPoint.series;
          if (hoverSeries && hoverSeries.onMouseOut) {
            hoverSeries.onMouseOut();
          }
          if (chart.highlightedPoint && chart.highlightedPoint.onMouseOut) {
            chart.highlightedPoint.onMouseOut();
          }
          delete chart.highlightedPoint;
        },
        /**
         * Function that attempts to highlight next/prev point. Handles wrap around.
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} handler
         * @param {boolean} directionIsNext
         * @return {number}
         * response
         */
        attemptHighlightAdjacentPoint: function(handler, directionIsNext) {
          var chart = this.chart, wrapAround = chart.options.accessibility.keyboardNavigation.wrapAround, highlightSuccessful = chart.highlightAdjacentPoint(directionIsNext);
          if (!highlightSuccessful) {
            if (wrapAround) {
              return handler.init(directionIsNext ? 1 : -1);
            }
            return handler.response[directionIsNext ? "next" : "prev"];
          }
          return handler.response.success;
        },
        /**
         * @private
         */
        onSeriesDestroy: function(series) {
          var chart = this.chart, currentHighlightedPointDestroyed = chart.highlightedPoint && chart.highlightedPoint.series === series;
          if (currentHighlightedPointDestroyed) {
            delete chart.highlightedPoint;
            if (chart.focusElement) {
              chart.focusElement.removeFocusBorder();
            }
          }
        },
        /**
         * @private
         */
        destroy: function() {
          this.eventProvider.removeAddedEvents();
        }
      }
    );
    var escapeStringForHTML = HTMLUtilities.escapeStringForHTML, stripHTMLTagsFromString$1 = HTMLUtilities.stripHTMLTagsFromString;
    function getChartAnnotationLabels(chart) {
      var annotations = chart.annotations || [];
      return annotations.reduce(function(acc, cur) {
        if (cur.options && cur.options.visible !== false) {
          acc = acc.concat(cur.labels);
        }
        return acc;
      }, []);
    }
    function getLabelText(label) {
      return label.options && label.options.accessibility && label.options.accessibility.description || label.graphic && label.graphic.text && label.graphic.text.textStr || "";
    }
    function getAnnotationLabelDescription(label) {
      var a11yDesc = label.options && label.options.accessibility && label.options.accessibility.description;
      if (a11yDesc) {
        return a11yDesc;
      }
      var chart = label.chart;
      var labelText = getLabelText(label);
      var points = label.points;
      var getAriaLabel = function(point) {
        return point.graphic && point.graphic.element && point.graphic.element.getAttribute("aria-label") || "";
      };
      var getValueDesc = function(point) {
        var valDesc = point.accessibility && point.accessibility.valueDescription || getAriaLabel(point);
        var seriesName = point && point.series.name || "";
        return (seriesName ? seriesName + ", " : "") + "data point " + valDesc;
      };
      var pointValueDescriptions = points.filter(function(p) {
        return !!p.graphic;
      }).map(getValueDesc).filter(function(desc) {
        return !!desc;
      });
      var numPoints = pointValueDescriptions.length;
      var pointsSelector = numPoints > 1 ? "MultiplePoints" : numPoints ? "SinglePoint" : "NoPoints";
      var langFormatStr = "accessibility.screenReaderSection.annotations.description" + pointsSelector;
      var context = {
        annotationText: labelText,
        annotation: label,
        numPoints,
        annotationPoint: pointValueDescriptions[0],
        additionalAnnotationPoints: pointValueDescriptions.slice(1)
      };
      return chart.langFormat(langFormatStr, context);
    }
    function getAnnotationListItems(chart) {
      var labels = getChartAnnotationLabels(chart);
      return labels.map(function(label) {
        var desc = escapeStringForHTML(stripHTMLTagsFromString$1(getAnnotationLabelDescription(label)));
        return desc ? "<li>" + desc + "</li>" : "";
      });
    }
    function getAnnotationsInfoHTML$1(chart) {
      var annotations = chart.annotations;
      if (!(annotations && annotations.length)) {
        return "";
      }
      var annotationItems = getAnnotationListItems(chart);
      return '<ul style="list-style-type: none">' + annotationItems.join(" ") + "</ul>";
    }
    function getPointAnnotationTexts$1(point) {
      var labels = getChartAnnotationLabels(point.series.chart);
      var pointLabels = labels.filter(function(label) {
        return label.points.indexOf(point) > -1;
      });
      if (!pointLabels.length) {
        return [];
      }
      return pointLabels.map(function(label) {
        return "" + getLabelText(label);
      });
    }
    var AnnotationsA11y = {
      getAnnotationsInfoHTML: getAnnotationsInfoHTML$1,
      getAnnotationLabelDescription,
      getAnnotationListItems,
      getPointAnnotationTexts: getPointAnnotationTexts$1
    };
    var getPointAnnotationTexts = AnnotationsA11y.getPointAnnotationTexts;
    var getAxisDescription$1 = ChartUtilities.getAxisDescription, getSeriesFirstPointElement = ChartUtilities.getSeriesFirstPointElement, getSeriesA11yElement = ChartUtilities.getSeriesA11yElement, unhideChartElementFromAT$4 = ChartUtilities.unhideChartElementFromAT;
    var format$6 = FormatUtilities.format, numberFormat = FormatUtilities.numberFormat;
    var reverseChildNodes = HTMLUtilities.reverseChildNodes, stripHTMLTags$1 = HTMLUtilities.stripHTMLTagsFromString;
    var find$6 = Utilities.find, isNumber$l = Utilities.isNumber, pick$T = Utilities.pick, defined$n = Utilities.defined;
    function findFirstPointWithGraphic(point) {
      var sourcePointIndex = point.index;
      if (!point.series || !point.series.data || !defined$n(sourcePointIndex)) {
        return null;
      }
      return find$6(point.series.data, function(p) {
        return !!(p && typeof p.index !== "undefined" && p.index > sourcePointIndex && p.graphic && p.graphic.element);
      }) || null;
    }
    function shouldAddDummyPoint(point) {
      var isSunburst = point.series && point.series.is("sunburst"), isNull = point.isNull;
      return isNull && !isSunburst;
    }
    function makeDummyElement(point, pos) {
      var renderer = point.series.chart.renderer, dummy = renderer.rect(pos.x, pos.y, 1, 1);
      dummy.attr({
        "class": "highcharts-a11y-dummy-point",
        fill: "none",
        opacity: 0,
        "fill-opacity": 0,
        "stroke-opacity": 0
      });
      return dummy;
    }
    function addDummyPointElement(point) {
      var series = point.series, firstPointWithGraphic = findFirstPointWithGraphic(point), firstGraphic = firstPointWithGraphic && firstPointWithGraphic.graphic, parentGroup = firstGraphic ? firstGraphic.parentGroup : series.graph || series.group, dummyPos = firstPointWithGraphic ? {
        x: pick$T(point.plotX, firstPointWithGraphic.plotX, 0),
        y: pick$T(point.plotY, firstPointWithGraphic.plotY, 0)
      } : {
        x: pick$T(point.plotX, 0),
        y: pick$T(point.plotY, 0)
      }, dummyElement = makeDummyElement(point, dummyPos);
      if (parentGroup && parentGroup.element) {
        point.graphic = dummyElement;
        point.hasDummyGraphic = true;
        dummyElement.add(parentGroup);
        parentGroup.element.insertBefore(dummyElement.element, firstGraphic ? firstGraphic.element : null);
        return dummyElement.element;
      }
    }
    function hasMorePointsThanDescriptionThreshold(series) {
      var chartA11yOptions = series.chart.options.accessibility, threshold = chartA11yOptions.series.pointDescriptionEnabledThreshold;
      return !!(threshold !== false && series.points && series.points.length >= threshold);
    }
    function shouldSetScreenReaderPropsOnPoints(series) {
      var seriesA11yOptions = series.options.accessibility || {};
      return !hasMorePointsThanDescriptionThreshold(series) && !seriesA11yOptions.exposeAsGroupOnly;
    }
    function shouldSetKeyboardNavPropsOnPoints(series) {
      var chartA11yOptions = series.chart.options.accessibility, seriesNavOptions = chartA11yOptions.keyboardNavigation.seriesNavigation;
      return !!(series.points && (series.points.length < seriesNavOptions.pointNavigationEnabledThreshold || seriesNavOptions.pointNavigationEnabledThreshold === false));
    }
    function shouldDescribeSeriesElement(series) {
      var chart = series.chart, chartOptions = chart.options.chart, chartHas3d = chartOptions.options3d && chartOptions.options3d.enabled, hasMultipleSeries = chart.series.length > 1, describeSingleSeriesOption = chart.options.accessibility.series.describeSingleSeries, exposeAsGroupOnlyOption = (series.options.accessibility || {}).exposeAsGroupOnly, noDescribe3D = chartHas3d && hasMultipleSeries;
      return !noDescribe3D && (hasMultipleSeries || describeSingleSeriesOption || exposeAsGroupOnlyOption || hasMorePointsThanDescriptionThreshold(series));
    }
    function pointNumberToString(point, value) {
      var chart = point.series.chart, a11yPointOptions = chart.options.accessibility.point || {}, tooltipOptions = point.series.tooltipOptions || {}, lang2 = chart.options.lang;
      if (isNumber$l(value)) {
        return numberFormat(value, a11yPointOptions.valueDecimals || tooltipOptions.valueDecimals || -1, lang2.decimalPoint, lang2.accessibility.thousandsSep || lang2.thousandsSep);
      }
      return value;
    }
    function getSeriesDescriptionText(series) {
      var seriesA11yOptions = series.options.accessibility || {}, descOpt = seriesA11yOptions.description;
      return descOpt && series.chart.langFormat("accessibility.series.description", {
        description: descOpt,
        series
      }) || "";
    }
    function getSeriesAxisDescriptionText(series, axisCollection) {
      var axis = series[axisCollection];
      return series.chart.langFormat("accessibility.series." + axisCollection + "Description", {
        name: getAxisDescription$1(axis),
        series
      });
    }
    function getPointA11yTimeDescription(point) {
      var series = point.series, chart = series.chart, a11yOptions = chart.options.accessibility.point || {}, dateXAxis = series.xAxis && series.xAxis.dateTime;
      if (dateXAxis) {
        var tooltipDateFormat = dateXAxis.getXDateFormat(point.x || 0, chart.options.tooltip.dateTimeLabelFormats), dateFormat2 = a11yOptions.dateFormatter && a11yOptions.dateFormatter(point) || a11yOptions.dateFormat || tooltipDateFormat;
        return chart.time.dateFormat(dateFormat2, point.x || 0, void 0);
      }
    }
    function getPointXDescription(point) {
      var timeDesc = getPointA11yTimeDescription(point), xAxis = point.series.xAxis || {}, pointCategory = xAxis.categories && defined$n(point.category) && ("" + point.category).replace("<br/>", " "), canUseId = point.id && point.id.indexOf("highcharts-") < 0, fallback = "x, " + point.x;
      return point.name || timeDesc || pointCategory || (canUseId ? point.id : fallback);
    }
    function getPointArrayMapValueDescription(point, prefix, suffix) {
      var pre = prefix || "", suf = suffix || "", keyToValStr = function(key) {
        var num = pointNumberToString(point, pick$T(point[key], point.options[key]));
        return key + ": " + pre + num + suf;
      }, pointArrayMap = point.series.pointArrayMap;
      return pointArrayMap.reduce(function(desc, key) {
        return desc + (desc.length ? ", " : "") + keyToValStr(key);
      }, "");
    }
    function getPointValue(point) {
      var series = point.series, a11yPointOpts = series.chart.options.accessibility.point || {}, tooltipOptions = series.tooltipOptions || {}, valuePrefix = a11yPointOpts.valuePrefix || tooltipOptions.valuePrefix || "", valueSuffix = a11yPointOpts.valueSuffix || tooltipOptions.valueSuffix || "", fallbackKey = typeof point.value !== "undefined" ? "value" : "y", fallbackDesc = pointNumberToString(point, point[fallbackKey]);
      if (point.isNull) {
        return series.chart.langFormat("accessibility.series.nullPointValue", {
          point
        });
      }
      if (series.pointArrayMap) {
        return getPointArrayMapValueDescription(point, valuePrefix, valueSuffix);
      }
      return valuePrefix + fallbackDesc + valueSuffix;
    }
    function getPointAnnotationDescription(point) {
      var chart = point.series.chart;
      var langKey = "accessibility.series.pointAnnotationsDescription";
      var annotations = getPointAnnotationTexts(point);
      var context = { point, annotations };
      return annotations.length ? chart.langFormat(langKey, context) : "";
    }
    function getPointValueDescription(point) {
      var series = point.series, chart = series.chart, pointValueDescriptionFormat = chart.options.accessibility.point.valueDescriptionFormat, showXDescription = pick$T(series.xAxis && series.xAxis.options.accessibility && series.xAxis.options.accessibility.enabled, !chart.angular), xDesc = showXDescription ? getPointXDescription(point) : "", context = {
        point,
        index: defined$n(point.index) ? point.index + 1 : "",
        xDescription: xDesc,
        value: getPointValue(point),
        separator: showXDescription ? ", " : ""
      };
      return format$6(pointValueDescriptionFormat, context, chart);
    }
    function defaultPointDescriptionFormatter$1(point) {
      var series = point.series, chart = series.chart, valText = getPointValueDescription(point), description = point.options && point.options.accessibility && point.options.accessibility.description, userDescText = description ? " " + description : "", seriesNameText = chart.series.length > 1 && series.name ? " " + series.name + "." : "", annotationsDesc = getPointAnnotationDescription(point), pointAnnotationsText = annotationsDesc ? " " + annotationsDesc : "";
      point.accessibility = point.accessibility || {};
      point.accessibility.valueDescription = valText;
      return valText + userDescText + seriesNameText + pointAnnotationsText;
    }
    function setPointScreenReaderAttribs(point, pointElement) {
      var series = point.series, a11yPointOptions = series.chart.options.accessibility.point || {}, seriesA11yOptions = series.options.accessibility || {}, label = stripHTMLTags$1(seriesA11yOptions.pointDescriptionFormatter && seriesA11yOptions.pointDescriptionFormatter(point) || a11yPointOptions.descriptionFormatter && a11yPointOptions.descriptionFormatter(point) || defaultPointDescriptionFormatter$1(point));
      pointElement.setAttribute("role", "img");
      pointElement.setAttribute("aria-label", label);
    }
    function describePointsInSeries(series) {
      var setScreenReaderProps = shouldSetScreenReaderPropsOnPoints(series), setKeyboardProps = shouldSetKeyboardNavPropsOnPoints(series);
      if (setScreenReaderProps || setKeyboardProps) {
        series.points.forEach(function(point) {
          var pointEl = point.graphic && point.graphic.element || shouldAddDummyPoint(point) && addDummyPointElement(point);
          var pointA11yDisabled = point.options && point.options.accessibility && point.options.accessibility.enabled === false;
          if (pointEl) {
            pointEl.setAttribute("tabindex", "-1");
            pointEl.style.outline = "0";
            if (setScreenReaderProps && !pointA11yDisabled) {
              setPointScreenReaderAttribs(point, pointEl);
            } else {
              pointEl.setAttribute("aria-hidden", true);
            }
          }
        });
      }
    }
    function defaultSeriesDescriptionFormatter$1(series) {
      var chart = series.chart, chartTypes = chart.types || [], description = getSeriesDescriptionText(series), shouldDescribeAxis = function(coll) {
        return chart[coll] && chart[coll].length > 1 && series[coll];
      }, xAxisInfo = getSeriesAxisDescriptionText(series, "xAxis"), yAxisInfo = getSeriesAxisDescriptionText(series, "yAxis"), summaryContext = {
        name: series.name || "",
        ix: series.index + 1,
        numSeries: chart.series && chart.series.length,
        numPoints: series.points && series.points.length,
        series
      }, combinationSuffix = chartTypes.length > 1 ? "Combination" : "", summary = chart.langFormat("accessibility.series.summary." + series.type + combinationSuffix, summaryContext) || chart.langFormat("accessibility.series.summary.default" + combinationSuffix, summaryContext);
      return summary + (description ? " " + description : "") + (shouldDescribeAxis("yAxis") ? " " + yAxisInfo : "") + (shouldDescribeAxis("xAxis") ? " " + xAxisInfo : "");
    }
    function describeSeriesElement(series, seriesElement) {
      var seriesA11yOptions = series.options.accessibility || {}, a11yOptions = series.chart.options.accessibility, landmarkVerbosity = a11yOptions.landmarkVerbosity;
      if (seriesA11yOptions.exposeAsGroupOnly) {
        seriesElement.setAttribute("role", "img");
      } else if (landmarkVerbosity === "all") {
        seriesElement.setAttribute("role", "region");
      }
      seriesElement.setAttribute("tabindex", "-1");
      seriesElement.style.outline = "0";
      seriesElement.setAttribute("aria-label", stripHTMLTags$1(a11yOptions.series.descriptionFormatter && a11yOptions.series.descriptionFormatter(series) || defaultSeriesDescriptionFormatter$1(series)));
    }
    function describeSeries$1(series) {
      var chart = series.chart, firstPointEl = getSeriesFirstPointElement(series), seriesEl = getSeriesA11yElement(series), is3d = chart.is3d && chart.is3d();
      if (seriesEl) {
        if (seriesEl.lastChild === firstPointEl && !is3d) {
          reverseChildNodes(seriesEl);
        }
        describePointsInSeries(series);
        unhideChartElementFromAT$4(chart, seriesEl);
        if (shouldDescribeSeriesElement(series)) {
          describeSeriesElement(series, seriesEl);
        } else {
          seriesEl.setAttribute("aria-label", "");
        }
      }
    }
    var SeriesDescriber = {
      describeSeries: describeSeries$1,
      defaultPointDescriptionFormatter: defaultPointDescriptionFormatter$1,
      defaultSeriesDescriptionFormatter: defaultSeriesDescriptionFormatter$1,
      getPointA11yTimeDescription,
      getPointXDescription,
      getPointValue,
      getPointValueDescription
    };
    var doc$9 = H.doc;
    var setElAttrs$3 = HTMLUtilities.setElAttrs, visuallyHideElement$1 = HTMLUtilities.visuallyHideElement;
    var Announcer = (
      /** @class */
      function() {
        function Announcer2(chart, type) {
          this.chart = chart;
          this.domElementProvider = new DOMElementProvider();
          this.announceRegion = this.addAnnounceRegion(type);
        }
        Announcer2.prototype.destroy = function() {
          this.domElementProvider.destroyCreatedElements();
        };
        Announcer2.prototype.announce = function(message) {
          var _this = this;
          AST.setElementHTML(this.announceRegion, message);
          if (this.clearAnnouncementRegionTimer) {
            clearTimeout(this.clearAnnouncementRegionTimer);
          }
          this.clearAnnouncementRegionTimer = setTimeout(function() {
            _this.announceRegion.innerHTML = "";
            delete _this.clearAnnouncementRegionTimer;
          }, 1e3);
        };
        Announcer2.prototype.addAnnounceRegion = function(type) {
          var chartContainer = this.chart.announcerContainer || this.createAnnouncerContainer(), div = this.domElementProvider.createElement("div");
          setElAttrs$3(div, {
            "aria-hidden": false,
            "aria-live": type
          });
          visuallyHideElement$1(div);
          chartContainer.appendChild(div);
          return div;
        };
        Announcer2.prototype.createAnnouncerContainer = function() {
          var chart = this.chart, container = doc$9.createElement("div");
          setElAttrs$3(container, {
            "aria-hidden": false,
            style: "position:relative",
            "class": "highcharts-announcer-container"
          });
          chart.renderTo.insertBefore(container, chart.renderTo.firstChild);
          chart.announcerContainer = container;
          return container;
        };
        return Announcer2;
      }()
    );
    var extend$S = Utilities.extend, defined$m = Utilities.defined;
    var getChartTitle$2 = ChartUtilities.getChartTitle;
    var defaultPointDescriptionFormatter = SeriesDescriber.defaultPointDescriptionFormatter, defaultSeriesDescriptionFormatter = SeriesDescriber.defaultSeriesDescriptionFormatter;
    function chartHasAnnounceEnabled(chart) {
      return !!chart.options.accessibility.announceNewData.enabled;
    }
    function findPointInDataArray(point) {
      var candidates = point.series.data.filter(function(candidate) {
        return point.x === candidate.x && point.y === candidate.y;
      });
      return candidates.length === 1 ? candidates[0] : point;
    }
    function getUniqueSeries(arrayA, arrayB) {
      var uniqueSeries = (arrayA || []).concat(arrayB || []).reduce(function(acc, cur) {
        acc[cur.name + cur.index] = cur;
        return acc;
      }, {});
      return Object.keys(uniqueSeries).map(function(ix) {
        return uniqueSeries[ix];
      });
    }
    var NewDataAnnouncer = function(chart) {
      this.chart = chart;
    };
    extend$S(NewDataAnnouncer.prototype, {
      /**
       * Initialize the new data announcer.
       * @private
       */
      init: function() {
        var chart = this.chart;
        var announceOptions = chart.options.accessibility.announceNewData;
        var announceType = announceOptions.interruptUser ? "assertive" : "polite";
        this.lastAnnouncementTime = 0;
        this.dirty = {
          allSeries: {}
        };
        this.eventProvider = new EventProvider();
        this.announcer = new Announcer(chart, announceType);
        this.addEventListeners();
      },
      /**
       * Remove traces of announcer.
       * @private
       */
      destroy: function() {
        this.eventProvider.removeAddedEvents();
        this.announcer.destroy();
      },
      /**
       * Add event listeners for the announcer
       * @private
       */
      addEventListeners: function() {
        var announcer = this, chart = this.chart, e2 = this.eventProvider;
        e2.addEvent(chart, "afterDrilldown", function() {
          announcer.lastAnnouncementTime = 0;
        });
        e2.addEvent(Series$e, "updatedData", function() {
          announcer.onSeriesUpdatedData(this);
        });
        e2.addEvent(chart, "afterAddSeries", function(e3) {
          announcer.onSeriesAdded(e3.series);
        });
        e2.addEvent(Series$e, "addPoint", function(e3) {
          announcer.onPointAdded(e3.point);
        });
        e2.addEvent(chart, "redraw", function() {
          announcer.announceDirtyData();
        });
      },
      /**
       * On new data in the series, make sure we add it to the dirty list.
       * @private
       * @param {Highcharts.Series} series
       */
      onSeriesUpdatedData: function(series) {
        var chart = this.chart;
        if (series.chart === chart && chartHasAnnounceEnabled(chart)) {
          this.dirty.hasDirty = true;
          this.dirty.allSeries[series.name + series.index] = series;
        }
      },
      /**
       * On new data series added, update dirty list.
       * @private
       * @param {Highcharts.Series} series
       */
      onSeriesAdded: function(series) {
        if (chartHasAnnounceEnabled(this.chart)) {
          this.dirty.hasDirty = true;
          this.dirty.allSeries[series.name + series.index] = series;
          this.dirty.newSeries = defined$m(this.dirty.newSeries) ? void 0 : series;
        }
      },
      /**
       * On new point added, update dirty list.
       * @private
       * @param {Highcharts.Point} point
       */
      onPointAdded: function(point) {
        var chart = point.series.chart;
        if (this.chart === chart && chartHasAnnounceEnabled(chart)) {
          this.dirty.newPoint = defined$m(this.dirty.newPoint) ? void 0 : point;
        }
      },
      /**
       * Gather what we know and announce the data to user.
       * @private
       */
      announceDirtyData: function() {
        var chart = this.chart, announcer = this;
        if (chart.options.accessibility.announceNewData && this.dirty.hasDirty) {
          var newPoint = this.dirty.newPoint;
          if (newPoint) {
            newPoint = findPointInDataArray(newPoint);
          }
          this.queueAnnouncement(Object.keys(this.dirty.allSeries).map(function(ix) {
            return announcer.dirty.allSeries[ix];
          }), this.dirty.newSeries, newPoint);
          this.dirty = {
            allSeries: {}
          };
        }
      },
      /**
       * Announce to user that there is new data.
       * @private
       * @param {Array<Highcharts.Series>} dirtySeries
       *          Array of series with new data.
       * @param {Highcharts.Series} [newSeries]
       *          If a single new series was added, a reference to this series.
       * @param {Highcharts.Point} [newPoint]
       *          If a single point was added, a reference to this point.
       */
      queueAnnouncement: function(dirtySeries, newSeries, newPoint) {
        var _this = this;
        var chart = this.chart;
        var annOptions = chart.options.accessibility.announceNewData;
        if (annOptions.enabled) {
          var now = +/* @__PURE__ */ new Date();
          var dTime = now - this.lastAnnouncementTime;
          var time = Math.max(0, annOptions.minAnnounceInterval - dTime);
          var allSeries = getUniqueSeries(this.queuedAnnouncement && this.queuedAnnouncement.series, dirtySeries);
          var message = this.buildAnnouncementMessage(allSeries, newSeries, newPoint);
          if (message) {
            if (this.queuedAnnouncement) {
              clearTimeout(this.queuedAnnouncementTimer);
            }
            this.queuedAnnouncement = {
              time: now,
              message,
              series: allSeries
            };
            this.queuedAnnouncementTimer = setTimeout(function() {
              if (_this && _this.announcer) {
                _this.lastAnnouncementTime = +/* @__PURE__ */ new Date();
                _this.announcer.announce(_this.queuedAnnouncement.message);
                delete _this.queuedAnnouncement;
                delete _this.queuedAnnouncementTimer;
              }
            }, time);
          }
        }
      },
      /**
       * Get announcement message for new data.
       * @private
       * @param {Array<Highcharts.Series>} dirtySeries
       *          Array of series with new data.
       * @param {Highcharts.Series} [newSeries]
       *          If a single new series was added, a reference to this series.
       * @param {Highcharts.Point} [newPoint]
       *          If a single point was added, a reference to this point.
       *
       * @return {string|null}
       * The announcement message to give to user.
       */
      buildAnnouncementMessage: function(dirtySeries, newSeries, newPoint) {
        var chart = this.chart, annOptions = chart.options.accessibility.announceNewData;
        if (annOptions.announcementFormatter) {
          var formatterRes = annOptions.announcementFormatter(dirtySeries, newSeries, newPoint);
          if (formatterRes !== false) {
            return formatterRes.length ? formatterRes : null;
          }
        }
        var multiple = H.charts && H.charts.length > 1 ? "Multiple" : "Single", langKey = newSeries ? "newSeriesAnnounce" + multiple : newPoint ? "newPointAnnounce" + multiple : "newDataAnnounce", chartTitle = getChartTitle$2(chart);
        return chart.langFormat("accessibility.announceNewData." + langKey, {
          chartTitle,
          seriesDesc: newSeries ? defaultSeriesDescriptionFormatter(newSeries) : null,
          pointDesc: newPoint ? defaultPointDescriptionFormatter(newPoint) : null,
          point: newPoint,
          series: newSeries
        });
      }
    });
    var addEvent$z = Utilities.addEvent, merge$M = Utilities.merge;
    function isWithinDescriptionThreshold(series) {
      var a11yOptions = series.chart.options.accessibility;
      return series.points.length < a11yOptions.series.pointDescriptionEnabledThreshold || a11yOptions.series.pointDescriptionEnabledThreshold === false;
    }
    function shouldForceMarkers(series) {
      var chart = series.chart, chartA11yEnabled = chart.options.accessibility.enabled, seriesA11yEnabled = (series.options.accessibility && series.options.accessibility.enabled) !== false;
      return chartA11yEnabled && seriesA11yEnabled && isWithinDescriptionThreshold(series);
    }
    function hasIndividualPointMarkerOptions(series) {
      return !!(series._hasPointMarkers && series.points && series.points.length);
    }
    function unforceSeriesMarkerOptions(series) {
      var resetMarkerOptions = series.resetA11yMarkerOptions;
      if (resetMarkerOptions) {
        merge$M(true, series.options, {
          marker: {
            enabled: resetMarkerOptions.enabled,
            states: {
              normal: {
                opacity: resetMarkerOptions.states && resetMarkerOptions.states.normal && resetMarkerOptions.states.normal.opacity
              }
            }
          }
        });
      }
    }
    function forceZeroOpacityMarkerOptions(options) {
      merge$M(true, options, {
        marker: {
          enabled: true,
          states: {
            normal: {
              opacity: 0
            }
          }
        }
      });
    }
    function getPointMarkerOpacity(pointOptions) {
      return pointOptions.marker.states && pointOptions.marker.states.normal && pointOptions.marker.states.normal.opacity || 1;
    }
    function unforcePointMarkerOptions(pointOptions) {
      merge$M(true, pointOptions.marker, {
        states: {
          normal: {
            opacity: getPointMarkerOpacity(pointOptions)
          }
        }
      });
    }
    function handleForcePointMarkers(series) {
      var i = series.points.length;
      while (i--) {
        var point = series.points[i];
        var pointOptions = point.options;
        delete point.hasForcedA11yMarker;
        if (pointOptions.marker) {
          if (pointOptions.marker.enabled) {
            unforcePointMarkerOptions(pointOptions);
            point.hasForcedA11yMarker = false;
          } else {
            forceZeroOpacityMarkerOptions(pointOptions);
            point.hasForcedA11yMarker = true;
          }
        }
      }
    }
    function addForceMarkersEvents() {
      addEvent$z(Series$e, "render", function() {
        var series = this, options = series.options;
        if (shouldForceMarkers(series)) {
          if (options.marker && options.marker.enabled === false) {
            series.a11yMarkersForced = true;
            forceZeroOpacityMarkerOptions(series.options);
          }
          if (hasIndividualPointMarkerOptions(series)) {
            handleForcePointMarkers(series);
          }
        } else if (series.a11yMarkersForced) {
          delete series.a11yMarkersForced;
          unforceSeriesMarkerOptions(series);
        }
      });
      addEvent$z(Series$e, "afterSetOptions", function(e2) {
        this.resetA11yMarkerOptions = merge$M(e2.options.marker || {}, this.userOptions.marker || {});
      });
      addEvent$z(Series$e, "afterRender", function() {
        var series = this;
        if (series.chart.styledMode) {
          if (series.markerGroup) {
            series.markerGroup[series.a11yMarkersForced ? "addClass" : "removeClass"]("highcharts-a11y-markers-hidden");
          }
          if (hasIndividualPointMarkerOptions(series)) {
            series.points.forEach(function(point) {
              if (point.graphic) {
                point.graphic[point.hasForcedA11yMarker ? "addClass" : "removeClass"]("highcharts-a11y-marker-hidden");
                point.graphic[point.hasForcedA11yMarker === false ? "addClass" : "removeClass"]("highcharts-a11y-marker-visible");
              }
            });
          }
        }
      });
    }
    var extend$R = Utilities.extend;
    var hideSeriesFromAT = ChartUtilities.hideSeriesFromAT;
    var describeSeries = SeriesDescriber.describeSeries;
    H.SeriesAccessibilityDescriber = SeriesDescriber;
    addForceMarkersEvents();
    var SeriesComponent = function() {
    };
    SeriesComponent.prototype = new AccessibilityComponent();
    extend$R(
      SeriesComponent.prototype,
      /** @lends Highcharts.SeriesComponent */
      {
        /**
         * Init the component.
         */
        init: function() {
          this.newDataAnnouncer = new NewDataAnnouncer(this.chart);
          this.newDataAnnouncer.init();
          this.keyboardNavigation = new SeriesKeyboardNavigation(this.chart, this.keyCodes);
          this.keyboardNavigation.init();
          this.hideTooltipFromATWhenShown();
          this.hideSeriesLabelsFromATWhenShown();
        },
        /**
         * @private
         */
        hideTooltipFromATWhenShown: function() {
          var component = this;
          this.addEvent(Tooltip, "refresh", function() {
            if (this.chart === component.chart && this.label && this.label.element) {
              this.label.element.setAttribute("aria-hidden", true);
            }
          });
        },
        /**
         * @private
         */
        hideSeriesLabelsFromATWhenShown: function() {
          this.addEvent(this.chart, "afterDrawSeriesLabels", function() {
            this.series.forEach(function(series) {
              if (series.labelBySeries) {
                series.labelBySeries.attr("aria-hidden", true);
              }
            });
          });
        },
        /**
         * Called on chart render. It is necessary to do this for render in case
         * markers change on zoom/pixel density.
         */
        onChartRender: function() {
          var chart = this.chart;
          chart.series.forEach(function(series) {
            var shouldDescribeSeries = (series.options.accessibility && series.options.accessibility.enabled) !== false && series.visible;
            if (shouldDescribeSeries) {
              describeSeries(series);
            } else {
              hideSeriesFromAT(series);
            }
          });
        },
        /**
         * Get keyboard navigation handler for this component.
         * @return {Highcharts.KeyboardNavigationHandler}
         */
        getKeyboardNavigation: function() {
          return this.keyboardNavigation.getKeyboardNavigationHandler();
        },
        /**
         * Remove traces
         */
        destroy: function() {
          this.newDataAnnouncer.destroy();
          this.keyboardNavigation.destroy();
        }
      }
    );
    var unhideChartElementFromAT$3 = ChartUtilities.unhideChartElementFromAT;
    var noop$d = H.noop;
    var removeElement = HTMLUtilities.removeElement, setElAttrs$2 = HTMLUtilities.setElAttrs;
    var extend$Q = Utilities.extend, pick$S = Utilities.pick;
    function chartHasMapZoom(chart) {
      return !!(chart.mapZoom && chart.mapNavButtons && chart.mapNavButtons.length);
    }
    H.Axis.prototype.panStep = function(direction, granularity) {
      var gran = granularity || 3, extremes = this.getExtremes(), step = (extremes.max - extremes.min) / gran * direction, newMax = extremes.max + step, newMin = extremes.min + step, size = newMax - newMin;
      if (direction < 0 && newMin < extremes.dataMin) {
        newMin = extremes.dataMin;
        newMax = newMin + size;
      } else if (direction > 0 && newMax > extremes.dataMax) {
        newMax = extremes.dataMax;
        newMin = newMax - size;
      }
      this.setExtremes(newMin, newMax);
    };
    var ZoomComponent = noop$d;
    ZoomComponent.prototype = new AccessibilityComponent();
    extend$Q(
      ZoomComponent.prototype,
      /** @lends Highcharts.ZoomComponent */
      {
        /**
         * Initialize the component
         */
        init: function() {
          var component = this, chart = this.chart;
          [
            "afterShowResetZoom",
            "afterDrilldown",
            "drillupall"
          ].forEach(function(eventType) {
            component.addEvent(chart, eventType, function() {
              component.updateProxyOverlays();
            });
          });
        },
        /**
         * Called when chart is updated
         */
        onChartUpdate: function() {
          var chart = this.chart, component = this;
          if (chart.mapNavButtons) {
            chart.mapNavButtons.forEach(function(button2, i) {
              unhideChartElementFromAT$3(chart, button2.element);
              component.setMapNavButtonAttrs(button2.element, "accessibility.zoom.mapZoom" + (i ? "Out" : "In"));
            });
          }
        },
        /**
         * @private
         * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} button
         * @param {string} labelFormatKey
         */
        setMapNavButtonAttrs: function(button2, labelFormatKey) {
          var chart = this.chart, label = chart.langFormat(labelFormatKey, { chart });
          setElAttrs$2(button2, {
            tabindex: -1,
            role: "button",
            "aria-label": label
          });
        },
        /**
         * Update the proxy overlays on every new render to ensure positions are
         * correct.
         */
        onChartRender: function() {
          this.updateProxyOverlays();
        },
        /**
         * Update proxy overlays, recreating the buttons.
         */
        updateProxyOverlays: function() {
          var chart = this.chart;
          removeElement(this.drillUpProxyGroup);
          removeElement(this.resetZoomProxyGroup);
          if (chart.resetZoomButton) {
            this.recreateProxyButtonAndGroup(chart.resetZoomButton, "resetZoomProxyButton", "resetZoomProxyGroup", chart.langFormat("accessibility.zoom.resetZoomButton", { chart }));
          }
          if (chart.drillUpButton) {
            this.recreateProxyButtonAndGroup(chart.drillUpButton, "drillUpProxyButton", "drillUpProxyGroup", chart.langFormat("accessibility.drillUpButton", {
              chart,
              buttonText: chart.getDrilldownBackText()
            }));
          }
        },
        /**
         * @private
         * @param {Highcharts.SVGElement} buttonEl
         * @param {string} buttonProp
         * @param {string} groupProp
         * @param {string} label
         */
        recreateProxyButtonAndGroup: function(buttonEl, buttonProp, groupProp, label) {
          removeElement(this[groupProp]);
          this[groupProp] = this.addProxyGroup();
          this[buttonProp] = this.createProxyButton(buttonEl, this[groupProp], { "aria-label": label, tabindex: -1 });
        },
        /**
         * Get keyboard navigation handler for map zoom.
         * @private
         * @return {Highcharts.KeyboardNavigationHandler} The module object
         */
        getMapZoomNavigation: function() {
          var keys2 = this.keyCodes, chart = this.chart, component = this;
          return new KeyboardNavigationHandler(chart, {
            keyCodeMap: [
              [
                [keys2.up, keys2.down, keys2.left, keys2.right],
                function(keyCode) {
                  return component.onMapKbdArrow(this, keyCode);
                }
              ],
              [
                [keys2.tab],
                function(_keyCode, e2) {
                  return component.onMapKbdTab(this, e2);
                }
              ],
              [
                [keys2.space, keys2.enter],
                function() {
                  return component.onMapKbdClick(this);
                }
              ]
            ],
            validate: function() {
              return chartHasMapZoom(chart);
            },
            init: function(direction) {
              return component.onMapNavInit(direction);
            }
          });
        },
        /**
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
         * @param {number} keyCode
         * @return {number} Response code
         */
        onMapKbdArrow: function(keyboardNavigationHandler, keyCode) {
          var keys2 = this.keyCodes, panAxis = keyCode === keys2.up || keyCode === keys2.down ? "yAxis" : "xAxis", stepDirection = keyCode === keys2.left || keyCode === keys2.up ? -1 : 1;
          this.chart[panAxis][0].panStep(stepDirection);
          return keyboardNavigationHandler.response.success;
        },
        /**
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
         * @param {global.KeyboardEvent} event
         * @return {number} Response code
         */
        onMapKbdTab: function(keyboardNavigationHandler, event) {
          var button2, chart = this.chart, response = keyboardNavigationHandler.response, isBackwards = event.shiftKey, isMoveOutOfRange = isBackwards && !this.focusedMapNavButtonIx || !isBackwards && this.focusedMapNavButtonIx;
          chart.mapNavButtons[this.focusedMapNavButtonIx].setState(0);
          if (isMoveOutOfRange) {
            chart.mapZoom();
            return response[isBackwards ? "prev" : "next"];
          }
          this.focusedMapNavButtonIx += isBackwards ? -1 : 1;
          button2 = chart.mapNavButtons[this.focusedMapNavButtonIx];
          chart.setFocusToElement(button2.box, button2.element);
          button2.setState(2);
          return response.success;
        },
        /**
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
         * @return {number} Response code
         */
        onMapKbdClick: function(keyboardNavigationHandler) {
          this.fakeClickEvent(this.chart.mapNavButtons[this.focusedMapNavButtonIx].element);
          return keyboardNavigationHandler.response.success;
        },
        /**
         * @private
         * @param {number} direction
         */
        onMapNavInit: function(direction) {
          var chart = this.chart, zoomIn = chart.mapNavButtons[0], zoomOut = chart.mapNavButtons[1], initialButton = direction > 0 ? zoomIn : zoomOut;
          chart.setFocusToElement(initialButton.box, initialButton.element);
          initialButton.setState(2);
          this.focusedMapNavButtonIx = direction > 0 ? 0 : 1;
        },
        /**
         * Get keyboard navigation handler for a simple chart button. Provide the
         * button reference for the chart, and a function to call on click.
         *
         * @private
         * @param {string} buttonProp The property on chart referencing the button.
         * @return {Highcharts.KeyboardNavigationHandler} The module object
         */
        simpleButtonNavigation: function(buttonProp, proxyProp, onClick) {
          var keys2 = this.keyCodes, component = this, chart = this.chart;
          return new KeyboardNavigationHandler(chart, {
            keyCodeMap: [
              [
                [keys2.tab, keys2.up, keys2.down, keys2.left, keys2.right],
                function(keyCode, e2) {
                  var isBackwards = keyCode === keys2.tab && e2.shiftKey || keyCode === keys2.left || keyCode === keys2.up;
                  return this.response[isBackwards ? "prev" : "next"];
                }
              ],
              [
                [keys2.space, keys2.enter],
                function() {
                  var res = onClick(this, chart);
                  return pick$S(res, this.response.success);
                }
              ]
            ],
            validate: function() {
              var hasButton = chart[buttonProp] && chart[buttonProp].box && component[proxyProp];
              return hasButton;
            },
            init: function() {
              chart.setFocusToElement(chart[buttonProp].box, component[proxyProp]);
            }
          });
        },
        /**
         * Get keyboard navigation handlers for this component.
         * @return {Array<Highcharts.KeyboardNavigationHandler>}
         *         List of module objects
         */
        getKeyboardNavigation: function() {
          return [
            this.simpleButtonNavigation("resetZoomButton", "resetZoomProxyButton", function(_handler, chart) {
              chart.zoomOut();
            }),
            this.simpleButtonNavigation("drillUpButton", "drillUpProxyButton", function(handler, chart) {
              chart.drillUp();
              return handler.response.prev;
            }),
            this.getMapZoomNavigation()
          ];
        }
      }
    );
    var unhideChartElementFromAT$2 = ChartUtilities.unhideChartElementFromAT, getAxisRangeDescription$1 = ChartUtilities.getAxisRangeDescription;
    var setElAttrs$1 = HTMLUtilities.setElAttrs;
    var addEvent$y = Utilities.addEvent, extend$P = Utilities.extend;
    function shouldRunInputNavigation(chart) {
      return Boolean(chart.rangeSelector && chart.rangeSelector.inputGroup && chart.rangeSelector.inputGroup.element.getAttribute("visibility") !== "hidden" && chart.options.rangeSelector.inputEnabled !== false && chart.rangeSelector.minInput && chart.rangeSelector.maxInput);
    }
    Chart$1.prototype.highlightRangeSelectorButton = function(ix) {
      var buttons = this.rangeSelector && this.rangeSelector.buttons || [];
      var curHighlightedIx = this.highlightedRangeSelectorItemIx;
      var curSelectedIx = this.rangeSelector && this.rangeSelector.selected;
      if (typeof curHighlightedIx !== "undefined" && buttons[curHighlightedIx] && curHighlightedIx !== curSelectedIx) {
        buttons[curHighlightedIx].setState(this.oldRangeSelectorItemState || 0);
      }
      this.highlightedRangeSelectorItemIx = ix;
      if (buttons[ix]) {
        this.setFocusToElement(buttons[ix].box, buttons[ix].element);
        if (ix !== curSelectedIx) {
          this.oldRangeSelectorItemState = buttons[ix].state;
          buttons[ix].setState(1);
        }
        return true;
      }
      return false;
    };
    addEvent$y(RangeSelector, "afterBtnClick", function() {
      if (this.chart.accessibility && this.chart.accessibility.components.rangeSelector) {
        return this.chart.accessibility.components.rangeSelector.onAfterBtnClick();
      }
    });
    var RangeSelectorComponent = function() {
    };
    RangeSelectorComponent.prototype = new AccessibilityComponent();
    extend$P(
      RangeSelectorComponent.prototype,
      /** @lends Highcharts.RangeSelectorComponent */
      {
        /**
         * Init the component
         * @private
         */
        init: function() {
          var chart = this.chart;
          this.announcer = new Announcer(chart, "polite");
        },
        /**
         * Called on first render/updates to the chart, including options changes.
         */
        onChartUpdate: function() {
          var chart = this.chart, component = this, rangeSelector = chart.rangeSelector;
          if (!rangeSelector) {
            return;
          }
          this.updateSelectorVisibility();
          this.setDropdownAttrs();
          if (rangeSelector.buttons && rangeSelector.buttons.length) {
            rangeSelector.buttons.forEach(function(button2) {
              component.setRangeButtonAttrs(button2);
            });
          }
          if (rangeSelector.maxInput && rangeSelector.minInput) {
            ["minInput", "maxInput"].forEach(function(key, i) {
              var input = rangeSelector[key];
              if (input) {
                unhideChartElementFromAT$2(chart, input);
                component.setRangeInputAttrs(input, "accessibility.rangeSelector." + (i ? "max" : "min") + "InputLabel");
              }
            });
          }
        },
        /**
         * Hide buttons from AT when showing dropdown, and vice versa.
         * @private
         */
        updateSelectorVisibility: function() {
          var chart = this.chart;
          var rangeSelector = chart.rangeSelector;
          var dropdown = rangeSelector && rangeSelector.dropdown;
          var buttons = rangeSelector && rangeSelector.buttons || [];
          var hideFromAT = function(el) {
            return el.setAttribute("aria-hidden", true);
          };
          if (rangeSelector && rangeSelector.hasVisibleDropdown && dropdown) {
            unhideChartElementFromAT$2(chart, dropdown);
            buttons.forEach(function(btn) {
              return hideFromAT(btn.element);
            });
          } else {
            if (dropdown) {
              hideFromAT(dropdown);
            }
            buttons.forEach(function(btn) {
              return unhideChartElementFromAT$2(chart, btn.element);
            });
          }
        },
        /**
         * Set accessibility related attributes on dropdown element.
         * @private
         */
        setDropdownAttrs: function() {
          var chart = this.chart;
          var dropdown = chart.rangeSelector && chart.rangeSelector.dropdown;
          if (dropdown) {
            var label = chart.langFormat("accessibility.rangeSelector.dropdownLabel", { rangeTitle: chart.options.lang.rangeSelectorZoom });
            dropdown.setAttribute("aria-label", label);
            dropdown.setAttribute("tabindex", -1);
          }
        },
        /**
         * @private
         * @param {Highcharts.SVGElement} button
         */
        setRangeButtonAttrs: function(button2) {
          setElAttrs$1(button2.element, {
            tabindex: -1,
            role: "button"
          });
        },
        /**
         * @private
         */
        setRangeInputAttrs: function(input, langKey) {
          var chart = this.chart;
          setElAttrs$1(input, {
            tabindex: -1,
            "aria-label": chart.langFormat(langKey, { chart })
          });
        },
        /**
         * @private
         * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
         * @param {number} keyCode
         * @return {number} Response code
         */
        onButtonNavKbdArrowKey: function(keyboardNavigationHandler, keyCode) {
          var response = keyboardNavigationHandler.response, keys2 = this.keyCodes, chart = this.chart, wrapAround = chart.options.accessibility.keyboardNavigation.wrapAround, direction = keyCode === keys2.left || keyCode === keys2.up ? -1 : 1, didHighlight = chart.highlightRangeSelectorButton(chart.highlightedRangeSelectorItemIx + direction);
          if (!didHighlight) {
            if (wrapAround) {
              keyboardNavigationHandler.init(direction);
              return response.success;
            }
            return response[direction > 0 ? "next" : "prev"];
          }
          return response.success;
        },
        /**
         * @private
         */
        onButtonNavKbdClick: function(keyboardNavigationHandler) {
          var response = keyboardNavigationHandler.response, chart = this.chart, wasDisabled = chart.oldRangeSelectorItemState === 3;
          if (!wasDisabled) {
            this.fakeClickEvent(chart.rangeSelector.buttons[chart.highlightedRangeSelectorItemIx].element);
          }
          return response.success;
        },
        /**
         * Called whenever a range selector button has been clicked, either by
         * mouse, touch, or kbd/voice/other.
         * @private
         */
        onAfterBtnClick: function() {
          var chart = this.chart;
          var axisRangeDescription = getAxisRangeDescription$1(chart.xAxis[0]);
          var announcement = chart.langFormat("accessibility.rangeSelector.clickButtonAnnouncement", { chart, axisRangeDescription });
          if (announcement) {
            this.announcer.announce(announcement);
          }
        },
        /**
         * @private
         */
        onInputKbdMove: function(direction) {
          var chart = this.chart;
          var rangeSel = chart.rangeSelector;
          var newIx = chart.highlightedInputRangeIx = (chart.highlightedInputRangeIx || 0) + direction;
          var newIxOutOfRange = newIx > 1 || newIx < 0;
          if (newIxOutOfRange) {
            if (chart.accessibility) {
              chart.accessibility.keyboardNavigation.tabindexContainer.focus();
              chart.accessibility.keyboardNavigation[direction < 0 ? "prev" : "next"]();
            }
          } else if (rangeSel) {
            var svgEl = rangeSel[newIx ? "maxDateBox" : "minDateBox"];
            var inputEl = rangeSel[newIx ? "maxInput" : "minInput"];
            if (svgEl && inputEl) {
              chart.setFocusToElement(svgEl, inputEl);
            }
          }
        },
        /**
         * @private
         * @param {number} direction
         */
        onInputNavInit: function(direction) {
          var _this = this;
          var component = this;
          var chart = this.chart;
          var buttonIxToHighlight = direction > 0 ? 0 : 1;
          var rangeSel = chart.rangeSelector;
          var svgEl = rangeSel && rangeSel[buttonIxToHighlight ? "maxDateBox" : "minDateBox"];
          var minInput = rangeSel && rangeSel.minInput;
          var maxInput = rangeSel && rangeSel.maxInput;
          var inputEl = buttonIxToHighlight ? maxInput : minInput;
          chart.highlightedInputRangeIx = buttonIxToHighlight;
          if (svgEl && minInput && maxInput) {
            chart.setFocusToElement(svgEl, inputEl);
            if (this.removeInputKeydownHandler) {
              this.removeInputKeydownHandler();
            }
            var keydownHandler = function(e2) {
              var isTab = (e2.which || e2.keyCode) === _this.keyCodes.tab;
              if (isTab) {
                e2.preventDefault();
                e2.stopPropagation();
                component.onInputKbdMove(e2.shiftKey ? -1 : 1);
              }
            };
            var minRemover_1 = addEvent$y(minInput, "keydown", keydownHandler);
            var maxRemover_1 = addEvent$y(maxInput, "keydown", keydownHandler);
            this.removeInputKeydownHandler = function() {
              minRemover_1();
              maxRemover_1();
            };
          }
        },
        /**
         * @private
         */
        onInputNavTerminate: function() {
          var rangeSel = this.chart.rangeSelector || {};
          if (rangeSel.maxInput) {
            rangeSel.hideInput("max");
          }
          if (rangeSel.minInput) {
            rangeSel.hideInput("min");
          }
          if (this.removeInputKeydownHandler) {
            this.removeInputKeydownHandler();
            delete this.removeInputKeydownHandler;
          }
        },
        /**
         * @private
         */
        initDropdownNav: function() {
          var _this = this;
          var chart = this.chart;
          var rangeSelector = chart.rangeSelector;
          var dropdown = rangeSelector && rangeSelector.dropdown;
          if (rangeSelector && dropdown) {
            chart.setFocusToElement(rangeSelector.buttonGroup, dropdown);
            if (this.removeDropdownKeydownHandler) {
              this.removeDropdownKeydownHandler();
            }
            this.removeDropdownKeydownHandler = addEvent$y(dropdown, "keydown", function(e2) {
              var isTab = (e2.which || e2.keyCode) === _this.keyCodes.tab;
              if (isTab) {
                e2.preventDefault();
                e2.stopPropagation();
                if (chart.accessibility) {
                  chart.accessibility.keyboardNavigation.tabindexContainer.focus();
                  chart.accessibility.keyboardNavigation[e2.shiftKey ? "prev" : "next"]();
                }
              }
            });
          }
        },
        /**
         * Get navigation for the range selector buttons.
         * @private
         * @return {Highcharts.KeyboardNavigationHandler} The module object.
         */
        getRangeSelectorButtonNavigation: function() {
          var chart = this.chart;
          var keys2 = this.keyCodes;
          var component = this;
          return new KeyboardNavigationHandler(chart, {
            keyCodeMap: [
              [
                [keys2.left, keys2.right, keys2.up, keys2.down],
                function(keyCode) {
                  return component.onButtonNavKbdArrowKey(this, keyCode);
                }
              ],
              [
                [keys2.enter, keys2.space],
                function() {
                  return component.onButtonNavKbdClick(this);
                }
              ]
            ],
            validate: function() {
              return !!(chart.rangeSelector && chart.rangeSelector.buttons && chart.rangeSelector.buttons.length);
            },
            init: function(direction) {
              var rangeSelector = chart.rangeSelector;
              if (rangeSelector && rangeSelector.hasVisibleDropdown) {
                component.initDropdownNav();
              } else if (rangeSelector) {
                var lastButtonIx = rangeSelector.buttons.length - 1;
                chart.highlightRangeSelectorButton(direction > 0 ? 0 : lastButtonIx);
              }
            },
            terminate: function() {
              if (component.removeDropdownKeydownHandler) {
                component.removeDropdownKeydownHandler();
                delete component.removeDropdownKeydownHandler;
              }
            }
          });
        },
        /**
         * Get navigation for the range selector input boxes.
         * @private
         * @return {Highcharts.KeyboardNavigationHandler}
         *         The module object.
         */
        getRangeSelectorInputNavigation: function() {
          var chart = this.chart;
          var component = this;
          return new KeyboardNavigationHandler(chart, {
            keyCodeMap: [],
            validate: function() {
              return shouldRunInputNavigation(chart);
            },
            init: function(direction) {
              component.onInputNavInit(direction);
            },
            terminate: function() {
              component.onInputNavTerminate();
            }
          });
        },
        /**
         * Get keyboard navigation handlers for this component.
         * @return {Array<Highcharts.KeyboardNavigationHandler>}
         *         List of module objects.
         */
        getKeyboardNavigation: function() {
          return [
            this.getRangeSelectorButtonNavigation(),
            this.getRangeSelectorInputNavigation()
          ];
        },
        /**
         * Remove component traces
         */
        destroy: function() {
          if (this.removeDropdownKeydownHandler) {
            this.removeDropdownKeydownHandler();
          }
          if (this.removeInputKeydownHandler) {
            this.removeInputKeydownHandler();
          }
          if (this.announcer) {
            this.announcer.destroy();
          }
        }
      }
    );
    var format$5 = FormatUtilities.format;
    var doc$8 = H.doc;
    var extend$O = Utilities.extend, pick$R = Utilities.pick;
    var getAnnotationsInfoHTML = AnnotationsA11y.getAnnotationsInfoHTML;
    var getAxisDescription = ChartUtilities.getAxisDescription, getAxisRangeDescription = ChartUtilities.getAxisRangeDescription, getChartTitle$1 = ChartUtilities.getChartTitle, unhideChartElementFromAT$1 = ChartUtilities.unhideChartElementFromAT;
    var addClass = HTMLUtilities.addClass, getElement = HTMLUtilities.getElement, getHeadingTagNameForElement = HTMLUtilities.getHeadingTagNameForElement, setElAttrs = HTMLUtilities.setElAttrs, stripHTMLTagsFromString = HTMLUtilities.stripHTMLTagsFromString, visuallyHideElement = HTMLUtilities.visuallyHideElement;
    function stripEmptyHTMLTags(str) {
      return str.replace(/<(\w+)[^>]*?>\s*<\/\1>/g, "");
    }
    function getTypeDescForMapChart(chart, formatContext) {
      return formatContext.mapTitle ? chart.langFormat("accessibility.chartTypes.mapTypeDescription", formatContext) : chart.langFormat("accessibility.chartTypes.unknownMap", formatContext);
    }
    function getTypeDescForCombinationChart(chart, formatContext) {
      return chart.langFormat("accessibility.chartTypes.combinationChart", formatContext);
    }
    function getTypeDescForEmptyChart(chart, formatContext) {
      return chart.langFormat("accessibility.chartTypes.emptyChart", formatContext);
    }
    function buildTypeDescriptionFromSeries(chart, types, context) {
      var firstType = types[0], typeExplaination = chart.langFormat("accessibility.seriesTypeDescriptions." + firstType, context), multi = chart.series && chart.series.length < 2 ? "Single" : "Multiple";
      return (chart.langFormat("accessibility.chartTypes." + firstType + multi, context) || chart.langFormat("accessibility.chartTypes.default" + multi, context)) + (typeExplaination ? " " + typeExplaination : "");
    }
    function getTableSummary(chart) {
      return chart.langFormat("accessibility.table.tableSummary", { chart });
    }
    Chart$1.prototype.getTypeDescription = function(types) {
      var firstType = types[0], firstSeries = this.series && this.series[0] || {}, formatContext = {
        numSeries: this.series.length,
        numPoints: firstSeries.points && firstSeries.points.length,
        chart: this,
        mapTitle: firstSeries.mapTitle
      };
      if (!firstType) {
        return getTypeDescForEmptyChart(this, formatContext);
      }
      if (firstType === "map") {
        return getTypeDescForMapChart(this, formatContext);
      }
      if (this.types.length > 1) {
        return getTypeDescForCombinationChart(this, formatContext);
      }
      return buildTypeDescriptionFromSeries(this, types, formatContext);
    };
    var InfoRegionsComponent = function() {
    };
    InfoRegionsComponent.prototype = new AccessibilityComponent();
    extend$O(
      InfoRegionsComponent.prototype,
      /** @lends Highcharts.InfoRegionsComponent */
      {
        /**
         * Init the component
         * @private
         */
        init: function() {
          var chart = this.chart;
          var component = this;
          this.initRegionsDefinitions();
          this.addEvent(chart, "aftergetTableAST", function(e2) {
            component.onDataTableCreated(e2);
          });
          this.addEvent(chart, "afterViewData", function(tableDiv) {
            component.dataTableDiv = tableDiv;
            setTimeout(function() {
              component.focusDataTable();
            }, 300);
          });
          this.announcer = new Announcer(chart, "assertive");
        },
        /**
         * @private
         */
        initRegionsDefinitions: function() {
          var component = this;
          this.screenReaderSections = {
            before: {
              element: null,
              buildContent: function(chart) {
                var formatter = chart.options.accessibility.screenReaderSection.beforeChartFormatter;
                return formatter ? formatter(chart) : component.defaultBeforeChartFormatter(chart);
              },
              insertIntoDOM: function(el, chart) {
                chart.renderTo.insertBefore(el, chart.renderTo.firstChild);
              },
              afterInserted: function() {
                if (typeof component.sonifyButtonId !== "undefined") {
                  component.initSonifyButton(component.sonifyButtonId);
                }
                if (typeof component.dataTableButtonId !== "undefined") {
                  component.initDataTableButton(component.dataTableButtonId);
                }
              }
            },
            after: {
              element: null,
              buildContent: function(chart) {
                var formatter = chart.options.accessibility.screenReaderSection.afterChartFormatter;
                return formatter ? formatter(chart) : component.defaultAfterChartFormatter();
              },
              insertIntoDOM: function(el, chart) {
                chart.renderTo.insertBefore(el, chart.container.nextSibling);
              },
              afterInserted: function() {
                if (component.chart.accessibility) {
                  component.chart.accessibility.keyboardNavigation.updateExitAnchor();
                }
              }
            }
          };
        },
        /**
         * Called on chart render. Have to update the sections on render, in order
         * to get a11y info from series.
         */
        onChartRender: function() {
          var component = this;
          this.linkedDescriptionElement = this.getLinkedDescriptionElement();
          this.setLinkedDescriptionAttrs();
          Object.keys(this.screenReaderSections).forEach(function(regionKey) {
            component.updateScreenReaderSection(regionKey);
          });
        },
        /**
         * @private
         */
        getLinkedDescriptionElement: function() {
          var chartOptions = this.chart.options, linkedDescOption = chartOptions.accessibility.linkedDescription;
          if (!linkedDescOption) {
            return;
          }
          if (typeof linkedDescOption !== "string") {
            return linkedDescOption;
          }
          var query = format$5(linkedDescOption, this.chart), queryMatch = doc$8.querySelectorAll(query);
          if (queryMatch.length === 1) {
            return queryMatch[0];
          }
        },
        /**
         * @private
         */
        setLinkedDescriptionAttrs: function() {
          var el = this.linkedDescriptionElement;
          if (el) {
            el.setAttribute("aria-hidden", "true");
            addClass(el, "highcharts-linked-description");
          }
        },
        /**
         * @private
         * @param {string} regionKey The name/key of the region to update
         */
        updateScreenReaderSection: function(regionKey) {
          var chart = this.chart, region = this.screenReaderSections[regionKey], content = region.buildContent(chart), sectionDiv = region.element = region.element || this.createElement("div"), hiddenDiv = sectionDiv.firstChild || this.createElement("div");
          this.setScreenReaderSectionAttribs(sectionDiv, regionKey);
          AST.setElementHTML(hiddenDiv, content);
          sectionDiv.appendChild(hiddenDiv);
          region.insertIntoDOM(sectionDiv, chart);
          visuallyHideElement(hiddenDiv);
          unhideChartElementFromAT$1(chart, hiddenDiv);
          if (region.afterInserted) {
            region.afterInserted();
          }
        },
        /**
         * @private
         * @param {Highcharts.HTMLDOMElement} sectionDiv The section element
         * @param {string} regionKey Name/key of the region we are setting attrs for
         */
        setScreenReaderSectionAttribs: function(sectionDiv, regionKey) {
          var labelLangKey = "accessibility.screenReaderSection." + regionKey + "RegionLabel", chart = this.chart, labelText = chart.langFormat(labelLangKey, { chart, chartTitle: getChartTitle$1(chart) }), sectionId = "highcharts-screen-reader-region-" + regionKey + "-" + chart.index;
          setElAttrs(sectionDiv, {
            id: sectionId,
            "aria-label": labelText
          });
          sectionDiv.style.position = "relative";
          if (chart.options.accessibility.landmarkVerbosity === "all" && labelText) {
            sectionDiv.setAttribute("role", "region");
          }
        },
        /**
         * @private
         * @return {string}
         */
        defaultBeforeChartFormatter: function() {
          var chart = this.chart, format2 = chart.options.accessibility.screenReaderSection.beforeChartFormat, axesDesc = this.getAxesDescription(), shouldHaveSonifyBtn = chart.sonify && chart.options.sonification && chart.options.sonification.enabled, sonifyButtonId = "highcharts-a11y-sonify-data-btn-" + chart.index, dataTableButtonId = "hc-linkto-highcharts-data-table-" + chart.index, annotationsList = getAnnotationsInfoHTML(chart), annotationsTitleStr = chart.langFormat("accessibility.screenReaderSection.annotations.heading", { chart }), context = {
            headingTagName: getHeadingTagNameForElement(chart.renderTo),
            chartTitle: getChartTitle$1(chart),
            typeDescription: this.getTypeDescriptionText(),
            chartSubtitle: this.getSubtitleText(),
            chartLongdesc: this.getLongdescText(),
            xAxisDescription: axesDesc.xAxis,
            yAxisDescription: axesDesc.yAxis,
            playAsSoundButton: shouldHaveSonifyBtn ? this.getSonifyButtonText(sonifyButtonId) : "",
            viewTableButton: chart.getCSV ? this.getDataTableButtonText(dataTableButtonId) : "",
            annotationsTitle: annotationsList ? annotationsTitleStr : "",
            annotationsList
          }, formattedString = H.i18nFormat(format2, context, chart);
          this.dataTableButtonId = dataTableButtonId;
          this.sonifyButtonId = sonifyButtonId;
          return stripEmptyHTMLTags(formattedString);
        },
        /**
         * @private
         * @return {string}
         */
        defaultAfterChartFormatter: function() {
          var chart = this.chart, format2 = chart.options.accessibility.screenReaderSection.afterChartFormat, context = {
            endOfChartMarker: this.getEndOfChartMarkerText()
          }, formattedString = H.i18nFormat(format2, context, chart);
          return stripEmptyHTMLTags(formattedString);
        },
        /**
         * @private
         * @return {string}
         */
        getLinkedDescription: function() {
          var el = this.linkedDescriptionElement, content = el && el.innerHTML || "";
          return stripHTMLTagsFromString(content);
        },
        /**
         * @private
         * @return {string}
         */
        getLongdescText: function() {
          var chartOptions = this.chart.options, captionOptions = chartOptions.caption, captionText = captionOptions && captionOptions.text, linkedDescription = this.getLinkedDescription();
          return chartOptions.accessibility.description || linkedDescription || captionText || "";
        },
        /**
         * @private
         * @return {string}
         */
        getTypeDescriptionText: function() {
          var chart = this.chart;
          return chart.types ? chart.options.accessibility.typeDescription || chart.getTypeDescription(chart.types) : "";
        },
        /**
         * @private
         * @param {string} buttonId
         * @return {string}
         */
        getDataTableButtonText: function(buttonId) {
          var chart = this.chart, buttonText = chart.langFormat("accessibility.table.viewAsDataTableButtonText", { chart, chartTitle: getChartTitle$1(chart) });
          return '<button id="' + buttonId + '">' + buttonText + "</button>";
        },
        /**
         * @private
         * @param {string} buttonId
         * @return {string}
         */
        getSonifyButtonText: function(buttonId) {
          var chart = this.chart;
          if (chart.options.sonification && chart.options.sonification.enabled === false) {
            return "";
          }
          var buttonText = chart.langFormat("accessibility.sonification.playAsSoundButtonText", { chart, chartTitle: getChartTitle$1(chart) });
          return '<button id="' + buttonId + '">' + buttonText + "</button>";
        },
        /**
         * @private
         * @return {string}
         */
        getSubtitleText: function() {
          var subtitle = this.chart.options.subtitle;
          return stripHTMLTagsFromString(subtitle && subtitle.text || "");
        },
        /**
         * @private
         * @return {string}
         */
        getEndOfChartMarkerText: function() {
          var chart = this.chart, markerText = chart.langFormat("accessibility.screenReaderSection.endOfChartMarker", { chart }), id = "highcharts-end-of-chart-marker-" + chart.index;
          return '<div id="' + id + '">' + markerText + "</div>";
        },
        /**
         * @private
         * @param {Highcharts.Dictionary<string>} e
         */
        onDataTableCreated: function(e2) {
          var chart = this.chart;
          if (chart.options.accessibility.enabled) {
            if (this.viewDataTableButton) {
              this.viewDataTableButton.setAttribute("aria-expanded", "true");
            }
            var attributes = e2.tree.attributes || {};
            attributes.tabindex = -1;
            attributes.summary = getTableSummary(chart);
            e2.tree.attributes = attributes;
          }
        },
        /**
         * @private
         */
        focusDataTable: function() {
          var tableDiv = this.dataTableDiv, table = tableDiv && tableDiv.getElementsByTagName("table")[0];
          if (table && table.focus) {
            table.focus();
          }
        },
        /**
         * @private
         * @param {string} sonifyButtonId
         */
        initSonifyButton: function(sonifyButtonId) {
          var _this = this;
          var el = this.sonifyButton = getElement(sonifyButtonId);
          var chart = this.chart;
          var defaultHandler = function(e2) {
            if (el) {
              el.setAttribute("aria-hidden", "true");
              el.setAttribute("aria-label", "");
            }
            e2.preventDefault();
            e2.stopPropagation();
            var announceMsg = chart.langFormat("accessibility.sonification.playAsSoundClickAnnouncement", { chart });
            _this.announcer.announce(announceMsg);
            setTimeout(function() {
              if (el) {
                el.removeAttribute("aria-hidden");
                el.removeAttribute("aria-label");
              }
              if (chart.sonify) {
                chart.sonify();
              }
            }, 1e3);
          };
          if (el && chart) {
            setElAttrs(el, {
              tabindex: -1
            });
            el.onclick = function(e2) {
              var onPlayAsSoundClick = chart.options.accessibility && chart.options.accessibility.screenReaderSection.onPlayAsSoundClick;
              (onPlayAsSoundClick || defaultHandler).call(this, e2, chart);
            };
          }
        },
        /**
         * Set attribs and handlers for default viewAsDataTable button if exists.
         * @private
         * @param {string} tableButtonId
         */
        initDataTableButton: function(tableButtonId) {
          var el = this.viewDataTableButton = getElement(tableButtonId), chart = this.chart, tableId = tableButtonId.replace("hc-linkto-", "");
          if (el) {
            setElAttrs(el, {
              tabindex: -1,
              "aria-expanded": !!getElement(tableId)
            });
            el.onclick = chart.options.accessibility.screenReaderSection.onViewDataTableClick || function() {
              chart.viewData();
            };
          }
        },
        /**
         * Return object with text description of each of the chart's axes.
         * @private
         * @return {Highcharts.Dictionary<string>}
         */
        getAxesDescription: function() {
          var chart = this.chart, shouldDescribeColl = function(collectionKey, defaultCondition) {
            var axes = chart[collectionKey];
            return axes.length > 1 || axes[0] && pick$R(axes[0].options.accessibility && axes[0].options.accessibility.enabled, defaultCondition);
          }, hasNoMap = !!chart.types && chart.types.indexOf("map") < 0, hasCartesian = !!chart.hasCartesianSeries, showXAxes = shouldDescribeColl("xAxis", !chart.angular && hasCartesian && hasNoMap), showYAxes = shouldDescribeColl("yAxis", hasCartesian && hasNoMap), desc = {};
          if (showXAxes) {
            desc.xAxis = this.getAxisDescriptionText("xAxis");
          }
          if (showYAxes) {
            desc.yAxis = this.getAxisDescriptionText("yAxis");
          }
          return desc;
        },
        /**
         * @private
         * @param {string} collectionKey
         * @return {string}
         */
        getAxisDescriptionText: function(collectionKey) {
          var chart = this.chart;
          var axes = chart[collectionKey];
          return chart.langFormat("accessibility.axis." + collectionKey + "Description" + (axes.length > 1 ? "Plural" : "Singular"), {
            chart,
            names: axes.map(function(axis) {
              return getAxisDescription(axis);
            }),
            ranges: axes.map(function(axis) {
              return getAxisRangeDescription(axis);
            }),
            numAxes: axes.length
          });
        },
        /**
         * Remove component traces
         */
        destroy: function() {
          if (this.announcer) {
            this.announcer.destroy();
          }
        }
      }
    );
    var unhideChartElementFromAT = ChartUtilities.unhideChartElementFromAT, getChartTitle = ChartUtilities.getChartTitle;
    var doc$7 = H.doc;
    var stripHTMLTags = HTMLUtilities.stripHTMLTagsFromString;
    var extend$N = Utilities.extend;
    var ContainerComponent = function() {
    };
    ContainerComponent.prototype = new AccessibilityComponent();
    extend$N(
      ContainerComponent.prototype,
      /** @lends Highcharts.ContainerComponent */
      {
        /**
         * Called on first render/updates to the chart, including options changes.
         */
        onChartUpdate: function() {
          this.handleSVGTitleElement();
          this.setSVGContainerLabel();
          this.setGraphicContainerAttrs();
          this.setRenderToAttrs();
          this.makeCreditsAccessible();
        },
        /**
         * @private
         */
        handleSVGTitleElement: function() {
          var chart = this.chart, titleId = "highcharts-title-" + chart.index, titleContents = stripHTMLTags(chart.langFormat("accessibility.svgContainerTitle", {
            chartTitle: getChartTitle(chart)
          }));
          if (titleContents.length) {
            var titleElement = this.svgTitleElement = this.svgTitleElement || doc$7.createElementNS("http://www.w3.org/2000/svg", "title");
            titleElement.textContent = titleContents;
            titleElement.id = titleId;
            chart.renderTo.insertBefore(titleElement, chart.renderTo.firstChild);
          }
        },
        /**
         * @private
         */
        setSVGContainerLabel: function() {
          var chart = this.chart, svgContainerLabel = chart.langFormat("accessibility.svgContainerLabel", {
            chartTitle: getChartTitle(chart)
          });
          if (chart.renderer.box && svgContainerLabel.length) {
            chart.renderer.box.setAttribute("aria-label", svgContainerLabel);
          }
        },
        /**
         * @private
         */
        setGraphicContainerAttrs: function() {
          var chart = this.chart, label = chart.langFormat("accessibility.graphicContainerLabel", {
            chartTitle: getChartTitle(chart)
          });
          if (label.length) {
            chart.container.setAttribute("aria-label", label);
          }
        },
        /**
         * @private
         */
        setRenderToAttrs: function() {
          var chart = this.chart;
          if (chart.options.accessibility.landmarkVerbosity !== "disabled") {
            chart.renderTo.setAttribute("role", "region");
          } else {
            chart.renderTo.removeAttribute("role");
          }
          chart.renderTo.setAttribute("aria-label", chart.langFormat("accessibility.chartContainerLabel", {
            title: getChartTitle(chart),
            chart
          }));
        },
        /**
         * @private
         */
        makeCreditsAccessible: function() {
          var chart = this.chart, credits = chart.credits;
          if (credits) {
            if (credits.textStr) {
              credits.element.setAttribute("aria-label", chart.langFormat("accessibility.credits", { creditsStr: stripHTMLTags(credits.textStr) }));
            }
            unhideChartElementFromAT(chart, credits.element);
          }
        },
        /**
         * Empty handler to just set focus on chart
         * @return {Highcharts.KeyboardNavigationHandler}
         */
        getKeyboardNavigation: function() {
          var chart = this.chart;
          return new KeyboardNavigationHandler(chart, {
            keyCodeMap: [],
            validate: function() {
              return true;
            },
            init: function() {
              var a11y = chart.accessibility;
              if (a11y) {
                a11y.keyboardNavigation.tabindexContainer.focus();
              }
            }
          });
        },
        /**
         * Accessibility disabled/chart destroyed.
         */
        destroy: function() {
          this.chart.renderTo.setAttribute("aria-hidden", true);
        }
      }
    );
    var doc$6 = H.doc, isMS = H.isMS, win$3 = H.win;
    var whcm = {
      /**
       * Detect WHCM in the browser.
       *
       * @function Highcharts#isHighContrastModeActive
       * @private
       * @return {boolean} Returns true if the browser is in High Contrast mode.
       */
      isHighContrastModeActive: function() {
        var isEdge = /(Edg)/.test(win$3.navigator.userAgent);
        if (win$3.matchMedia && isEdge) {
          return win$3.matchMedia("(-ms-high-contrast: active)").matches;
        }
        if (isMS && win$3.getComputedStyle) {
          var testDiv = doc$6.createElement("div");
          var imageSrc = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          testDiv.style.backgroundImage = "url(" + imageSrc + ")";
          doc$6.body.appendChild(testDiv);
          var bi = (testDiv.currentStyle || win$3.getComputedStyle(testDiv)).backgroundImage;
          doc$6.body.removeChild(testDiv);
          return bi === "none";
        }
        return false;
      },
      /**
       * Force high contrast theme for the chart. The default theme is defined in
       * a separate file.
       *
       * @function Highcharts#setHighContrastTheme
       * @private
       * @param {Highcharts.AccessibilityChart} chart The chart to set the theme of.
       * @return {void}
       */
      setHighContrastTheme: function(chart) {
        chart.highContrastModeActive = true;
        var theme2 = chart.options.accessibility.highContrastTheme;
        chart.update(theme2, false);
        chart.series.forEach(function(s) {
          var plotOpts = theme2.plotOptions[s.type] || {};
          s.update({
            color: plotOpts.color || "windowText",
            colors: [plotOpts.color || "windowText"],
            borderColor: plotOpts.borderColor || "window"
          });
          s.points.forEach(function(p) {
            if (p.options && p.options.color) {
              p.update({
                color: plotOpts.color || "windowText",
                borderColor: plotOpts.borderColor || "window"
              }, false);
            }
          });
        });
        chart.redraw();
      }
    };
    var theme = {
      chart: {
        backgroundColor: "window"
      },
      title: {
        style: {
          color: "windowText"
        }
      },
      subtitle: {
        style: {
          color: "windowText"
        }
      },
      colorAxis: {
        minColor: "windowText",
        maxColor: "windowText",
        stops: []
      },
      colors: ["windowText"],
      xAxis: {
        gridLineColor: "windowText",
        labels: {
          style: {
            color: "windowText"
          }
        },
        lineColor: "windowText",
        minorGridLineColor: "windowText",
        tickColor: "windowText",
        title: {
          style: {
            color: "windowText"
          }
        }
      },
      yAxis: {
        gridLineColor: "windowText",
        labels: {
          style: {
            color: "windowText"
          }
        },
        lineColor: "windowText",
        minorGridLineColor: "windowText",
        tickColor: "windowText",
        title: {
          style: {
            color: "windowText"
          }
        }
      },
      tooltip: {
        backgroundColor: "window",
        borderColor: "windowText",
        style: {
          color: "windowText"
        }
      },
      plotOptions: {
        series: {
          lineColor: "windowText",
          fillColor: "window",
          borderColor: "windowText",
          edgeColor: "windowText",
          borderWidth: 1,
          dataLabels: {
            connectorColor: "windowText",
            color: "windowText",
            style: {
              color: "windowText",
              textOutline: "none"
            }
          },
          marker: {
            lineColor: "windowText",
            fillColor: "windowText"
          }
        },
        pie: {
          color: "window",
          colors: ["window"],
          borderColor: "windowText",
          borderWidth: 1
        },
        boxplot: {
          fillColor: "window"
        },
        candlestick: {
          lineColor: "windowText",
          fillColor: "window"
        },
        errorbar: {
          fillColor: "window"
        }
      },
      legend: {
        backgroundColor: "window",
        itemStyle: {
          color: "windowText"
        },
        itemHoverStyle: {
          color: "windowText"
        },
        itemHiddenStyle: {
          color: "#555"
        },
        title: {
          style: {
            color: "windowText"
          }
        }
      },
      credits: {
        style: {
          color: "windowText"
        }
      },
      labels: {
        style: {
          color: "windowText"
        }
      },
      drilldown: {
        activeAxisLabelStyle: {
          color: "windowText"
        },
        activeDataLabelStyle: {
          color: "windowText"
        }
      },
      navigation: {
        buttonOptions: {
          symbolStroke: "windowText",
          theme: {
            fill: "window"
          }
        }
      },
      rangeSelector: {
        buttonTheme: {
          fill: "window",
          stroke: "windowText",
          style: {
            color: "windowText"
          },
          states: {
            hover: {
              fill: "window",
              stroke: "windowText",
              style: {
                color: "windowText"
              }
            },
            select: {
              fill: "#444",
              stroke: "windowText",
              style: {
                color: "windowText"
              }
            }
          }
        },
        inputBoxBorderColor: "windowText",
        inputStyle: {
          backgroundColor: "window",
          color: "windowText"
        },
        labelStyle: {
          color: "windowText"
        }
      },
      navigator: {
        handles: {
          backgroundColor: "window",
          borderColor: "windowText"
        },
        outlineColor: "windowText",
        maskFill: "transparent",
        series: {
          color: "windowText",
          lineColor: "windowText"
        },
        xAxis: {
          gridLineColor: "windowText"
        }
      },
      scrollbar: {
        barBackgroundColor: "#444",
        barBorderColor: "windowText",
        buttonArrowColor: "windowText",
        buttonBackgroundColor: "window",
        buttonBorderColor: "windowText",
        rifleColor: "windowText",
        trackBackgroundColor: "window",
        trackBorderColor: "windowText"
      }
    };
    var Options = {
      /**
       * Options for configuring accessibility for the chart. Requires the
       * [accessibility module](https://code.highcharts.com/modules/accessibility.js)
       * to be loaded. For a description of the module and information
       * on its features, see
       * [Highcharts Accessibility](https://www.highcharts.com/docs/accessibility/accessibility-module).
       *
       * @since        5.0.0
       * @requires     modules/accessibility
       * @optionparent accessibility
       */
      accessibility: {
        /**
         * Enable accessibility functionality for the chart.
         *
         * @since 5.0.0
         */
        enabled: true,
        /**
         * Accessibility options for the screen reader information sections
         * added before and after the chart.
         *
         * @since 8.0.0
         */
        screenReaderSection: {
          /**
           * Function to run upon clicking the "View as Data Table" link in
           * the screen reader region.
           *
           * By default Highcharts will insert and set focus to a data table
           * representation of the chart.
           *
           * @type      {Highcharts.ScreenReaderClickCallbackFunction}
           * @since 8.0.0
           * @apioption accessibility.screenReaderSection.onViewDataTableClick
           */
          /**
           * Function to run upon clicking the "Play as sound" button in
           * the screen reader region.
           *
           * By default Highcharts will call the `chart.sonify` function.
           *
           * @type      {Highcharts.ScreenReaderClickCallbackFunction}
           * @since 8.0.1
           * @apioption accessibility.screenReaderSection.onPlayAsSoundClick
           */
          /**
           * A formatter function to create the HTML contents of the hidden
           * screen reader information region before the chart. Receives one
           * argument, `chart`, referring to the chart object. Should return a
           * string with the HTML content of the region. By default this
           * returns an automatic description of the chart based on
           * [beforeChartFormat](#accessibility.screenReaderSection.beforeChartFormat).
           *
           * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Chart>}
           * @since 8.0.0
           * @apioption accessibility.screenReaderSection.beforeChartFormatter
           */
          /**
           * Format for the screen reader information region before the chart.
           * Supported HTML tags are `<h1-6>`, `<p>`, `<div>`, `<a>`, `<ul>`,
           * `<ol>`, `<li>`, and `<button>`. Attributes are not supported,
           * except for id on `<div>`, `<a>`, and `<button>`. Id is required
           * on `<a>` and `<button>` in the format `<tag id="abcd">`. Numbers,
           * lower- and uppercase letters, "-" and "#" are valid characters in
           * IDs.
           *
           * The headingTagName is an auto-detected heading (h1-h6) that
           * corresponds to the heading level below the previous heading in
           * the DOM.
           *
           * @since 8.0.0
           */
          beforeChartFormat: "<{headingTagName}>{chartTitle}</{headingTagName}><div>{typeDescription}</div><div>{chartSubtitle}</div><div>{chartLongdesc}</div><div>{playAsSoundButton}</div><div>{viewTableButton}</div><div>{xAxisDescription}</div><div>{yAxisDescription}</div><div>{annotationsTitle}{annotationsList}</div>",
          /**
           * A formatter function to create the HTML contents of the hidden
           * screen reader information region after the chart. Analogous to
           * [beforeChartFormatter](#accessibility.screenReaderSection.beforeChartFormatter).
           *
           * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Chart>}
           * @since 8.0.0
           * @apioption accessibility.screenReaderSection.afterChartFormatter
           */
          /**
           * Format for the screen reader information region after the chart.
           * Analogous to [beforeChartFormat](#accessibility.screenReaderSection.beforeChartFormat).
           *
           * @since 8.0.0
           */
          afterChartFormat: "{endOfChartMarker}",
          /**
           * Date format to use to describe range of datetime axes.
           *
           * For an overview of the replacement codes, see
           * [dateFormat](/class-reference/Highcharts#.dateFormat).
           *
           * @see [point.dateFormat](#accessibility.point.dateFormat)
           *
           * @since 8.0.0
           */
          axisRangeDateFormat: "%Y-%m-%d %H:%M:%S"
        },
        /**
         * Accessibility options global to all data series. Individual series
         * can also have specific [accessibility options](#plotOptions.series.accessibility)
         * set.
         *
         * @since 8.0.0
         */
        series: {
          /**
           * Formatter function to use instead of the default for series
           * descriptions. Receives one argument, `series`, referring to the
           * series to describe. Should return a string with the description
           * of the series for a screen reader user. If `false` is returned,
           * the default formatter will be used for that series.
           *
           * @see [series.description](#plotOptions.series.description)
           *
           * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Series>}
           * @since 8.0.0
           * @apioption accessibility.series.descriptionFormatter
           */
          /**
           * Whether or not to add series descriptions to charts with a single
           * series.
           *
           * @since 8.0.0
           */
          describeSingleSeries: false,
          /**
           * When a series contains more points than this, we no longer expose
           * information about individual points to screen readers.
           *
           * Set to `false` to disable.
           *
           * @type  {boolean|number}
           * @since 8.0.0
           */
          pointDescriptionEnabledThreshold: 200
        },
        /**
         * Options for descriptions of individual data points.
         *
         * @since 8.0.0
         */
        point: {
          /**
           * Date format to use for points on datetime axes when describing
           * them to screen reader users.
           *
           * Defaults to the same format as in tooltip.
           *
           * For an overview of the replacement codes, see
           * [dateFormat](/class-reference/Highcharts#.dateFormat).
           *
           * @see [dateFormatter](#accessibility.point.dateFormatter)
           *
           * @type      {string}
           * @since 8.0.0
           * @apioption accessibility.point.dateFormat
           */
          /**
           * Formatter function to determine the date/time format used with
           * points on datetime axes when describing them to screen reader
           * users. Receives one argument, `point`, referring to the point
           * to describe. Should return a date format string compatible with
           * [dateFormat](/class-reference/Highcharts#.dateFormat).
           *
           * @see [dateFormat](#accessibility.point.dateFormat)
           *
           * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}
           * @since 8.0.0
           * @apioption accessibility.point.dateFormatter
           */
          /**
           * Prefix to add to the values in the point descriptions. Uses
           * [tooltip.valuePrefix](#tooltip.valuePrefix) if not defined.
           *
           * @type        {string}
           * @since 8.0.0
           * @apioption   accessibility.point.valuePrefix
           */
          /**
           * Suffix to add to the values in the point descriptions. Uses
           * [tooltip.valueSuffix](#tooltip.valueSuffix) if not defined.
           *
           * @type        {string}
           * @since 8.0.0
           * @apioption   accessibility.point.valueSuffix
           */
          /**
           * Decimals to use for the values in the point descriptions. Uses
           * [tooltip.valueDecimals](#tooltip.valueDecimals) if not defined.
           *
           * @type        {number}
           * @since 8.0.0
           * @apioption   accessibility.point.valueDecimals
           */
          /**
           * Formatter function to use instead of the default for point
           * descriptions.
           *
           * Receives one argument, `point`, referring to the point to
           * describe. Should return a string with the description of the
           * point for a screen reader user. If `false` is returned, the
           * default formatter will be used for that point.
           *
           * Note: Prefer using [accessibility.point.valueDescriptionFormat](#accessibility.point.valueDescriptionFormat)
           * instead if possible, as default functionality such as describing
           * annotations will be preserved.
           *
           * @see [accessibility.point.valueDescriptionFormat](#accessibility.point.valueDescriptionFormat)
           * @see [point.accessibility.description](#series.line.data.accessibility.description)
           *
           * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}
           * @since 8.0.0
           * @apioption accessibility.point.descriptionFormatter
           */
          /**
           * Format to use for describing the values of data points
           * to assistive technology - including screen readers.
           * The point context is available as `{point}`.
           *
           * Additionally, the series name, annotation info, and
           * description added in `point.accessibility.description`
           * is added by default if relevant. To override this, use the
           * [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)
           * option.
           *
           * @see [point.accessibility.description](#series.line.data.accessibility.description)
           * @see [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)
           *
           * @type      {string}
           * @since 8.0.1
           */
          valueDescriptionFormat: "{index}. {xDescription}{separator}{value}."
        },
        /**
         * Amount of landmarks/regions to create for screen reader users. More
         * landmarks can make navigation with screen readers easier, but can
         * be distracting if there are lots of charts on the page. Three modes
         * are available:
         *  - `all`: Adds regions for all series, legend, menu, information
         *      region.
         *  - `one`: Adds a single landmark per chart.
         *  - `disabled`: No landmarks are added.
         *
         * @since 7.1.0
         * @validvalue ["all", "one", "disabled"]
         */
        landmarkVerbosity: "all",
        /**
         * Link the chart to an HTML element describing the contents of the
         * chart.
         *
         * It is always recommended to describe charts using visible text, to
         * improve SEO as well as accessibility for users with disabilities.
         * This option lets an HTML element with a description be linked to the
         * chart, so that screen reader users can connect the two.
         *
         * By setting this option to a string, Highcharts runs the string as an
         * HTML selector query on the entire document. If there is only a single
         * match, this element is linked to the chart. The content of the linked
         * element will be included in the chart description for screen reader
         * users.
         *
         * By default, the chart looks for an adjacent sibling element with the
         * `highcharts-description` class.
         *
         * The feature can be disabled by setting the option to an empty string,
         * or overridden by providing the
         * [accessibility.description](#accessibility.description) option.
         * Alternatively, the HTML element to link can be passed in directly as
         * an HTML node.
         *
         * If you need the description to be part of the exported image,
         * consider using the [caption](#caption) feature.
         *
         * If you need the description to be hidden visually, use the
         * [accessibility.description](#accessibility.description) option.
         *
         * @see [caption](#caption)
         * @see [description](#accessibility.description)
         * @see [typeDescription](#accessibility.typeDescription)
         *
         * @sample highcharts/accessibility/accessible-line
         *         Accessible line chart
         *
         * @type  {string|Highcharts.HTMLDOMElement}
         * @since 8.0.0
         */
        linkedDescription: '*[data-highcharts-chart="{index}"] + .highcharts-description',
        /**
         * A hook for adding custom components to the accessibility module.
         * Should be an object mapping component names to instances of classes
         * inheriting from the Highcharts.AccessibilityComponent base class.
         * Remember to add the component to the
         * [keyboardNavigation.order](#accessibility.keyboardNavigation.order)
         * for the keyboard navigation to be usable.
         *
         * @sample highcharts/accessibility/custom-component
         *         Custom accessibility component
         *
         * @type      {*}
         * @since     7.1.0
         * @apioption accessibility.customComponents
         */
        /**
         * Theme to apply to the chart when Windows High Contrast Mode is
         * detected. By default, a high contrast theme matching the high
         * contrast system system colors is used.
         *
         * @type      {*}
         * @since     7.1.3
         * @apioption accessibility.highContrastTheme
         */
        /**
         * A text description of the chart.
         *
         * **Note: Prefer using [linkedDescription](#accessibility.linkedDescription)
         * or [caption](#caption.text) instead.**
         *
         * If the Accessibility module is loaded, this option is included by
         * default as a long description of the chart in the hidden screen
         * reader information region.
         *
         * Note: Since Highcharts now supports captions and linked descriptions,
         * it is preferred to define the description using those methods, as a
         * visible caption/description benefits all users. If the
         * `accessibility.description` option is defined, the linked description
         * is ignored, and the caption is hidden from screen reader users.
         *
         * @see [linkedDescription](#accessibility.linkedDescription)
         * @see [caption](#caption)
         * @see [typeDescription](#accessibility.typeDescription)
         *
         * @type      {string}
         * @since     5.0.0
         * @apioption accessibility.description
         */
        /**
         * A text description of the chart type.
         *
         * If the Accessibility module is loaded, this will be included in the
         * description of the chart in the screen reader information region.
         *
         * Highcharts will by default attempt to guess the chart type, but for
         * more complex charts it is recommended to specify this property for
         * clarity.
         *
         * @type      {string}
         * @since     5.0.0
         * @apioption accessibility.typeDescription
         */
        /**
         * Options for keyboard navigation.
         *
         * @declare Highcharts.KeyboardNavigationOptionsObject
         * @since   5.0.0
         */
        keyboardNavigation: {
          /**
           * Enable keyboard navigation for the chart.
           *
           * @since 5.0.0
           */
          enabled: true,
          /**
           * Options for the focus border drawn around elements while
           * navigating through them.
           *
           * @sample highcharts/accessibility/custom-focus
           *         Custom focus ring
           *
           * @declare Highcharts.KeyboardNavigationFocusBorderOptionsObject
           * @since   6.0.3
           */
          focusBorder: {
            /**
             * Enable/disable focus border for chart.
             *
             * @since 6.0.3
             */
            enabled: true,
            /**
             * Hide the browser's default focus indicator.
             *
             * @since 6.0.4
             */
            hideBrowserFocusOutline: true,
            /**
             * Style options for the focus border drawn around elements
             * while navigating through them. Note that some browsers in
             * addition draw their own borders for focused elements. These
             * automatic borders can not be styled by Highcharts.
             *
             * In styled mode, the border is given the
             * `.highcharts-focus-border` class.
             *
             * @type    {Highcharts.CSSObject}
             * @since   6.0.3
             */
            style: {
              /** @internal */
              color: palette.highlightColor80,
              /** @internal */
              lineWidth: 2,
              /** @internal */
              borderRadius: 3
            },
            /**
             * Focus border margin around the elements.
             *
             * @since 6.0.3
             */
            margin: 2
          },
          /**
           * Order of tab navigation in the chart. Determines which elements
           * are tabbed to first. Available elements are: `series`, `zoom`,
           * `rangeSelector`, `chartMenu`, `legend` and `container`. In
           * addition, any custom components can be added here. Adding
           * `container` first in order will make the keyboard focus stop on
           * the chart container first, requiring the user to tab again to
           * enter the chart.
           *
           * @type  {Array<string>}
           * @since 7.1.0
           */
          order: ["series", "zoom", "rangeSelector", "legend", "chartMenu"],
          /**
           * Whether or not to wrap around when reaching the end of arrow-key
           * navigation for an element in the chart.
           * @since 7.1.0
           */
          wrapAround: true,
          /**
           * Options for the keyboard navigation of data points and series.
           *
           * @declare Highcharts.KeyboardNavigationSeriesNavigationOptionsObject
           * @since 8.0.0
           */
          seriesNavigation: {
            /**
             * Set the keyboard navigation mode for the chart. Can be
             * "normal" or "serialize". In normal mode, left/right arrow
             * keys move between points in a series, while up/down arrow
             * keys move between series. Up/down navigation acts
             * intelligently to figure out which series makes sense to move
             * to from any given point.
             *
             * In "serialize" mode, points are instead navigated as a single
             * list. Left/right behaves as in "normal" mode. Up/down arrow
             * keys will behave like left/right. This can be useful for
             * unifying navigation behavior with/without screen readers
             * enabled.
             *
             * @type       {string}
             * @default    normal
             * @since 8.0.0
             * @validvalue ["normal", "serialize"]
             * @apioption  accessibility.keyboardNavigation.seriesNavigation.mode
             */
            /**
             * Skip null points when navigating through points with the
             * keyboard.
             *
             * @since 8.0.0
             */
            skipNullPoints: true,
            /**
             * When a series contains more points than this, we no longer
             * allow keyboard navigation for it.
             *
             * Set to `false` to disable.
             *
             * @type  {boolean|number}
             * @since 8.0.0
             */
            pointNavigationEnabledThreshold: false
          }
        },
        /**
         * Options for announcing new data to screen reader users. Useful
         * for dynamic data applications and drilldown.
         *
         * Keep in mind that frequent announcements will not be useful to
         * users, as they won't have time to explore the new data. For these
         * applications, consider making snapshots of the data accessible, and
         * do the announcements in batches.
         *
         * @declare Highcharts.AccessibilityAnnounceNewDataOptionsObject
         * @since   7.1.0
         */
        announceNewData: {
          /**
           * Optional formatter callback for the announcement. Receives
           * up to three arguments. The first argument is always an array
           * of all series that received updates. If an announcement is
           * already queued, the series that received updates for that
           * announcement are also included in this array. The second
           * argument is provided if `chart.addSeries` was called, and
           * there is a new series. In that case, this argument is a
           * reference to the new series. The third argument, similarly,
           * is provided if `series.addPoint` was called, and there is a
           * new point. In that case, this argument is a reference to the
           * new point.
           *
           * The function should return a string with the text to announce
           * to the user. Return empty string to not announce anything.
           * Return `false` to use the default announcement format.
           *
           * @sample highcharts/accessibility/custom-dynamic
           *         High priority live alerts
           *
           * @type      {Highcharts.AccessibilityAnnouncementFormatter}
           * @apioption accessibility.announceNewData.announcementFormatter
           */
          /**
           * Enable announcing new data to screen reader users
           * @sample highcharts/accessibility/accessible-dynamic
           *         Dynamic data accessible
           */
          enabled: false,
          /**
           * Minimum interval between announcements in milliseconds. If
           * new data arrives before this amount of time has passed, it is
           * queued for announcement. If another new data event happens
           * while an announcement is queued, the queued announcement is
           * dropped, and the latest announcement is queued instead. Set
           * to 0 to allow all announcements, but be warned that frequent
           * announcements are disturbing to users.
           */
          minAnnounceInterval: 5e3,
          /**
           * Choose whether or not the announcements should interrupt the
           * screen reader. If not enabled, the user will be notified once
           * idle. It is recommended not to enable this setting unless
           * there is a specific reason to do so.
           */
          interruptUser: false
        }
      },
      /**
       * Accessibility options for a data point.
       *
       * @declare   Highcharts.PointAccessibilityOptionsObject
       * @since     7.1.0
       * @apioption series.line.data.accessibility
       */
      /**
       * Provide a description of the data point, announced to screen readers.
       *
       * @type      {string}
       * @since     7.1.0
       * @apioption series.line.data.accessibility.description
       */
      /**
       * Set to false to disable accessibility functionality for a specific point.
       * The point will not be included in keyboard navigation, and will not be
       * exposed to assistive technology.
       *
       * @type      {boolean}
       * @since 9.0.1
       * @apioption series.line.data.accessibility.enabled
       */
      /**
       * Accessibility options for a series.
       *
       * @declare    Highcharts.SeriesAccessibilityOptionsObject
       * @since      7.1.0
       * @requires   modules/accessibility
       * @apioption  plotOptions.series.accessibility
       */
      /**
       * Enable/disable accessibility functionality for a specific series.
       *
       * @type       {boolean}
       * @since      7.1.0
       * @apioption  plotOptions.series.accessibility.enabled
       */
      /**
       * Provide a description of the series, announced to screen readers.
       *
       * @type       {string}
       * @since      7.1.0
       * @apioption  plotOptions.series.accessibility.description
       */
      /**
       * Formatter function to use instead of the default for point
       * descriptions. Same as `accessibility.point.descriptionFormatter`, but for
       * a single series.
       *
       * @see [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)
       *
       * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}
       * @since     7.1.0
       * @apioption plotOptions.series.accessibility.pointDescriptionFormatter
       */
      /**
       * Expose only the series element to screen readers, not its points.
       *
       * @type       {boolean}
       * @since      7.1.0
       * @apioption  plotOptions.series.accessibility.exposeAsGroupOnly
       */
      /**
       * Keyboard navigation for a series
       *
       * @declare    Highcharts.SeriesAccessibilityKeyboardNavigationOptionsObject
       * @since      7.1.0
       * @apioption  plotOptions.series.accessibility.keyboardNavigation
       */
      /**
       * Enable/disable keyboard navigation support for a specific series.
       *
       * @type       {boolean}
       * @since      7.1.0
       * @apioption  plotOptions.series.accessibility.keyboardNavigation.enabled
       */
      /**
       * Accessibility options for an annotation label.
       *
       * @declare    Highcharts.AnnotationLabelAccessibilityOptionsObject
       * @since 8.0.1
       * @requires   modules/accessibility
       * @apioption  annotations.labelOptions.accessibility
       */
      /**
       * Description of an annotation label for screen readers and other assistive
       * technology.
       *
       * @type       {string}
       * @since 8.0.1
       * @apioption  annotations.labelOptions.accessibility.description
       */
      /**
       * Accessibility options for an axis. Requires the accessibility module.
       *
       * @declare    Highcharts.AxisAccessibilityOptionsObject
       * @since      7.1.0
       * @requires   modules/accessibility
       * @apioption  xAxis.accessibility
       */
      /**
       * Enable axis accessibility features, including axis information in the
       * screen reader information region. If this is disabled on the xAxis, the
       * x values are not exposed to screen readers for the individual data points
       * by default.
       *
       * @type       {boolean}
       * @since      7.1.0
       * @apioption  xAxis.accessibility.enabled
       */
      /**
       * Description for an axis to expose to screen reader users.
       *
       * @type       {string}
       * @since      7.1.0
       * @apioption  xAxis.accessibility.description
       */
      /**
       * Range description for an axis. Overrides the default range description.
       * Set to empty to disable range description for this axis.
       *
       * @type       {string}
       * @since      7.1.0
       * @apioption  xAxis.accessibility.rangeDescription
       */
      /**
       * @optionparent legend
       */
      legend: {
        /**
         * Accessibility options for the legend. Requires the Accessibility
         * module.
         *
         * @since     7.1.0
         * @requires  modules/accessibility
         */
        accessibility: {
          /**
           * Enable accessibility support for the legend.
           *
           * @since  7.1.0
           */
          enabled: true,
          /**
           * Options for keyboard navigation for the legend.
           *
           * @since     7.1.0
           * @requires  modules/accessibility
           */
          keyboardNavigation: {
            /**
             * Enable keyboard navigation for the legend.
             *
             * @see [accessibility.keyboardNavigation](#accessibility.keyboardNavigation.enabled)
             *
             * @since  7.1.0
             */
            enabled: true
          }
        }
      },
      /**
       * @optionparent exporting
       */
      exporting: {
        /**
         * Accessibility options for the exporting menu. Requires the
         * Accessibility module.
         *
         * @since    7.1.0
         * @requires modules/accessibility
         */
        accessibility: {
          /**
           * Enable accessibility support for the export menu.
           *
           * @since 7.1.0
           */
          enabled: true
        }
      }
    };
    var langOptions = {
      /**
       * Configure the accessibility strings in the chart. Requires the
       * [accessibility module](https://code.highcharts.com/modules/accessibility.js)
       * to be loaded. For a description of the module and information on its
       * features, see
       * [Highcharts Accessibility](https://www.highcharts.com/docs/chart-concepts/accessibility).
       *
       * For more dynamic control over the accessibility functionality, see
       * [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter),
       * [accessibility.series.descriptionFormatter](#accessibility.series.descriptionFormatter),
       * and
       * [accessibility.screenReaderSection.beforeChartFormatter](#accessibility.screenReaderSection.beforeChartFormatter).
       *
       * @since        6.0.6
       * @optionparent lang.accessibility
       */
      accessibility: {
        defaultChartTitle: "Chart",
        chartContainerLabel: "{title}. Highcharts interactive chart.",
        svgContainerLabel: "Interactive chart",
        drillUpButton: "{buttonText}",
        credits: "Chart credits: {creditsStr}",
        /**
         * Thousands separator to use when formatting numbers for screen
         * readers. Note that many screen readers will not handle space as a
         * thousands separator, and will consider "11 700" as two numbers.
         *
         * Set to `null` to use the separator defined in
         * [lang.thousandsSep](lang.thousandsSep).
         *
         * @since 7.1.0
         */
        thousandsSep: ",",
        /**
         * Title element text for the chart SVG element. Leave this
         * empty to disable adding the title element. Browsers will display
         * this content when hovering over elements in the chart. Assistive
         * technology may use this element to label the chart.
         *
         * @since 6.0.8
         */
        svgContainerTitle: "",
        /**
         * Set a label on the container wrapping the SVG.
         *
         * @see [chartContainerLabel](#lang.accessibility.chartContainerLabel)
         *
         * @since 8.0.0
         */
        graphicContainerLabel: "",
        /**
         * Language options for the screen reader information sections added
         * before and after the charts.
         *
         * @since 8.0.0
         */
        screenReaderSection: {
          beforeRegionLabel: "Chart screen reader information, {chartTitle}.",
          afterRegionLabel: "",
          /**
           * Language options for annotation descriptions.
           *
           * @since 8.0.1
           */
          annotations: {
            heading: "Chart annotations summary",
            descriptionSinglePoint: "{annotationText}. Related to {annotationPoint}",
            descriptionMultiplePoints: "{annotationText}. Related to {annotationPoint}{ Also related to, #each(additionalAnnotationPoints)}",
            descriptionNoPoints: "{annotationText}"
          },
          /**
           * Label for the end of the chart. Announced by screen readers.
           *
           * @since 8.0.0
           */
          endOfChartMarker: "End of interactive chart."
        },
        /**
         * Language options for sonification.
         *
         * @since 8.0.1
         */
        sonification: {
          playAsSoundButtonText: "Play as sound, {chartTitle}",
          playAsSoundClickAnnouncement: "Play"
        },
        /**
         * Language options for accessibility of the legend.
         *
         * @since 8.0.0
         */
        legend: {
          legendLabelNoTitle: "Toggle series visibility, {chartTitle}",
          legendLabel: "Chart legend: {legendTitle}",
          legendItem: "Show {itemName}"
        },
        /**
         * Chart and map zoom accessibility language options.
         *
         * @since 8.0.0
         */
        zoom: {
          mapZoomIn: "Zoom chart",
          mapZoomOut: "Zoom out chart",
          resetZoomButton: "Reset zoom"
        },
        /**
         * Range selector language options for accessibility.
         *
         * @since 8.0.0
         */
        rangeSelector: {
          dropdownLabel: "{rangeTitle}",
          minInputLabel: "Select start date.",
          maxInputLabel: "Select end date.",
          clickButtonAnnouncement: "Viewing {axisRangeDescription}"
        },
        /**
         * Accessibility language options for the data table.
         *
         * @since 8.0.0
         */
        table: {
          viewAsDataTableButtonText: "View as data table, {chartTitle}",
          tableSummary: "Table representation of chart."
        },
        /**
         * Default announcement for new data in charts. If addPoint or
         * addSeries is used, and only one series/point is added, the
         * `newPointAnnounce` and `newSeriesAnnounce` strings are used.
         * The `...Single` versions will be used if there is only one chart
         * on the page, and the `...Multiple` versions will be used if there
         * are multiple charts on the page. For all other new data events,
         * the `newDataAnnounce` string will be used.
         *
         * @since 7.1.0
         */
        announceNewData: {
          newDataAnnounce: "Updated data for chart {chartTitle}",
          newSeriesAnnounceSingle: "New data series: {seriesDesc}",
          newPointAnnounceSingle: "New data point: {pointDesc}",
          newSeriesAnnounceMultiple: "New data series in chart {chartTitle}: {seriesDesc}",
          newPointAnnounceMultiple: "New data point in chart {chartTitle}: {pointDesc}"
        },
        /**
         * Descriptions of lesser known series types. The relevant
         * description is added to the screen reader information region
         * when these series types are used.
         *
         * @since 6.0.6
         */
        seriesTypeDescriptions: {
          boxplot: "Box plot charts are typically used to display groups of statistical data. Each data point in the chart can have up to 5 values: minimum, lower quartile, median, upper quartile, and maximum.",
          arearange: "Arearange charts are line charts displaying a range between a lower and higher value for each point.",
          areasplinerange: "These charts are line charts displaying a range between a lower and higher value for each point.",
          bubble: "Bubble charts are scatter charts where each data point also has a size value.",
          columnrange: "Columnrange charts are column charts displaying a range between a lower and higher value for each point.",
          errorbar: "Errorbar series are used to display the variability of the data.",
          funnel: "Funnel charts are used to display reduction of data in stages.",
          pyramid: "Pyramid charts consist of a single pyramid with item heights corresponding to each point value.",
          waterfall: "A waterfall chart is a column chart where each column contributes towards a total end value."
        },
        /**
         * Chart type description strings. This is added to the chart
         * information region.
         *
         * If there is only a single series type used in the chart, we use
         * the format string for the series type, or default if missing.
         * There is one format string for cases where there is only a single
         * series in the chart, and one for multiple series of the same
         * type.
         *
         * @since 6.0.6
         */
        chartTypes: {
          /* eslint-disable max-len */
          emptyChart: "Empty chart",
          mapTypeDescription: "Map of {mapTitle} with {numSeries} data series.",
          unknownMap: "Map of unspecified region with {numSeries} data series.",
          combinationChart: "Combination chart with {numSeries} data series.",
          defaultSingle: "Chart with {numPoints} data {#plural(numPoints, points, point)}.",
          defaultMultiple: "Chart with {numSeries} data series.",
          splineSingle: "Line chart with {numPoints} data {#plural(numPoints, points, point)}.",
          splineMultiple: "Line chart with {numSeries} lines.",
          lineSingle: "Line chart with {numPoints} data {#plural(numPoints, points, point)}.",
          lineMultiple: "Line chart with {numSeries} lines.",
          columnSingle: "Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.",
          columnMultiple: "Bar chart with {numSeries} data series.",
          barSingle: "Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.",
          barMultiple: "Bar chart with {numSeries} data series.",
          pieSingle: "Pie chart with {numPoints} {#plural(numPoints, slices, slice)}.",
          pieMultiple: "Pie chart with {numSeries} pies.",
          scatterSingle: "Scatter chart with {numPoints} {#plural(numPoints, points, point)}.",
          scatterMultiple: "Scatter chart with {numSeries} data series.",
          boxplotSingle: "Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.",
          boxplotMultiple: "Boxplot with {numSeries} data series.",
          bubbleSingle: "Bubble chart with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
          bubbleMultiple: "Bubble chart with {numSeries} data series."
        },
        /**
         * Axis description format strings.
         *
         * @since 6.0.6
         */
        axis: {
          /* eslint-disable max-len */
          xAxisDescriptionSingular: "The chart has 1 X axis displaying {names[0]}. {ranges[0]}",
          xAxisDescriptionPlural: "The chart has {numAxes} X axes displaying {#each(names, -1) }and {names[-1]}.",
          yAxisDescriptionSingular: "The chart has 1 Y axis displaying {names[0]}. {ranges[0]}",
          yAxisDescriptionPlural: "The chart has {numAxes} Y axes displaying {#each(names, -1) }and {names[-1]}.",
          timeRangeDays: "Range: {range} days.",
          timeRangeHours: "Range: {range} hours.",
          timeRangeMinutes: "Range: {range} minutes.",
          timeRangeSeconds: "Range: {range} seconds.",
          rangeFromTo: "Range: {rangeFrom} to {rangeTo}.",
          rangeCategories: "Range: {numCategories} categories."
        },
        /**
         * Exporting menu format strings for accessibility module.
         *
         * @since 6.0.6
         */
        exporting: {
          chartMenuLabel: "Chart menu",
          menuButtonLabel: "View chart menu",
          exportRegionLabel: "Chart menu, {chartTitle}"
        },
        /**
         * Lang configuration for different series types. For more dynamic
         * control over the series element descriptions, see
         * [accessibility.seriesDescriptionFormatter](#accessibility.seriesDescriptionFormatter).
         *
         * @since 6.0.6
         */
        series: {
          /**
           * Lang configuration for the series main summary. Each series
           * type has two modes:
           *
           * 1. This series type is the only series type used in the
           *    chart
           *
           * 2. This is a combination chart with multiple series types
           *
           * If a definition does not exist for the specific series type
           * and mode, the 'default' lang definitions are used.
           *
           * @since 6.0.6
           */
          summary: {
            /* eslint-disable max-len */
            "default": "{name}, series {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
            defaultCombination: "{name}, series {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
            line: "{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
            lineCombination: "{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.",
            spline: "{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
            splineCombination: "{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.",
            column: "{name}, bar series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bars, bar)}.",
            columnCombination: "{name}, series {ix} of {numSeries}. Bar series with {numPoints} {#plural(numPoints, bars, bar)}.",
            bar: "{name}, bar series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bars, bar)}.",
            barCombination: "{name}, series {ix} of {numSeries}. Bar series with {numPoints} {#plural(numPoints, bars, bar)}.",
            pie: "{name}, pie {ix} of {numSeries} with {numPoints} {#plural(numPoints, slices, slice)}.",
            pieCombination: "{name}, series {ix} of {numSeries}. Pie with {numPoints} {#plural(numPoints, slices, slice)}.",
            scatter: "{name}, scatter plot {ix} of {numSeries} with {numPoints} {#plural(numPoints, points, point)}.",
            scatterCombination: "{name}, series {ix} of {numSeries}, scatter plot with {numPoints} {#plural(numPoints, points, point)}.",
            boxplot: "{name}, boxplot {ix} of {numSeries} with {numPoints} {#plural(numPoints, boxes, box)}.",
            boxplotCombination: "{name}, series {ix} of {numSeries}. Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.",
            bubble: "{name}, bubble series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
            bubbleCombination: "{name}, series {ix} of {numSeries}. Bubble series with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
            map: "{name}, map {ix} of {numSeries} with {numPoints} {#plural(numPoints, areas, area)}.",
            mapCombination: "{name}, series {ix} of {numSeries}. Map with {numPoints} {#plural(numPoints, areas, area)}.",
            mapline: "{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
            maplineCombination: "{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.",
            mapbubble: "{name}, bubble series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
            mapbubbleCombination: "{name}, series {ix} of {numSeries}. Bubble series with {numPoints} {#plural(numPoints, bubbles, bubble)}."
          },
          /**
           * User supplied description text. This is added in the point
           * comment description by default if present.
           *
           * @since 6.0.6
           */
          description: "{description}",
          /**
           * xAxis description for series if there are multiple xAxes in
           * the chart.
           *
           * @since 6.0.6
           */
          xAxisDescription: "X axis, {name}",
          /**
           * yAxis description for series if there are multiple yAxes in
           * the chart.
           *
           * @since 6.0.6
           */
          yAxisDescription: "Y axis, {name}",
          /**
           * Description for the value of null points.
           *
           * @since 8.0.0
           */
          nullPointValue: "No value",
          /**
           * Description for annotations on a point, as it is made available
           * to assistive technology.
           *
           * @since 8.0.1
           */
          pointAnnotationsDescription: "{Annotation: #each(annotations). }"
        }
      }
    };
    var error$1 = Utilities.error, pick$Q = Utilities.pick;
    function traverseSetOption(root2, optionAsArray, val) {
      var opt = root2, prop, i = 0;
      for (; i < optionAsArray.length - 1; ++i) {
        prop = optionAsArray[i];
        opt = opt[prop] = pick$Q(opt[prop], {});
      }
      opt[optionAsArray[optionAsArray.length - 1]] = val;
    }
    function deprecateFromOptionsMap(chart, rootOldAsArray, rootNewAsArray, mapToNewOptions) {
      function getChildProp(root2, propAsArray) {
        return propAsArray.reduce(function(acc, cur) {
          return acc[cur];
        }, root2);
      }
      var rootOld = getChildProp(chart.options, rootOldAsArray), rootNew = getChildProp(chart.options, rootNewAsArray);
      Object.keys(mapToNewOptions).forEach(function(oldOptionKey) {
        var _a2;
        var val = rootOld[oldOptionKey];
        if (typeof val !== "undefined") {
          traverseSetOption(rootNew, mapToNewOptions[oldOptionKey], val);
          error$1(32, false, chart, (_a2 = {}, _a2[rootOldAsArray.join(".") + "." + oldOptionKey] = rootNewAsArray.join(".") + "." + mapToNewOptions[oldOptionKey].join("."), _a2));
        }
      });
    }
    function copyDeprecatedChartOptions(chart) {
      var chartOptions = chart.options.chart, a11yOptions = chart.options.accessibility || {};
      ["description", "typeDescription"].forEach(function(prop) {
        var _a2;
        if (chartOptions[prop]) {
          a11yOptions[prop] = chartOptions[prop];
          error$1(32, false, chart, (_a2 = {}, _a2["chart." + prop] = "use accessibility." + prop, _a2));
        }
      });
    }
    function copyDeprecatedAxisOptions(chart) {
      chart.axes.forEach(function(axis) {
        var opts = axis.options;
        if (opts && opts.description) {
          opts.accessibility = opts.accessibility || {};
          opts.accessibility.description = opts.description;
          error$1(32, false, chart, { "axis.description": "use axis.accessibility.description" });
        }
      });
    }
    function copyDeprecatedSeriesOptions(chart) {
      var oldToNewSeriesOptions = {
        description: ["accessibility", "description"],
        exposeElementToA11y: ["accessibility", "exposeAsGroupOnly"],
        pointDescriptionFormatter: [
          "accessibility",
          "pointDescriptionFormatter"
        ],
        skipKeyboardNavigation: [
          "accessibility",
          "keyboardNavigation",
          "enabled"
        ]
      };
      chart.series.forEach(function(series) {
        Object.keys(oldToNewSeriesOptions).forEach(function(oldOption) {
          var _a2;
          var optionVal = series.options[oldOption];
          if (typeof optionVal !== "undefined") {
            traverseSetOption(
              series.options,
              oldToNewSeriesOptions[oldOption],
              // Note that skipKeyboardNavigation has inverted option
              // value, since we set enabled rather than disabled
              oldOption === "skipKeyboardNavigation" ? !optionVal : optionVal
            );
            error$1(32, false, chart, (_a2 = {}, _a2["series." + oldOption] = "series." + oldToNewSeriesOptions[oldOption].join("."), _a2));
          }
        });
      });
    }
    function copyDeprecatedTopLevelAccessibilityOptions(chart) {
      deprecateFromOptionsMap(chart, ["accessibility"], ["accessibility"], {
        pointDateFormat: ["point", "dateFormat"],
        pointDateFormatter: ["point", "dateFormatter"],
        pointDescriptionFormatter: ["point", "descriptionFormatter"],
        pointDescriptionThreshold: [
          "series",
          "pointDescriptionEnabledThreshold"
        ],
        pointNavigationThreshold: [
          "keyboardNavigation",
          "seriesNavigation",
          "pointNavigationEnabledThreshold"
        ],
        pointValueDecimals: ["point", "valueDecimals"],
        pointValuePrefix: ["point", "valuePrefix"],
        pointValueSuffix: ["point", "valueSuffix"],
        screenReaderSectionFormatter: [
          "screenReaderSection",
          "beforeChartFormatter"
        ],
        describeSingleSeries: ["series", "describeSingleSeries"],
        seriesDescriptionFormatter: ["series", "descriptionFormatter"],
        onTableAnchorClick: ["screenReaderSection", "onViewDataTableClick"],
        axisRangeDateFormat: ["screenReaderSection", "axisRangeDateFormat"]
      });
    }
    function copyDeprecatedKeyboardNavigationOptions(chart) {
      deprecateFromOptionsMap(chart, ["accessibility", "keyboardNavigation"], ["accessibility", "keyboardNavigation", "seriesNavigation"], {
        skipNullPoints: ["skipNullPoints"],
        mode: ["mode"]
      });
    }
    function copyDeprecatedLangOptions(chart) {
      deprecateFromOptionsMap(chart, ["lang", "accessibility"], ["lang", "accessibility"], {
        legendItem: ["legend", "legendItem"],
        legendLabel: ["legend", "legendLabel"],
        mapZoomIn: ["zoom", "mapZoomIn"],
        mapZoomOut: ["zoom", "mapZoomOut"],
        resetZoomButton: ["zoom", "resetZoomButton"],
        screenReaderRegionLabel: [
          "screenReaderSection",
          "beforeRegionLabel"
        ],
        rangeSelectorButton: ["rangeSelector", "buttonText"],
        rangeSelectorMaxInput: ["rangeSelector", "maxInputLabel"],
        rangeSelectorMinInput: ["rangeSelector", "minInputLabel"],
        svgContainerEnd: ["screenReaderSection", "endOfChartMarker"],
        viewAsDataTable: ["table", "viewAsDataTableButtonText"],
        tableSummary: ["table", "tableSummary"]
      });
    }
    function copyDeprecatedOptions(chart) {
      copyDeprecatedChartOptions(chart);
      copyDeprecatedAxisOptions(chart);
      if (chart.series) {
        copyDeprecatedSeriesOptions(chart);
      }
      copyDeprecatedTopLevelAccessibilityOptions(chart);
      copyDeprecatedKeyboardNavigationOptions(chart);
      copyDeprecatedLangOptions(chart);
    }
    var format$4 = FormatUtilities.format;
    var pick$P = Utilities.pick;
    function stringTrim(str) {
      return str.trim && str.trim() || str.replace(/^\s+|\s+$/g, "");
    }
    function formatExtendedStatement(statement, ctx) {
      var eachStart = statement.indexOf("#each("), pluralStart = statement.indexOf("#plural("), indexStart = statement.indexOf("["), indexEnd = statement.indexOf("]"), arr, result2;
      if (eachStart > -1) {
        var eachEnd = statement.slice(eachStart).indexOf(")") + eachStart, preEach = statement.substring(0, eachStart), postEach = statement.substring(eachEnd + 1), eachStatement = statement.substring(eachStart + 6, eachEnd), eachArguments = eachStatement.split(","), lenArg = Number(eachArguments[1]), len = void 0;
        result2 = "";
        arr = ctx[eachArguments[0]];
        if (arr) {
          lenArg = isNaN(lenArg) ? arr.length : lenArg;
          len = lenArg < 0 ? arr.length + lenArg : Math.min(lenArg, arr.length);
          for (var i = 0; i < len; ++i) {
            result2 += preEach + arr[i] + postEach;
          }
        }
        return result2.length ? result2 : "";
      }
      if (pluralStart > -1) {
        var pluralEnd = statement.slice(pluralStart).indexOf(")") + pluralStart, pluralStatement = statement.substring(pluralStart + 8, pluralEnd), pluralArguments = pluralStatement.split(","), num = Number(ctx[pluralArguments[0]]);
        switch (num) {
          case 0:
            result2 = pick$P(pluralArguments[4], pluralArguments[1]);
            break;
          case 1:
            result2 = pick$P(pluralArguments[2], pluralArguments[1]);
            break;
          case 2:
            result2 = pick$P(pluralArguments[3], pluralArguments[1]);
            break;
          default:
            result2 = pluralArguments[1];
        }
        return result2 ? stringTrim(result2) : "";
      }
      if (indexStart > -1) {
        var arrayName = statement.substring(0, indexStart), ix = Number(statement.substring(indexStart + 1, indexEnd)), val = void 0;
        arr = ctx[arrayName];
        if (!isNaN(ix) && arr) {
          if (ix < 0) {
            val = arr[arr.length + ix];
            if (typeof val === "undefined") {
              val = arr[0];
            }
          } else {
            val = arr[ix];
            if (typeof val === "undefined") {
              val = arr[arr.length - 1];
            }
          }
        }
        return typeof val !== "undefined" ? val : "";
      }
      return "{" + statement + "}";
    }
    H.i18nFormat = function(formatString, context, chart) {
      var getFirstBracketStatement = function(sourceStr, offset2) {
        var str = sourceStr.slice(offset2 || 0), startBracket = str.indexOf("{"), endBracket = str.indexOf("}");
        if (startBracket > -1 && endBracket > startBracket) {
          return {
            statement: str.substring(startBracket + 1, endBracket),
            begin: offset2 + startBracket + 1,
            end: offset2 + endBracket
          };
        }
      }, tokens = [], bracketRes, constRes, cursor = 0;
      do {
        bracketRes = getFirstBracketStatement(formatString, cursor);
        constRes = formatString.substring(cursor, bracketRes && bracketRes.begin - 1);
        if (constRes.length) {
          tokens.push({
            value: constRes,
            type: "constant"
          });
        }
        if (bracketRes) {
          tokens.push({
            value: bracketRes.statement,
            type: "statement"
          });
        }
        cursor = bracketRes ? bracketRes.end + 1 : cursor + 1;
      } while (bracketRes);
      tokens.forEach(function(token) {
        if (token.type === "statement") {
          token.value = formatExtendedStatement(token.value, context);
        }
      });
      return format$4(tokens.reduce(function(acc, cur) {
        return acc + cur.value;
      }, ""), context, chart);
    };
    Chart$1.prototype.langFormat = function(langKey, context) {
      var keys2 = langKey.split("."), formatString = this.options.lang, i = 0;
      for (; i < keys2.length; ++i) {
        formatString = formatString && formatString[keys2[i]];
      }
      return typeof formatString === "string" ? H.i18nFormat(formatString, context, this) : "";
    };
    var addEvent$x = Utilities.addEvent, extend$M = Utilities.extend, pick$O = Utilities.pick;
    var svgElementBorderUpdateTriggers = [
      "x",
      "y",
      "transform",
      "width",
      "height",
      "r",
      "d",
      "stroke-width"
    ];
    function addDestroyFocusBorderHook(el) {
      if (el.focusBorderDestroyHook) {
        return;
      }
      var origDestroy = el.destroy;
      el.destroy = function() {
        if (el.focusBorder && el.focusBorder.destroy) {
          el.focusBorder.destroy();
        }
        return origDestroy.apply(el, arguments);
      };
      el.focusBorderDestroyHook = origDestroy;
    }
    function removeDestroyFocusBorderHook(el) {
      if (!el.focusBorderDestroyHook) {
        return;
      }
      el.destroy = el.focusBorderDestroyHook;
      delete el.focusBorderDestroyHook;
    }
    function addUpdateFocusBorderHooks(el) {
      var updateParams = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        updateParams[_i - 1] = arguments[_i];
      }
      if (el.focusBorderUpdateHooks) {
        return;
      }
      el.focusBorderUpdateHooks = {};
      svgElementBorderUpdateTriggers.forEach(function(trigger) {
        var setterKey = trigger + "Setter";
        var origSetter = el[setterKey] || el._defaultSetter;
        el.focusBorderUpdateHooks[setterKey] = origSetter;
        el[setterKey] = function() {
          var ret = origSetter.apply(el, arguments);
          el.addFocusBorder.apply(el, updateParams);
          return ret;
        };
      });
    }
    function removeUpdateFocusBorderHooks(el) {
      if (!el.focusBorderUpdateHooks) {
        return;
      }
      Object.keys(el.focusBorderUpdateHooks).forEach(function(setterKey) {
        var origSetter = el.focusBorderUpdateHooks[setterKey];
        if (origSetter === el._defaultSetter) {
          delete el[setterKey];
        } else {
          el[setterKey] = origSetter;
        }
      });
      delete el.focusBorderUpdateHooks;
    }
    extend$M(SVGElement.prototype, {
      /**
       * @private
       * @function Highcharts.SVGElement#addFocusBorder
       *
       * @param {number} margin
       *
       * @param {SVGAttributes} attribs
       */
      addFocusBorder: function(margin, attribs) {
        if (this.focusBorder) {
          this.removeFocusBorder();
        }
        var bb = this.getBBox(), pad2 = pick$O(margin, 3);
        bb.x += this.translateX ? this.translateX : 0;
        bb.y += this.translateY ? this.translateY : 0;
        var borderPosX = bb.x - pad2, borderPosY = bb.y - pad2, borderWidth = bb.width + 2 * pad2, borderHeight = bb.height + 2 * pad2;
        function getTextAnchorCorrection(text) {
          var posXCorrection = 0, posYCorrection = 0;
          if (text.attr("text-anchor") === "middle") {
            posXCorrection = posYCorrection = 0.5;
          } else if (!text.rotation) {
            posYCorrection = 0.75;
          } else {
            posXCorrection = 0.25;
          }
          return {
            x: posXCorrection,
            y: posYCorrection
          };
        }
        var isLabel = this instanceof SVGLabel;
        if (this.element.nodeName === "text" || isLabel) {
          var isRotated = !!this.rotation;
          var correction = !isLabel ? getTextAnchorCorrection(this) : {
            x: isRotated ? 1 : 0,
            y: 0
          };
          var attrX = +this.attr("x");
          var attrY = +this.attr("y");
          if (!isNaN(attrX)) {
            borderPosX = attrX - bb.width * correction.x - pad2;
          }
          if (!isNaN(attrY)) {
            borderPosY = attrY - bb.height * correction.y - pad2;
          }
          if (isLabel && isRotated) {
            var temp = borderWidth;
            borderWidth = borderHeight;
            borderHeight = temp;
            if (!isNaN(attrX)) {
              borderPosX = attrX - bb.height * correction.x - pad2;
            }
            if (!isNaN(attrY)) {
              borderPosY = attrY - bb.width * correction.y - pad2;
            }
          }
        }
        this.focusBorder = this.renderer.rect(borderPosX, borderPosY, borderWidth, borderHeight, parseInt((attribs && attribs.r || 0).toString(), 10)).addClass("highcharts-focus-border").attr({
          zIndex: 99
        }).add(this.parentGroup);
        if (!this.renderer.styledMode) {
          this.focusBorder.attr({
            stroke: attribs && attribs.stroke,
            "stroke-width": attribs && attribs.strokeWidth
          });
        }
        addUpdateFocusBorderHooks(this, margin, attribs);
        addDestroyFocusBorderHook(this);
      },
      /**
       * @private
       * @function Highcharts.SVGElement#removeFocusBorder
       */
      removeFocusBorder: function() {
        removeUpdateFocusBorderHooks(this);
        removeDestroyFocusBorderHook(this);
        if (this.focusBorder) {
          this.focusBorder.destroy();
          delete this.focusBorder;
        }
      }
    });
    Chart$1.prototype.renderFocusBorder = function() {
      var focusElement = this.focusElement, focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder;
      if (focusElement) {
        focusElement.removeFocusBorder();
        if (focusBorderOptions.enabled) {
          focusElement.addFocusBorder(focusBorderOptions.margin, {
            stroke: focusBorderOptions.style.color,
            strokeWidth: focusBorderOptions.style.lineWidth,
            r: focusBorderOptions.style.borderRadius
          });
        }
      }
    };
    Chart$1.prototype.setFocusToElement = function(svgElement, focusElement) {
      var focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder, browserFocusElement = focusElement || svgElement.element;
      if (browserFocusElement && browserFocusElement.focus) {
        if (!(browserFocusElement.hcEvents && browserFocusElement.hcEvents.focusin)) {
          addEvent$x(browserFocusElement, "focusin", function() {
          });
        }
        browserFocusElement.focus();
        if (focusBorderOptions.hideBrowserFocusOutline) {
          browserFocusElement.style.outline = "none";
        }
      }
      if (this.focusElement) {
        this.focusElement.removeFocusBorder();
      }
      this.focusElement = svgElement;
      this.renderFocusBorder();
    };
    var doc$5 = H.doc;
    var defaultOptions$5 = DefaultOptions.defaultOptions;
    var addEvent$w = Utilities.addEvent, extend$L = Utilities.extend, fireEvent$d = Utilities.fireEvent, merge$L = Utilities.merge;
    merge$L(true, defaultOptions$5, Options, {
      accessibility: {
        highContrastTheme: theme
      },
      lang: langOptions
    });
    H.A11yChartUtilities = ChartUtilities;
    H.A11yHTMLUtilities = HTMLUtilities;
    H.KeyboardNavigationHandler = KeyboardNavigationHandler;
    H.AccessibilityComponent = AccessibilityComponent;
    function Accessibility(chart) {
      this.init(chart);
    }
    Accessibility.prototype = {
      /**
       * Initialize the accessibility class
       * @private
       * @param {Highcharts.Chart} chart
       *        Chart object
       */
      init: function(chart) {
        this.chart = chart;
        if (!doc$5.addEventListener || !chart.renderer.isSVG) {
          chart.renderTo.setAttribute("aria-hidden", true);
          return;
        }
        copyDeprecatedOptions(chart);
        this.initComponents();
        this.keyboardNavigation = new KeyboardNavigation(chart, this.components);
        this.update();
      },
      /**
       * @private
       */
      initComponents: function() {
        var chart = this.chart, a11yOptions = chart.options.accessibility;
        this.components = {
          container: new ContainerComponent(),
          infoRegions: new InfoRegionsComponent(),
          legend: new LegendComponent(),
          chartMenu: new MenuComponent(),
          rangeSelector: new RangeSelectorComponent(),
          series: new SeriesComponent(),
          zoom: new ZoomComponent()
        };
        if (a11yOptions.customComponents) {
          extend$L(this.components, a11yOptions.customComponents);
        }
        var components = this.components;
        this.getComponentOrder().forEach(function(componentName) {
          components[componentName].initBase(chart);
          components[componentName].init();
        });
      },
      /**
       * Get order to update components in.
       * @private
       */
      getComponentOrder: function() {
        if (!this.components) {
          return [];
        }
        if (!this.components.series) {
          return Object.keys(this.components);
        }
        var componentsExceptSeries = Object.keys(this.components).filter(function(c) {
          return c !== "series";
        });
        return ["series"].concat(componentsExceptSeries);
      },
      /**
       * Update all components.
       */
      update: function() {
        var components = this.components, chart = this.chart, a11yOptions = chart.options.accessibility;
        fireEvent$d(chart, "beforeA11yUpdate");
        chart.types = this.getChartTypes();
        this.getComponentOrder().forEach(function(componentName) {
          components[componentName].onChartUpdate();
          fireEvent$d(chart, "afterA11yComponentUpdate", {
            name: componentName,
            component: components[componentName]
          });
        });
        this.keyboardNavigation.update(a11yOptions.keyboardNavigation.order);
        if (!chart.highContrastModeActive && // Only do this once
        whcm.isHighContrastModeActive()) {
          whcm.setHighContrastTheme(chart);
        }
        fireEvent$d(chart, "afterA11yUpdate", {
          accessibility: this
        });
      },
      /**
       * Destroy all elements.
       */
      destroy: function() {
        var chart = this.chart || {};
        var components = this.components;
        Object.keys(components).forEach(function(componentName) {
          components[componentName].destroy();
          components[componentName].destroyBase();
        });
        if (this.keyboardNavigation) {
          this.keyboardNavigation.destroy();
        }
        if (chart.renderTo) {
          chart.renderTo.setAttribute("aria-hidden", true);
        }
        if (chart.focusElement) {
          chart.focusElement.removeFocusBorder();
        }
      },
      /**
       * Return a list of the types of series we have in the chart.
       * @private
       */
      getChartTypes: function() {
        var types = {};
        this.chart.series.forEach(function(series) {
          types[series.type] = 1;
        });
        return Object.keys(types);
      }
    };
    Chart$1.prototype.updateA11yEnabled = function() {
      var a11y = this.accessibility, accessibilityOptions = this.options.accessibility;
      if (accessibilityOptions && accessibilityOptions.enabled) {
        if (a11y) {
          a11y.update();
        } else {
          this.accessibility = a11y = new Accessibility(this);
        }
      } else if (a11y) {
        if (a11y.destroy) {
          a11y.destroy();
        }
        delete this.accessibility;
      } else {
        this.renderTo.setAttribute("aria-hidden", true);
      }
    };
    addEvent$w(Chart$1, "render", function(e2) {
      if (this.a11yDirty && this.renderTo) {
        delete this.a11yDirty;
        this.updateA11yEnabled();
      }
      var a11y = this.accessibility;
      if (a11y) {
        a11y.getComponentOrder().forEach(function(componentName) {
          a11y.components[componentName].onChartRender();
        });
      }
    });
    addEvent$w(Chart$1, "update", function(e2) {
      var newOptions = e2.options.accessibility;
      if (newOptions) {
        if (newOptions.customComponents) {
          this.options.accessibility.customComponents = newOptions.customComponents;
          delete newOptions.customComponents;
        }
        merge$L(true, this.options.accessibility, newOptions);
        if (this.accessibility && this.accessibility.destroy) {
          this.accessibility.destroy();
          delete this.accessibility;
        }
      }
      this.a11yDirty = true;
    });
    addEvent$w(Point$2, "update", function() {
      if (this.series.chart.accessibility) {
        this.series.chart.a11yDirty = true;
      }
    });
    ["addSeries", "init"].forEach(function(event) {
      addEvent$w(Chart$1, event, function() {
        this.a11yDirty = true;
      });
    });
    ["update", "updatedData", "remove"].forEach(function(event) {
      addEvent$w(Series$e, event, function() {
        if (this.chart.accessibility) {
          this.chart.a11yDirty = true;
        }
      });
    });
    [
      "afterDrilldown",
      "drillupall"
    ].forEach(function(event) {
      addEvent$w(Chart$1, event, function() {
        if (this.accessibility) {
          this.accessibility.update();
        }
      });
    });
    addEvent$w(Chart$1, "destroy", function() {
      if (this.accessibility) {
        this.accessibility.destroy();
      }
    });
    var addEvent$v = Utilities.addEvent, fireEvent$c = Utilities.fireEvent, objectEach$c = Utilities.objectEach, pick$N = Utilities.pick, removeEvent$2 = Utilities.removeEvent;
    var eventEmitterMixin = {
      /**
       * Add emitter events.
       */
      addEvents: function() {
        var emitter = this, addMouseDownEvent = function(element) {
          addEvent$v(element, H.isTouchDevice ? "touchstart" : "mousedown", function(e2) {
            emitter.onMouseDown(e2);
          }, { passive: false });
        };
        addMouseDownEvent(this.graphic.element);
        (emitter.labels || []).forEach(function(label) {
          if (label.options.useHTML && label.graphic.text) {
            addMouseDownEvent(label.graphic.text.element);
          }
        });
        objectEach$c(emitter.options.events, function(event, type) {
          var eventHandler = function(e2) {
            if (type !== "click" || !emitter.cancelClick) {
              event.call(emitter, emitter.chart.pointer.normalize(e2), emitter.target);
            }
          };
          if ((emitter.nonDOMEvents || []).indexOf(type) === -1) {
            emitter.graphic.on(type, eventHandler);
          } else {
            addEvent$v(emitter, type, eventHandler, { passive: false });
          }
        });
        if (emitter.options.draggable) {
          addEvent$v(emitter, "drag", emitter.onDrag);
          if (!emitter.graphic.renderer.styledMode) {
            var cssPointer_1 = {
              cursor: {
                x: "ew-resize",
                y: "ns-resize",
                xy: "move"
              }[emitter.options.draggable]
            };
            emitter.graphic.css(cssPointer_1);
            (emitter.labels || []).forEach(function(label) {
              if (label.options.useHTML && label.graphic.text) {
                label.graphic.text.css(cssPointer_1);
              }
            });
          }
        }
        if (!emitter.isUpdating) {
          fireEvent$c(emitter, "add");
        }
      },
      /**
       * Remove emitter document events.
       */
      removeDocEvents: function() {
        if (this.removeDrag) {
          this.removeDrag = this.removeDrag();
        }
        if (this.removeMouseUp) {
          this.removeMouseUp = this.removeMouseUp();
        }
      },
      /**
       * Mouse down handler.
       */
      onMouseDown: function(e2) {
        var emitter = this, pointer = emitter.chart.pointer, prevChartX, prevChartY;
        if (e2.preventDefault) {
          e2.preventDefault();
        }
        if (e2.button === 2) {
          return;
        }
        e2 = pointer.normalize(e2);
        prevChartX = e2.chartX;
        prevChartY = e2.chartY;
        emitter.cancelClick = false;
        emitter.chart.hasDraggedAnnotation = true;
        emitter.removeDrag = addEvent$v(H.doc, H.isTouchDevice ? "touchmove" : "mousemove", function(e3) {
          emitter.hasDragged = true;
          e3 = pointer.normalize(e3);
          e3.prevChartX = prevChartX;
          e3.prevChartY = prevChartY;
          fireEvent$c(emitter, "drag", e3);
          prevChartX = e3.chartX;
          prevChartY = e3.chartY;
        }, H.isTouchDevice ? { passive: false } : void 0);
        emitter.removeMouseUp = addEvent$v(H.doc, H.isTouchDevice ? "touchend" : "mouseup", function(e3) {
          var annotation = pick$N(emitter.target && emitter.target.annotation, emitter.target);
          if (annotation) {
            annotation.cancelClick = emitter.hasDragged;
          }
          emitter.cancelClick = emitter.hasDragged;
          emitter.hasDragged = false;
          emitter.chart.hasDraggedAnnotation = false;
          fireEvent$c(pick$N(
            annotation,
            // #15952
            emitter
          ), "afterUpdate");
          emitter.onMouseUp(e3);
        }, H.isTouchDevice ? { passive: false } : void 0);
      },
      /**
       * Mouse up handler.
       */
      onMouseUp: function(_e) {
        var chart = this.chart, annotation = this.target || this, annotationsOptions = chart.options.annotations, index = chart.annotations.indexOf(annotation);
        this.removeDocEvents();
        annotationsOptions[index] = annotation.options;
      },
      /**
       * Drag and drop event. All basic annotations should share this
       * capability as well as the extended ones.
       */
      onDrag: function(e2) {
        if (this.chart.isInsidePlot(e2.chartX - this.chart.plotLeft, e2.chartY - this.chart.plotTop, {
          visiblePlotOnly: true
        })) {
          var translation_1 = this.mouseMoveToTranslation(e2);
          if (this.options.draggable === "x") {
            translation_1.y = 0;
          }
          if (this.options.draggable === "y") {
            translation_1.x = 0;
          }
          if (this.points.length) {
            this.translate(translation_1.x, translation_1.y);
          } else {
            this.shapes.forEach(function(shape) {
              shape.translate(translation_1.x, translation_1.y);
            });
            this.labels.forEach(function(label) {
              label.translate(translation_1.x, translation_1.y);
            });
          }
          this.redraw(false);
        }
      },
      /**
       * Map mouse move event to the radians.
       */
      mouseMoveToRadians: function(e2, cx, cy) {
        var prevDy = e2.prevChartY - cy, prevDx = e2.prevChartX - cx, dy = e2.chartY - cy, dx = e2.chartX - cx, temp;
        if (this.chart.inverted) {
          temp = prevDx;
          prevDx = prevDy;
          prevDy = temp;
          temp = dx;
          dx = dy;
          dy = temp;
        }
        return Math.atan2(dy, dx) - Math.atan2(prevDy, prevDx);
      },
      /**
       * Map mouse move event to the distance between two following events.
       */
      mouseMoveToTranslation: function(e2) {
        var dx = e2.chartX - e2.prevChartX, dy = e2.chartY - e2.prevChartY, temp;
        if (this.chart.inverted) {
          temp = dy;
          dy = dx;
          dx = temp;
        }
        return {
          x: dx,
          y: dy
        };
      },
      /**
       * Map mouse move to the scale factors.
       *
       * @param {Object} e event
       * @param {number} cx center x
       * @param {number} cy center y
       **/
      mouseMoveToScale: function(e2, cx, cy) {
        var prevDx = e2.prevChartX - cx, prevDy = e2.prevChartY - cy, dx = e2.chartX - cx, dy = e2.chartY - cy, sx = (dx || 1) / (prevDx || 1), sy = (dy || 1) / (prevDy || 1), temp;
        if (this.chart.inverted) {
          temp = sy;
          sy = sx;
          sx = temp;
        }
        return {
          x: sx,
          y: sy
        };
      },
      /**
       * Destroy the event emitter.
       */
      destroy: function() {
        this.removeDocEvents();
        removeEvent$2(this);
        this.hcEvents = null;
      }
    };
    var merge$K = Utilities.merge, pick$M = Utilities.pick;
    var ControlPoint = (
      /** @class */
      function() {
        function ControlPoint2(chart, target, options, index) {
          this.addEvents = eventEmitterMixin.addEvents;
          this.graphic = void 0;
          this.mouseMoveToRadians = eventEmitterMixin.mouseMoveToRadians;
          this.mouseMoveToScale = eventEmitterMixin.mouseMoveToScale;
          this.mouseMoveToTranslation = eventEmitterMixin.mouseMoveToTranslation;
          this.onDrag = eventEmitterMixin.onDrag;
          this.onMouseDown = eventEmitterMixin.onMouseDown;
          this.onMouseUp = eventEmitterMixin.onMouseUp;
          this.removeDocEvents = eventEmitterMixin.removeDocEvents;
          this.nonDOMEvents = ["drag"];
          this.chart = chart;
          this.target = target;
          this.options = options;
          this.index = pick$M(options.index, index);
        }
        ControlPoint2.prototype.setVisibility = function(visible) {
          this.graphic.attr("visibility", visible ? "visible" : "hidden");
          this.options.visible = visible;
        };
        ControlPoint2.prototype.render = function() {
          var chart = this.chart, options = this.options;
          this.graphic = chart.renderer.symbol(options.symbol, 0, 0, options.width, options.height).add(chart.controlPointsGroup).css(options.style);
          this.setVisibility(options.visible);
          this.addEvents();
        };
        ControlPoint2.prototype.redraw = function(animation) {
          this.graphic[animation ? "animate" : "attr"](this.options.positioner.call(this, this.target));
        };
        ControlPoint2.prototype.destroy = function() {
          eventEmitterMixin.destroy.call(this);
          if (this.graphic) {
            this.graphic = this.graphic.destroy();
          }
          this.chart = null;
          this.target = null;
          this.options = null;
        };
        ControlPoint2.prototype.update = function(userOptions) {
          var chart = this.chart, target = this.target, index = this.index, options = merge$K(true, this.options, userOptions);
          this.destroy();
          this.constructor(chart, target, options, index);
          this.render(chart.controlPointsGroup);
          this.redraw();
        };
        return ControlPoint2;
      }()
    );
    var defined$l = Utilities.defined, fireEvent$b = Utilities.fireEvent;
    var MockPoint = (
      /** @class */
      function() {
        function MockPoint2(chart, target, options) {
          this.isInside = void 0;
          this.negative = void 0;
          this.plotX = void 0;
          this.plotY = void 0;
          this.ttBelow = void 0;
          this.x = void 0;
          this.y = void 0;
          this.mock = true;
          this.series = {
            visible: true,
            chart,
            getPlotBox: Series$e.prototype.getPlotBox
          };
          this.target = target || null;
          this.options = options;
          this.applyOptions(this.getOptions());
        }
        MockPoint2.fromPoint = function(point) {
          return new MockPoint2(point.series.chart, null, {
            x: point.x,
            y: point.y,
            xAxis: point.series.xAxis,
            yAxis: point.series.yAxis
          });
        };
        MockPoint2.pointToPixels = function(point, paneCoordinates) {
          var series = point.series, chart = series.chart, x = point.plotX, y = point.plotY, plotBox;
          if (chart.inverted) {
            if (point.mock) {
              x = point.plotY;
              y = point.plotX;
            } else {
              x = chart.plotWidth - point.plotY;
              y = chart.plotHeight - point.plotX;
            }
          }
          if (series && !paneCoordinates) {
            plotBox = series.getPlotBox();
            x += plotBox.translateX;
            y += plotBox.translateY;
          }
          return {
            x,
            y
          };
        };
        MockPoint2.pointToOptions = function(point) {
          return {
            x: point.x,
            y: point.y,
            xAxis: point.series.xAxis,
            yAxis: point.series.yAxis
          };
        };
        MockPoint2.prototype.hasDynamicOptions = function() {
          return typeof this.options === "function";
        };
        MockPoint2.prototype.getOptions = function() {
          return this.hasDynamicOptions() ? this.options(this.target) : this.options;
        };
        MockPoint2.prototype.applyOptions = function(options) {
          this.command = options.command;
          this.setAxis(options, "x");
          this.setAxis(options, "y");
          this.refresh();
        };
        MockPoint2.prototype.setAxis = function(options, xOrY) {
          var axisName = xOrY + "Axis", axisOptions = options[axisName], chart = this.series.chart;
          this.series[axisName] = axisOptions instanceof Axis ? axisOptions : defined$l(axisOptions) ? chart[axisName][axisOptions] || chart.get(axisOptions) : null;
        };
        MockPoint2.prototype.toAnchor = function() {
          var anchor = [this.plotX, this.plotY, 0, 0];
          if (this.series.chart.inverted) {
            anchor[0] = this.plotY;
            anchor[1] = this.plotX;
          }
          return anchor;
        };
        MockPoint2.prototype.getLabelConfig = function() {
          return {
            x: this.x,
            y: this.y,
            point: this
          };
        };
        MockPoint2.prototype.isInsidePlot = function() {
          var plotX = this.plotX, plotY = this.plotY, xAxis = this.series.xAxis, yAxis = this.series.yAxis, e2 = {
            x: plotX,
            y: plotY,
            isInsidePlot: true
          };
          if (xAxis) {
            e2.isInsidePlot = defined$l(plotX) && plotX >= 0 && plotX <= xAxis.len;
          }
          if (yAxis) {
            e2.isInsidePlot = e2.isInsidePlot && defined$l(plotY) && plotY >= 0 && plotY <= yAxis.len;
          }
          fireEvent$b(this.series.chart, "afterIsInsidePlot", e2);
          return e2.isInsidePlot;
        };
        MockPoint2.prototype.refresh = function() {
          var series = this.series, xAxis = series.xAxis, yAxis = series.yAxis, options = this.getOptions();
          if (xAxis) {
            this.x = options.x;
            this.plotX = xAxis.toPixels(options.x, true);
          } else {
            this.x = null;
            this.plotX = options.x;
          }
          if (yAxis) {
            this.y = options.y;
            this.plotY = yAxis.toPixels(options.y, true);
          } else {
            this.y = null;
            this.plotY = options.y;
          }
          this.isInside = this.isInsidePlot();
        };
        MockPoint2.prototype.translate = function(_cx, _cy, dx, dy) {
          if (!this.hasDynamicOptions()) {
            this.plotX += dx;
            this.plotY += dy;
            this.refreshOptions();
          }
        };
        MockPoint2.prototype.scale = function(cx, cy, sx, sy) {
          if (!this.hasDynamicOptions()) {
            var x = this.plotX * sx, y = this.plotY * sy, tx = (1 - sx) * cx, ty = (1 - sy) * cy;
            this.plotX = tx + x;
            this.plotY = ty + y;
            this.refreshOptions();
          }
        };
        MockPoint2.prototype.rotate = function(cx, cy, radians) {
          if (!this.hasDynamicOptions()) {
            var cos2 = Math.cos(radians), sin2 = Math.sin(radians), x = this.plotX, y = this.plotY, tx = void 0, ty = void 0;
            x -= cx;
            y -= cy;
            tx = x * cos2 - y * sin2;
            ty = x * sin2 + y * cos2;
            this.plotX = tx + cx;
            this.plotY = ty + cy;
            this.refreshOptions();
          }
        };
        MockPoint2.prototype.refreshOptions = function() {
          var series = this.series, xAxis = series.xAxis, yAxis = series.yAxis;
          this.x = this.options.x = xAxis ? this.options.x = xAxis.toValue(this.plotX, true) : this.plotX;
          this.y = this.options.y = yAxis ? yAxis.toValue(this.plotY, true) : this.plotY;
        };
        return MockPoint2;
      }()
    );
    var isObject$7 = Utilities.isObject, isString$2 = Utilities.isString, merge$J = Utilities.merge, splat$6 = Utilities.splat;
    var controllableMixin = {
      /**
       * Init the controllable
       */
      init: function(annotation, options, index) {
        this.annotation = annotation;
        this.chart = annotation.chart;
        this.options = options;
        this.points = [];
        this.controlPoints = [];
        this.index = index;
        this.linkPoints();
        this.addControlPoints();
      },
      /**
       * Redirect attr usage on the controllable graphic element.
       */
      attr: function() {
        this.graphic.attr.apply(this.graphic, arguments);
      },
      /**
       * Get the controllable's points options.
       *
       * @return {Array<Highcharts.PointOptionsObject>}
       * An array of points' options.
       */
      getPointsOptions: function() {
        var options = this.options;
        return options.points || options.point && splat$6(options.point);
      },
      /**
       * Utility function for mapping item's options
       * to element's attribute
       *
       * @param {Highcharts.AnnotationsLabelsOptions|Highcharts.AnnotationsShapesOptions} options
       *
       * @return {Highcharts.SVGAttributes}
       * Mapped options.
       */
      attrsFromOptions: function(options) {
        var map = this.constructor.attrsMap, attrs = {}, key, mappedKey, styledMode = this.chart.styledMode;
        for (key in options) {
          mappedKey = map[key];
          if (mappedKey && (!styledMode || ["fill", "stroke", "stroke-width"].indexOf(mappedKey) === -1)) {
            attrs[mappedKey] = options[key];
          }
        }
        return attrs;
      },
      /**
       * Returns object which denotes anchor position - relative and absolute.
       *
       * @param {Highcharts.AnnotationPointType} point
       * A point like object.
       *
       * @return {Highcharts.AnnotationAnchorObject} a controllable anchor
       */
      anchor: function(point) {
        var plotBox = point.series.getPlotBox(), chart = point.series.chart, box = point.mock ? point.toAnchor() : Tooltip.prototype.getAnchor.call({
          chart: point.series.chart
        }, point), anchor = {
          x: box[0] + (this.options.x || 0),
          y: box[1] + (this.options.y || 0),
          height: box[2] || 0,
          width: box[3] || 0
        };
        return {
          relativePosition: anchor,
          absolutePosition: merge$J(anchor, {
            x: anchor.x + (point.mock ? plotBox.translateX : chart.plotLeft),
            y: anchor.y + (point.mock ? plotBox.translateY : chart.plotTop)
          })
        };
      },
      /**
       * Map point's options to a point-like object.
       *
       * @param {string|Function|Highcharts.AnnotationMockPointOptionsObject|Highcharts.AnnotationPointType} pointOptions
       * Point's options.
       *
       * @param {Highcharts.AnnotationPointType} point
       * A point-like instance.
       *
       * @return {Highcharts.AnnotationPointType|null}
       *         if the point is found/set returns this point, otherwise null
       */
      point: function(pointOptions, point) {
        if (pointOptions && pointOptions.series) {
          return pointOptions;
        }
        if (!point || point.series === null) {
          if (isObject$7(pointOptions)) {
            point = new MockPoint(this.chart, this, pointOptions);
          } else if (isString$2(pointOptions)) {
            point = this.chart.get(pointOptions) || null;
          } else if (typeof pointOptions === "function") {
            var pointConfig = pointOptions.call(point, this);
            point = pointConfig.series ? pointConfig : new MockPoint(this.chart, this, pointOptions);
          }
        }
        return point;
      },
      /**
       * Find point-like objects based on points options.
       *
       * @return {Array<Annotation.PointLike>} an array of point-like objects
       */
      linkPoints: function() {
        var pointsOptions = this.getPointsOptions(), points = this.points, len = pointsOptions && pointsOptions.length || 0, i, point;
        for (i = 0; i < len; i++) {
          point = this.point(pointsOptions[i], points[i]);
          if (!point) {
            points.length = 0;
            return;
          }
          if (point.mock) {
            point.refresh();
          }
          points[i] = point;
        }
        return points;
      },
      /**
       * Add control points to a controllable.
       */
      addControlPoints: function() {
        var controlPointsOptions = this.options.controlPoints;
        (controlPointsOptions || []).forEach(function(controlPointOptions, i) {
          var options = merge$J(this.options.controlPointOptions, controlPointOptions);
          if (!options.index) {
            options.index = i;
          }
          controlPointsOptions[i] = options;
          this.controlPoints.push(new ControlPoint(this.chart, this, options));
        }, this);
      },
      /**
       * Check if a controllable should be rendered/redrawn.
       *
       * @return {boolean}
       * Whether a controllable should be drawn.
       */
      shouldBeDrawn: function() {
        return Boolean(this.points.length);
      },
      /**
       * Render a controllable.
       */
      render: function(_parentGroup) {
        this.controlPoints.forEach(function(controlPoint) {
          controlPoint.render();
        });
      },
      /**
       * Redraw a controllable.
       *
       * @param {boolean} [animation]
       */
      redraw: function(animation) {
        this.controlPoints.forEach(function(controlPoint) {
          controlPoint.redraw(animation);
        });
      },
      /**
       * Transform a controllable with a specific transformation.
       *
       * @param {string} transformation a transformation name
       * @param {number|null} cx origin x transformation
       * @param {number|null} cy origin y transformation
       * @param {number} p1 param for the transformation
       * @param {number} [p2] param for the transformation
       */
      transform: function(transformation, cx, cy, p1, p2) {
        if (this.chart.inverted) {
          var temp = cx;
          cx = cy;
          cy = temp;
        }
        this.points.forEach(function(point, i) {
          this.transformPoint(transformation, cx, cy, p1, p2, i);
        }, this);
      },
      /**
       * Transform a point with a specific transformation
       * If a transformed point is a real point it is replaced with
       * the mock point.
       *
       * @param {string} transformation a transformation name
       * @param {number|null} cx origin x transformation
       * @param {number|null} cy origin y transformation
       * @param {number} p1 param for the transformation
       * @param {number|undefined} p2 param for the transformation
       * @param {number} i index of the point
       */
      transformPoint: function(transformation, cx, cy, p1, p2, i) {
        var point = this.points[i];
        if (!point.mock) {
          point = this.points[i] = MockPoint.fromPoint(point);
        }
        point[transformation](cx, cy, p1, p2);
      },
      /**
       * Translate a controllable.
       *
       * @param {number} dx translation for x coordinate
       * @param {number} dy translation for y coordinate
       **/
      translate: function(dx, dy) {
        this.transform("translate", null, null, dx, dy);
      },
      /**
       * Translate a specific point within a controllable.
       *
       * @param {number} dx translation for x coordinate
       * @param {number} dy translation for y coordinate
       * @param {number} i index of the point
       **/
      translatePoint: function(dx, dy, i) {
        this.transformPoint("translate", null, null, dx, dy, i);
      },
      /**
       * Translate shape within controllable item.
       * Replaces `controllable.translate` method.
       *
       * @param {number} dx translation for x coordinate
       * @param {number} dy translation for y coordinate
       */
      translateShape: function(dx, dy) {
        var chart = this.annotation.chart, shapeOptions = this.annotation.userOptions, annotationIndex = chart.annotations.indexOf(this.annotation), chartOptions = chart.options.annotations[annotationIndex];
        this.translatePoint(dx, dy, 0);
        chartOptions[this.collection][this.index].point = this.options.point;
        shapeOptions[this.collection][this.index].point = this.options.point;
      },
      /**
       * Rotate a controllable.
       *
       * @param {number} cx origin x rotation
       * @param {number} cy origin y rotation
       * @param {number} radians
       **/
      rotate: function(cx, cy, radians) {
        this.transform("rotate", cx, cy, radians);
      },
      /**
       * Scale a controllable.
       *
       * @param {number} cx origin x rotation
       * @param {number} cy origin y rotation
       * @param {number} sx scale factor x
       * @param {number} sy scale factor y
       */
      scale: function(cx, cy, sx, sy) {
        this.transform("scale", cx, cy, sx, sy);
      },
      /**
       * Set control points' visibility.
       *
       * @param {boolean} visible
       */
      setControlPointsVisibility: function(visible) {
        this.controlPoints.forEach(function(controlPoint) {
          controlPoint.setVisibility(visible);
        });
      },
      /**
       * Destroy a controllable.
       */
      destroy: function() {
        if (this.graphic) {
          this.graphic = this.graphic.destroy();
        }
        if (this.tracker) {
          this.tracker = this.tracker.destroy();
        }
        this.controlPoints.forEach(function(controlPoint) {
          controlPoint.destroy();
        });
        this.chart = null;
        this.points = null;
        this.controlPoints = null;
        this.options = null;
        if (this.annotation) {
          this.annotation = null;
        }
      },
      /**
       * Update a controllable.
       *
       * @param {Object} newOptions
       */
      update: function(newOptions) {
        var annotation = this.annotation, options = merge$J(true, this.options, newOptions), parentGroup = this.graphic.parentGroup;
        this.destroy();
        this.constructor(annotation, options, this.index);
        this.render(parentGroup);
        this.redraw();
      }
    };
    var addEvent$u = Utilities.addEvent, defined$k = Utilities.defined, merge$I = Utilities.merge, uniqueKey$2 = Utilities.uniqueKey;
    var defaultMarkers = {
      /**
       * @type {Highcharts.ASTNode}
       */
      arrow: {
        tagName: "marker",
        attributes: {
          id: "arrow",
          refY: 5,
          refX: 9,
          markerWidth: 10,
          markerHeight: 10
        },
        /**
         * @type {Array<Highcharts.DefsOptions>}
         */
        children: [{
          tagName: "path",
          attributes: {
            d: "M 0 0 L 10 5 L 0 10 Z",
            "stroke-width": 0
          }
        }]
      },
      /**
       * @type {Highcharts.ASTNode}
       */
      "reverse-arrow": {
        tagName: "marker",
        attributes: {
          id: "reverse-arrow",
          refY: 5,
          refX: 1,
          markerWidth: 10,
          markerHeight: 10
        },
        children: [{
          tagName: "path",
          attributes: {
            // reverse triangle (used as an arrow)
            d: "M 0 5 L 10 0 L 10 10 Z",
            "stroke-width": 0
          }
        }]
      }
    };
    SVGRenderer.prototype.addMarker = function(id, markerOptions) {
      var options = { attributes: { id } };
      var attrs = {
        stroke: markerOptions.color || "none",
        fill: markerOptions.color || "rgba(0, 0, 0, 0.75)"
      };
      options.children = markerOptions.children && markerOptions.children.map(function(child) {
        return merge$I(attrs, child);
      });
      var ast = merge$I(true, {
        attributes: {
          markerWidth: 20,
          markerHeight: 20,
          refX: 0,
          refY: 0,
          orient: "auto"
        }
      }, markerOptions, options);
      var marker = this.definition(ast);
      marker.id = id;
      return marker;
    };
    function createMarkerSetter(markerType) {
      return function(value) {
        this.attr(markerType, "url(#" + value + ")");
      };
    }
    var markerMixin = {
      markerEndSetter: createMarkerSetter("marker-end"),
      markerStartSetter: createMarkerSetter("marker-start"),
      /**
       * Set markers.
       * @private
       * @param {Highcharts.AnnotationControllablePath} item
       */
      setItemMarkers: function(item2) {
        var itemOptions = item2.options, chart = item2.chart, defs = chart.options.defs, fill = itemOptions.fill, color2 = defined$k(fill) && fill !== "none" ? fill : itemOptions.stroke, setMarker = function(markerType) {
          var markerId = itemOptions[markerType], def, predefinedMarker, key, marker;
          if (markerId) {
            for (key in defs) {
              def = defs[key];
              if ((markerId === (def.attributes && def.attributes.id) || // Legacy, for
              // unit-tests/annotations/annotations-shapes
              markerId === def.id) && def.tagName === "marker") {
                predefinedMarker = def;
                break;
              }
            }
            if (predefinedMarker) {
              marker = item2[markerType] = chart.renderer.addMarker((itemOptions.id || uniqueKey$2()) + "-" + markerId, merge$I(predefinedMarker, { color: color2 }));
              item2.attr(markerType, marker.getAttribute("id"));
            }
          }
        };
        ["markerStart", "markerEnd"].forEach(setMarker);
      }
    };
    addEvent$u(Chart$1, "afterGetContainer", function() {
      this.options.defs = merge$I(defaultMarkers, this.options.defs || {});
    });
    var extend$K = Utilities.extend;
    var TRACKER_FILL = "rgba(192,192,192," + (H.svg ? 1e-4 : 2e-3) + ")";
    var ControllablePath = (
      /** @class */
      function() {
        function ControllablePath2(annotation, options, index) {
          this.addControlPoints = controllableMixin.addControlPoints;
          this.anchor = controllableMixin.anchor;
          this.attr = controllableMixin.attr;
          this.attrsFromOptions = controllableMixin.attrsFromOptions;
          this.destroy = controllableMixin.destroy;
          this.getPointsOptions = controllableMixin.getPointsOptions;
          this.init = controllableMixin.init;
          this.linkPoints = controllableMixin.linkPoints;
          this.point = controllableMixin.point;
          this.rotate = controllableMixin.rotate;
          this.scale = controllableMixin.scale;
          this.setControlPointsVisibility = controllableMixin.setControlPointsVisibility;
          this.setMarkers = markerMixin.setItemMarkers;
          this.transform = controllableMixin.transform;
          this.transformPoint = controllableMixin.transformPoint;
          this.translate = controllableMixin.translate;
          this.translatePoint = controllableMixin.translatePoint;
          this.translateShape = controllableMixin.translateShape;
          this.update = controllableMixin.update;
          this.type = "path";
          this.init(annotation, options, index);
          this.collection = "shapes";
        }
        ControllablePath2.prototype.toD = function() {
          var dOption = this.options.d;
          if (dOption) {
            return typeof dOption === "function" ? dOption.call(this) : dOption;
          }
          var points = this.points, len = points.length, showPath = len, point = points[0], position = showPath && this.anchor(point).absolutePosition, pointIndex = 0, command, d = [];
          if (position) {
            d.push(["M", position.x, position.y]);
            while (++pointIndex < len && showPath) {
              point = points[pointIndex];
              command = point.command || "L";
              position = this.anchor(point).absolutePosition;
              if (command === "M") {
                d.push([command, position.x, position.y]);
              } else if (command === "L") {
                d.push([command, position.x, position.y]);
              } else if (command === "Z") {
                d.push([command]);
              }
              showPath = point.series.visible;
            }
          }
          return showPath ? this.chart.renderer.crispLine(d, this.graphic.strokeWidth()) : null;
        };
        ControllablePath2.prototype.shouldBeDrawn = function() {
          return controllableMixin.shouldBeDrawn.call(this) || Boolean(this.options.d);
        };
        ControllablePath2.prototype.render = function(parent) {
          var options = this.options, attrs = this.attrsFromOptions(options);
          this.graphic = this.annotation.chart.renderer.path([["M", 0, 0]]).attr(attrs).add(parent);
          if (options.className) {
            this.graphic.addClass(options.className);
          }
          this.tracker = this.annotation.chart.renderer.path([["M", 0, 0]]).addClass("highcharts-tracker-line").attr({
            zIndex: 2
          }).add(parent);
          if (!this.annotation.chart.styledMode) {
            this.tracker.attr({
              "stroke-linejoin": "round",
              stroke: TRACKER_FILL,
              fill: TRACKER_FILL,
              "stroke-width": this.graphic.strokeWidth() + options.snap * 2
            });
          }
          controllableMixin.render.call(this);
          extend$K(this.graphic, {
            markerStartSetter: markerMixin.markerStartSetter,
            markerEndSetter: markerMixin.markerEndSetter
          });
          this.setMarkers(this);
        };
        ControllablePath2.prototype.redraw = function(animation) {
          var d = this.toD(), action = animation ? "animate" : "attr";
          if (d) {
            this.graphic[action]({ d });
            this.tracker[action]({ d });
          } else {
            this.graphic.attr({ d: "M 0 " + -9e9 });
            this.tracker.attr({ d: "M 0 " + -9e9 });
          }
          this.graphic.placed = this.tracker.placed = Boolean(d);
          controllableMixin.redraw.call(this, animation);
        };
        ControllablePath2.attrsMap = {
          dashStyle: "dashstyle",
          strokeWidth: "stroke-width",
          stroke: "stroke",
          fill: "fill",
          zIndex: "zIndex"
        };
        return ControllablePath2;
      }()
    );
    var merge$H = Utilities.merge;
    var ControllableRect = (
      /** @class */
      function() {
        function ControllableRect2(annotation, options, index) {
          this.addControlPoints = controllableMixin.addControlPoints;
          this.anchor = controllableMixin.anchor;
          this.attr = controllableMixin.attr;
          this.attrsFromOptions = controllableMixin.attrsFromOptions;
          this.destroy = controllableMixin.destroy;
          this.getPointsOptions = controllableMixin.getPointsOptions;
          this.init = controllableMixin.init;
          this.linkPoints = controllableMixin.linkPoints;
          this.point = controllableMixin.point;
          this.rotate = controllableMixin.rotate;
          this.scale = controllableMixin.scale;
          this.setControlPointsVisibility = controllableMixin.setControlPointsVisibility;
          this.shouldBeDrawn = controllableMixin.shouldBeDrawn;
          this.transform = controllableMixin.transform;
          this.transformPoint = controllableMixin.transformPoint;
          this.translatePoint = controllableMixin.translatePoint;
          this.translateShape = controllableMixin.translateShape;
          this.update = controllableMixin.update;
          this.type = "rect";
          this.translate = controllableMixin.translateShape;
          this.init(annotation, options, index);
          this.collection = "shapes";
        }
        ControllableRect2.prototype.render = function(parent) {
          var attrs = this.attrsFromOptions(this.options);
          this.graphic = this.annotation.chart.renderer.rect(0, -9e9, 0, 0).attr(attrs).add(parent);
          controllableMixin.render.call(this);
        };
        ControllableRect2.prototype.redraw = function(animation) {
          var position = this.anchor(this.points[0]).absolutePosition;
          if (position) {
            this.graphic[animation ? "animate" : "attr"]({
              x: position.x,
              y: position.y,
              width: this.options.width,
              height: this.options.height
            });
          } else {
            this.attr({
              x: 0,
              y: -9e9
            });
          }
          this.graphic.placed = Boolean(position);
          controllableMixin.redraw.call(this, animation);
        };
        ControllableRect2.attrsMap = merge$H(ControllablePath.attrsMap, {
          width: "width",
          height: "height"
        });
        return ControllableRect2;
      }()
    );
    var merge$G = Utilities.merge;
    var ControllableCircle = (
      /** @class */
      function() {
        function ControllableCircle2(annotation, options, index) {
          this.addControlPoints = controllableMixin.addControlPoints;
          this.anchor = controllableMixin.anchor;
          this.attr = controllableMixin.attr;
          this.attrsFromOptions = controllableMixin.attrsFromOptions;
          this.destroy = controllableMixin.destroy;
          this.getPointsOptions = controllableMixin.getPointsOptions;
          this.init = controllableMixin.init;
          this.linkPoints = controllableMixin.linkPoints;
          this.point = controllableMixin.point;
          this.rotate = controllableMixin.rotate;
          this.scale = controllableMixin.scale;
          this.setControlPointsVisibility = controllableMixin.setControlPointsVisibility;
          this.shouldBeDrawn = controllableMixin.shouldBeDrawn;
          this.transform = controllableMixin.transform;
          this.transformPoint = controllableMixin.transformPoint;
          this.translatePoint = controllableMixin.translatePoint;
          this.translateShape = controllableMixin.translateShape;
          this.update = controllableMixin.update;
          this.type = "circle";
          this.translate = controllableMixin.translateShape;
          this.init(annotation, options, index);
          this.collection = "shapes";
        }
        ControllableCircle2.prototype.render = function(parent) {
          var attrs = this.attrsFromOptions(this.options);
          this.graphic = this.annotation.chart.renderer.circle(0, -9e9, 0).attr(attrs).add(parent);
          controllableMixin.render.call(this);
        };
        ControllableCircle2.prototype.redraw = function(animation) {
          var position = this.anchor(this.points[0]).absolutePosition;
          if (position) {
            this.graphic[animation ? "animate" : "attr"]({
              x: position.x,
              y: position.y,
              r: this.options.r
            });
          } else {
            this.graphic.attr({
              x: 0,
              y: -9e9
            });
          }
          this.graphic.placed = Boolean(position);
          controllableMixin.redraw.call(this, animation);
        };
        ControllableCircle2.prototype.setRadius = function(r) {
          this.options.r = r;
        };
        ControllableCircle2.attrsMap = merge$G(ControllablePath.attrsMap, { r: "r" });
        return ControllableCircle2;
      }()
    );
    var format$3 = FormatUtilities.format;
    var symbols$2 = SVGRenderer.prototype.symbols;
    var extend$J = Utilities.extend, isNumber$k = Utilities.isNumber, pick$L = Utilities.pick;
    var ControllableLabel = (
      /** @class */
      function() {
        function ControllableLabel2(annotation, options, index) {
          this.addControlPoints = controllableMixin.addControlPoints;
          this.attr = controllableMixin.attr;
          this.attrsFromOptions = controllableMixin.attrsFromOptions;
          this.destroy = controllableMixin.destroy;
          this.getPointsOptions = controllableMixin.getPointsOptions;
          this.init = controllableMixin.init;
          this.linkPoints = controllableMixin.linkPoints;
          this.point = controllableMixin.point;
          this.rotate = controllableMixin.rotate;
          this.scale = controllableMixin.scale;
          this.setControlPointsVisibility = controllableMixin.setControlPointsVisibility;
          this.shouldBeDrawn = controllableMixin.shouldBeDrawn;
          this.transform = controllableMixin.transform;
          this.transformPoint = controllableMixin.transformPoint;
          this.translateShape = controllableMixin.translateShape;
          this.update = controllableMixin.update;
          this.init(annotation, options, index);
          this.collection = "labels";
        }
        ControllableLabel2.alignedPosition = function(alignOptions, box) {
          var align = alignOptions.align, vAlign = alignOptions.verticalAlign;
          var x = (box.x || 0) + (alignOptions.x || 0), y = (box.y || 0) + (alignOptions.y || 0), alignFactor, vAlignFactor;
          if (align === "right") {
            alignFactor = 1;
          } else if (align === "center") {
            alignFactor = 2;
          }
          if (alignFactor) {
            x += (box.width - (alignOptions.width || 0)) / alignFactor;
          }
          if (vAlign === "bottom") {
            vAlignFactor = 1;
          } else if (vAlign === "middle") {
            vAlignFactor = 2;
          }
          if (vAlignFactor) {
            y += (box.height - (alignOptions.height || 0)) / vAlignFactor;
          }
          return {
            x: Math.round(x),
            y: Math.round(y)
          };
        };
        ControllableLabel2.justifiedOptions = function(chart, label, alignOptions, alignAttr) {
          var align = alignOptions.align, verticalAlign = alignOptions.verticalAlign, padding = label.box ? 0 : label.padding || 0, bBox = label.getBBox(), options = {
            align,
            verticalAlign,
            x: alignOptions.x,
            y: alignOptions.y,
            width: label.width,
            height: label.height
          }, x = (alignAttr.x || 0) - chart.plotLeft, y = (alignAttr.y || 0) - chart.plotTop;
          var off;
          off = x + padding;
          if (off < 0) {
            if (align === "right") {
              options.align = "left";
            } else {
              options.x = (options.x || 0) - off;
            }
          }
          off = x + bBox.width - padding;
          if (off > chart.plotWidth) {
            if (align === "left") {
              options.align = "right";
            } else {
              options.x = (options.x || 0) + chart.plotWidth - off;
            }
          }
          off = y + padding;
          if (off < 0) {
            if (verticalAlign === "bottom") {
              options.verticalAlign = "top";
            } else {
              options.y = (options.y || 0) - off;
            }
          }
          off = y + bBox.height - padding;
          if (off > chart.plotHeight) {
            if (verticalAlign === "top") {
              options.verticalAlign = "bottom";
            } else {
              options.y = (options.y || 0) + chart.plotHeight - off;
            }
          }
          return options;
        };
        ControllableLabel2.prototype.translatePoint = function(dx, dy) {
          controllableMixin.translatePoint.call(this, dx, dy, 0);
        };
        ControllableLabel2.prototype.translate = function(dx, dy) {
          var chart = this.annotation.chart, labelOptions = this.annotation.userOptions, annotationIndex = chart.annotations.indexOf(this.annotation), chartAnnotations = chart.options.annotations, chartOptions = chartAnnotations[annotationIndex];
          if (chart.inverted) {
            var temp = dx;
            dx = dy;
            dy = temp;
          }
          this.options.x += dx;
          this.options.y += dy;
          chartOptions[this.collection][this.index].x = this.options.x;
          chartOptions[this.collection][this.index].y = this.options.y;
          labelOptions[this.collection][this.index].x = this.options.x;
          labelOptions[this.collection][this.index].y = this.options.y;
        };
        ControllableLabel2.prototype.render = function(parent) {
          var options = this.options, attrs = this.attrsFromOptions(options), style = options.style;
          this.graphic = this.annotation.chart.renderer.label(
            "",
            0,
            -9999,
            // #10055
            options.shape,
            null,
            null,
            options.useHTML,
            null,
            "annotation-label"
          ).attr(attrs).add(parent);
          if (!this.annotation.chart.styledMode) {
            if (style.color === "contrast") {
              style.color = this.annotation.chart.renderer.getContrast(ControllableLabel2.shapesWithoutBackground.indexOf(options.shape) > -1 ? "#FFFFFF" : options.backgroundColor);
            }
            this.graphic.css(options.style).shadow(options.shadow);
          }
          if (options.className) {
            this.graphic.addClass(options.className);
          }
          this.graphic.labelrank = options.labelrank;
          controllableMixin.render.call(this);
        };
        ControllableLabel2.prototype.redraw = function(animation) {
          var options = this.options, text = this.text || options.format || options.text, label = this.graphic, point = this.points[0];
          label.attr({
            text: text ? format$3(text, point.getLabelConfig(), this.annotation.chart) : options.formatter.call(point, this)
          });
          var anchor = this.anchor(point);
          var attrs = this.position(anchor);
          if (attrs) {
            label.alignAttr = attrs;
            attrs.anchorX = anchor.absolutePosition.x;
            attrs.anchorY = anchor.absolutePosition.y;
            label[animation ? "animate" : "attr"](attrs);
          } else {
            label.attr({
              x: 0,
              y: -9999
              // #10055
            });
          }
          label.placed = !!attrs;
          controllableMixin.redraw.call(this, animation);
        };
        ControllableLabel2.prototype.anchor = function(_point) {
          var anchor = controllableMixin.anchor.apply(this, arguments), x = this.options.x || 0, y = this.options.y || 0;
          anchor.absolutePosition.x -= x;
          anchor.absolutePosition.y -= y;
          anchor.relativePosition.x -= x;
          anchor.relativePosition.y -= y;
          return anchor;
        };
        ControllableLabel2.prototype.position = function(anchor) {
          var item2 = this.graphic, chart = this.annotation.chart, point = this.points[0], itemOptions = this.options, anchorAbsolutePosition = anchor.absolutePosition, anchorRelativePosition = anchor.relativePosition;
          var itemPosition, alignTo, itemPosRelativeX, itemPosRelativeY, showItem = point.series.visible && MockPoint.prototype.isInsidePlot.call(point);
          var _a2 = item2.width, width = _a2 === void 0 ? 0 : _a2, _b = item2.height, height = _b === void 0 ? 0 : _b;
          if (showItem) {
            if (itemOptions.distance) {
              itemPosition = Tooltip.prototype.getPosition.call({
                chart,
                distance: pick$L(itemOptions.distance, 16)
              }, width, height, {
                plotX: anchorRelativePosition.x,
                plotY: anchorRelativePosition.y,
                negative: point.negative,
                ttBelow: point.ttBelow,
                h: anchorRelativePosition.height || anchorRelativePosition.width
              });
            } else if (itemOptions.positioner) {
              itemPosition = itemOptions.positioner.call(this);
            } else {
              alignTo = {
                x: anchorAbsolutePosition.x,
                y: anchorAbsolutePosition.y,
                width: 0,
                height: 0
              };
              itemPosition = ControllableLabel2.alignedPosition(extend$J(itemOptions, {
                width,
                height
              }), alignTo);
              if (this.options.overflow === "justify") {
                itemPosition = ControllableLabel2.alignedPosition(ControllableLabel2.justifiedOptions(chart, item2, itemOptions, itemPosition), alignTo);
              }
            }
            if (itemOptions.crop) {
              itemPosRelativeX = itemPosition.x - chart.plotLeft;
              itemPosRelativeY = itemPosition.y - chart.plotTop;
              showItem = chart.isInsidePlot(itemPosRelativeX, itemPosRelativeY) && chart.isInsidePlot(itemPosRelativeX + width, itemPosRelativeY + height);
            }
          }
          return showItem ? itemPosition : null;
        };
        ControllableLabel2.attrsMap = {
          backgroundColor: "fill",
          borderColor: "stroke",
          borderWidth: "stroke-width",
          zIndex: "zIndex",
          borderRadius: "r",
          padding: "padding"
        };
        ControllableLabel2.shapesWithoutBackground = ["connector"];
        return ControllableLabel2;
      }()
    );
    symbols$2.connector = function(x, y, w2, h, options) {
      var anchorX = options && options.anchorX, anchorY = options && options.anchorY;
      var path, yOffset, lateral = w2 / 2;
      if (isNumber$k(anchorX) && isNumber$k(anchorY)) {
        path = [["M", anchorX, anchorY]];
        yOffset = y - anchorY;
        if (yOffset < 0) {
          yOffset = -h - yOffset;
        }
        if (yOffset < w2) {
          lateral = anchorX < x + w2 / 2 ? yOffset : w2 - yOffset;
        }
        if (anchorY > y + h) {
          path.push(["L", x + lateral, y + h]);
        } else if (anchorY < y) {
          path.push(["L", x + lateral, y]);
        } else if (anchorX < x) {
          path.push(["L", x, y + h / 2]);
        } else if (anchorX > x + w2) {
          path.push(["L", x + w2, y + h / 2]);
        }
      }
      return path || [];
    };
    var ControllableImage = (
      /** @class */
      function() {
        function ControllableImage2(annotation, options, index) {
          this.addControlPoints = controllableMixin.addControlPoints;
          this.anchor = controllableMixin.anchor;
          this.attr = controllableMixin.attr;
          this.attrsFromOptions = controllableMixin.attrsFromOptions;
          this.destroy = controllableMixin.destroy;
          this.getPointsOptions = controllableMixin.getPointsOptions;
          this.init = controllableMixin.init;
          this.linkPoints = controllableMixin.linkPoints;
          this.point = controllableMixin.point;
          this.rotate = controllableMixin.rotate;
          this.scale = controllableMixin.scale;
          this.setControlPointsVisibility = controllableMixin.setControlPointsVisibility;
          this.shouldBeDrawn = controllableMixin.shouldBeDrawn;
          this.transform = controllableMixin.transform;
          this.transformPoint = controllableMixin.transformPoint;
          this.translatePoint = controllableMixin.translatePoint;
          this.translateShape = controllableMixin.translateShape;
          this.update = controllableMixin.update;
          this.type = "image";
          this.translate = controllableMixin.translateShape;
          this.init(annotation, options, index);
          this.collection = "shapes";
        }
        ControllableImage2.prototype.render = function(parent) {
          var attrs = this.attrsFromOptions(this.options), options = this.options;
          this.graphic = this.annotation.chart.renderer.image(options.src, 0, -9e9, options.width, options.height).attr(attrs).add(parent);
          this.graphic.width = options.width;
          this.graphic.height = options.height;
          controllableMixin.render.call(this);
        };
        ControllableImage2.prototype.redraw = function(animation) {
          var anchor = this.anchor(this.points[0]), position = ControllableLabel.prototype.position.call(this, anchor);
          if (position) {
            this.graphic[animation ? "animate" : "attr"]({
              x: position.x,
              y: position.y
            });
          } else {
            this.graphic.attr({
              x: 0,
              y: -9e9
            });
          }
          this.graphic.placed = Boolean(position);
          controllableMixin.redraw.call(this, animation);
        };
        ControllableImage2.attrsMap = {
          width: "width",
          height: "height",
          zIndex: "zIndex"
        };
        return ControllableImage2;
      }()
    );
    var getDeferredAnimation = animationExports.getDeferredAnimation;
    var chartProto = Chart$1.prototype;
    var addEvent$t = Utilities.addEvent, defined$j = Utilities.defined, destroyObjectProperties = Utilities.destroyObjectProperties, erase = Utilities.erase, extend$I = Utilities.extend, find$5 = Utilities.find, fireEvent$a = Utilities.fireEvent, merge$F = Utilities.merge, pick$K = Utilities.pick, splat$5 = Utilities.splat, wrap$a = Utilities.wrap;
    var Annotation = (
      /** @class */
      function() {
        function Annotation2(chart, userOptions) {
          this.annotation = void 0;
          this.coll = "annotations";
          this.collection = void 0;
          this.animationConfig = void 0;
          this.graphic = void 0;
          this.group = void 0;
          this.labelCollector = void 0;
          this.labelsGroup = void 0;
          this.shapesGroup = void 0;
          var labelsAndShapes;
          this.chart = chart;
          this.points = [];
          this.controlPoints = [];
          this.coll = "annotations";
          this.labels = [];
          this.shapes = [];
          this.options = merge$F(this.defaultOptions, userOptions);
          this.userOptions = userOptions;
          labelsAndShapes = this.getLabelsAndShapesOptions(this.options, userOptions);
          this.options.labels = labelsAndShapes.labels;
          this.options.shapes = labelsAndShapes.shapes;
          this.init(chart, this.options);
        }
        Annotation2.prototype.init = function() {
          var chart = this.chart, animOptions = this.options.animation;
          this.linkPoints();
          this.addControlPoints();
          this.addShapes();
          this.addLabels();
          this.setLabelCollector();
          this.animationConfig = getDeferredAnimation(chart, animOptions);
        };
        Annotation2.prototype.getLabelsAndShapesOptions = function(baseOptions, newOptions) {
          var mergedOptions = {};
          ["labels", "shapes"].forEach(function(name) {
            if (baseOptions[name]) {
              if (newOptions[name]) {
                mergedOptions[name] = splat$5(newOptions[name]).map(function(basicOptions, i) {
                  return merge$F(baseOptions[name][i], basicOptions);
                });
              } else {
                mergedOptions[name] = baseOptions[name];
              }
            }
          });
          return mergedOptions;
        };
        Annotation2.prototype.addShapes = function() {
          (this.options.shapes || []).forEach(function(shapeOptions, i) {
            var shape = this.initShape(shapeOptions, i);
            merge$F(true, this.options.shapes[i], shape.options);
          }, this);
        };
        Annotation2.prototype.addLabels = function() {
          (this.options.labels || []).forEach(function(labelsOptions, i) {
            var labels = this.initLabel(labelsOptions, i);
            merge$F(true, this.options.labels[i], labels.options);
          }, this);
        };
        Annotation2.prototype.addClipPaths = function() {
          this.setClipAxes();
          if (this.clipXAxis && this.clipYAxis) {
            this.clipRect = this.chart.renderer.clipRect(this.getClipBox());
          }
        };
        Annotation2.prototype.setClipAxes = function() {
          var xAxes = this.chart.xAxis, yAxes = this.chart.yAxis, linkedAxes = (this.options.labels || []).concat(this.options.shapes || []).reduce(function(axes, labelOrShape) {
            var point = labelOrShape && (labelOrShape.point || labelOrShape.points && labelOrShape.points[0]);
            return [
              xAxes[point && point.xAxis] || axes[0],
              yAxes[point && point.yAxis] || axes[1]
            ];
          }, []);
          this.clipXAxis = linkedAxes[0];
          this.clipYAxis = linkedAxes[1];
        };
        Annotation2.prototype.getClipBox = function() {
          if (this.clipXAxis && this.clipYAxis) {
            return {
              x: this.clipXAxis.left,
              y: this.clipYAxis.top,
              width: this.clipXAxis.width,
              height: this.clipYAxis.height
            };
          }
        };
        Annotation2.prototype.setLabelCollector = function() {
          var annotation = this;
          annotation.labelCollector = function() {
            return annotation.labels.reduce(function(labels, label) {
              if (!label.options.allowOverlap) {
                labels.push(label.graphic);
              }
              return labels;
            }, []);
          };
          annotation.chart.labelCollectors.push(annotation.labelCollector);
        };
        Annotation2.prototype.setOptions = function(userOptions) {
          this.options = merge$F(this.defaultOptions, userOptions);
        };
        Annotation2.prototype.redraw = function(animation) {
          this.linkPoints();
          if (!this.graphic) {
            this.render();
          }
          if (this.clipRect) {
            this.clipRect.animate(this.getClipBox());
          }
          this.redrawItems(this.shapes, animation);
          this.redrawItems(this.labels, animation);
          controllableMixin.redraw.call(this, animation);
        };
        Annotation2.prototype.redrawItems = function(items, animation) {
          var i = items.length;
          while (i--) {
            this.redrawItem(items[i], animation);
          }
        };
        Annotation2.prototype.renderItems = function(items) {
          var i = items.length;
          while (i--) {
            this.renderItem(items[i]);
          }
        };
        Annotation2.prototype.render = function() {
          var renderer = this.chart.renderer;
          this.graphic = renderer.g("annotation").attr({
            opacity: 0,
            zIndex: this.options.zIndex,
            visibility: this.options.visible ? "visible" : "hidden"
          }).add();
          this.shapesGroup = renderer.g("annotation-shapes").add(this.graphic).clip(this.chart.plotBoxClip);
          this.labelsGroup = renderer.g("annotation-labels").attr({
            // hideOverlappingLabels requires translation
            translateX: 0,
            translateY: 0
          }).add(this.graphic);
          this.addClipPaths();
          if (this.clipRect) {
            this.graphic.clip(this.clipRect);
          }
          this.renderItems(this.shapes);
          this.renderItems(this.labels);
          this.addEvents();
          controllableMixin.render.call(this);
        };
        Annotation2.prototype.setVisibility = function(visible) {
          var options = this.options, navigation2 = this.chart.navigationBindings, visibility = pick$K(visible, !options.visible);
          this.graphic.attr("visibility", visibility ? "visible" : "hidden");
          if (!visibility) {
            this.setControlPointsVisibility(false);
            if (navigation2.activeAnnotation === this && navigation2.popup && navigation2.popup.formType === "annotation-toolbar") {
              fireEvent$a(navigation2, "closePopup");
            }
          }
          options.visible = visibility;
        };
        Annotation2.prototype.setControlPointsVisibility = function(visible) {
          var setItemControlPointsVisibility = function(item2) {
            item2.setControlPointsVisibility(visible);
          };
          controllableMixin.setControlPointsVisibility.call(this, visible);
          this.shapes.forEach(setItemControlPointsVisibility);
          this.labels.forEach(setItemControlPointsVisibility);
        };
        Annotation2.prototype.destroy = function() {
          var chart = this.chart, destroyItem = function(item2) {
            item2.destroy();
          };
          this.labels.forEach(destroyItem);
          this.shapes.forEach(destroyItem);
          this.clipXAxis = null;
          this.clipYAxis = null;
          erase(chart.labelCollectors, this.labelCollector);
          eventEmitterMixin.destroy.call(this);
          controllableMixin.destroy.call(this);
          destroyObjectProperties(this, chart);
        };
        Annotation2.prototype.remove = function() {
          return this.chart.removeAnnotation(this);
        };
        Annotation2.prototype.update = function(userOptions, redraw) {
          var chart = this.chart, labelsAndShapes = this.getLabelsAndShapesOptions(this.userOptions, userOptions), userOptionsIndex = chart.annotations.indexOf(this), options = merge$F(true, this.userOptions, userOptions);
          options.labels = labelsAndShapes.labels;
          options.shapes = labelsAndShapes.shapes;
          this.destroy();
          this.constructor(chart, options);
          chart.options.annotations[userOptionsIndex] = options;
          this.isUpdating = true;
          if (pick$K(redraw, true)) {
            chart.redraw();
          }
          fireEvent$a(this, "afterUpdate");
          this.isUpdating = false;
        };
        Annotation2.prototype.initShape = function(shapeOptions, index) {
          var options = merge$F(this.options.shapeOptions, {
            controlPointOptions: this.options.controlPointOptions
          }, shapeOptions), shape = new Annotation2.shapesMap[options.type](this, options, index);
          shape.itemType = "shape";
          this.shapes.push(shape);
          return shape;
        };
        Annotation2.prototype.initLabel = function(labelOptions, index) {
          var options = merge$F(this.options.labelOptions, {
            controlPointOptions: this.options.controlPointOptions
          }, labelOptions), label = new ControllableLabel(this, options, index);
          label.itemType = "label";
          this.labels.push(label);
          return label;
        };
        Annotation2.prototype.redrawItem = function(item2, animation) {
          item2.linkPoints();
          if (!item2.shouldBeDrawn()) {
            this.destroyItem(item2);
          } else {
            if (!item2.graphic) {
              this.renderItem(item2);
            }
            item2.redraw(pick$K(animation, true) && item2.graphic.placed);
            if (item2.points.length) {
              this.adjustVisibility(item2);
            }
          }
        };
        Annotation2.prototype.adjustVisibility = function(item2) {
          var hasVisiblePoints = false, label = item2.graphic;
          item2.points.forEach(function(point) {
            if (point.series.visible !== false && point.visible !== false) {
              hasVisiblePoints = true;
            }
          });
          if (!hasVisiblePoints) {
            label.hide();
          } else if (label.visibility === "hidden") {
            label.show();
          }
        };
        Annotation2.prototype.destroyItem = function(item2) {
          erase(this[item2.itemType + "s"], item2);
          item2.destroy();
        };
        Annotation2.prototype.renderItem = function(item2) {
          item2.render(item2.itemType === "label" ? this.labelsGroup : this.shapesGroup);
        };
        Annotation2.ControlPoint = ControlPoint;
        Annotation2.MockPoint = MockPoint;
        Annotation2.shapesMap = {
          "rect": ControllableRect,
          "circle": ControllableCircle,
          "path": ControllablePath,
          "image": ControllableImage
        };
        Annotation2.types = {};
        return Annotation2;
      }()
    );
    merge$F(
      true,
      Annotation.prototype,
      controllableMixin,
      eventEmitterMixin,
      // restore original Annotation implementation after mixin overwrite
      merge$F(
        Annotation.prototype,
        /** @lends Highcharts.Annotation# */
        {
          /**
           * List of events for `annotation.options.events` that should not be
           * added to `annotation.graphic` but to the `annotation`.
           *
           * @private
           * @type {Array<string>}
           */
          nonDOMEvents: ["add", "afterUpdate", "drag", "remove"],
          /**
           * A basic type of an annotation. It allows to add custom labels
           * or shapes. The items  can be tied to points, axis coordinates
           * or chart pixel coordinates.
           *
           * @sample highcharts/annotations/basic/
           *         Basic annotations
           * @sample highcharts/demo/annotations/
           *         Advanced annotations
           * @sample highcharts/css/annotations
           *         Styled mode
           * @sample highcharts/annotations-advanced/controllable
           *         Controllable items
           * @sample {highstock} stock/annotations/fibonacci-retracements
           *         Custom annotation, Fibonacci retracement
           *
           * @type         {Array<*>}
           * @since        6.0.0
           * @requires     modules/annotations
           * @optionparent annotations
           *
           * @private
           */
          defaultOptions: {
            /**
             * Sets an ID for an annotation. Can be user later when
             * removing an annotation in [Chart#removeAnnotation(id)](
             * /class-reference/Highcharts.Chart#removeAnnotation) method.
             *
             * @type      {number|string}
             * @apioption annotations.id
             */
            /**
             * Whether the annotation is visible.
             *
             * @sample highcharts/annotations/visible/
             *         Set annotation visibility
             */
            visible: true,
            /**
             * Enable or disable the initial animation when a series is
             * displayed for the `annotation`. The animation can also be set
             * as a configuration object. Please note that this option only
             * applies to the initial animation.
             * For other animations, see [chart.animation](#chart.animation)
             * and the animation parameter under the API methods.
             * The following properties are supported:
             *
             * - `defer`: The animation delay time in milliseconds.
             *
             * @sample {highcharts} highcharts/annotations/defer/
             *          Animation defer settings
             * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
             * @since 8.2.0
             * @apioption annotations.animation
             */
            animation: {},
            /**
             * The animation delay time in milliseconds.
             * Set to `0` renders annotation immediately.
             * As `undefined` inherits defer time from the [series.animation.defer](#plotOptions.series.animation.defer).
             *
             * @type      {number}
             * @since 8.2.0
             * @apioption annotations.animation.defer
             */
            /**
             * Allow an annotation to be draggable by a user. Possible
             * values are `'x'`, `'xy'`, `'y'` and `''` (disabled).
             *
             * @sample highcharts/annotations/draggable/
             *         Annotations draggable: 'xy'
             *
             * @type {Highcharts.AnnotationDraggableValue}
             */
            draggable: "xy",
            /**
             * Options for annotation's labels. Each label inherits options
             * from the labelOptions object. An option from the labelOptions
             * can be overwritten by config for a specific label.
             *
             * @requires modules/annotations
             */
            labelOptions: {
              /**
               * The alignment of the annotation's label. If right,
               * the right side of the label should be touching the point.
               *
               * @sample highcharts/annotations/label-position/
               *         Set labels position
               *
               * @type {Highcharts.AlignValue}
               */
              align: "center",
              /**
               * Whether to allow the annotation's labels to overlap.
               * To make the labels less sensitive for overlapping,
               * the can be set to 0.
               *
               * @sample highcharts/annotations/tooltip-like/
               *         Hide overlapping labels
               */
              allowOverlap: false,
              /**
               * The background color or gradient for the annotation's
               * label.
               *
               * @sample highcharts/annotations/label-presentation/
               *         Set labels graphic options
               *
               * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               */
              backgroundColor: "rgba(0, 0, 0, 0.75)",
              /**
               * The border color for the annotation's label.
               *
               * @sample highcharts/annotations/label-presentation/
               *         Set labels graphic options
               *
               * @type {Highcharts.ColorString}
               */
              borderColor: palette.neutralColor100,
              /**
               * The border radius in pixels for the annotaiton's label.
               *
               * @sample highcharts/annotations/label-presentation/
               *         Set labels graphic options
               */
              borderRadius: 3,
              /**
               * The border width in pixels for the annotation's label
               *
               * @sample highcharts/annotations/label-presentation/
               *         Set labels graphic options
               */
              borderWidth: 1,
              /**
               * A class name for styling by CSS.
               *
               * @sample highcharts/css/annotations
               *         Styled mode annotations
               *
               * @since 6.0.5
               */
              className: "highcharts-no-tooltip",
              /**
               * Whether to hide the annotation's label
               * that is outside the plot area.
               *
               * @sample highcharts/annotations/label-crop-overflow/
               *         Crop or justify labels
               */
              crop: false,
              /**
               * The label's pixel distance from the point.
               *
               * @sample highcharts/annotations/label-position/
               *         Set labels position
               *
               * @type      {number}
               * @apioption annotations.labelOptions.distance
               */
              /**
               * A
               * [format](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
               * string for the data label.
               *
               * @see [plotOptions.series.dataLabels.format](plotOptions.series.dataLabels.format.html)
               *
               * @sample highcharts/annotations/label-text/
               *         Set labels text
               *
               * @type      {string}
               * @apioption annotations.labelOptions.format
               */
              /**
               * Alias for the format option.
               *
               * @see [format](annotations.labelOptions.format.html)
               *
               * @sample highcharts/annotations/label-text/
               *         Set labels text
               *
               * @type      {string}
               * @apioption annotations.labelOptions.text
               */
              /**
               * Callback JavaScript function to format the annotation's
               * label. Note that if a `format` or `text` are defined,
               * the format or text take precedence and the formatter is
               * ignored. `This` refers to a point object.
               *
               * @sample highcharts/annotations/label-text/
               *         Set labels text
               *
               * @type    {Highcharts.FormatterCallbackFunction<Highcharts.Point>}
               * @default function () { return defined(this.y) ? this.y : 'Annotation label'; }
               */
              formatter: function() {
                return defined$j(this.y) ? this.y : "Annotation label";
              },
              /**
               * Whether the annotation is visible in the exported data
               * table.
               *
               * @sample highcharts/annotations/include-in-data-export/
               *         Do not include in the data export
               *
               * @since 8.2.0
               * @requires modules/export-data
               */
              includeInDataExport: true,
              /**
               * How to handle the annotation's label that flow outside
               * the plot area. The justify option aligns the label inside
               * the plot area.
               *
               * @sample highcharts/annotations/label-crop-overflow/
               *         Crop or justify labels
               *
               * @validvalue ["allow", "justify"]
               */
              overflow: "justify",
              /**
               * When either the borderWidth or the backgroundColor is
               * set, this is the padding within the box.
               *
               * @sample highcharts/annotations/label-presentation/
               *         Set labels graphic options
               */
              padding: 5,
              /**
               * The shadow of the box. The shadow can be an object
               * configuration containing `color`, `offsetX`, `offsetY`,
               * `opacity` and `width`.
               *
               * @sample highcharts/annotations/label-presentation/
               *         Set labels graphic options
               *
               * @type {boolean|Highcharts.ShadowOptionsObject}
               */
              shadow: false,
              /**
               * The name of a symbol to use for the border around the
               * label. Symbols are predefined functions on the Renderer
               * object.
               *
               * @sample highcharts/annotations/shapes/
               *         Available shapes for labels
               */
              shape: "callout",
              /**
               * Styles for the annotation's label.
               *
               * @see [plotOptions.series.dataLabels.style](plotOptions.series.dataLabels.style.html)
               *
               * @sample highcharts/annotations/label-presentation/
               *         Set labels graphic options
               *
               * @type {Highcharts.CSSObject}
               */
              style: {
                /** @ignore */
                fontSize: "11px",
                /** @ignore */
                fontWeight: "normal",
                /** @ignore */
                color: "contrast"
              },
              /**
               * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
               * to render the annotation's label.
               */
              useHTML: false,
              /**
               * The vertical alignment of the annotation's label.
               *
               * @sample highcharts/annotations/label-position/
               *         Set labels position
               *
               * @type {Highcharts.VerticalAlignValue}
               */
              verticalAlign: "bottom",
              /**
               * The x position offset of the label relative to the point.
               * Note that if a `distance` is defined, the distance takes
               * precedence over `x` and `y` options.
               *
               * @sample highcharts/annotations/label-position/
               *         Set labels position
               */
              x: 0,
              /**
               * The y position offset of the label relative to the point.
               * Note that if a `distance` is defined, the distance takes
               * precedence over `x` and `y` options.
               *
               * @sample highcharts/annotations/label-position/
               *         Set labels position
               */
              y: -16
            },
            /**
             * An array of labels for the annotation. For options that apply
             * to multiple labels, they can be added to the
             * [labelOptions](annotations.labelOptions.html).
             *
             * @type      {Array<*>}
             * @extends   annotations.labelOptions
             * @apioption annotations.labels
             */
            /**
             * This option defines the point to which the label will be
             * connected. It can be either the point which exists in the
             * series - it is referenced by the point's id - or a new point
             * with defined x, y properties and optionally axes.
             *
             * @sample highcharts/annotations/mock-point/
             *         Attach annotation to a mock point
             * @sample highcharts/annotations/mock-points/
             *         Attach annotation to a mock point with different ways
             *
             * @declare   Highcharts.AnnotationMockPointOptionsObject
             * @type      {
             *               string|
             *               Highcharts.AnnotationMockPointOptionsObject|
             *               Highcharts.AnnotationMockPointFunction
             *            }
             * @requires  modules/annotations
             * @apioption annotations.labels.point
             */
            /**
             * An array of shapes for the annotation. For options that apply
             * to multiple shapes, then can be added to the
             * [shapeOptions](annotations.shapeOptions.html).
             *
             * @type      {Array<*>}
             * @extends   annotations.shapeOptions
             * @apioption annotations.shapes
             */
            /**
             * This option defines the point to which the shape will be
             * connected. It can be either the point which exists in the
             * series - it is referenced by the point's id - or a new point
             * with defined x, y properties and optionally axes.
             *
             * @sample highcharts/annotations/mock-points/
             *         Attach annotation to a mock point with different ways
             *
             * @declare   Highcharts.AnnotationMockPointOptionsObject
             * @type      {
             *               string|
             *               Highcharts.AnnotationMockPointOptionsObject|
             *               Highcharts.AnnotationMockPointFunction
             *            }
             * @extends   annotations.labels.point
             * @requires  modules/annotations
             * @apioption annotations.shapes.point
             */
            /**
             * An array of points for the shape
             * or a callback function that returns that shape point.
             *
             * This option is available
             * for shapes which can use multiple points such as path. A
             * point can be either a point object or a point's id.
             *
             * @see [annotations.shapes.point](annotations.shapes.point.html)
             *
             * @type      {Array<Highcharts.AnnotationShapePointOptions>}
             * @extends   annotations.labels.point
             * @apioption annotations.shapes.points
             */
            /**
             * The URL for an image to use as the annotation shape. Note,
             * type has to be set to `'image'`.
             *
             * @see [annotations.shapes.type](annotations.shapes.type)
             * @sample highcharts/annotations/shape-src/
             *         Define a marker image url for annotations
             *
             * @type      {string}
             * @apioption annotations.shapes.src
             */
            /**
             * Id of the marker which will be drawn at the final vertex of
             * the path. Custom markers can be defined in defs property.
             *
             * @see [defs.markers](defs.markers.html)
             *
             * @sample highcharts/annotations/custom-markers/
             *         Define a custom marker for annotations
             *
             * @type      {string}
             * @apioption annotations.shapes.markerEnd
             */
            /**
             * Id of the marker which will be drawn at the first vertex of
             * the path. Custom markers can be defined in defs property.
             *
             * @see [defs.markers](defs.markers.html)
             *
             * @sample {highcharts} highcharts/annotations/custom-markers/
             *         Define a custom marker for annotations
             *
             * @type      {string}
             * @apioption annotations.shapes.markerStart
             */
            /**
             * Options for annotation's shapes. Each shape inherits options
             * from the shapeOptions object. An option from the shapeOptions
             * can be overwritten by config for a specific shape.
             *
             * @requires  modules/annotations
             */
            shapeOptions: {
              /**
               * The width of the shape.
               *
               * @sample highcharts/annotations/shape/
               *         Basic shape annotation
               *
               * @type      {number}
               * @apioption annotations.shapeOptions.width
               **/
              /**
               * The height of the shape.
               *
               * @sample highcharts/annotations/shape/
               *         Basic shape annotation
               *
               * @type      {number}
               * @apioption annotations.shapeOptions.height
               */
              /**
               * The type of the shape, e.g. circle or rectangle.
               *
               * @sample highcharts/annotations/shape/
               *         Basic shape annotation
               *
               * @type      {string}
               * @default   rect
               * @apioption annotations.shapeOptions.type
               */
              /**
               * The URL for an image to use as the annotation shape.
               * Note, type has to be set to `'image'`.
               *
               * @see [annotations.shapeOptions.type](annotations.shapeOptions.type)
               * @sample highcharts/annotations/shape-src/
               *         Define a marker image url for annotations
               *
               * @type      {string}
               * @apioption annotations.shapeOptions.src
               */
              /**
               * Name of the dash style to use for the shape's stroke.
               *
               * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
               *         Possible values demonstrated
               *
               * @type      {Highcharts.DashStyleValue}
               * @apioption annotations.shapeOptions.dashStyle
               */
              /**
               * The color of the shape's stroke.
               *
               * @sample highcharts/annotations/shape/
               *         Basic shape annotation
               *
               * @type {Highcharts.ColorString}
               */
              stroke: "rgba(0, 0, 0, 0.75)",
              /**
               * The pixel stroke width of the shape.
               *
               * @sample highcharts/annotations/shape/
               *         Basic shape annotation
               */
              strokeWidth: 1,
              /**
               * The color of the shape's fill.
               *
               * @sample highcharts/annotations/shape/
               *         Basic shape annotation
               *
               * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               */
              fill: "rgba(0, 0, 0, 0.75)",
              /**
               * The radius of the shape.
               *
               * @sample highcharts/annotations/shape/
               *         Basic shape annotation
               */
              r: 0,
              /**
               * Defines additional snapping area around an annotation
               * making this annotation to focus. Defined in pixels.
               */
              snap: 2
            },
            /**
             * Options for annotation's control points. Each control point
             * inherits options from controlPointOptions object.
             * Options from the controlPointOptions can be overwritten
             * by options in a specific control point.
             *
             * @declare   Highcharts.AnnotationControlPointOptionsObject
             * @requires  modules/annotations
             * @apioption annotations.controlPointOptions
             */
            controlPointOptions: {
              /**
               * @type      {Highcharts.AnnotationControlPointPositionerFunction}
               * @apioption annotations.controlPointOptions.positioner
               */
              symbol: "circle",
              width: 10,
              height: 10,
              style: {
                stroke: palette.neutralColor100,
                "stroke-width": 2,
                fill: palette.backgroundColor
              },
              visible: false,
              events: {}
            },
            /**
             * Event callback when annotation is added to the chart.
             *
             * @type      {Highcharts.EventCallbackFunction<Highcharts.Annotation>}
             * @since     7.1.0
             * @apioption annotations.events.add
             */
            /**
             * Event callback when annotation is updated (e.g. drag and
             * droppped or resized by control points).
             *
             * @type      {Highcharts.EventCallbackFunction<Highcharts.Annotation>}
             * @since     7.1.0
             * @apioption annotations.events.afterUpdate
             */
            /**
             * Event callback when annotation is removed from the chart.
             *
             * @type      {Highcharts.EventCallbackFunction<Highcharts.Annotation>}
             * @since     7.1.0
             * @apioption annotations.events.remove
             */
            /**
             * Events available in annotations.
             *
             * @requires modules/annotations
             */
            events: {},
            /**
             * The Z index of the annotation.
             */
            zIndex: 6
          }
        }
      )
    );
    H.extendAnnotation = function(Constructor, BaseConstructor, prototype, defaultOptions2) {
      BaseConstructor = BaseConstructor || Annotation;
      extend$I(Constructor.prototype, merge$F(BaseConstructor.prototype, prototype));
      Constructor.prototype.defaultOptions = merge$F(Constructor.prototype.defaultOptions, defaultOptions2 || {});
    };
    extend$I(
      chartProto,
      /** @lends Highcharts.Chart# */
      {
        initAnnotation: function(userOptions) {
          var Constructor = Annotation.types[userOptions.type] || Annotation, annotation = new Constructor(this, userOptions);
          this.annotations.push(annotation);
          return annotation;
        },
        /**
         * Add an annotation to the chart after render time.
         *
         * @param  {Highcharts.AnnotationsOptions} options
         *         The annotation options for the new, detailed annotation.
         * @param {boolean} [redraw]
         *
         * @return {Highcharts.Annotation} - The newly generated annotation.
         */
        addAnnotation: function(userOptions, redraw) {
          var annotation = this.initAnnotation(userOptions);
          this.options.annotations.push(annotation.options);
          if (pick$K(redraw, true)) {
            annotation.redraw();
            annotation.graphic.attr({
              opacity: 1
            });
          }
          return annotation;
        },
        /**
         * Remove an annotation from the chart.
         *
         * @param {number|string|Highcharts.Annotation} idOrAnnotation
         * The annotation's id or direct annotation object.
         */
        removeAnnotation: function(idOrAnnotation) {
          var annotations = this.annotations, annotation = idOrAnnotation.coll === "annotations" ? idOrAnnotation : find$5(annotations, function(annotation2) {
            return annotation2.options.id === idOrAnnotation;
          });
          if (annotation) {
            fireEvent$a(annotation, "remove");
            erase(this.options.annotations, annotation.options);
            erase(annotations, annotation);
            annotation.destroy();
          }
        },
        drawAnnotations: function() {
          this.plotBoxClip.attr(this.plotBox);
          this.annotations.forEach(function(annotation) {
            annotation.redraw();
            annotation.graphic.animate({
              opacity: 1
            }, annotation.animationConfig);
          });
        }
      }
    );
    chartProto.collectionsWithUpdate.push("annotations");
    chartProto.collectionsWithInit.annotations = [chartProto.addAnnotation];
    addEvent$t(Chart$1, "afterInit", function() {
      this.annotations = [];
      if (!this.options.annotations) {
        this.options.annotations = [];
      }
    });
    chartProto.callbacks.push(function(chart) {
      chart.plotBoxClip = this.renderer.clipRect(this.plotBox);
      chart.controlPointsGroup = chart.renderer.g("control-points").attr({ zIndex: 99 }).clip(chart.plotBoxClip).add();
      chart.options.annotations.forEach(function(annotationOptions, i) {
        if (
          // Verify that it has not been previously added in a responsive rule
          !chart.annotations.some(function(annotation2) {
            return annotation2.options === annotationOptions;
          })
        ) {
          var annotation = chart.initAnnotation(annotationOptions);
          chart.options.annotations[i] = annotation.options;
        }
      });
      chart.drawAnnotations();
      addEvent$t(chart, "redraw", chart.drawAnnotations);
      addEvent$t(chart, "destroy", function() {
        chart.plotBoxClip.destroy();
        chart.controlPointsGroup.destroy();
      });
      addEvent$t(chart, "exportData", function(event) {
        var annotations = chart.annotations, csvColumnHeaderFormatter = (this.options.exporting && this.options.exporting.csv || {}).columnHeaderFormatter, multiLevelHeaders = !event.dataRows[1].xValues, annotationHeader = chart.options.lang && chart.options.lang.exportData && chart.options.lang.exportData.annotationHeader, columnHeaderFormatter = function(index) {
          var s;
          if (csvColumnHeaderFormatter) {
            s = csvColumnHeaderFormatter(index);
            if (s !== false) {
              return s;
            }
          }
          s = annotationHeader + " " + index;
          if (multiLevelHeaders) {
            return {
              columnTitle: s,
              topLevelColumnTitle: s
            };
          }
          return s;
        }, startRowLength = event.dataRows[0].length, annotationSeparator = chart.options.exporting && chart.options.exporting.csv && chart.options.exporting.csv.annotations && chart.options.exporting.csv.annotations.itemDelimiter, joinAnnotations = chart.options.exporting && chart.options.exporting.csv && chart.options.exporting.csv.annotations && chart.options.exporting.csv.annotations.join;
        annotations.forEach(function(annotation) {
          if (annotation.options.labelOptions.includeInDataExport) {
            annotation.labels.forEach(function(label) {
              if (label.options.text) {
                var annotationText_1 = label.options.text;
                label.points.forEach(function(points) {
                  var annotationX = points.x, xAxisIndex = points.series.xAxis ? points.series.xAxis.options.index : -1;
                  var wasAdded = false;
                  if (xAxisIndex === -1) {
                    var n = event.dataRows[0].length, newRow = new Array(n);
                    for (var i2 = 0; i2 < n; ++i2) {
                      newRow[i2] = "";
                    }
                    newRow.push(annotationText_1);
                    newRow.xValues = [];
                    newRow.xValues[xAxisIndex] = annotationX;
                    event.dataRows.push(newRow);
                    wasAdded = true;
                  }
                  if (!wasAdded) {
                    event.dataRows.forEach(function(row, rowIndex) {
                      if (!wasAdded && row.xValues && xAxisIndex !== void 0 && annotationX === row.xValues[xAxisIndex]) {
                        if (joinAnnotations && row.length > startRowLength) {
                          row[row.length - 1] += annotationSeparator + annotationText_1;
                        } else {
                          row.push(annotationText_1);
                        }
                        wasAdded = true;
                      }
                    });
                  }
                  if (!wasAdded) {
                    var n = event.dataRows[0].length, newRow = new Array(n);
                    for (var i2 = 0; i2 < n; ++i2) {
                      newRow[i2] = "";
                    }
                    newRow[0] = annotationX;
                    newRow.push(annotationText_1);
                    newRow.xValues = [];
                    if (xAxisIndex !== void 0) {
                      newRow.xValues[xAxisIndex] = annotationX;
                    }
                    event.dataRows.push(newRow);
                  }
                });
              }
            });
          }
        });
        var maxRowLen = 0;
        event.dataRows.forEach(function(row) {
          maxRowLen = Math.max(maxRowLen, row.length);
        });
        var newRows = maxRowLen - event.dataRows[0].length;
        for (var i = 0; i < newRows; i++) {
          var header = columnHeaderFormatter(i + 1);
          if (multiLevelHeaders) {
            event.dataRows[0].push(header.topLevelColumnTitle);
            event.dataRows[1].push(header.columnTitle);
          } else {
            event.dataRows[0].push(header);
          }
        }
      });
    });
    wrap$a(Pointer.prototype, "onContainerMouseDown", function(proceed) {
      if (!this.chart.hasDraggedAnnotation) {
        proceed.apply(this, Array.prototype.slice.call(arguments, 1));
      }
    });
    H.Annotation = Annotation;
    var chartNavigation = {
      /**
       * Initializes `chart.navigation` object which delegates `update()` methods
       * to all other common classes (used in exporting and navigationBindings).
       *
       * @private
       * @param {Highcharts.Chart} chart
       *        The chart instance.
       * @return {void}
       */
      initUpdate: function(chart) {
        if (!chart.navigation) {
          chart.navigation = {
            updates: [],
            update: function(options, redraw) {
              this.updates.forEach(function(updateConfig) {
                updateConfig.update.call(updateConfig.context, options, redraw);
              });
            }
          };
        }
      },
      /**
       * Registers an `update()` method in the `chart.navigation` object.
       *
       * @private
       * @param {Highcharts.ChartNavigationUpdateFunction} update
       *        The `update()` method that will be called in `chart.update()`.
       * @param {Highcharts.Chart} chart
       *        The chart instance. `update()` will use that as a context
       *        (`this`).
       * @return {void}
       */
      addUpdate: function(update, chart) {
        if (!chart.navigation) {
          this.initUpdate(chart);
        }
        chart.navigation.updates.push({
          update,
          context: chart
        });
      }
    };
    var format$2 = FormatUtilities.format;
    var setOptions$1 = DefaultOptions.setOptions;
    var addEvent$s = Utilities.addEvent, attr = Utilities.attr, fireEvent$9 = Utilities.fireEvent, isArray$7 = Utilities.isArray, isFunction$1 = Utilities.isFunction, isNumber$j = Utilities.isNumber, isObject$6 = Utilities.isObject, merge$E = Utilities.merge, objectEach$b = Utilities.objectEach, pick$J = Utilities.pick;
    var doc$4 = H.doc, win$2 = H.win, PREFIX$1 = "highcharts-";
    function closestPolyfill(el, s) {
      var ElementProto = win$2.Element.prototype, elementMatches = ElementProto.matches || ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector, ret = null;
      if (ElementProto.closest) {
        ret = ElementProto.closest.call(el, s);
      } else {
        do {
          if (elementMatches.call(el, s)) {
            return el;
          }
          el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
      }
      return ret;
    }
    var bindingsUtils = {
      /**
       * Get field type according to value
       *
       * @private
       * @function Highcharts.NavigationBindingsUtilsObject.getFieldType
       *
       * @param {'boolean'|'number'|'string'} value
       * Atomic type (one of: string, number, boolean)
       *
       * @return {'checkbox'|'number'|'text'}
       * Field type (one of: text, number, checkbox)
       */
      getFieldType: function(value) {
        return {
          "string": "text",
          "number": "number",
          "boolean": "checkbox"
        }[typeof value];
      },
      /**
       * Update size of background (rect) in some annotations: Measure, Simple
       * Rect.
       *
       * @private
       * @function Highcharts.NavigationBindingsUtilsObject.updateRectSize
       *
       * @param {Highcharts.PointerEventObject} event
       * Normalized browser event
       *
       * @param {Highcharts.Annotation} annotation
       * Annotation to be updated
       */
      updateRectSize: function(event, annotation) {
        var chart = annotation.chart, options = annotation.options.typeOptions, xAxis = isNumber$j(options.xAxis) && chart.xAxis[options.xAxis], yAxis = isNumber$j(options.yAxis) && chart.yAxis[options.yAxis];
        if (xAxis && yAxis) {
          var x = xAxis.toValue(event[xAxis.horiz ? "chartX" : "chartY"]), y = yAxis.toValue(event[yAxis.horiz ? "chartX" : "chartY"]), width = x - options.point.x, height = options.point.y - y;
          annotation.update({
            typeOptions: {
              background: {
                width: chart.inverted ? height : width,
                height: chart.inverted ? width : height
              }
            }
          });
        }
      },
      /**
       * Returns the first xAxis or yAxis that was clicked with its value.
       *
       * @private
       * @function Highcharts.NavigationBindingsUtilsObject#getAssignedAxis
       *
       * @param {Array<Highcharts.PointerAxisCoordinateObject>} coords
       *        All the chart's x or y axes with a current pointer's axis value.
       *
       * @return {Highcharts.PointerAxisCoordinateObject}
       *         Object with a first found axis and its value that pointer
       *         is currently pointing.
       */
      getAssignedAxis: function(coords) {
        return coords.filter(function(coord) {
          var axisMin = coord.axis.min, axisMax = coord.axis.max, minPointOffset = pick$J(coord.axis.minPointOffset, 0);
          return isNumber$j(axisMin) && isNumber$j(axisMax) && coord.value >= axisMin - minPointOffset && coord.value <= axisMax + minPointOffset && // don't count navigator axis
          !coord.axis.options.isInternal;
        })[0];
      }
    };
    var NavigationBindings = (
      /** @class */
      function() {
        function NavigationBindings2(chart, options) {
          this.boundClassNames = void 0;
          this.selectedButton = void 0;
          this.chart = chart;
          this.options = options;
          this.eventsToUnbind = [];
          this.container = doc$4.getElementsByClassName(this.options.bindingsClassName || "");
        }
        NavigationBindings2.prototype.initEvents = function() {
          var navigation2 = this, chart = navigation2.chart, bindingsContainer = navigation2.container, options = navigation2.options;
          navigation2.boundClassNames = {};
          objectEach$b(options.bindings || {}, function(value) {
            navigation2.boundClassNames[value.className] = value;
          });
          [].forEach.call(bindingsContainer, function(subContainer) {
            navigation2.eventsToUnbind.push(addEvent$s(subContainer, "click", function(event) {
              var bindings = navigation2.getButtonEvents(subContainer, event);
              if (bindings && bindings.button.className.indexOf("highcharts-disabled-btn") === -1) {
                navigation2.bindingsButtonClick(bindings.button, bindings.events, event);
              }
            }));
          });
          objectEach$b(options.events || {}, function(callback, eventName) {
            if (isFunction$1(callback)) {
              navigation2.eventsToUnbind.push(addEvent$s(navigation2, eventName, callback, { passive: false }));
            }
          });
          navigation2.eventsToUnbind.push(addEvent$s(chart.container, "click", function(e2) {
            if (!chart.cancelClick && chart.isInsidePlot(e2.chartX - chart.plotLeft, e2.chartY - chart.plotTop, {
              visiblePlotOnly: true
            })) {
              navigation2.bindingsChartClick(this, e2);
            }
          }));
          navigation2.eventsToUnbind.push(addEvent$s(chart.container, H.isTouchDevice ? "touchmove" : "mousemove", function(e2) {
            navigation2.bindingsContainerMouseMove(this, e2);
          }, H.isTouchDevice ? { passive: false } : void 0));
        };
        NavigationBindings2.prototype.initUpdate = function() {
          var navigation2 = this;
          chartNavigation.addUpdate(function(options) {
            navigation2.update(options);
          }, this.chart);
        };
        NavigationBindings2.prototype.bindingsButtonClick = function(button2, events, clickEvent) {
          var navigation2 = this, chart = navigation2.chart;
          if (navigation2.selectedButtonElement) {
            fireEvent$9(navigation2, "deselectButton", { button: navigation2.selectedButtonElement });
            if (navigation2.nextEvent) {
              if (navigation2.currentUserDetails && navigation2.currentUserDetails.coll === "annotations") {
                chart.removeAnnotation(navigation2.currentUserDetails);
              }
              navigation2.mouseMoveEvent = navigation2.nextEvent = false;
            }
          }
          navigation2.selectedButton = events;
          navigation2.selectedButtonElement = button2;
          fireEvent$9(navigation2, "selectButton", { button: button2 });
          if (events.init) {
            events.init.call(navigation2, button2, clickEvent);
          }
          if (events.start || events.steps) {
            chart.renderer.boxWrapper.addClass(PREFIX$1 + "draw-mode");
          }
        };
        NavigationBindings2.prototype.bindingsChartClick = function(chart, clickEvent) {
          chart = this.chart;
          var navigation2 = this, activeAnnotation = navigation2.activeAnnotation, selectedButton = navigation2.selectedButton, svgContainer = chart.renderer.boxWrapper;
          if (activeAnnotation) {
            if (!activeAnnotation.cancelClick && // #15729
            !clickEvent.activeAnnotation && // Element could be removed in the child action, e.g. button
            clickEvent.target.parentNode && // TO DO: Polyfill for IE11?
            !closestPolyfill(clickEvent.target, "." + PREFIX$1 + "popup")) {
              fireEvent$9(navigation2, "closePopup");
            } else if (activeAnnotation.cancelClick) {
              setTimeout(function() {
                activeAnnotation.cancelClick = false;
              }, 0);
            }
          }
          if (!selectedButton || !selectedButton.start) {
            return;
          }
          if (!navigation2.nextEvent) {
            navigation2.currentUserDetails = selectedButton.start.call(navigation2, clickEvent);
            if (navigation2.currentUserDetails && selectedButton.steps) {
              navigation2.stepIndex = 0;
              navigation2.steps = true;
              navigation2.mouseMoveEvent = navigation2.nextEvent = selectedButton.steps[navigation2.stepIndex];
            } else {
              fireEvent$9(navigation2, "deselectButton", { button: navigation2.selectedButtonElement });
              svgContainer.removeClass(PREFIX$1 + "draw-mode");
              navigation2.steps = false;
              navigation2.selectedButton = null;
              if (selectedButton.end) {
                selectedButton.end.call(navigation2, clickEvent, navigation2.currentUserDetails);
              }
            }
          } else {
            navigation2.nextEvent(clickEvent, navigation2.currentUserDetails);
            if (navigation2.steps) {
              navigation2.stepIndex++;
              if (selectedButton.steps[navigation2.stepIndex]) {
                navigation2.mouseMoveEvent = navigation2.nextEvent = selectedButton.steps[navigation2.stepIndex];
              } else {
                fireEvent$9(navigation2, "deselectButton", { button: navigation2.selectedButtonElement });
                svgContainer.removeClass(PREFIX$1 + "draw-mode");
                if (selectedButton.end) {
                  selectedButton.end.call(navigation2, clickEvent, navigation2.currentUserDetails);
                }
                navigation2.nextEvent = false;
                navigation2.mouseMoveEvent = false;
                navigation2.selectedButton = null;
              }
            }
          }
        };
        NavigationBindings2.prototype.bindingsContainerMouseMove = function(_container, moveEvent) {
          if (this.mouseMoveEvent) {
            this.mouseMoveEvent(moveEvent, this.currentUserDetails);
          }
        };
        NavigationBindings2.prototype.fieldsToOptions = function(fields2, config2) {
          objectEach$b(fields2, function(value, field) {
            var parsedValue = parseFloat(value), path = field.split("."), parent = config2, pathLength = path.length - 1;
            if (isNumber$j(parsedValue) && !value.match(/px/g) && !field.match(/format/g)) {
              value = parsedValue;
            }
            if (value !== "" && value !== "undefined") {
              path.forEach(function(name, index) {
                var nextName = pick$J(path[index + 1], "");
                if (pathLength === index) {
                  parent[name] = value;
                } else if (!parent[name]) {
                  parent[name] = nextName.match(/\d/g) ? [] : {};
                  parent = parent[name];
                } else {
                  parent = parent[name];
                }
              });
            }
          });
          return config2;
        };
        NavigationBindings2.prototype.deselectAnnotation = function() {
          if (this.activeAnnotation) {
            this.activeAnnotation.setControlPointsVisibility(false);
            this.activeAnnotation = false;
          }
        };
        NavigationBindings2.prototype.annotationToFields = function(annotation) {
          var options = annotation.options, editables = NavigationBindings2.annotationsEditable, nestedEditables = editables.nestedOptions, getFieldType = this.utils.getFieldType, type = pick$J(options.type, options.shapes && options.shapes[0] && options.shapes[0].type, options.labels && options.labels[0] && options.labels[0].itemType, "label"), nonEditables = NavigationBindings2.annotationsNonEditable[options.langKey] || [], visualOptions = {
            langKey: options.langKey,
            type
          };
          function traverse(option, key, parentEditables, parent) {
            var nextParent;
            if (parentEditables && option && nonEditables.indexOf(key) === -1 && ((parentEditables.indexOf && parentEditables.indexOf(key)) >= 0 || parentEditables[key] || // nested array
            parentEditables === true)) {
              if (isArray$7(option)) {
                parent[key] = [];
                option.forEach(function(arrayOption, i) {
                  if (!isObject$6(arrayOption)) {
                    traverse(arrayOption, 0, nestedEditables[key], parent[key]);
                  } else {
                    parent[key][i] = {};
                    objectEach$b(arrayOption, function(nestedOption, nestedKey) {
                      traverse(nestedOption, nestedKey, nestedEditables[key], parent[key][i]);
                    });
                  }
                });
              } else if (isObject$6(option)) {
                nextParent = {};
                if (isArray$7(parent)) {
                  parent.push(nextParent);
                  nextParent[key] = {};
                  nextParent = nextParent[key];
                } else {
                  parent[key] = nextParent;
                }
                objectEach$b(option, function(nestedOption, nestedKey) {
                  traverse(nestedOption, nestedKey, key === 0 ? parentEditables : nestedEditables[key], nextParent);
                });
              } else {
                if (key === "format") {
                  parent[key] = [
                    format$2(option, annotation.labels[0].points[0]).toString(),
                    "text"
                  ];
                } else if (isArray$7(parent)) {
                  parent.push([option, getFieldType(option)]);
                } else {
                  parent[key] = [option, getFieldType(option)];
                }
              }
            }
          }
          objectEach$b(options, function(option, key) {
            if (key === "typeOptions") {
              visualOptions[key] = {};
              objectEach$b(options[key], function(typeOption, typeKey) {
                traverse(typeOption, typeKey, nestedEditables, visualOptions[key]);
              });
            } else {
              traverse(option, key, editables[type], visualOptions);
            }
          });
          return visualOptions;
        };
        NavigationBindings2.prototype.getClickedClassNames = function(container, event) {
          var element = event.target, classNames = [], elemClassName;
          while (element) {
            elemClassName = attr(element, "class");
            if (elemClassName) {
              classNames = classNames.concat(elemClassName.split(" ").map(function(name) {
                return [
                  name,
                  element
                ];
              }));
            }
            element = element.parentNode;
            if (element === container) {
              return classNames;
            }
          }
          return classNames;
        };
        NavigationBindings2.prototype.getButtonEvents = function(container, event) {
          var navigation2 = this, classNames = this.getClickedClassNames(container, event), bindings;
          classNames.forEach(function(className) {
            if (navigation2.boundClassNames[className[0]] && !bindings) {
              bindings = {
                events: navigation2.boundClassNames[className[0]],
                button: className[1]
              };
            }
          });
          return bindings;
        };
        NavigationBindings2.prototype.update = function(options) {
          this.options = merge$E(true, this.options, options);
          this.removeEvents();
          this.initEvents();
        };
        NavigationBindings2.prototype.removeEvents = function() {
          this.eventsToUnbind.forEach(function(unbinder) {
            unbinder();
          });
        };
        NavigationBindings2.prototype.destroy = function() {
          this.removeEvents();
        };
        NavigationBindings2.annotationsEditable = {
          // `typeOptions` are always available
          // Nested and shared options:
          nestedOptions: {
            labelOptions: ["style", "format", "backgroundColor"],
            labels: ["style"],
            label: ["style"],
            style: ["fontSize", "color"],
            background: ["fill", "strokeWidth", "stroke"],
            innerBackground: ["fill", "strokeWidth", "stroke"],
            outerBackground: ["fill", "strokeWidth", "stroke"],
            shapeOptions: ["fill", "strokeWidth", "stroke"],
            shapes: ["fill", "strokeWidth", "stroke"],
            line: ["strokeWidth", "stroke"],
            backgroundColors: [true],
            connector: ["fill", "strokeWidth", "stroke"],
            crosshairX: ["strokeWidth", "stroke"],
            crosshairY: ["strokeWidth", "stroke"]
          },
          // Simple shapes:
          circle: ["shapes"],
          verticalLine: [],
          label: ["labelOptions"],
          // Measure
          measure: ["background", "crosshairY", "crosshairX"],
          // Others:
          fibonacci: [],
          tunnel: ["background", "line", "height"],
          pitchfork: ["innerBackground", "outerBackground"],
          rect: ["shapes"],
          // Crooked lines, elliots, arrows etc:
          crookedLine: [],
          basicAnnotation: ["shapes", "labelOptions"]
        };
        NavigationBindings2.annotationsNonEditable = {
          rectangle: ["crosshairX", "crosshairY", "label"]
        };
        return NavigationBindings2;
      }()
    );
    NavigationBindings.prototype.utils = bindingsUtils;
    Chart$1.prototype.initNavigationBindings = function() {
      var chart = this, options = chart.options;
      if (options && options.navigation && options.navigation.bindings) {
        chart.navigationBindings = new NavigationBindings(chart, options.navigation);
        chart.navigationBindings.initEvents();
        chart.navigationBindings.initUpdate();
      }
    };
    addEvent$s(Chart$1, "load", function() {
      this.initNavigationBindings();
    });
    addEvent$s(Chart$1, "destroy", function() {
      if (this.navigationBindings) {
        this.navigationBindings.destroy();
      }
    });
    addEvent$s(NavigationBindings, "deselectButton", function() {
      this.selectedButtonElement = null;
    });
    addEvent$s(Annotation, "remove", function() {
      if (this.chart.navigationBindings) {
        this.chart.navigationBindings.deselectAnnotation();
      }
    });
    function selectableAnnotation(annotationType) {
      var originalClick = annotationType.prototype.defaultOptions.events && annotationType.prototype.defaultOptions.events.click;
      function selectAndShowPopup(eventArguments) {
        var annotation = this, navigation2 = annotation.chart.navigationBindings, prevAnnotation = navigation2.activeAnnotation;
        if (originalClick) {
          originalClick.call(annotation, eventArguments);
        }
        if (prevAnnotation !== annotation) {
          navigation2.deselectAnnotation();
          navigation2.activeAnnotation = annotation;
          annotation.setControlPointsVisibility(true);
          fireEvent$9(navigation2, "showPopup", {
            annotation,
            formType: "annotation-toolbar",
            options: navigation2.annotationToFields(annotation),
            onSubmit: function(data) {
              var config2 = {}, typeOptions;
              if (data.actionType === "remove") {
                navigation2.activeAnnotation = false;
                navigation2.chart.removeAnnotation(annotation);
              } else {
                navigation2.fieldsToOptions(data.fields, config2);
                navigation2.deselectAnnotation();
                typeOptions = config2.typeOptions;
                if (annotation.options.type === "measure") {
                  typeOptions.crosshairY.enabled = typeOptions.crosshairY.strokeWidth !== 0;
                  typeOptions.crosshairX.enabled = typeOptions.crosshairX.strokeWidth !== 0;
                }
                annotation.update(config2);
              }
            }
          });
        } else {
          fireEvent$9(navigation2, "closePopup");
        }
        eventArguments.activeAnnotation = true;
      }
      merge$E(true, annotationType.prototype.defaultOptions.events, {
        click: selectAndShowPopup
      });
    }
    if (H.Annotation) {
      selectableAnnotation(Annotation);
      objectEach$b(Annotation.types, function(annotationType) {
        selectableAnnotation(annotationType);
      });
    }
    setOptions$1({
      /**
       * @optionparent lang
       *
       * @private
       */
      lang: {
        /**
         * Configure the Popup strings in the chart. Requires the
         * `annotations.js` or `annotations-advanced.src.js` module to be
         * loaded.
         *
         * @since   7.0.0
         * @product highcharts highstock
         */
        navigation: {
          /**
           * Translations for all field names used in popup.
           *
           * @product highcharts highstock
           */
          popup: {
            simpleShapes: "Simple shapes",
            lines: "Lines",
            circle: "Circle",
            rectangle: "Rectangle",
            label: "Label",
            shapeOptions: "Shape options",
            typeOptions: "Details",
            fill: "Fill",
            format: "Text",
            strokeWidth: "Line width",
            stroke: "Line color",
            title: "Title",
            name: "Name",
            labelOptions: "Label options",
            labels: "Labels",
            backgroundColor: "Background color",
            backgroundColors: "Background colors",
            borderColor: "Border color",
            borderRadius: "Border radius",
            borderWidth: "Border width",
            style: "Style",
            padding: "Padding",
            fontSize: "Font size",
            color: "Color",
            height: "Height",
            shapes: "Shape options"
          }
        }
      },
      /**
       * @optionparent navigation
       * @product      highcharts highstock
       *
       * @private
       */
      navigation: {
        /**
         * A CSS class name where all bindings will be attached to. Multiple
         * charts on the same page should have separate class names to prevent
         * duplicating events.
         *
         * Default value of versions < 7.0.4 `highcharts-bindings-wrapper`
         *
         * @since     7.0.0
         * @type      {string}
         */
        bindingsClassName: "highcharts-bindings-container",
        /**
         * Bindings definitions for custom HTML buttons. Each binding implements
         * simple event-driven interface:
         *
         * - `className`: classname used to bind event to
         *
         * - `init`: initial event, fired on button click
         *
         * - `start`: fired on first click on a chart
         *
         * - `steps`: array of sequential events fired one after another on each
         *   of users clicks
         *
         * - `end`: last event to be called after last step event
         *
         * @type         {Highcharts.Dictionary<Highcharts.NavigationBindingsOptionsObject>|*}
         * @sample       stock/stocktools/stocktools-thresholds
         *               Custom bindings in Highcharts Stock
         * @since        7.0.0
         * @product      highcharts highstock
         */
        bindings: {
          /**
           * A circle annotation bindings. Includes `start` and one event in
           * `steps` array.
           *
           * @type    {Highcharts.NavigationBindingsOptionsObject}
           * @default {"className": "highcharts-circle-annotation", "start": function() {}, "steps": [function() {}], "annotationsOptions": {}}
           */
          circleAnnotation: {
            /** @ignore-option */
            className: "highcharts-circle-annotation",
            /** @ignore-option */
            start: function(e2) {
              var coords = this.chart.pointer.getCoordinates(e2), coordsX = this.utils.getAssignedAxis(coords.xAxis), coordsY = this.utils.getAssignedAxis(coords.yAxis), navigation2 = this.chart.options.navigation;
              if (!coordsX || !coordsY) {
                return;
              }
              return this.chart.addAnnotation(merge$E({
                langKey: "circle",
                type: "basicAnnotation",
                shapes: [{
                  type: "circle",
                  point: {
                    x: coordsX.value,
                    y: coordsY.value,
                    xAxis: coordsX.axis.options.index,
                    yAxis: coordsY.axis.options.index
                  },
                  r: 5
                }]
              }, navigation2.annotationsOptions, navigation2.bindings.circleAnnotation.annotationsOptions));
            },
            /** @ignore-option */
            steps: [
              function(e2, annotation) {
                var mockPointOpts = annotation.options.shapes[0].point, inverted = this.chart.inverted, x, y, distance;
                if (isNumber$j(mockPointOpts.xAxis) && isNumber$j(mockPointOpts.yAxis)) {
                  x = this.chart.xAxis[mockPointOpts.xAxis].toPixels(mockPointOpts.x);
                  y = this.chart.yAxis[mockPointOpts.yAxis].toPixels(mockPointOpts.y);
                  distance = Math.max(Math.sqrt(Math.pow(inverted ? y - e2.chartX : x - e2.chartX, 2) + Math.pow(inverted ? x - e2.chartY : y - e2.chartY, 2)), 5);
                }
                annotation.update({
                  shapes: [{
                    r: distance
                  }]
                });
              }
            ]
          },
          /**
           * A rectangle annotation bindings. Includes `start` and one event
           * in `steps` array.
           *
           * @type    {Highcharts.NavigationBindingsOptionsObject}
           * @default {"className": "highcharts-rectangle-annotation", "start": function() {}, "steps": [function() {}], "annotationsOptions": {}}
           */
          rectangleAnnotation: {
            /** @ignore-option */
            className: "highcharts-rectangle-annotation",
            /** @ignore-option */
            start: function(e2) {
              var coords = this.chart.pointer.getCoordinates(e2), coordsX = this.utils.getAssignedAxis(coords.xAxis), coordsY = this.utils.getAssignedAxis(coords.yAxis);
              if (!coordsX || !coordsY) {
                return;
              }
              var x = coordsX.value, y = coordsY.value, xAxis = coordsX.axis.options.index, yAxis = coordsY.axis.options.index, navigation2 = this.chart.options.navigation;
              return this.chart.addAnnotation(merge$E({
                langKey: "rectangle",
                type: "basicAnnotation",
                shapes: [{
                  type: "path",
                  points: [
                    { xAxis, yAxis, x, y },
                    { xAxis, yAxis, x, y },
                    { xAxis, yAxis, x, y },
                    { xAxis, yAxis, x, y }
                  ]
                }]
              }, navigation2.annotationsOptions, navigation2.bindings.rectangleAnnotation.annotationsOptions));
            },
            /** @ignore-option */
            steps: [
              function(e2, annotation) {
                var points = annotation.options.shapes[0].points, coords = this.chart.pointer.getCoordinates(e2), coordsX = this.utils.getAssignedAxis(coords.xAxis), coordsY = this.utils.getAssignedAxis(coords.yAxis), x, y;
                if (coordsX && coordsY) {
                  x = coordsX.value;
                  y = coordsY.value;
                  points[1].x = x;
                  points[2].x = x;
                  points[2].y = y;
                  points[3].y = y;
                  annotation.update({
                    shapes: [{
                      points
                    }]
                  });
                }
              }
            ]
          },
          /**
           * A label annotation bindings. Includes `start` event only.
           *
           * @type    {Highcharts.NavigationBindingsOptionsObject}
           * @default {"className": "highcharts-label-annotation", "start": function() {}, "steps": [function() {}], "annotationsOptions": {}}
           */
          labelAnnotation: {
            /** @ignore-option */
            className: "highcharts-label-annotation",
            /** @ignore-option */
            start: function(e2) {
              var coords = this.chart.pointer.getCoordinates(e2), coordsX = this.utils.getAssignedAxis(coords.xAxis), coordsY = this.utils.getAssignedAxis(coords.yAxis), navigation2 = this.chart.options.navigation;
              if (!coordsX || !coordsY) {
                return;
              }
              return this.chart.addAnnotation(merge$E({
                langKey: "label",
                type: "basicAnnotation",
                labelOptions: {
                  format: "{y:.2f}"
                },
                labels: [{
                  point: {
                    xAxis: coordsX.axis.options.index,
                    yAxis: coordsY.axis.options.index,
                    x: coordsX.value,
                    y: coordsY.value
                  },
                  overflow: "none",
                  crop: true
                }]
              }, navigation2.annotationsOptions, navigation2.bindings.labelAnnotation.annotationsOptions));
            }
          }
        },
        /**
         * Path where Highcharts will look for icons. Change this to use icons
         * from a different server.
         *
         * @type      {string}
         * @default   https://code.highcharts.com/9.2.2/gfx/stock-icons/
         * @since     7.1.3
         * @apioption navigation.iconsURL
         */
        /**
         * A `showPopup` event. Fired when selecting for example an annotation.
         *
         * @type      {Function}
         * @apioption navigation.events.showPopup
         */
        /**
         * A `closePopup` event. Fired when Popup should be hidden, for example
         * when clicking on an annotation again.
         *
         * @type      {Function}
         * @apioption navigation.events.closePopup
         */
        /**
         * Event fired on a button click.
         *
         * @type      {Function}
         * @sample    highcharts/annotations/gui/
         *            Change icon in a dropddown on event
         * @sample    highcharts/annotations/gui-buttons/
         *            Change button class on event
         * @apioption navigation.events.selectButton
         */
        /**
         * Event fired when button state should change, for example after
         * adding an annotation.
         *
         * @type      {Function}
         * @sample    highcharts/annotations/gui/
         *            Change icon in a dropddown on event
         * @sample    highcharts/annotations/gui-buttons/
         *            Change button class on event
         * @apioption navigation.events.deselectButton
         */
        /**
         * Events to communicate between Stock Tools and custom GUI.
         *
         * @since        7.0.0
         * @product      highcharts highstock
         * @optionparent navigation.events
         */
        events: {},
        /**
         * Additional options to be merged into all annotations.
         *
         * @sample stock/stocktools/navigation-annotation-options
         *         Set red color of all line annotations
         *
         * @type      {Highcharts.AnnotationsOptions}
         * @extends   annotations
         * @exclude   crookedLine, elliottWave, fibonacci, infinityLine,
         *            measure, pitchfork, tunnel, verticalLine, basicAnnotation
         * @apioption navigation.annotationsOptions
         */
        annotationsOptions: {
          animation: {
            defer: 0
          }
        }
      }
    });
    addEvent$s(Chart$1, "render", function() {
      var chart = this, navigationBindings = chart.navigationBindings, disabledClassName = "highcharts-disabled-btn";
      if (chart && navigationBindings) {
        var buttonsEnabled_1 = false;
        chart.series.forEach(function(series) {
          if (!series.options.isInternal && series.visible) {
            buttonsEnabled_1 = true;
          }
        });
        objectEach$b(navigationBindings.boundClassNames, function(value, key) {
          if (chart.navigationBindings && chart.navigationBindings.container && chart.navigationBindings.container[0]) {
            var buttonNode = chart.navigationBindings.container[0].querySelectorAll("." + key);
            if (buttonNode) {
              for (var i = 0; i < buttonNode.length; i++) {
                var button2 = buttonNode[i];
                if (value.noDataState === "normal") {
                  if (button2.className.indexOf(disabledClassName) !== -1) {
                    button2.classList.remove(disabledClassName);
                  }
                } else if (!buttonsEnabled_1) {
                  if (button2.className.indexOf(disabledClassName) === -1) {
                    button2.className += " " + disabledClassName;
                  }
                } else {
                  if (button2.className.indexOf(disabledClassName) !== -1) {
                    button2.classList.remove(disabledClassName);
                  }
                }
              }
            }
          }
        });
      }
    });
    addEvent$s(NavigationBindings, "closePopup", function() {
      this.deselectAnnotation();
    });
    var doc$3 = H.doc, isFirefox = H.isFirefox;
    var getOptions$1 = DefaultOptions.getOptions;
    var addEvent$r = Utilities.addEvent, createElement$2 = Utilities.createElement, defined$i = Utilities.defined, fireEvent$8 = Utilities.fireEvent, isArray$6 = Utilities.isArray, isObject$5 = Utilities.isObject, isString$1 = Utilities.isString, objectEach$a = Utilities.objectEach, pick$I = Utilities.pick, stableSort$3 = Utilities.stableSort, wrap$9 = Utilities.wrap;
    var indexFilter = /\d/g, PREFIX = "highcharts-", DIV = "div", INPUT = "input", LABEL = "label", BUTTON = "button", SELECT = "select", OPTION = "option", SPAN = "span", UL = "ul", LI = "li", H3 = "h3";
    wrap$9(Pointer.prototype, "onContainerMouseDown", function(proceed, e2) {
      var popupClass = e2.target && e2.target.className;
      if (!(isString$1(popupClass) && popupClass.indexOf(PREFIX + "popup-field") >= 0)) {
        proceed.apply(this, Array.prototype.slice.call(arguments, 1));
      }
    });
    H.Popup = function(parentDiv, iconsURL, chart) {
      this.init(parentDiv, iconsURL, chart);
    };
    H.Popup.prototype = {
      /**
       * Initialize the popup. Create base div and add close button.
       * @private
       * @param {Highcharts.HTMLDOMElement} parentDiv
       * Container where popup should be placed
       * @param {string} iconsURL
       * Icon URL
       */
      init: function(parentDiv, iconsURL, chart) {
        this.chart = chart;
        this.container = createElement$2(DIV, {
          className: PREFIX + "popup highcharts-no-tooltip"
        }, null, parentDiv);
        this.lang = this.getLangpack();
        this.iconsURL = iconsURL;
        this.addCloseBtn();
      },
      /**
       * Create HTML element and attach click event (close popup).
       * @private
       */
      addCloseBtn: function() {
        var _self = this, closeBtn;
        var iconsURL = this.iconsURL;
        closeBtn = createElement$2(DIV, {
          className: PREFIX + "popup-close"
        }, null, this.container);
        closeBtn.style["background-image"] = "url(" + (iconsURL.match(/png|svg|jpeg|jpg|gif/ig) ? iconsURL : iconsURL + "close.svg") + ")";
        ["click", "touchstart"].forEach(function(eventName) {
          addEvent$r(closeBtn, eventName, function() {
            if (_self.chart) {
              fireEvent$8(_self.chart.navigationBindings, "closePopup");
            } else {
              _self.closePopup();
            }
          });
        });
      },
      /**
       * Create two columns (divs) in HTML.
       * @private
       * @param {Highcharts.HTMLDOMElement} container
       * Container of columns
       * @return {Highcharts.Dictionary<Highcharts.HTMLDOMElement>}
       * Reference to two HTML columns (lhsCol, rhsCol)
       */
      addColsContainer: function(container) {
        var rhsCol, lhsCol;
        lhsCol = createElement$2(DIV, {
          className: PREFIX + "popup-lhs-col"
        }, null, container);
        rhsCol = createElement$2(DIV, {
          className: PREFIX + "popup-rhs-col"
        }, null, container);
        createElement$2(DIV, {
          className: PREFIX + "popup-rhs-col-wrapper"
        }, null, rhsCol);
        return {
          lhsCol,
          rhsCol
        };
      },
      /**
       * Create input with label.
       * @private
       * @param {string} option
       * Chain of fields i.e params.styles.fontSize
       * @param {string} type
       * Indicator type
       * @param {Highhcharts.HTMLDOMElement}
       * Container where elements should be added
       * @param {string} value
       * Default value of input i.e period value is 14, extracted from
       * defaultOptions (ADD mode) or series options (EDIT mode)
       */
      addInput: function(option, type, parentDiv, value) {
        var optionParamList = option.split("."), optionName = optionParamList[optionParamList.length - 1], lang2 = this.lang, inputName = PREFIX + type + "-" + optionName;
        if (!inputName.match(indexFilter)) {
          createElement$2(LABEL, {
            htmlFor: inputName
          }, void 0, parentDiv).appendChild(doc$3.createTextNode(lang2[optionName] || optionName));
        }
        if (value !== "") {
          createElement$2(INPUT, {
            name: inputName,
            value: value[0],
            type: value[1],
            className: PREFIX + "popup-field"
          }, void 0, parentDiv).setAttribute(PREFIX + "data-name", option);
        }
      },
      /**
       * Create button.
       * @private
       * @param {Highcharts.HTMLDOMElement} parentDiv
       * Container where elements should be added
       * @param {string} label
       * Text placed as button label
       * @param {string} type
       * add | edit | remove
       * @param {Function} callback
       * On click callback
       * @param {Highcharts.HTMLDOMElement} fieldsDiv
       * Container where inputs are generated
       * @return {Highcharts.HTMLDOMElement}
       * HTML button
       */
      addButton: function(parentDiv, label, type, callback, fieldsDiv) {
        var _self = this, closePopup = this.closePopup, getFields = this.getFields, button2;
        button2 = createElement$2(BUTTON, void 0, void 0, parentDiv);
        button2.appendChild(doc$3.createTextNode(label));
        ["click", "touchstart"].forEach(function(eventName) {
          addEvent$r(button2, eventName, function() {
            closePopup.call(_self);
            return callback(getFields(fieldsDiv, type));
          });
        });
        return button2;
      },
      /**
       * Get values from all inputs and create JSON.
       * @private
       * @param {Highcharts.HTMLDOMElement} - container where inputs are created
       * @param {string} - add | edit | remove
       * @return {Highcharts.PopupFieldsObject} - fields
       */
      getFields: function(parentDiv, type) {
        var inputList = parentDiv.querySelectorAll("input"), optionSeries = "#" + PREFIX + "select-series > option:checked", optionVolume = "#" + PREFIX + "select-volume > option:checked", linkedTo = parentDiv.querySelectorAll(optionSeries)[0], volumeTo = parentDiv.querySelectorAll(optionVolume)[0], seriesId, param, fieldsOutput;
        fieldsOutput = {
          actionType: type,
          linkedTo: linkedTo && linkedTo.getAttribute("value"),
          fields: {}
        };
        [].forEach.call(inputList, function(input) {
          param = input.getAttribute(PREFIX + "data-name");
          seriesId = input.getAttribute(PREFIX + "data-series-id");
          if (seriesId) {
            fieldsOutput.seriesId = input.value;
          } else if (param) {
            fieldsOutput.fields[param] = input.value;
          } else {
            fieldsOutput.type = input.value;
          }
        });
        if (volumeTo) {
          fieldsOutput.fields["params.volumeSeriesID"] = volumeTo.getAttribute("value");
        }
        return fieldsOutput;
      },
      /**
       * Reset content of the current popup and show.
       * @private
       */
      showPopup: function() {
        var popupDiv = this.container, toolbarClass = PREFIX + "annotation-toolbar", popupCloseBtn = popupDiv.querySelectorAll("." + PREFIX + "popup-close")[0];
        this.formType = void 0;
        popupDiv.innerHTML = "";
        if (popupDiv.className.indexOf(toolbarClass) >= 0) {
          popupDiv.classList.remove(toolbarClass);
          popupDiv.removeAttribute("style");
        }
        popupDiv.appendChild(popupCloseBtn);
        popupDiv.style.display = "block";
        popupDiv.style.height = "";
      },
      /**
       * Hide popup.
       * @private
       */
      closePopup: function() {
        var container = pick$I(this.popup && this.popup.container, this.container);
        container.style.display = "none";
      },
      /**
       * Create content and show popup.
       * @private
       * @param {string} - type of popup i.e indicators
       * @param {Highcharts.Chart} - chart
       * @param {Highcharts.AnnotationsOptions} - options
       * @param {Function} - on click callback
       */
      showForm: function(type, chart, options, callback) {
        if (!chart) {
          return;
        }
        this.popup = chart.navigationBindings.popup;
        this.showPopup();
        if (type === "indicators") {
          this.indicators.addForm.call(this, chart, options, callback);
        }
        if (type === "annotation-toolbar") {
          this.annotations.addToolbar.call(this, chart, options, callback);
        }
        if (type === "annotation-edit") {
          this.annotations.addForm.call(this, chart, options, callback);
        }
        if (type === "flag") {
          this.annotations.addForm.call(this, chart, options, callback, true);
        }
        this.formType = type;
        this.container.style.height = this.container.offsetHeight + "px";
      },
      /**
       * Return lang definitions for popup.
       * @private
       * @return {Highcharts.Dictionary<string>} - elements translations.
       */
      getLangpack: function() {
        return getOptions$1().lang.navigation.popup;
      },
      annotations: {
        /**
         * Create annotation simple form. It contains two buttons
         * (edit / remove) and text label.
         * @private
         * @param {Highcharts.Chart} - chart
         * @param {Highcharts.AnnotationsOptions} - options
         * @param {Function} - on click callback
         */
        addToolbar: function(chart, options, callback) {
          var _self = this, lang2 = this.lang, popupDiv = this.popup.container, showForm = this.showForm, toolbarClass = PREFIX + "annotation-toolbar", button2;
          if (popupDiv.className.indexOf(toolbarClass) === -1) {
            popupDiv.className += " " + toolbarClass;
          }
          if (chart) {
            popupDiv.style.top = chart.plotTop + 10 + "px";
          }
          createElement$2(SPAN, void 0, void 0, popupDiv).appendChild(doc$3.createTextNode(pick$I(
            // Advanced annotations:
            lang2[options.langKey] || options.langKey,
            // Basic shapes:
            options.shapes && options.shapes[0].type
          )));
          button2 = this.addButton(popupDiv, lang2.removeButton || "remove", "remove", callback, popupDiv);
          button2.className += " " + PREFIX + "annotation-remove-button";
          button2.style["background-image"] = "url(" + this.iconsURL + "destroy.svg)";
          button2 = this.addButton(popupDiv, lang2.editButton || "edit", "edit", function() {
            showForm.call(_self, "annotation-edit", chart, options, callback);
          }, popupDiv);
          button2.className += " " + PREFIX + "annotation-edit-button";
          button2.style["background-image"] = "url(" + this.iconsURL + "edit.svg)";
        },
        /**
         * Create annotation simple form.
         * It contains fields with param names.
         * @private
         * @param {Highcharts.Chart} chart
         * Chart
         * @param {Object} options
         * Options
         * @param {Function} callback
         * On click callback
         * @param {boolean} [isInit]
         * If it is a form declared for init annotation
         */
        addForm: function(chart, options, callback, isInit) {
          var popupDiv = this.popup.container, lang2 = this.lang, bottomRow, lhsCol;
          if (!chart) {
            return;
          }
          lhsCol = createElement$2("h2", {
            className: PREFIX + "popup-main-title"
          }, void 0, popupDiv);
          lhsCol.appendChild(doc$3.createTextNode(lang2[options.langKey] || options.langKey || ""));
          lhsCol = createElement$2(DIV, {
            className: PREFIX + "popup-lhs-col " + PREFIX + "popup-lhs-full"
          }, null, popupDiv);
          bottomRow = createElement$2(DIV, {
            className: PREFIX + "popup-bottom-row"
          }, null, popupDiv);
          this.annotations.addFormFields.call(this, lhsCol, chart, "", options, [], true);
          this.addButton(bottomRow, isInit ? lang2.addButton || "add" : lang2.saveButton || "save", isInit ? "add" : "save", callback, popupDiv);
        },
        /**
         * Create annotation's form fields.
         * @private
         * @param {Highcharts.HTMLDOMElement} parentDiv
         * Div where inputs are placed
         * @param {Highcharts.Chart} chart
         * Chart
         * @param {string} parentNode
         * Name of parent to create chain of names
         * @param {Highcharts.AnnotationsOptions} options
         * Options
         * @param {Array<unknown>} storage
         * Array where all items are stored
         * @param {boolean} [isRoot]
         * Recursive flag for root
         */
        addFormFields: function(parentDiv, chart, parentNode, options, storage, isRoot) {
          var _self = this, addFormFields = this.annotations.addFormFields, addInput = this.addInput, lang2 = this.lang, parentFullName, titleName;
          if (!chart) {
            return;
          }
          objectEach$a(options, function(value, option) {
            parentFullName = parentNode !== "" ? parentNode + "." + option : option;
            if (isObject$5(value)) {
              if (
                // value is object of options
                !isArray$6(value) || // array of objects with params. i.e labels in Fibonacci
                isArray$6(value) && isObject$5(value[0])
              ) {
                titleName = lang2[option] || option;
                if (!titleName.match(indexFilter)) {
                  storage.push([
                    true,
                    titleName,
                    parentDiv
                  ]);
                }
                addFormFields.call(_self, parentDiv, chart, parentFullName, value, storage, false);
              } else {
                storage.push([
                  _self,
                  parentFullName,
                  "annotation",
                  parentDiv,
                  value
                ]);
              }
            }
          });
          if (isRoot) {
            stableSort$3(storage, function(a) {
              return a[1].match(/format/g) ? -1 : 1;
            });
            if (isFirefox) {
              storage.reverse();
            }
            storage.forEach(function(genInput) {
              if (genInput[0] === true) {
                createElement$2(SPAN, {
                  className: PREFIX + "annotation-title"
                }, void 0, genInput[2]).appendChild(doc$3.createTextNode(genInput[1]));
              } else {
                addInput.apply(genInput[0], genInput.splice(1));
              }
            });
          }
        }
      },
      indicators: {
        /**
         * Create indicator's form. It contains two tabs (ADD and EDIT) with
         * content.
         * @private
         */
        addForm: function(chart, _options, callback) {
          var tabsContainers, indicators = this.indicators, lang2 = this.lang, buttonParentDiv;
          if (!chart) {
            return;
          }
          this.tabs.init.call(this, chart);
          tabsContainers = this.popup.container.querySelectorAll("." + PREFIX + "tab-item-content");
          this.addColsContainer(tabsContainers[0]);
          indicators.addIndicatorList.call(this, chart, tabsContainers[0], "add");
          buttonParentDiv = tabsContainers[0].querySelectorAll("." + PREFIX + "popup-rhs-col")[0];
          this.addButton(buttonParentDiv, lang2.addButton || "add", "add", callback, buttonParentDiv);
          this.addColsContainer(tabsContainers[1]);
          indicators.addIndicatorList.call(this, chart, tabsContainers[1], "edit");
          buttonParentDiv = tabsContainers[1].querySelectorAll("." + PREFIX + "popup-rhs-col")[0];
          this.addButton(buttonParentDiv, lang2.saveButton || "save", "edit", callback, buttonParentDiv);
          this.addButton(buttonParentDiv, lang2.removeButton || "remove", "remove", callback, buttonParentDiv);
        },
        /**
         * Create HTML list of all indicators (ADD mode) or added indicators
         * (EDIT mode).
         * @private
         */
        addIndicatorList: function(chart, parentDiv, listType) {
          var _self = this, lhsCol = parentDiv.querySelectorAll("." + PREFIX + "popup-lhs-col")[0], rhsCol = parentDiv.querySelectorAll("." + PREFIX + "popup-rhs-col")[0], isEdit = listType === "edit", series = isEdit ? chart.series : (
            // EDIT mode
            chart.options.plotOptions
          ), addFormFields = this.indicators.addFormFields, rhsColWrapper, indicatorList, item2;
          if (!chart) {
            return;
          }
          indicatorList = createElement$2(UL, {
            className: PREFIX + "indicator-list"
          }, null, lhsCol);
          rhsColWrapper = rhsCol.querySelectorAll("." + PREFIX + "popup-rhs-col-wrapper")[0];
          objectEach$a(series, function(serie, value) {
            var seriesOptions = serie.options;
            if (serie.params || seriesOptions && seriesOptions.params) {
              var indicatorNameType_1 = _self.indicators.getNameType(serie, value), indicatorType_1 = indicatorNameType_1.type;
              item2 = createElement$2(LI, {
                className: PREFIX + "indicator-list"
              }, void 0, indicatorList);
              item2.appendChild(doc$3.createTextNode(indicatorNameType_1.name));
              ["click", "touchstart"].forEach(function(eventName) {
                addEvent$r(item2, eventName, function() {
                  addFormFields.call(_self, chart, isEdit ? serie : series[indicatorType_1], indicatorNameType_1.type, rhsColWrapper);
                  if (isEdit && serie.options) {
                    createElement$2(INPUT, {
                      type: "hidden",
                      name: PREFIX + "id-" + indicatorType_1,
                      value: serie.options.id
                    }, null, rhsColWrapper).setAttribute(PREFIX + "data-series-id", serie.options.id);
                  }
                });
              });
            }
          });
          if (indicatorList.childNodes.length > 0) {
            indicatorList.childNodes[0].click();
          }
        },
        /**
         * Extract full name and type of requested indicator.
         * @private
         * @param {Highcharts.Series} series
         * Series which name is needed. (EDIT mode - defaultOptions.series, ADD
         * mode - indicator series).
         * @param {string} - indicator type like: sma, ema, etc.
         * @return {Object} - series name and type like: sma, ema, etc.
         */
        getNameType: function(series, type) {
          var options = series.options, seriesTypes2 = H.seriesTypes, seriesName = seriesTypes2[type] && seriesTypes2[type].prototype.nameBase || type.toUpperCase(), seriesType = type;
          if (options && options.type) {
            seriesType = series.options.type;
            seriesName = series.name;
          }
          return {
            name: seriesName,
            type: seriesType
          };
        },
        /**
         * List all series with unique ID. Its mandatory for indicators to set
         * correct linking.
         * @private
         * @param {string} type
         * Indicator type like: sma, ema, etc.
         * @param {string} optionName
         * Type of select i.e series or volume.
         * @param {Highcharts.Chart} chart
         * Chart
         * @param {Highcharts.HTMLDOMElement} parentDiv
         * Element where created HTML list is added
         * @param {string} selectedOption
         *         optional param for default value in dropdown
         */
        listAllSeries: function(type, optionName, chart, parentDiv, selectedOption) {
          var selectName = PREFIX + optionName + "-type-" + type, lang2 = this.lang, selectBox, seriesOptions;
          if (!chart) {
            return;
          }
          createElement$2(LABEL, {
            htmlFor: selectName
          }, null, parentDiv).appendChild(doc$3.createTextNode(lang2[optionName] || optionName));
          selectBox = createElement$2(SELECT, {
            name: selectName,
            className: PREFIX + "popup-field"
          }, null, parentDiv);
          selectBox.setAttribute("id", PREFIX + "select-" + optionName);
          chart.series.forEach(function(serie) {
            seriesOptions = serie.options;
            if (!seriesOptions.params && seriesOptions.id && seriesOptions.id !== PREFIX + "navigator-series") {
              createElement$2(OPTION, {
                value: seriesOptions.id
              }, null, selectBox).appendChild(doc$3.createTextNode(seriesOptions.name || seriesOptions.id));
            }
          });
          if (defined$i(selectedOption)) {
            selectBox.value = selectedOption;
          }
        },
        /**
         * Create typical inputs for chosen indicator. Fields are extracted from
         * defaultOptions (ADD mode) or current indicator (ADD mode). Two extra
         * fields are added:
         * - hidden input - contains indicator type (required for callback)
         * - select - list of series which can be linked with indicator
         * @private
         * @param {Highcharts.Chart} chart
         * Chart
         * @param {Highcharts.Series} series
         * Indicator
         * @param {string} seriesType
         * Indicator type like: sma, ema, etc.
         * @param {Highcharts.HTMLDOMElement} rhsColWrapper
         * Element where created HTML list is added
         */
        addFormFields: function(chart, series, seriesType, rhsColWrapper) {
          var fields2 = series.params || series.options.params, getNameType = this.indicators.getNameType;
          rhsColWrapper.innerHTML = "";
          createElement$2(H3, {
            className: PREFIX + "indicator-title"
          }, void 0, rhsColWrapper).appendChild(doc$3.createTextNode(getNameType(series, seriesType).name));
          createElement$2(INPUT, {
            type: "hidden",
            name: PREFIX + "type-" + seriesType,
            value: seriesType
          }, null, rhsColWrapper);
          this.indicators.listAllSeries.call(this, seriesType, "series", chart, rhsColWrapper, series.linkedParent && fields2.volumeSeriesID);
          if (fields2.volumeSeriesID) {
            this.indicators.listAllSeries.call(this, seriesType, "volume", chart, rhsColWrapper, series.linkedParent && series.linkedParent.options.id);
          }
          this.indicators.addParamInputs.call(this, chart, "params", fields2, seriesType, rhsColWrapper);
        },
        /**
         * Recurent function which lists all fields, from params object and
         * create them as inputs. Each input has unique `data-name` attribute,
         * which keeps chain of fields i.e params.styles.fontSize.
         * @private
         * @param {Highcharts.Chart} chart
         * Chart
         * @param {string} parentNode
         * Name of parent to create chain of names
         * @param {Highcharts.PopupFieldsDictionary<string>} fields
         * Params which are based for input create
         * @param {string} type
         * Indicator type like: sma, ema, etc.
         * @param {Highcharts.HTMLDOMElement} parentDiv
         * Element where created HTML list is added
         */
        addParamInputs: function(chart, parentNode, fields2, type, parentDiv) {
          var _self = this, addParamInputs = this.indicators.addParamInputs, addInput = this.addInput, parentFullName;
          if (!chart) {
            return;
          }
          objectEach$a(fields2, function(value, fieldName) {
            parentFullName = parentNode + "." + fieldName;
            if (value !== void 0) {
              if (isObject$5(value)) {
                addInput.call(
                  // (15733) 'Periods' has an arrayed value. Label must be created here.
                  _self,
                  parentFullName,
                  type,
                  parentDiv,
                  ""
                );
                addParamInputs.call(_self, chart, parentFullName, value, type, parentDiv);
              } else if (
                // skip volume field which is created by addFormFields
                parentFullName !== "params.volumeSeriesID"
              ) {
                addInput.call(
                  _self,
                  parentFullName,
                  type,
                  parentDiv,
                  [value, "text"]
                  // all inputs are text type
                );
              }
            }
          });
        },
        /**
         * Get amount of indicators added to chart.
         * @private
         * @return {number} - Amount of indicators
         */
        getAmount: function() {
          var series = this.series, counter = 0;
          series.forEach(function(serie) {
            var seriesOptions = serie.options;
            if (serie.params || seriesOptions && seriesOptions.params) {
              counter++;
            }
          });
          return counter;
        }
      },
      tabs: {
        /**
         * Init tabs. Create tab menu items, tabs containers
         * @private
         * @param {Highcharts.Chart} chart
         * Reference to current chart
         */
        init: function(chart) {
          var tabs = this.tabs, indicatorsCount = this.indicators.getAmount.call(chart), firstTab;
          if (!chart) {
            return;
          }
          firstTab = tabs.addMenuItem.call(this, "add");
          tabs.addMenuItem.call(this, "edit", indicatorsCount);
          tabs.addContentItem.call(this, "add");
          tabs.addContentItem.call(this, "edit");
          tabs.switchTabs.call(this, indicatorsCount);
          tabs.selectTab.call(this, firstTab, 0);
        },
        /**
         * Create tab menu item
         * @private
         * @param {string} tabName
         * `add` or `edit`
         * @param {number} [disableTab]
         * Disable tab when 0
         * @return {Highcharts.HTMLDOMElement}
         * Created HTML tab-menu element
         */
        addMenuItem: function(tabName, disableTab) {
          var popupDiv = this.popup.container, className = PREFIX + "tab-item", lang2 = this.lang, menuItem;
          if (disableTab === 0) {
            className += " " + PREFIX + "tab-disabled";
          }
          menuItem = createElement$2(SPAN, {
            className
          }, void 0, popupDiv);
          menuItem.appendChild(doc$3.createTextNode(lang2[tabName + "Button"] || tabName));
          menuItem.setAttribute(PREFIX + "data-tab-type", tabName);
          return menuItem;
        },
        /**
         * Create tab content
         * @private
         * @return {HTMLDOMElement} - created HTML tab-content element
         */
        addContentItem: function() {
          var popupDiv = this.popup.container;
          return createElement$2(DIV, {
            className: PREFIX + "tab-item-content " + PREFIX + "no-mousewheel"
            // #12100
          }, null, popupDiv);
        },
        /**
         * Add click event to each tab
         * @private
         * @param {number} disableTab
         * Disable tab when 0
         */
        switchTabs: function(disableTab) {
          var _self = this, popupDiv = this.popup.container, tabs = popupDiv.querySelectorAll("." + PREFIX + "tab-item"), dataParam;
          tabs.forEach(function(tab, i) {
            dataParam = tab.getAttribute(PREFIX + "data-tab-type");
            if (dataParam === "edit" && disableTab === 0) {
              return;
            }
            ["click", "touchstart"].forEach(function(eventName) {
              addEvent$r(tab, eventName, function() {
                _self.tabs.deselectAll.call(_self);
                _self.tabs.selectTab.call(_self, this, i);
              });
            });
          });
        },
        /**
         * Set tab as visible
         * @private
         * @param {globals.Element} - current tab
         * @param {number} - Index of tab in menu
         */
        selectTab: function(tab, index) {
          var allTabs = this.popup.container.querySelectorAll("." + PREFIX + "tab-item-content");
          tab.className += " " + PREFIX + "tab-item-active";
          allTabs[index].className += " " + PREFIX + "tab-item-show";
        },
        /**
         * Set all tabs as invisible.
         * @private
         */
        deselectAll: function() {
          var popupDiv = this.popup.container, tabs = popupDiv.querySelectorAll("." + PREFIX + "tab-item"), tabsContent = popupDiv.querySelectorAll("." + PREFIX + "tab-item-content"), i;
          for (i = 0; i < tabs.length; i++) {
            tabs[i].classList.remove(PREFIX + "tab-item-active");
            tabsContent[i].classList.remove(PREFIX + "tab-item-show");
          }
        }
      }
    };
    addEvent$r(NavigationBindings, "showPopup", function(config2) {
      if (!this.popup) {
        this.popup = new H.Popup(this.chart.container, this.chart.options.navigation.iconsURL || this.chart.options.stockTools && this.chart.options.stockTools.gui.iconsURL || "https://code.highcharts.com/9.2.2/gfx/stock-icons/", this.chart);
      }
      this.popup.showForm(config2.formType, this.chart, config2.options, config2.onSubmit);
    });
    addEvent$r(NavigationBindings, "closePopup", function() {
      if (this.popup) {
        this.popup.closePopup();
      }
    });
    H.Popup;
    var addEvent$q = Utilities.addEvent, extend$H = Utilities.extend, merge$D = Utilities.merge, pick$H = Utilities.pick, splat$4 = Utilities.splat;
    Chart$1.prototype.collectionsWithUpdate.push("pane");
    var Pane = (
      /** @class */
      function() {
        function Pane2(options, chart) {
          this.background = void 0;
          this.center = void 0;
          this.chart = void 0;
          this.options = void 0;
          this.coll = "pane";
          this.defaultOptions = {
            /**
             * The end angle of the polar X axis or gauge value axis, given in
             * degrees where 0 is north. Defaults to [startAngle](#pane.startAngle)
             * + 360.
             *
             * @sample {highcharts} highcharts/demo/gauge-vu-meter/
             *         VU-meter with custom start and end angle
             *
             * @type      {number}
             * @since     2.3.0
             * @product   highcharts
             * @apioption pane.endAngle
             */
            /**
             * The center of a polar chart or angular gauge, given as an array
             * of [x, y] positions. Positions can be given as integers that
             * transform to pixels, or as percentages of the plot area size.
             *
             * @sample {highcharts} highcharts/demo/gauge-vu-meter/
             *         Two gauges with different center
             *
             * @type    {Array<string|number>}
             * @default ["50%", "50%"]
             * @since   2.3.0
             * @product highcharts
             */
            center: ["50%", "50%"],
            /**
             * The size of the pane, either as a number defining pixels, or a
             * percentage defining a percentage of the available plot area (the
             * smallest of the plot height or plot width).
             *
             * @sample {highcharts} highcharts/demo/gauge-vu-meter/
             *         Smaller size
             *
             * @type    {number|string}
             * @product highcharts
             */
            size: "85%",
            /**
             * The inner size of the pane, either as a number defining pixels, or a
             * percentage defining a percentage of the pane's size.
             *
             * @sample {highcharts} highcharts/series-polar/column-inverted-inner
             *         The inner size set to 20%
             *
             * @type    {number|string}
             * @product highcharts
             */
            innerSize: "0%",
            /**
             * The start angle of the polar X axis or gauge axis, given in degrees
             * where 0 is north. Defaults to 0.
             *
             * @sample {highcharts} highcharts/demo/gauge-vu-meter/
             *         VU-meter with custom start and end angle
             *
             * @since   2.3.0
             * @product highcharts
             */
            startAngle: 0
          };
          this.defaultBackgroundOptions = {
            /**
             * The class name for this background.
             *
             * @sample {highcharts} highcharts/css/pane/
             *         Panes styled by CSS
             * @sample {highstock} highcharts/css/pane/
             *         Panes styled by CSS
             * @sample {highmaps} highcharts/css/pane/
             *         Panes styled by CSS
             *
             * @type      {string}
             * @default   highcharts-pane
             * @since     5.0.0
             * @apioption pane.background.className
             */
            /**
             * The shape of the pane background. When `solid`, the background
             * is circular. When `arc`, the background extends only from the min
             * to the max of the value axis.
             *
             * @type    {Highcharts.PaneBackgroundShapeValue}
             * @since   2.3.0
             * @product highcharts
             */
            shape: "circle",
            /**
             * The pixel border width of the pane background.
             *
             * @since 2.3.0
             * @product highcharts
             */
            borderWidth: 1,
            /**
             * The pane background border color.
             *
             * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @since   2.3.0
             * @product highcharts
             */
            borderColor: palette.neutralColor20,
            /**
             * The background color or gradient for the pane.
             *
             * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @default { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, #ffffff], [1, #e6e6e6]] }
             * @since   2.3.0
             * @product highcharts
             */
            backgroundColor: {
              /** @ignore-option */
              linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
              /** @ignore-option */
              stops: [
                [0, palette.backgroundColor],
                [1, palette.neutralColor10]
              ]
            },
            /** @ignore-option */
            from: -Number.MAX_VALUE,
            /**
             * The inner radius of the pane background. Can be either numeric
             * (pixels) or a percentage string.
             *
             * @type    {number|string}
             * @since   2.3.0
             * @product highcharts
             */
            innerRadius: 0,
            /** @ignore-option */
            to: Number.MAX_VALUE,
            /**
             * The outer radius of the circular pane background. Can be either
             * numeric (pixels) or a percentage string.
             *
             * @type     {number|string}
             * @since    2.3.0
             * @product  highcharts
             */
            outerRadius: "105%"
          };
          this.init(options, chart);
        }
        Pane2.prototype.init = function(options, chart) {
          this.chart = chart;
          this.background = [];
          chart.pane.push(this);
          this.setOptions(options);
        };
        Pane2.prototype.setOptions = function(options) {
          this.options = options = merge$D(this.defaultOptions, this.chart.angular ? { background: {} } : void 0, options);
        };
        Pane2.prototype.render = function() {
          var options = this.options, backgroundOption = this.options.background, renderer = this.chart.renderer, len, i;
          if (!this.group) {
            this.group = renderer.g("pane-group").attr({ zIndex: options.zIndex || 0 }).add();
          }
          this.updateCenter();
          if (backgroundOption) {
            backgroundOption = splat$4(backgroundOption);
            len = Math.max(backgroundOption.length, this.background.length || 0);
            for (i = 0; i < len; i++) {
              if (backgroundOption[i] && this.axis) {
                this.renderBackground(merge$D(this.defaultBackgroundOptions, backgroundOption[i]), i);
              } else if (this.background[i]) {
                this.background[i] = this.background[i].destroy();
                this.background.splice(i, 1);
              }
            }
          }
        };
        Pane2.prototype.renderBackground = function(backgroundOptions, i) {
          var method = "animate", attribs = {
            "class": "highcharts-pane " + (backgroundOptions.className || "")
          };
          if (!this.chart.styledMode) {
            extend$H(attribs, {
              "fill": backgroundOptions.backgroundColor,
              "stroke": backgroundOptions.borderColor,
              "stroke-width": backgroundOptions.borderWidth
            });
          }
          if (!this.background[i]) {
            this.background[i] = this.chart.renderer.path().add(this.group);
            method = "attr";
          }
          this.background[i][method]({
            "d": this.axis.getPlotBandPath(backgroundOptions.from, backgroundOptions.to, backgroundOptions)
          }).attr(attribs);
        };
        Pane2.prototype.updateCenter = function(axis) {
          this.center = (axis || this.axis || {}).center = centeredSeriesMixin.getCenter.call(this);
        };
        Pane2.prototype.update = function(options, redraw) {
          merge$D(true, this.options, options);
          this.setOptions(this.options);
          this.render();
          this.chart.axes.forEach(function(axis) {
            if (axis.pane === this) {
              axis.pane = null;
              axis.update({}, redraw);
            }
          }, this);
        };
        return Pane2;
      }()
    );
    function isInsidePane(x, y, center) {
      return Math.sqrt(Math.pow(x - center[0], 2) + Math.pow(y - center[1], 2)) <= center[2] / 2;
    }
    Chart$1.prototype.getHoverPane = function(eventArgs) {
      var chart = this;
      var hoverPane;
      if (eventArgs) {
        chart.pane.forEach(function(pane) {
          var plotX = eventArgs.chartX - chart.plotLeft, plotY = eventArgs.chartY - chart.plotTop, x = chart.inverted ? plotY : plotX, y = chart.inverted ? plotX : plotY;
          if (isInsidePane(x, y, pane.center)) {
            hoverPane = pane;
          }
        });
      }
      return hoverPane;
    };
    addEvent$q(Chart$1, "afterIsInsidePlot", function(e2) {
      var chart = this;
      if (chart.polar) {
        e2.isInsidePlot = chart.pane.some(function(pane) {
          return isInsidePane(e2.x, e2.y, pane.center);
        });
      }
    });
    addEvent$q(Pointer, "beforeGetHoverData", function(eventArgs) {
      var chart = this.chart;
      if (chart.polar) {
        chart.hoverPane = chart.getHoverPane(eventArgs);
        eventArgs.filter = function(s) {
          return s.visible && !(!eventArgs.shared && s.directTouch) && // #3821
          pick$H(s.options.enableMouseTracking, true) && (!chart.hoverPane || s.xAxis.pane === chart.hoverPane);
        };
      } else {
        chart.hoverPane = void 0;
      }
    });
    addEvent$q(Pointer, "afterGetHoverData", function(eventArgs) {
      var chart = this.chart;
      if (eventArgs.hoverPoint && eventArgs.hoverPoint.plotX && eventArgs.hoverPoint.plotY && chart.hoverPane && !isInsidePane(eventArgs.hoverPoint.plotX, eventArgs.hoverPoint.plotY, chart.hoverPane.center)) {
        eventArgs.hoverPoint = void 0;
      }
    });
    H.Pane = Pane;
    const Pane$1 = H.Pane;
    var defaultOptions$4 = DefaultOptions.defaultOptions;
    var noop$c = H.noop;
    var addEvent$p = Utilities.addEvent, correctFloat$3 = Utilities.correctFloat, defined$h = Utilities.defined, extend$G = Utilities.extend, fireEvent$7 = Utilities.fireEvent, merge$C = Utilities.merge, pick$G = Utilities.pick, relativeLength$2 = Utilities.relativeLength, wrap$8 = Utilities.wrap;
    var RadialAxis;
    (function(RadialAxis2) {
      var composedClasses2 = [];
      var defaultCircularOptions = {
        gridLineWidth: 1,
        labels: {
          align: void 0,
          distance: 15,
          x: 0,
          y: void 0,
          style: {
            textOverflow: "none"
            // wrap lines by default (#7248)
          }
        },
        maxPadding: 0,
        minPadding: 0,
        showLastLabel: false,
        tickLength: 0
      };
      var defaultRadialGaugeOptions = {
        labels: {
          align: "center",
          x: 0,
          y: void 0
          // auto
        },
        minorGridLineWidth: 0,
        minorTickInterval: "auto",
        minorTickLength: 10,
        minorTickPosition: "inside",
        minorTickWidth: 1,
        tickLength: 10,
        tickPosition: "inside",
        tickWidth: 2,
        title: {
          rotation: 0
        },
        zIndex: 2
        // behind dials, points in the series group
      };
      var defaultRadialOptions = {
        /**
         * In a polar chart, this is the angle of the Y axis in degrees, where
         * 0 is up and 90 is right. The angle determines the position of the
         * axis line and the labels, though the coordinate system is unaffected.
         * Since v8.0.0 this option is also applicable for X axis (inverted
         * polar).
         *
         * @sample {highcharts} highcharts/xaxis/angle/
         *         Custom X axis' angle on inverted polar chart
         * @sample {highcharts} highcharts/yaxis/angle/
         *         Dual axis polar chart
         *
         * @type      {number}
         * @default   0
         * @since     4.2.7
         * @product   highcharts
         * @apioption xAxis.angle
         */
        /**
         * Polar charts only. Whether the grid lines should draw as a polygon
         * with straight lines between categories, or as circles. Can be either
         * `circle` or `polygon`. Since v8.0.0 this option is also applicable
         * for X axis (inverted polar).
         *
         * @sample {highcharts} highcharts/demo/polar-spider/
         *         Polygon grid lines
         * @sample {highcharts} highcharts/xaxis/gridlineinterpolation/
         *         Circle and polygon on inverted polar
         * @sample {highcharts} highcharts/yaxis/gridlineinterpolation/
         *         Circle and polygon
         *
         * @type       {string}
         * @product    highcharts
         * @validvalue ["circle", "polygon"]
         * @apioption  xAxis.gridLineInterpolation
         */
        gridLineInterpolation: "circle",
        gridLineWidth: 1,
        labels: {
          align: "right",
          x: -3,
          y: -2
        },
        showLastLabel: false,
        title: {
          x: 4,
          text: null,
          rotation: 90
        }
      };
      function beforeSetTickPositions() {
        this.autoConnect = this.isCircular && typeof pick$G(this.userMax, this.options.max) === "undefined" && correctFloat$3(this.endAngleRad - this.startAngleRad) === correctFloat$3(2 * Math.PI);
        if (!this.isCircular && this.chart.inverted) {
          this.max++;
        }
        if (this.autoConnect) {
          this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0;
        }
      }
      function compose(AxisClass, TickClass) {
        if (composedClasses2.indexOf(AxisClass) === -1) {
          composedClasses2.push(AxisClass);
          addEvent$p(AxisClass, "afterInit", onAxisAfterInit);
          addEvent$p(AxisClass, "autoLabelAlign", onAxisAutoLabelAlign);
          addEvent$p(AxisClass, "destroy", onAxisDestroy);
          addEvent$p(AxisClass, "init", onAxisInit);
          addEvent$p(AxisClass, "initialAxisTranslation", onAxisInitialAxisTranslation);
        }
        if (composedClasses2.indexOf(TickClass) === -1) {
          composedClasses2.push(TickClass);
          addEvent$p(TickClass, "afterGetLabelPosition", onTickAfterGetLabelPosition);
          addEvent$p(TickClass, "afterGetPosition", onTickAfterGetPosition);
          wrap$8(TickClass.prototype, "getMarkPath", wrapTickGetMarkPath);
        }
        return AxisClass;
      }
      RadialAxis2.compose = compose;
      function createLabelCollector() {
        var _this = this;
        return function() {
          if (_this.isRadial && _this.tickPositions && // undocumented option for now, but working
          _this.options.labels && _this.options.labels.allowOverlap !== true) {
            return _this.tickPositions.map(function(pos) {
              return _this.ticks[pos] && _this.ticks[pos].label;
            }).filter(function(label) {
              return Boolean(label);
            });
          }
        };
      }
      function createLabelCollectorHidden() {
        return noop$c;
      }
      function getCrosshairPosition(options, x1, y1) {
        var center = this.pane.center;
        var value = options.value, shapeArgs, end, x2, y2;
        if (this.isCircular) {
          if (!defined$h(value)) {
            x2 = options.chartX || 0;
            y2 = options.chartY || 0;
            value = this.translate(Math.atan2(y2 - y1, x2 - x1) - this.startAngleRad, true);
          } else if (options.point) {
            shapeArgs = options.point.shapeArgs || {};
            if (shapeArgs.start) {
              value = this.chart.inverted ? this.translate(options.point.rectPlotY, true) : options.point.x;
            }
          }
          end = this.getPosition(value);
          x2 = end.x;
          y2 = end.y;
        } else {
          if (!defined$h(value)) {
            x2 = options.chartX;
            y2 = options.chartY;
          }
          if (defined$h(x2) && defined$h(y2)) {
            y1 = center[1] + this.chart.plotTop;
            value = this.translate(Math.min(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), center[2] / 2) - center[3] / 2, true);
          }
        }
        return [value, x2 || 0, y2 || 0];
      }
      function getLinePath(_lineWidth, radius, innerRadius) {
        var center = this.pane.center, chart = this.chart, left = this.left || 0, top = this.top || 0;
        var end, r = pick$G(radius, center[2] / 2 - this.offset), path;
        if (typeof innerRadius === "undefined") {
          innerRadius = this.horiz ? 0 : this.center && -this.center[3] / 2;
        }
        if (innerRadius) {
          r += innerRadius;
        }
        if (this.isCircular || typeof radius !== "undefined") {
          path = this.chart.renderer.symbols.arc(left + center[0], top + center[1], r, r, {
            start: this.startAngleRad,
            end: this.endAngleRad,
            open: true,
            innerR: 0
          });
          path.xBounds = [left + center[0]];
          path.yBounds = [top + center[1] - r];
        } else {
          end = this.postTranslate(this.angleRad, r);
          path = [
            ["M", this.center[0] + chart.plotLeft, this.center[1] + chart.plotTop],
            ["L", end.x, end.y]
          ];
        }
        return path;
      }
      function getOffset() {
        var axisProto = this.constructor.prototype;
        axisProto.getOffset.call(this);
        this.chart.axisOffset[this.side] = 0;
      }
      function getPlotBandPath(from, to, options) {
        var chart = this.chart, radiusToPixels = function(radius) {
          if (typeof radius === "string") {
            var r = parseInt(radius, 10);
            if (percentRegex.test(radius)) {
              r = r * fullRadius / 100;
            }
            return r;
          }
          return radius;
        }, center = this.center, startAngleRad = this.startAngleRad, fullRadius = center[2] / 2, offset2 = Math.min(this.offset, 0), left = this.left || 0, top = this.top || 0, percentRegex = /%$/, isCircular = this.isCircular;
        var start, end, angle, xOnPerimeter, open, path, outerRadius = pick$G(radiusToPixels(options.outerRadius), fullRadius), innerRadius = radiusToPixels(options.innerRadius), thickness = pick$G(radiusToPixels(options.thickness), 10);
        if (this.options.gridLineInterpolation === "polygon") {
          path = this.getPlotLinePath({ value: from }).concat(this.getPlotLinePath({ value: to, reverse: true }));
        } else {
          from = Math.max(from, this.min);
          to = Math.min(to, this.max);
          var transFrom = this.translate(from), transTo = this.translate(to);
          if (!isCircular) {
            outerRadius = transFrom || 0;
            innerRadius = transTo || 0;
          }
          if (options.shape === "circle" || !isCircular) {
            start = -Math.PI / 2;
            end = Math.PI * 1.5;
            open = true;
          } else {
            start = startAngleRad + (transFrom || 0);
            end = startAngleRad + (transTo || 0);
          }
          outerRadius -= offset2;
          thickness -= offset2;
          path = chart.renderer.symbols.arc(left + center[0], top + center[1], outerRadius, outerRadius, {
            // Math is for reversed yAxis (#3606)
            start: Math.min(start, end),
            end: Math.max(start, end),
            innerR: pick$G(innerRadius, outerRadius - thickness),
            open
          });
          if (isCircular) {
            angle = (end + start) / 2;
            xOnPerimeter = left + center[0] + center[2] / 2 * Math.cos(angle);
            path.xBounds = angle > -Math.PI / 2 && angle < Math.PI / 2 ? (
              // Right hemisphere
              [xOnPerimeter, chart.plotWidth]
            ) : (
              // Left hemisphere
              [0, xOnPerimeter]
            );
            path.yBounds = [
              top + center[1] + center[2] / 2 * Math.sin(angle)
            ];
            path.yBounds[0] += angle > -Math.PI && angle < 0 || angle > Math.PI ? -10 : 10;
          }
        }
        return path;
      }
      function getPlotLinePath(options) {
        var _this = this;
        var center = this.pane.center, chart = this.chart, inverted = chart.inverted, reverse = options.reverse, background = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {}, innerRadius = background.innerRadius || "0%", outerRadius = background.outerRadius || "100%", x1 = center[0] + chart.plotLeft, y1 = center[1] + chart.plotTop, height = this.height, isCrosshair = options.isCrosshair, paneInnerR = center[3] / 2;
        var value = options.value, innerRatio, distance, a, b, otherAxis, xy, tickPositions, crossPos, path;
        var end = this.getPosition(value);
        var x2 = end.x, y2 = end.y;
        if (isCrosshair) {
          crossPos = this.getCrosshairPosition(options, x1, y1);
          value = crossPos[0];
          x2 = crossPos[1];
          y2 = crossPos[2];
        }
        if (this.isCircular) {
          distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
          a = typeof innerRadius === "string" ? relativeLength$2(innerRadius, 1) : innerRadius / distance;
          b = typeof outerRadius === "string" ? relativeLength$2(outerRadius, 1) : outerRadius / distance;
          if (center && paneInnerR) {
            innerRatio = paneInnerR / distance;
            if (a < innerRatio) {
              a = innerRatio;
            }
            if (b < innerRatio) {
              b = innerRatio;
            }
          }
          path = [
            ["M", x1 + a * (x2 - x1), y1 - a * (y1 - y2)],
            ["L", x2 - (1 - b) * (x2 - x1), y2 + (1 - b) * (y1 - y2)]
          ];
        } else {
          value = this.translate(value);
          if (value) {
            if (value < 0 || value > height) {
              value = 0;
            }
          }
          if (this.options.gridLineInterpolation === "circle") {
            path = this.getLinePath(0, value, paneInnerR);
          } else {
            path = [];
            chart[inverted ? "yAxis" : "xAxis"].forEach(function(a2) {
              if (a2.pane === _this.pane) {
                otherAxis = a2;
              }
            });
            if (otherAxis) {
              tickPositions = otherAxis.tickPositions;
              if (otherAxis.autoConnect) {
                tickPositions = tickPositions.concat([tickPositions[0]]);
              }
              if (reverse) {
                tickPositions = tickPositions.slice().reverse();
              }
              if (value) {
                value += paneInnerR;
              }
              for (var i = 0; i < tickPositions.length; i++) {
                xy = otherAxis.getPosition(tickPositions[i], value);
                path.push(i ? ["L", xy.x, xy.y] : ["M", xy.x, xy.y]);
              }
            }
          }
        }
        return path;
      }
      function getPosition(value, length) {
        var translatedVal = this.translate(value);
        return this.postTranslate(
          this.isCircular ? translatedVal : this.angleRad,
          // #2848
          // In case when translatedVal is negative, the 0 value must be
          // used instead, in order to deal with lines and labels that
          // fall out of the visible range near the center of a pane
          pick$G(this.isCircular ? length : translatedVal < 0 ? 0 : translatedVal, this.center[2] / 2) - this.offset
        );
      }
      function getTitlePosition() {
        var center = this.center, chart = this.chart, titleOptions = this.options.title;
        return {
          x: chart.plotLeft + center[0] + (titleOptions.x || 0),
          y: chart.plotTop + center[1] - {
            high: 0.5,
            middle: 0.25,
            low: 0
          }[titleOptions.align] * center[2] + (titleOptions.y || 0)
        };
      }
      function modify(axis) {
        axis.beforeSetTickPositions = beforeSetTickPositions;
        axis.createLabelCollector = createLabelCollector;
        axis.getCrosshairPosition = getCrosshairPosition;
        axis.getLinePath = getLinePath;
        axis.getOffset = getOffset;
        axis.getPlotBandPath = getPlotBandPath;
        axis.getPlotLinePath = getPlotLinePath;
        axis.getPosition = getPosition;
        axis.getTitlePosition = getTitlePosition;
        axis.postTranslate = postTranslate;
        axis.setAxisSize = setAxisSize;
        axis.setAxisTranslation = setAxisTranslation;
        axis.setOptions = setOptions2;
      }
      function modifyAsHidden(radialAxis) {
        radialAxis.isHidden = true;
        radialAxis.createLabelCollector = createLabelCollectorHidden;
        radialAxis.getOffset = noop$c;
        radialAxis.redraw = renderHidden;
        radialAxis.render = renderHidden;
        radialAxis.setScale = noop$c;
        radialAxis.setCategories = noop$c;
        radialAxis.setTitle = noop$c;
      }
      function onAxisAfterInit() {
        var chart = this.chart, options = this.options, isHidden = chart.angular && this.isXAxis, pane = this.pane, paneOptions = pane && pane.options;
        if (!isHidden && pane && (chart.angular || chart.polar)) {
          this.angleRad = (options.angle || 0) * Math.PI / 180;
          this.startAngleRad = (paneOptions.startAngle - 90) * Math.PI / 180;
          this.endAngleRad = (pick$G(paneOptions.endAngle, paneOptions.startAngle + 360) - 90) * Math.PI / 180;
          this.offset = options.offset || 0;
        }
      }
      function onAxisAutoLabelAlign(e2) {
        if (this.isRadial) {
          e2.align = void 0;
          e2.preventDefault();
        }
      }
      function onAxisDestroy() {
        if (this.chart && this.chart.labelCollectors) {
          var index = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;
          if (index >= 0) {
            this.chart.labelCollectors.splice(index, 1);
          }
        }
      }
      function onAxisInit(e2) {
        var chart = this.chart, inverted = chart.inverted, angular = chart.angular, polar = chart.polar, isX = this.isXAxis, coll = this.coll, isHidden = angular && isX, chartOptions = chart.options, paneIndex = e2.userOptions.pane || 0, pane = this.pane = chart.pane && chart.pane[paneIndex];
        var isCircular;
        if (coll === "colorAxis") {
          this.isRadial = false;
          return;
        }
        if (angular) {
          if (isHidden) {
            modifyAsHidden(this);
          } else {
            modify(this);
          }
          isCircular = !isX;
          if (isCircular) {
            this.defaultPolarOptions = defaultRadialGaugeOptions;
          }
        } else if (polar) {
          modify(this);
          isCircular = this.horiz;
          this.defaultPolarOptions = isCircular ? defaultCircularOptions : merge$C(coll === "xAxis" ? AxisDefaults$1.defaultXAxisOptions : AxisDefaults$1.defaultYAxisOptions, defaultRadialOptions);
          if (inverted && coll === "yAxis") {
            this.defaultPolarOptions.stackLabels = AxisDefaults$1.defaultYAxisOptions.stackLabels;
            this.defaultPolarOptions.reversedStacks = true;
          }
        }
        if (angular || polar) {
          this.isRadial = true;
          chartOptions.chart.zoomType = null;
          if (!this.labelCollector) {
            this.labelCollector = this.createLabelCollector();
          }
          if (this.labelCollector) {
            chart.labelCollectors.push(this.labelCollector);
          }
        } else {
          this.isRadial = false;
        }
        if (pane && isCircular) {
          pane.axis = this;
        }
        this.isCircular = isCircular;
      }
      function onAxisInitialAxisTranslation() {
        if (this.isRadial) {
          this.beforeSetTickPositions();
        }
      }
      function onTickAfterGetLabelPosition(e2) {
        var label = this.label;
        if (!label) {
          return;
        }
        var axis = this.axis, labelBBox = label.getBBox(), labelOptions = axis.options.labels, angle = (axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360, correctAngle = Math.round(angle), labelYPosCorrection = !defined$h(labelOptions.y) ? -labelBBox.height * 0.3 : 0;
        var optionsY = labelOptions.y, ret, centerSlot = 20, align = labelOptions.align, labelDir = "end", reducedAngle1 = correctAngle < 0 ? correctAngle + 360 : correctAngle, reducedAngle2 = reducedAngle1, translateY = 0, translateX = 0;
        if (axis.isRadial) {
          ret = axis.getPosition(this.pos, axis.center[2] / 2 + relativeLength$2(pick$G(labelOptions.distance, -25), axis.center[2] / 2, -axis.center[2] / 2));
          if (labelOptions.rotation === "auto") {
            label.attr({
              rotation: angle
            });
          } else if (!defined$h(optionsY)) {
            optionsY = axis.chart.renderer.fontMetrics(label.styles && label.styles.fontSize).b - labelBBox.height / 2;
          }
          if (!defined$h(align)) {
            if (axis.isCircular) {
              if (labelBBox.width > axis.len * axis.tickInterval / (axis.max - axis.min)) {
                centerSlot = 0;
              }
              if (angle > centerSlot && angle < 180 - centerSlot) {
                align = "left";
              } else if (angle > 180 + centerSlot && angle < 360 - centerSlot) {
                align = "right";
              } else {
                align = "center";
              }
            } else {
              align = "center";
            }
            label.attr({
              align
            });
          }
          if (align === "auto" && axis.tickPositions.length === 2 && axis.isCircular) {
            if (reducedAngle1 > 90 && reducedAngle1 < 180) {
              reducedAngle1 = 180 - reducedAngle1;
            } else if (reducedAngle1 > 270 && reducedAngle1 <= 360) {
              reducedAngle1 = 540 - reducedAngle1;
            }
            if (reducedAngle2 > 180 && reducedAngle2 <= 360) {
              reducedAngle2 = 360 - reducedAngle2;
            }
            if (axis.pane.options.startAngle === correctAngle || axis.pane.options.startAngle === correctAngle + 360 || axis.pane.options.startAngle === correctAngle - 360) {
              labelDir = "start";
            }
            if (correctAngle >= -90 && correctAngle <= 90 || correctAngle >= -360 && correctAngle <= -270 || correctAngle >= 270 && correctAngle <= 360) {
              align = labelDir === "start" ? "right" : "left";
            } else {
              align = labelDir === "start" ? "left" : "right";
            }
            if (reducedAngle2 > 70 && reducedAngle2 < 110) {
              align = "center";
            }
            if (reducedAngle1 < 15 || reducedAngle1 >= 180 && reducedAngle1 < 195) {
              translateY = labelBBox.height * 0.3;
            } else if (reducedAngle1 >= 15 && reducedAngle1 <= 35) {
              translateY = labelDir === "start" ? 0 : labelBBox.height * 0.75;
            } else if (reducedAngle1 >= 195 && reducedAngle1 <= 215) {
              translateY = labelDir === "start" ? labelBBox.height * 0.75 : 0;
            } else if (reducedAngle1 > 35 && reducedAngle1 <= 90) {
              translateY = labelDir === "start" ? -labelBBox.height * 0.25 : labelBBox.height;
            } else if (reducedAngle1 > 215 && reducedAngle1 <= 270) {
              translateY = labelDir === "start" ? labelBBox.height : -labelBBox.height * 0.25;
            }
            if (reducedAngle2 < 15) {
              translateX = labelDir === "start" ? -labelBBox.height * 0.15 : labelBBox.height * 0.15;
            } else if (reducedAngle2 > 165 && reducedAngle2 <= 180) {
              translateX = labelDir === "start" ? labelBBox.height * 0.15 : -labelBBox.height * 0.15;
            }
            label.attr({ align });
            label.translate(translateX, translateY + labelYPosCorrection);
          }
          e2.pos.x = ret.x + (labelOptions.x || 0);
          e2.pos.y = ret.y + (optionsY || 0);
        }
      }
      function onTickAfterGetPosition(e2) {
        if (this.axis.getPosition) {
          extend$G(e2.pos, this.axis.getPosition(this.pos));
        }
      }
      function postTranslate(angle, radius) {
        var chart = this.chart, center = this.center;
        angle = this.startAngleRad + angle;
        return {
          x: chart.plotLeft + center[0] + Math.cos(angle) * radius,
          y: chart.plotTop + center[1] + Math.sin(angle) * radius
        };
      }
      function renderHidden() {
        this.isDirty = false;
      }
      function setAxisSize() {
        var axisProto = this.constructor.prototype;
        var center, start;
        axisProto.setAxisSize.call(this);
        if (this.isRadial) {
          this.pane.updateCenter(this);
          center = this.center = this.pane.center.slice();
          if (this.isCircular) {
            this.sector = this.endAngleRad - this.startAngleRad;
          } else {
            start = this.postTranslate(this.angleRad, center[3] / 2);
            center[0] = start.x - this.chart.plotLeft;
            center[1] = start.y - this.chart.plotTop;
          }
          this.len = this.width = this.height = (center[2] - center[3]) * pick$G(this.sector, 1) / 2;
        }
      }
      function setAxisTranslation() {
        var axisProto = this.constructor.prototype;
        axisProto.setAxisTranslation.call(this);
        if (this.center) {
          if (this.isCircular) {
            this.transA = (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1);
          } else {
            this.transA = (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1);
          }
          if (this.isXAxis) {
            this.minPixelPadding = this.transA * this.minPointOffset;
          } else {
            this.minPixelPadding = 0;
          }
        }
      }
      function setOptions2(userOptions) {
        var options = this.options = merge$C(
          this.constructor.defaultOptions,
          this.defaultPolarOptions,
          defaultOptions$4[this.coll],
          // #16112
          userOptions
        );
        if (!options.plotBands) {
          options.plotBands = [];
        }
        fireEvent$7(this, "afterSetOptions");
      }
      function wrapTickGetMarkPath(proceed, x, y, tickLength, tickWidth, horiz, renderer) {
        var axis = this.axis;
        var endPoint, ret;
        if (axis.isRadial) {
          endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);
          ret = [
            "M",
            x,
            y,
            "L",
            endPoint.x,
            endPoint.y
          ];
        } else {
          ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);
        }
        return ret;
      }
    })(RadialAxis || (RadialAxis = {}));
    const RadialAxis$1 = RadialAxis;
    var __extends$F = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var pointProto = Point$2.prototype;
    var defined$g = Utilities.defined, isNumber$i = Utilities.isNumber;
    var AreaRangePoint$1 = (
      /** @class */
      function(_super) {
        __extends$F(AreaRangePoint2, _super);
        function AreaRangePoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.high = void 0;
          _this.low = void 0;
          _this.options = void 0;
          _this.plotHigh = void 0;
          _this.plotLow = void 0;
          _this.plotHighX = void 0;
          _this.plotLowX = void 0;
          _this.plotX = void 0;
          _this.series = void 0;
          return _this;
        }
        AreaRangePoint2.prototype.setState = function() {
          var prevState = this.state, series = this.series, isPolar = series.chart.polar;
          if (!defined$g(this.plotHigh)) {
            this.plotHigh = series.yAxis.toPixels(this.high, true);
          }
          if (!defined$g(this.plotLow)) {
            this.plotLow = this.plotY = series.yAxis.toPixels(this.low, true);
          }
          if (series.stateMarkerGraphic) {
            series.lowerStateMarkerGraphic = series.stateMarkerGraphic;
            series.stateMarkerGraphic = series.upperStateMarkerGraphic;
          }
          this.graphic = this.upperGraphic;
          this.plotY = this.plotHigh;
          if (isPolar) {
            this.plotX = this.plotHighX;
          }
          pointProto.setState.apply(this, arguments);
          this.state = prevState;
          this.plotY = this.plotLow;
          this.graphic = this.lowerGraphic;
          if (isPolar) {
            this.plotX = this.plotLowX;
          }
          if (series.stateMarkerGraphic) {
            series.upperStateMarkerGraphic = series.stateMarkerGraphic;
            series.stateMarkerGraphic = series.lowerStateMarkerGraphic;
            series.lowerStateMarkerGraphic = void 0;
          }
          pointProto.setState.apply(this, arguments);
        };
        AreaRangePoint2.prototype.haloPath = function() {
          var isPolar = this.series.chart.polar, path = [];
          this.plotY = this.plotLow;
          if (isPolar) {
            this.plotX = this.plotLowX;
          }
          if (this.isInside) {
            path = pointProto.haloPath.apply(this, arguments);
          }
          this.plotY = this.plotHigh;
          if (isPolar) {
            this.plotX = this.plotHighX;
          }
          if (this.isTopInside) {
            path = path.concat(pointProto.haloPath.apply(this, arguments));
          }
          return path;
        };
        AreaRangePoint2.prototype.isValid = function() {
          return isNumber$i(this.low) && isNumber$i(this.high);
        };
        return AreaRangePoint2;
      }(AreaSeries$1.prototype.pointClass)
    );
    var __extends$E = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var areaProto = AreaSeries$1.prototype;
    var columnProto$4 = ColumnSeries$h.prototype;
    var noop$b = H.noop;
    var seriesProto$1 = Series$e.prototype;
    var defined$f = Utilities.defined, extend$F = Utilities.extend, isArray$5 = Utilities.isArray, pick$F = Utilities.pick, merge$B = Utilities.merge;
    var AreaRangeSeries$2 = (
      /** @class */
      function(_super) {
        __extends$E(AreaRangeSeries2, _super);
        function AreaRangeSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          _this.lowerStateMarkerGraphic = void 0;
          _this.xAxis = void 0;
          return _this;
        }
        AreaRangeSeries2.prototype.toYData = function(point) {
          return [point.low, point.high];
        };
        AreaRangeSeries2.prototype.highToXY = function(point) {
          var chart = this.chart, xy = this.xAxis.postTranslate(point.rectPlotX || 0, this.yAxis.len - point.plotHigh);
          point.plotHighX = xy.x - chart.plotLeft;
          point.plotHigh = xy.y - chart.plotTop;
          point.plotLowX = point.plotX;
        };
        AreaRangeSeries2.prototype.translate = function() {
          var series = this, yAxis = series.yAxis, hasModifyValue = !!series.modifyValue;
          areaProto.translate.apply(series);
          series.points.forEach(function(point) {
            var high = point.high, plotY = point.plotY;
            if (point.isNull) {
              point.plotY = null;
            } else {
              point.plotLow = plotY;
              point.plotHigh = yAxis.translate(hasModifyValue ? series.modifyValue(high, point) : high, 0, 1, 0, 1);
              if (hasModifyValue) {
                point.yBottom = point.plotHigh;
              }
            }
          });
          if (this.chart.polar) {
            this.points.forEach(function(point) {
              series.highToXY(point);
              point.tooltipPos = [
                (point.plotHighX + point.plotLowX) / 2,
                (point.plotHigh + point.plotLow) / 2
              ];
            });
          }
        };
        AreaRangeSeries2.prototype.getGraphPath = function(points) {
          var highPoints = [], highAreaPoints = [], i, getGraphPath = areaProto.getGraphPath, point, pointShim, linePath, lowerPath, options = this.options, polar = this.chart.polar, connectEnds = polar && options.connectEnds !== false, connectNulls = options.connectNulls, step = options.step, higherPath, higherAreaPath;
          points = points || this.points;
          i = points.length;
          while (i--) {
            point = points[i];
            var highAreaPoint = polar ? {
              plotX: point.rectPlotX,
              plotY: point.yBottom,
              doCurve: false
              // #5186, gaps in areasplinerange fill
            } : {
              plotX: point.plotX,
              plotY: point.plotY,
              doCurve: false
              // #5186, gaps in areasplinerange fill
            };
            if (!point.isNull && !connectEnds && !connectNulls && (!points[i + 1] || points[i + 1].isNull)) {
              highAreaPoints.push(highAreaPoint);
            }
            pointShim = {
              polarPlotY: point.polarPlotY,
              rectPlotX: point.rectPlotX,
              yBottom: point.yBottom,
              // plotHighX is for polar charts
              plotX: pick$F(point.plotHighX, point.plotX),
              plotY: point.plotHigh,
              isNull: point.isNull
            };
            highAreaPoints.push(pointShim);
            highPoints.push(pointShim);
            if (!point.isNull && !connectEnds && !connectNulls && (!points[i - 1] || points[i - 1].isNull)) {
              highAreaPoints.push(highAreaPoint);
            }
          }
          lowerPath = getGraphPath.call(this, points);
          if (step) {
            if (step === true) {
              step = "left";
            }
            options.step = {
              left: "right",
              center: "center",
              right: "left"
            }[step];
          }
          higherPath = getGraphPath.call(this, highPoints);
          higherAreaPath = getGraphPath.call(this, highAreaPoints);
          options.step = step;
          linePath = [].concat(lowerPath, higherPath);
          if (!this.chart.polar && higherAreaPath[0] && higherAreaPath[0][0] === "M") {
            higherAreaPath[0] = ["L", higherAreaPath[0][1], higherAreaPath[0][2]];
          }
          this.graphPath = linePath;
          this.areaPath = lowerPath.concat(higherAreaPath);
          linePath.isArea = true;
          linePath.xMap = lowerPath.xMap;
          this.areaPath.xMap = lowerPath.xMap;
          return linePath;
        };
        AreaRangeSeries2.prototype.drawDataLabels = function() {
          var data = this.points, length = data.length, i, originalDataLabels = [], dataLabelOptions = this.options.dataLabels, point, up, inverted = this.chart.inverted, upperDataLabelOptions, lowerDataLabelOptions;
          if (dataLabelOptions) {
            if (isArray$5(dataLabelOptions)) {
              upperDataLabelOptions = dataLabelOptions[0] || { enabled: false };
              lowerDataLabelOptions = dataLabelOptions[1] || { enabled: false };
            } else {
              upperDataLabelOptions = extend$F({}, dataLabelOptions);
              upperDataLabelOptions.x = dataLabelOptions.xHigh;
              upperDataLabelOptions.y = dataLabelOptions.yHigh;
              lowerDataLabelOptions = extend$F({}, dataLabelOptions);
              lowerDataLabelOptions.x = dataLabelOptions.xLow;
              lowerDataLabelOptions.y = dataLabelOptions.yLow;
            }
            if (upperDataLabelOptions.enabled || this._hasPointLabels) {
              i = length;
              while (i--) {
                point = data[i];
                if (point) {
                  up = upperDataLabelOptions.inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow;
                  point.y = point.high;
                  point._plotY = point.plotY;
                  point.plotY = point.plotHigh;
                  originalDataLabels[i] = point.dataLabel;
                  point.dataLabel = point.dataLabelUpper;
                  point.below = up;
                  if (inverted) {
                    if (!upperDataLabelOptions.align) {
                      upperDataLabelOptions.align = up ? "right" : "left";
                    }
                  } else {
                    if (!upperDataLabelOptions.verticalAlign) {
                      upperDataLabelOptions.verticalAlign = up ? "top" : "bottom";
                    }
                  }
                }
              }
              this.options.dataLabels = upperDataLabelOptions;
              if (seriesProto$1.drawDataLabels) {
                seriesProto$1.drawDataLabels.apply(this, arguments);
              }
              i = length;
              while (i--) {
                point = data[i];
                if (point) {
                  point.dataLabelUpper = point.dataLabel;
                  point.dataLabel = originalDataLabels[i];
                  delete point.dataLabels;
                  point.y = point.low;
                  point.plotY = point._plotY;
                }
              }
            }
            if (lowerDataLabelOptions.enabled || this._hasPointLabels) {
              i = length;
              while (i--) {
                point = data[i];
                if (point) {
                  up = lowerDataLabelOptions.inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow;
                  point.below = !up;
                  if (inverted) {
                    if (!lowerDataLabelOptions.align) {
                      lowerDataLabelOptions.align = up ? "left" : "right";
                    }
                  } else {
                    if (!lowerDataLabelOptions.verticalAlign) {
                      lowerDataLabelOptions.verticalAlign = up ? "bottom" : "top";
                    }
                  }
                }
              }
              this.options.dataLabels = lowerDataLabelOptions;
              if (seriesProto$1.drawDataLabels) {
                seriesProto$1.drawDataLabels.apply(this, arguments);
              }
            }
            if (upperDataLabelOptions.enabled) {
              i = length;
              while (i--) {
                point = data[i];
                if (point) {
                  point.dataLabels = [
                    point.dataLabelUpper,
                    point.dataLabel
                  ].filter(function(label) {
                    return !!label;
                  });
                }
              }
            }
            this.options.dataLabels = dataLabelOptions;
          }
        };
        AreaRangeSeries2.prototype.alignDataLabel = function() {
          columnProto$4.alignDataLabel.apply(this, arguments);
        };
        AreaRangeSeries2.prototype.drawPoints = function() {
          var series = this, pointLength = series.points.length, point, i;
          seriesProto$1.drawPoints.apply(series, arguments);
          i = 0;
          while (i < pointLength) {
            point = series.points[i];
            point.origProps = {
              plotY: point.plotY,
              plotX: point.plotX,
              isInside: point.isInside,
              negative: point.negative,
              zone: point.zone,
              y: point.y
            };
            point.lowerGraphic = point.graphic;
            point.graphic = point.upperGraphic;
            point.plotY = point.plotHigh;
            if (defined$f(point.plotHighX)) {
              point.plotX = point.plotHighX;
            }
            point.y = pick$F(point.high, point.origProps.y);
            point.negative = point.y < (series.options.threshold || 0);
            if (series.zones.length) {
              point.zone = point.getZone();
            }
            if (!series.chart.polar) {
              point.isInside = point.isTopInside = typeof point.plotY !== "undefined" && point.plotY >= 0 && point.plotY <= series.yAxis.len && // #3519
              point.plotX >= 0 && point.plotX <= series.xAxis.len;
            }
            i++;
          }
          seriesProto$1.drawPoints.apply(series, arguments);
          i = 0;
          while (i < pointLength) {
            point = series.points[i];
            point.upperGraphic = point.graphic;
            point.graphic = point.lowerGraphic;
            if (point.origProps) {
              extend$F(point, point.origProps);
              delete point.origProps;
            }
            i++;
          }
        };
        AreaRangeSeries2.defaultOptions = merge$B(AreaSeries$1.defaultOptions, {
          /**
           * @see [fillColor](#plotOptions.arearange.fillColor)
           * @see [fillOpacity](#plotOptions.arearange.fillOpacity)
           *
           * @apioption plotOptions.arearange.color
           */
          /**
           * @default   low
           * @apioption plotOptions.arearange.colorKey
           */
          /**
           * @see [color](#plotOptions.arearange.color)
           * @see [fillOpacity](#plotOptions.arearange.fillOpacity)
           *
           * @apioption plotOptions.arearange.fillColor
           */
          /**
           * @see [color](#plotOptions.arearange.color)
           * @see [fillColor](#plotOptions.arearange.fillColor)
           *
           * @default   {highcharts} 0.75
           * @default   {highstock} 0.75
           * @apioption plotOptions.arearange.fillOpacity
           */
          /**
           * Whether to apply a drop shadow to the graph line. Since 2.3 the
           * shadow can be an object configuration containing `color`, `offsetX`,
           * `offsetY`, `opacity` and `width`.
           *
           * @type      {boolean|Highcharts.ShadowOptionsObject}
           * @product   highcharts
           * @apioption plotOptions.arearange.shadow
           */
          /**
           * Pixel width of the arearange graph line.
           *
           * @since 2.3.0
           *
           * @private
           */
          lineWidth: 1,
          threshold: null,
          tooltip: {
            pointFormat: '<span style="color:{series.color}"></span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
          },
          /**
           * Whether the whole area or just the line should respond to mouseover
           * tooltips and other mouse or touch events.
           *
           * @since 2.3.0
           *
           * @private
           */
          trackByArea: true,
          /**
           * Extended data labels for range series types. Range series data
           * labels use no `x` and `y` options. Instead, they have `xLow`,
           * `xHigh`, `yLow` and `yHigh` options to allow the higher and lower
           * data label sets individually.
           *
           * @declare Highcharts.SeriesAreaRangeDataLabelsOptionsObject
           * @exclude x, y
           * @since   2.3.0
           * @product highcharts highstock
           *
           * @private
           */
          dataLabels: {
            align: void 0,
            verticalAlign: void 0,
            /**
             * X offset of the lower data labels relative to the point value.
             *
             * @sample highcharts/plotoptions/arearange-datalabels/
             *         Data labels on range series
             * @sample highcharts/plotoptions/arearange-datalabels/
             *         Data labels on range series
             */
            xLow: 0,
            /**
             * X offset of the higher data labels relative to the point value.
             *
             * @sample highcharts/plotoptions/arearange-datalabels/
             *         Data labels on range series
             */
            xHigh: 0,
            /**
             * Y offset of the lower data labels relative to the point value.
             *
             * @sample highcharts/plotoptions/arearange-datalabels/
             *         Data labels on range series
             */
            yLow: 0,
            /**
             * Y offset of the higher data labels relative to the point value.
             *
             * @sample highcharts/plotoptions/arearange-datalabels/
             *         Data labels on range series
             */
            yHigh: 0
          }
        });
        return AreaRangeSeries2;
      }(AreaSeries$1)
    );
    extend$F(AreaRangeSeries$2.prototype, {
      pointArrayMap: ["low", "high"],
      pointValKey: "low",
      deferTranslatePolar: true,
      pointClass: AreaRangePoint$1,
      setStackedPoints: noop$b
    });
    SeriesRegistry$1.registerSeriesType("arearange", AreaRangeSeries$2);
    var __extends$D = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var SplineSeries = SeriesRegistry$1.seriesTypes.spline;
    var merge$A = Utilities.merge, extend$E = Utilities.extend;
    var AreaSplineRangeSeries = (
      /** @class */
      function(_super) {
        __extends$D(AreaSplineRangeSeries2, _super);
        function AreaSplineRangeSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.options = void 0;
          _this.data = void 0;
          _this.points = void 0;
          return _this;
        }
        AreaSplineRangeSeries2.defaultOptions = merge$A(AreaRangeSeries$2.defaultOptions);
        return AreaSplineRangeSeries2;
      }(AreaRangeSeries$2)
    );
    extend$E(AreaSplineRangeSeries.prototype, {
      getPointSpline: SplineSeries.prototype.getPointSpline
    });
    SeriesRegistry$1.registerSeriesType("areasplinerange", AreaSplineRangeSeries);
    var __extends$C = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var noop$a = H.noop;
    var extend$D = Utilities.extend, merge$z = Utilities.merge, pick$E = Utilities.pick;
    var BoxPlotSeries = (
      /** @class */
      function(_super) {
        __extends$C(BoxPlotSeries2, _super);
        function BoxPlotSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        BoxPlotSeries2.prototype.pointAttribs = function() {
          return {};
        };
        BoxPlotSeries2.prototype.translate = function() {
          var series = this, yAxis = series.yAxis, pointArrayMap = series.pointArrayMap;
          _super.prototype.translate.apply(series);
          series.points.forEach(function(point) {
            pointArrayMap.forEach(function(key) {
              if (point[key] !== null) {
                point[key + "Plot"] = yAxis.translate(point[key], 0, 1, 0, 1);
              }
            });
            point.plotHigh = point.highPlot;
          });
        };
        BoxPlotSeries2.prototype.drawPoints = function() {
          var series = this, points = series.points, options = series.options, chart = series.chart, renderer = chart.renderer, q1Plot, q3Plot, highPlot, lowPlot, medianPlot, medianPath, crispCorr, crispX = 0, boxPath, width, left, right, halfWidth, doQuartiles = series.doQuartiles !== false, pointWiskerLength, whiskerLength = series.options.whiskerLength;
          points.forEach(function(point) {
            var graphic = point.graphic, verb = graphic ? "animate" : "attr", shapeArgs = point.shapeArgs, boxAttr = {}, stemAttr = {}, whiskersAttr = {}, medianAttr = {}, color2 = point.color || series.color;
            if (typeof point.plotY !== "undefined") {
              width = Math.round(shapeArgs.width);
              left = Math.floor(shapeArgs.x);
              right = left + width;
              halfWidth = Math.round(width / 2);
              q1Plot = Math.floor(doQuartiles ? point.q1Plot : point.lowPlot);
              q3Plot = Math.floor(doQuartiles ? point.q3Plot : point.lowPlot);
              highPlot = Math.floor(point.highPlot);
              lowPlot = Math.floor(point.lowPlot);
              if (!graphic) {
                point.graphic = graphic = renderer.g("point").add(series.group);
                point.stem = renderer.path().addClass("highcharts-boxplot-stem").add(graphic);
                if (whiskerLength) {
                  point.whiskers = renderer.path().addClass("highcharts-boxplot-whisker").add(graphic);
                }
                if (doQuartiles) {
                  point.box = renderer.path(boxPath).addClass("highcharts-boxplot-box").add(graphic);
                }
                point.medianShape = renderer.path(medianPath).addClass("highcharts-boxplot-median").add(graphic);
              }
              if (!chart.styledMode) {
                stemAttr.stroke = point.stemColor || options.stemColor || color2;
                stemAttr["stroke-width"] = pick$E(point.stemWidth, options.stemWidth, options.lineWidth);
                stemAttr.dashstyle = point.stemDashStyle || options.stemDashStyle || options.dashStyle;
                point.stem.attr(stemAttr);
                if (whiskerLength) {
                  whiskersAttr.stroke = point.whiskerColor || options.whiskerColor || color2;
                  whiskersAttr["stroke-width"] = pick$E(point.whiskerWidth, options.whiskerWidth, options.lineWidth);
                  whiskersAttr.dashstyle = point.whiskerDashStyle || options.whiskerDashStyle || options.dashStyle;
                  point.whiskers.attr(whiskersAttr);
                }
                if (doQuartiles) {
                  boxAttr.fill = point.fillColor || options.fillColor || color2;
                  boxAttr.stroke = options.lineColor || color2;
                  boxAttr["stroke-width"] = options.lineWidth || 0;
                  boxAttr.dashstyle = point.boxDashStyle || options.boxDashStyle || options.dashStyle;
                  point.box.attr(boxAttr);
                }
                medianAttr.stroke = point.medianColor || options.medianColor || color2;
                medianAttr["stroke-width"] = pick$E(point.medianWidth, options.medianWidth, options.lineWidth);
                medianAttr.dashstyle = point.medianDashStyle || options.medianDashStyle || options.dashStyle;
                point.medianShape.attr(medianAttr);
              }
              var d = void 0;
              crispCorr = point.stem.strokeWidth() % 2 / 2;
              crispX = left + halfWidth + crispCorr;
              d = [
                // stem up
                ["M", crispX, q3Plot],
                ["L", crispX, highPlot],
                // stem down
                ["M", crispX, q1Plot],
                ["L", crispX, lowPlot]
              ];
              point.stem[verb]({ d });
              if (doQuartiles) {
                crispCorr = point.box.strokeWidth() % 2 / 2;
                q1Plot = Math.floor(q1Plot) + crispCorr;
                q3Plot = Math.floor(q3Plot) + crispCorr;
                left += crispCorr;
                right += crispCorr;
                d = [
                  ["M", left, q3Plot],
                  ["L", left, q1Plot],
                  ["L", right, q1Plot],
                  ["L", right, q3Plot],
                  ["L", left, q3Plot],
                  ["Z"]
                ];
                point.box[verb]({ d });
              }
              if (whiskerLength) {
                crispCorr = point.whiskers.strokeWidth() % 2 / 2;
                highPlot = highPlot + crispCorr;
                lowPlot = lowPlot + crispCorr;
                pointWiskerLength = /%$/.test(whiskerLength) ? halfWidth * parseFloat(whiskerLength) / 100 : whiskerLength / 2;
                d = [
                  // High whisker
                  ["M", crispX - pointWiskerLength, highPlot],
                  ["L", crispX + pointWiskerLength, highPlot],
                  // Low whisker
                  ["M", crispX - pointWiskerLength, lowPlot],
                  ["L", crispX + pointWiskerLength, lowPlot]
                ];
                point.whiskers[verb]({ d });
              }
              medianPlot = Math.round(point.medianPlot);
              crispCorr = point.medianShape.strokeWidth() % 2 / 2;
              medianPlot = medianPlot + crispCorr;
              d = [
                ["M", left, medianPlot],
                ["L", right, medianPlot]
              ];
              point.medianShape[verb]({ d });
            }
          });
        };
        BoxPlotSeries2.prototype.toYData = function(point) {
          return [point.low, point.q1, point.median, point.q3, point.high];
        };
        BoxPlotSeries2.defaultOptions = merge$z(ColumnSeries$h.defaultOptions, {
          threshold: null,
          tooltip: {
            pointFormat: '<span style="color:{point.color}"></span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'
          },
          /**
           * The length of the whiskers, the horizontal lines marking low and
           * high values. It can be a numerical pixel value, or a percentage
           * value of the box width. Set `0` to disable whiskers.
           *
           * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
           *         True by default
           *
           * @type    {number|string}
           * @since   3.0
           * @product highcharts
           */
          whiskerLength: "50%",
          /**
           * The fill color of the box.
           *
           * In styled mode, the fill color can be set with the
           * `.highcharts-boxplot-box` class.
           *
           * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
           *         Box plot styling
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default #ffffff
           * @since   3.0
           * @product highcharts
           */
          fillColor: palette.backgroundColor,
          /**
           * The width of the line surrounding the box. If any of
           * [stemWidth](#plotOptions.boxplot.stemWidth),
           * [medianWidth](#plotOptions.boxplot.medianWidth)
           * or [whiskerWidth](#plotOptions.boxplot.whiskerWidth) are `null`,
           * the lineWidth also applies to these lines.
           *
           * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
           *         Box plot styling
           * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
           *         Error bar styling
           *
           * @since   3.0
           * @product highcharts
           */
          lineWidth: 1,
          /**
           * The color of the median line. If `undefined`, the general series
           * color applies.
           *
           * In styled mode, the median stroke width can be set with the
           * `.highcharts-boxplot-median` class.
           *
           * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
           *         Box plot styling
           * @sample {highcharts} highcharts/css/boxplot/
           *         Box plot in styled mode
           * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
           *         Error bar styling
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject}
           * @since     3.0
           * @product   highcharts
           * @apioption plotOptions.boxplot.medianColor
           */
          /**
           * The pixel width of the median line. If `null`, the
           * [lineWidth](#plotOptions.boxplot.lineWidth) is used.
           *
           * In styled mode, the median stroke width can be set with the
           * `.highcharts-boxplot-median` class.
           *
           * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
           *         Box plot styling
           * @sample {highcharts} highcharts/css/boxplot/
           *         Box plot in styled mode
           *
           * @type    {number|null}
           * @since   3.0
           * @product highcharts
           */
          medianWidth: 2,
          /*
                  // States are not working and are removed from docs.
                  // Refer to: #2340
                  states: {
                      hover: {
                          brightness: -0.3
                      }
                  },
          
                  /**
                   * The color of the stem, the vertical line extending from the box to
                   * the whiskers. If `undefined`, the series color is used.
                   *
                   * In styled mode, the stem stroke can be set with the
                   * `.highcharts-boxplot-stem` class.
                   *
                   * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                   *         Box plot styling
                   * @sample {highcharts} highcharts/css/boxplot/
                   *         Box plot in styled mode
                   * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
                   *         Error bar styling
                   *
                   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                   * @since     3.0
                   * @product   highcharts
                   * @apioption plotOptions.boxplot.stemColor
                   */
          /**
           * The dash style of the box.
           *
           * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
           *         Box plot styling
           * @sample {highcharts} highcharts/css/boxplot/
           *         Box plot in styled mode
           *
           * @type      {Highcharts.DashStyleValue}
           * @default   Solid
           * @since 8.1.0
           * @product   highcharts
           * @apioption plotOptions.boxplot.boxDashStyle
           */
          /**
           * The dash style of the median.
           *
           * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
           *         Box plot styling
           * @sample {highcharts} highcharts/css/boxplot/
           *         Box plot in styled mode
           *
           * @type      {Highcharts.DashStyleValue}
           * @default   Solid
           * @since 8.1.0
           * @product   highcharts
           * @apioption plotOptions.boxplot.medianDashStyle
           */
          /**
           * The dash style of the stem, the vertical line extending from the
           * box to the whiskers.
           *
           * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
           *         Box plot styling
           * @sample {highcharts} highcharts/css/boxplot/
           *         Box plot in styled mode
           * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
           *         Error bar styling
           *
           * @type      {Highcharts.DashStyleValue}
           * @default   Solid
           * @since     3.0
           * @product   highcharts
           * @apioption plotOptions.boxplot.stemDashStyle
           */
          /**
           * The dash style of the whiskers.
           *
           * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
           *         Box plot styling
           * @sample {highcharts} highcharts/css/boxplot/
           *         Box plot in styled mode
           *
           * @type      {Highcharts.DashStyleValue}
           * @default   Solid
           * @since 8.1.0
           * @product   highcharts
           * @apioption plotOptions.boxplot.whiskerDashStyle
           */
          /**
           * The width of the stem, the vertical line extending from the box to
           * the whiskers. If `undefined`, the width is inherited from the
           * [lineWidth](#plotOptions.boxplot.lineWidth) option.
           *
           * In styled mode, the stem stroke width can be set with the
           * `.highcharts-boxplot-stem` class.
           *
           * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
           *         Box plot styling
           * @sample {highcharts} highcharts/css/boxplot/
           *         Box plot in styled mode
           * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
           *         Error bar styling
           *
           * @type      {number}
           * @since     3.0
           * @product   highcharts
           * @apioption plotOptions.boxplot.stemWidth
           */
          /**
           * @default   high
           * @apioption plotOptions.boxplot.colorKey
           */
          /**
           * The color of the whiskers, the horizontal lines marking low and high
           * values. When `undefined`, the general series color is used.
           *
           * In styled mode, the whisker stroke can be set with the
           * `.highcharts-boxplot-whisker` class .
           *
           * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
           *         Box plot styling
           * @sample {highcharts} highcharts/css/boxplot/
           *         Box plot in styled mode
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @since     3.0
           * @product   highcharts
           * @apioption plotOptions.boxplot.whiskerColor
           */
          /**
           * The line width of the whiskers, the horizontal lines marking low and
           * high values. When `undefined`, the general
           * [lineWidth](#plotOptions.boxplot.lineWidth) applies.
           *
           * In styled mode, the whisker stroke width can be set with the
           * `.highcharts-boxplot-whisker` class.
           *
           * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
           *         Box plot styling
           * @sample {highcharts} highcharts/css/boxplot/
           *         Box plot in styled mode
           *
           * @since   3.0
           * @product highcharts
           */
          whiskerWidth: 2
        });
        return BoxPlotSeries2;
      }(ColumnSeries$h)
    );
    extend$D(BoxPlotSeries.prototype, {
      // array point configs are mapped to this
      pointArrayMap: ["low", "q1", "median", "q3", "high"],
      // defines the top of the tracker
      pointValKey: "high",
      // Disable data labels for box plot
      drawDataLabels: noop$a,
      setStackedPoints: noop$a
      // #3890
    });
    SeriesRegistry$1.registerSeriesType("boxplot", BoxPlotSeries);
    var BubbleLegendDefaults = {
      /**
       * The color of the ranges borders, can be also defined for an
       * individual range.
       *
       * @sample highcharts/bubble-legend/similartoseries/
       *         Similar look to the bubble series
       * @sample highcharts/bubble-legend/bordercolor/
       *         Individual bubble border color
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      borderColor: void 0,
      /**
       * The width of the ranges borders in pixels, can be also
       * defined for an individual range.
       */
      borderWidth: 2,
      /**
       * An additional class name to apply to the bubble legend'
       * circle graphical elements. This option does not replace
       * default class names of the graphical element.
       *
       * @sample {highcharts} highcharts/css/bubble-legend/
       *         Styling by CSS
       *
       * @type {string}
       */
      className: void 0,
      /**
       * The main color of the bubble legend. Applies to ranges, if
       * individual color is not defined.
       *
       * @sample highcharts/bubble-legend/similartoseries/
       *         Similar look to the bubble series
       * @sample highcharts/bubble-legend/color/
       *         Individual bubble color
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      color: void 0,
      /**
       * An additional class name to apply to the bubble legend's
       * connector graphical elements. This option does not replace
       * default class names of the graphical element.
       *
       * @sample {highcharts} highcharts/css/bubble-legend/
       *         Styling by CSS
       *
       * @type {string}
       */
      connectorClassName: void 0,
      /**
       * The color of the connector, can be also defined
       * for an individual range.
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      connectorColor: void 0,
      /**
       * The length of the connectors in pixels. If labels are
       * centered, the distance is reduced to 0.
       *
       * @sample highcharts/bubble-legend/connectorandlabels/
       *         Increased connector length
       */
      connectorDistance: 60,
      /**
       * The width of the connectors in pixels.
       *
       * @sample highcharts/bubble-legend/connectorandlabels/
       *         Increased connector width
       */
      connectorWidth: 1,
      /**
       * Enable or disable the bubble legend.
       */
      enabled: false,
      /**
       * Options for the bubble legend labels.
       */
      labels: {
        /**
         * An additional class name to apply to the bubble legend
         * label graphical elements. This option does not replace
         * default class names of the graphical element.
         *
         * @sample {highcharts} highcharts/css/bubble-legend/
         *         Styling by CSS
         *
         * @type {string}
         */
        className: void 0,
        /**
         * Whether to allow data labels to overlap.
         */
        allowOverlap: false,
        /**
         * A format string for the bubble legend labels. Available
         * variables are the same as for `formatter`.
         *
         * @sample highcharts/bubble-legend/format/
         *         Add a unit
         *
         * @type {string}
         */
        format: "",
        /**
         * Available `this` properties are:
         *
         * - `this.value`: The bubble value.
         *
         * - `this.radius`: The radius of the bubble range.
         *
         * - `this.center`: The center y position of the range.
         *
         * @type {Highcharts.FormatterCallbackFunction<Highcharts.BubbleLegendFormatterContextObject>}
         */
        formatter: void 0,
        /**
         * The alignment of the labels compared to the bubble
         * legend. Can be one of `left`, `center` or `right`.
         *
         * @sample highcharts/bubble-legend/connectorandlabels/
         *         Labels on left
         *
         * @type {Highcharts.AlignValue}
         */
        align: "right",
        /**
         * CSS styles for the labels.
         *
         * @type {Highcharts.CSSObject}
         */
        style: {
          /** @ignore-option */
          fontSize: "10px",
          /** @ignore-option */
          color: palette.neutralColor100
        },
        /**
         * The x position offset of the label relative to the
         * connector.
         */
        x: 0,
        /**
         * The y position offset of the label relative to the
         * connector.
         */
        y: 0
      },
      /**
       * Miximum bubble legend range size. If values for ranges are
       * not specified, the `minSize` and the `maxSize` are calculated
       * from bubble series.
       */
      maxSize: 60,
      /**
       * Minimum bubble legend range size. If values for ranges are
       * not specified, the `minSize` and the `maxSize` are calculated
       * from bubble series.
       */
      minSize: 10,
      /**
       * The position of the bubble legend in the legend.
       * @sample highcharts/bubble-legend/connectorandlabels/
       *         Bubble legend as last item in legend
       */
      legendIndex: 0,
      /**
       * Options for specific range. One range consists of bubble,
       * label and connector.
       *
       * @sample highcharts/bubble-legend/ranges/
       *         Manually defined ranges
       * @sample highcharts/bubble-legend/autoranges/
       *         Auto calculated ranges
       *
       * @type {Array<*>}
       */
      ranges: {
        /**
         * Range size value, similar to bubble Z data.
         * @type {number}
         */
        value: void 0,
        /**
         * The color of the border for individual range.
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        borderColor: void 0,
        /**
         * The color of the bubble for individual range.
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        color: void 0,
        /**
         * The color of the connector for individual range.
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        connectorColor: void 0
      },
      /**
       * Whether the bubble legend range value should be represented
       * by the area or the width of the bubble. The default, area,
       * corresponds best to the human perception of the size of each
       * bubble.
       *
       * @sample highcharts/bubble-legend/ranges/
       *         Size by width
       *
       * @type {Highcharts.BubbleSizeByValue}
       */
      sizeBy: "area",
      /**
       * When this is true, the absolute value of z determines the
       * size of the bubble. This means that with the default
       * zThreshold of 0, a bubble of value -1 will have the same size
       * as a bubble of value 1, while a bubble of value 0 will have a
       * smaller size according to minSize.
       */
      sizeByAbsoluteValue: false,
      /**
       * Define the visual z index of the bubble legend.
       */
      zIndex: 1,
      /**
       * Ranges with with lower value than zThreshold, are skipped.
       */
      zThreshold: 0
    };
    var color$a = Color.parse;
    var noop$9 = H.noop;
    var arrayMax$3 = Utilities.arrayMax, arrayMin$3 = Utilities.arrayMin, isNumber$h = Utilities.isNumber, merge$y = Utilities.merge, pick$D = Utilities.pick, stableSort$2 = Utilities.stableSort;
    var BubbleLegendItem = (
      /** @class */
      function() {
        function BubbleLegendItem2(options, legend) {
          this.chart = void 0;
          this.fontMetrics = void 0;
          this.legend = void 0;
          this.legendGroup = void 0;
          this.legendItem = void 0;
          this.legendItemHeight = void 0;
          this.legendItemWidth = void 0;
          this.legendSymbol = void 0;
          this.maxLabel = void 0;
          this.movementX = void 0;
          this.ranges = void 0;
          this.selected = void 0;
          this.visible = void 0;
          this.symbols = void 0;
          this.options = void 0;
          this.setState = noop$9;
          this.init(options, legend);
        }
        BubbleLegendItem2.prototype.init = function(options, legend) {
          this.options = options;
          this.visible = true;
          this.chart = legend.chart;
          this.legend = legend;
        };
        BubbleLegendItem2.prototype.addToLegend = function(items) {
          items.splice(this.options.legendIndex, 0, this);
        };
        BubbleLegendItem2.prototype.drawLegendSymbol = function(legend) {
          var chart = this.chart, options = this.options, itemDistance = pick$D(legend.options.itemDistance, 20), ranges = options.ranges, connectorDistance = options.connectorDistance;
          var connectorSpace;
          this.fontMetrics = chart.renderer.fontMetrics(options.labels.style.fontSize);
          if (!ranges || !ranges.length || !isNumber$h(ranges[0].value)) {
            legend.options.bubbleLegend.autoRanges = true;
            return;
          }
          stableSort$2(ranges, function(a, b) {
            return b.value - a.value;
          });
          this.ranges = ranges;
          this.setOptions();
          this.render();
          var maxLabel = this.getMaxLabelSize(), radius = this.ranges[0].radius, size = radius * 2;
          connectorSpace = connectorDistance - radius + maxLabel.width;
          connectorSpace = connectorSpace > 0 ? connectorSpace : 0;
          this.maxLabel = maxLabel;
          this.movementX = options.labels.align === "left" ? connectorSpace : 0;
          this.legendItemWidth = size + connectorSpace + itemDistance;
          this.legendItemHeight = size + this.fontMetrics.h / 2;
        };
        BubbleLegendItem2.prototype.setOptions = function() {
          var ranges = this.ranges, options = this.options, series = this.chart.series[options.seriesIndex], baseline = this.legend.baseline, bubbleAttribs = {
            zIndex: options.zIndex,
            "stroke-width": options.borderWidth
          }, connectorAttribs = {
            zIndex: options.zIndex,
            "stroke-width": options.connectorWidth
          }, labelAttribs = {
            align: this.legend.options.rtl || options.labels.align === "left" ? "right" : "left",
            zIndex: options.zIndex
          }, fillOpacity = series.options.marker.fillOpacity, styledMode = this.chart.styledMode;
          ranges.forEach(function(range, i) {
            if (!styledMode) {
              bubbleAttribs.stroke = pick$D(range.borderColor, options.borderColor, series.color);
              bubbleAttribs.fill = pick$D(range.color, options.color, fillOpacity !== 1 ? color$a(series.color).setOpacity(fillOpacity).get("rgba") : series.color);
              connectorAttribs.stroke = pick$D(range.connectorColor, options.connectorColor, series.color);
            }
            ranges[i].radius = this.getRangeRadius(range.value);
            ranges[i] = merge$y(ranges[i], {
              center: ranges[0].radius - ranges[i].radius + baseline
            });
            if (!styledMode) {
              merge$y(true, ranges[i], {
                bubbleAttribs: merge$y(bubbleAttribs),
                connectorAttribs: merge$y(connectorAttribs),
                labelAttribs
              });
            }
          }, this);
        };
        BubbleLegendItem2.prototype.getRangeRadius = function(value) {
          var options = this.options, seriesIndex = this.options.seriesIndex, bubbleSeries = this.chart.series[seriesIndex], zMax = options.ranges[0].value, zMin = options.ranges[options.ranges.length - 1].value, minSize = options.minSize, maxSize = options.maxSize;
          return bubbleSeries.getRadius.call(this, zMin, zMax, minSize, maxSize, value);
        };
        BubbleLegendItem2.prototype.render = function() {
          var renderer = this.chart.renderer, zThreshold = this.options.zThreshold;
          if (!this.symbols) {
            this.symbols = {
              connectors: [],
              bubbleItems: [],
              labels: []
            };
          }
          this.legendSymbol = renderer.g("bubble-legend");
          this.legendItem = renderer.g("bubble-legend-item");
          this.legendSymbol.translateX = 0;
          this.legendSymbol.translateY = 0;
          this.ranges.forEach(function(range) {
            if (range.value >= zThreshold) {
              this.renderRange(range);
            }
          }, this);
          this.legendSymbol.add(this.legendItem);
          this.legendItem.add(this.legendGroup);
          this.hideOverlappingLabels();
        };
        BubbleLegendItem2.prototype.renderRange = function(range) {
          var mainRange = this.ranges[0], legend = this.legend, options = this.options, labelsOptions = options.labels, chart = this.chart, bubbleSeries = chart.series[options.seriesIndex], renderer = chart.renderer, symbols2 = this.symbols, labels = symbols2.labels, elementCenter = range.center, absoluteRadius = Math.abs(range.radius), connectorDistance = options.connectorDistance || 0, labelsAlign = labelsOptions.align, rtl = legend.options.rtl, borderWidth = options.borderWidth, connectorWidth = options.connectorWidth, posX = mainRange.radius || 0, posY = elementCenter - absoluteRadius - borderWidth / 2 + connectorWidth / 2, fontMetrics = this.fontMetrics, labelMovement = fontMetrics.f / 2 - (fontMetrics.h - fontMetrics.f) / 2, crispMovement = (posY % 1 ? 1 : 0.5) - (connectorWidth % 2 ? 0 : 0.5), styledMode = renderer.styledMode;
          var connectorLength = rtl || labelsAlign === "left" ? -connectorDistance : connectorDistance;
          if (labelsAlign === "center") {
            connectorLength = 0;
            options.connectorDistance = 0;
            range.labelAttribs.align = "center";
          }
          var labelY = posY + options.labels.y, labelX = posX + connectorLength + options.labels.x;
          symbols2.bubbleItems.push(renderer.circle(posX, elementCenter + crispMovement, absoluteRadius).attr(styledMode ? {} : range.bubbleAttribs).addClass((styledMode ? "highcharts-color-" + bubbleSeries.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (options.className || "")).add(this.legendSymbol));
          symbols2.connectors.push(renderer.path(renderer.crispLine([
            ["M", posX, posY],
            ["L", posX + connectorLength, posY]
          ], options.connectorWidth)).attr(styledMode ? {} : range.connectorAttribs).addClass((styledMode ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (options.connectorClassName || "")).add(this.legendSymbol));
          var label = renderer.text(this.formatLabel(range), labelX, labelY + labelMovement).attr(styledMode ? {} : range.labelAttribs).css(styledMode ? {} : labelsOptions.style).addClass("highcharts-bubble-legend-labels " + (options.labels.className || "")).add(this.legendSymbol);
          labels.push(label);
          label.placed = true;
          label.alignAttr = {
            x: labelX,
            y: labelY + labelMovement
          };
        };
        BubbleLegendItem2.prototype.getMaxLabelSize = function() {
          var labels = this.symbols.labels;
          var maxLabel, labelSize;
          labels.forEach(function(label) {
            labelSize = label.getBBox(true);
            if (maxLabel) {
              maxLabel = labelSize.width > maxLabel.width ? labelSize : maxLabel;
            } else {
              maxLabel = labelSize;
            }
          });
          return maxLabel || {};
        };
        BubbleLegendItem2.prototype.formatLabel = function(range) {
          var options = this.options, formatter = options.labels.formatter, format2 = options.labels.format;
          var numberFormatter = this.chart.numberFormatter;
          return format2 ? FormatUtilities.format(format2, range) : formatter ? formatter.call(range) : numberFormatter(range.value, 1);
        };
        BubbleLegendItem2.prototype.hideOverlappingLabels = function() {
          var chart = this.chart, allowOverlap = this.options.labels.allowOverlap, symbols2 = this.symbols;
          if (!allowOverlap && symbols2) {
            chart.hideOverlappingLabels(symbols2.labels);
            symbols2.labels.forEach(function(label, index) {
              if (!label.newOpacity) {
                symbols2.connectors[index].hide();
              } else if (label.newOpacity !== label.oldOpacity) {
                symbols2.connectors[index].show();
              }
            });
          }
        };
        BubbleLegendItem2.prototype.getRanges = function() {
          var bubbleLegend = this.legend.bubbleLegend, series = bubbleLegend.chart.series, rangesOptions = bubbleLegend.options.ranges;
          var ranges, zData, minZ = Number.MAX_VALUE, maxZ = -Number.MAX_VALUE;
          series.forEach(function(s) {
            if (s.isBubble && !s.ignoreSeries) {
              zData = s.zData.filter(isNumber$h);
              if (zData.length) {
                minZ = pick$D(s.options.zMin, Math.min(minZ, Math.max(arrayMin$3(zData), s.options.displayNegative === false ? s.options.zThreshold : -Number.MAX_VALUE)));
                maxZ = pick$D(s.options.zMax, Math.max(maxZ, arrayMax$3(zData)));
              }
            }
          });
          if (minZ === maxZ) {
            ranges = [{ value: maxZ }];
          } else {
            ranges = [
              { value: minZ },
              { value: (minZ + maxZ) / 2 },
              { value: maxZ, autoRanges: true }
            ];
          }
          if (rangesOptions.length && rangesOptions[0].radius) {
            ranges.reverse();
          }
          ranges.forEach(function(range, i) {
            if (rangesOptions && rangesOptions[i]) {
              ranges[i] = merge$y(rangesOptions[i], range);
            }
          });
          return ranges;
        };
        BubbleLegendItem2.prototype.predictBubbleSizes = function() {
          var chart = this.chart, fontMetrics = this.fontMetrics, legendOptions = chart.legend.options, floating = legendOptions.floating, horizontal = legendOptions.layout === "horizontal", lastLineHeight = horizontal ? chart.legend.lastLineHeight : 0, plotSizeX = chart.plotSizeX, plotSizeY = chart.plotSizeY, bubbleSeries = chart.series[this.options.seriesIndex], minSize = Math.ceil(bubbleSeries.minPxSize), maxPxSize = Math.ceil(bubbleSeries.maxPxSize), plotSize = Math.min(plotSizeY, plotSizeX);
          var calculatedSize, maxSize = bubbleSeries.options.maxSize;
          if (floating || !/%$/.test(maxSize)) {
            calculatedSize = maxPxSize;
          } else {
            maxSize = parseFloat(maxSize);
            calculatedSize = (plotSize + lastLineHeight - fontMetrics.h / 2) * maxSize / 100 / (maxSize / 100 + 1);
            if (horizontal && plotSizeY - calculatedSize >= plotSizeX || !horizontal && plotSizeX - calculatedSize >= plotSizeY) {
              calculatedSize = maxPxSize;
            }
          }
          return [minSize, Math.ceil(calculatedSize)];
        };
        BubbleLegendItem2.prototype.updateRanges = function(min, max) {
          var bubbleLegendOptions = this.legend.options.bubbleLegend;
          bubbleLegendOptions.minSize = min;
          bubbleLegendOptions.maxSize = max;
          bubbleLegendOptions.ranges = this.getRanges();
        };
        BubbleLegendItem2.prototype.correctSizes = function() {
          var legend = this.legend, chart = this.chart, bubbleSeries = chart.series[this.options.seriesIndex], bubbleSeriesSize = bubbleSeries.maxPxSize, bubbleLegendSize = this.options.maxSize;
          if (Math.abs(Math.ceil(bubbleSeriesSize) - bubbleLegendSize) > 1) {
            this.updateRanges(this.options.minSize, bubbleSeries.maxPxSize);
            legend.render();
          }
        };
        return BubbleLegendItem2;
      }()
    );
    var setOptions = DefaultOptions.setOptions;
    var addEvent$o = Utilities.addEvent, objectEach$9 = Utilities.objectEach, wrap$7 = Utilities.wrap;
    var BubbleLegendComposition;
    (function(BubbleLegendComposition2) {
      var composedClasses2 = [];
      function chartDrawChartBox(proceed, options, callback) {
        var chart = this, legend = chart.legend, bubbleSeries = getVisibleBubbleSeriesIndex(chart) >= 0;
        var bubbleLegendOptions, bubbleSizes;
        if (legend && legend.options.enabled && legend.bubbleLegend && legend.options.bubbleLegend.autoRanges && bubbleSeries) {
          bubbleLegendOptions = legend.bubbleLegend.options;
          bubbleSizes = legend.bubbleLegend.predictBubbleSizes();
          legend.bubbleLegend.updateRanges(bubbleSizes[0], bubbleSizes[1]);
          if (!bubbleLegendOptions.placed) {
            legend.group.placed = false;
            legend.allItems.forEach(function(item2) {
              item2.legendGroup.translateY = null;
            });
          }
          legend.render();
          chart.getMargins();
          chart.axes.forEach(function(axis) {
            if (axis.visible) {
              axis.render();
            }
            if (!bubbleLegendOptions.placed) {
              axis.setScale();
              axis.updateNames();
              objectEach$9(axis.ticks, function(tick) {
                tick.isNew = true;
                tick.isNewLabel = true;
              });
            }
          });
          bubbleLegendOptions.placed = true;
          chart.getMargins();
          proceed.call(chart, options, callback);
          legend.bubbleLegend.correctSizes();
          retranslateItems(legend, getLinesHeights(legend));
        } else {
          proceed.call(chart, options, callback);
          if (legend && legend.options.enabled && legend.bubbleLegend) {
            legend.render();
            retranslateItems(legend, getLinesHeights(legend));
          }
        }
      }
      function compose(ChartClass, LegendClass, SeriesClass) {
        if (composedClasses2.indexOf(ChartClass) === -1) {
          composedClasses2.push(ChartClass);
          setOptions({
            // Set default bubble legend options
            legend: {
              bubbleLegend: BubbleLegendDefaults
            }
          });
          wrap$7(ChartClass.prototype, "drawChartBox", chartDrawChartBox);
        }
        if (composedClasses2.indexOf(LegendClass) === -1) {
          composedClasses2.push(LegendClass);
          addEvent$o(LegendClass, "afterGetAllItems", onLegendAfterGetAllItems);
        }
        if (composedClasses2.indexOf(SeriesClass) === -1) {
          composedClasses2.push(SeriesClass);
          addEvent$o(SeriesClass, "legendItemClick", onSeriesLegendItemClick);
        }
      }
      BubbleLegendComposition2.compose = compose;
      function getVisibleBubbleSeriesIndex(chart) {
        var series = chart.series;
        var i = 0;
        while (i < series.length) {
          if (series[i] && series[i].isBubble && series[i].visible && series[i].zData.length) {
            return i;
          }
          i++;
        }
        return -1;
      }
      function getLinesHeights(legend) {
        var items = legend.allItems, lines = [], length = items.length;
        var lastLine, i = 0, j = 0;
        for (i = 0; i < length; i++) {
          if (items[i].legendItemHeight) {
            items[i].itemHeight = items[i].legendItemHeight;
          }
          if (
            // Line break
            items[i] === items[length - 1] || items[i + 1] && items[i]._legendItemPos[1] !== items[i + 1]._legendItemPos[1]
          ) {
            lines.push({ height: 0 });
            lastLine = lines[lines.length - 1];
            for (j; j <= i; j++) {
              if (items[j].itemHeight > lastLine.height) {
                lastLine.height = items[j].itemHeight;
              }
            }
            lastLine.step = i;
          }
        }
        return lines;
      }
      function onLegendAfterGetAllItems(e2) {
        var legend = this, bubbleLegend = legend.bubbleLegend, legendOptions = legend.options, options = legendOptions.bubbleLegend, bubbleSeriesIndex = getVisibleBubbleSeriesIndex(legend.chart);
        if (bubbleLegend && bubbleLegend.ranges && bubbleLegend.ranges.length) {
          if (options.ranges.length) {
            options.autoRanges = !!options.ranges[0].autoRanges;
          }
          legend.destroyItem(bubbleLegend);
        }
        if (bubbleSeriesIndex >= 0 && legendOptions.enabled && options.enabled) {
          options.seriesIndex = bubbleSeriesIndex;
          legend.bubbleLegend = new BubbleLegendItem(options, legend);
          legend.bubbleLegend.addToLegend(e2.allItems);
        }
      }
      function onSeriesLegendItemClick() {
        var series = this, chart = series.chart, visible = series.visible, legend = series.chart.legend;
        var status;
        if (legend && legend.bubbleLegend) {
          series.visible = !visible;
          series.ignoreSeries = visible;
          status = getVisibleBubbleSeriesIndex(chart) >= 0;
          if (legend.bubbleLegend.visible !== status) {
            legend.update({
              bubbleLegend: { enabled: status }
            });
            legend.bubbleLegend.visible = status;
          }
          series.visible = visible;
        }
      }
      function retranslateItems(legend, lines) {
        var items = legend.allItems, rtl = legend.options.rtl;
        var orgTranslateX, orgTranslateY, movementX, actualLine = 0;
        items.forEach(function(item2, index) {
          orgTranslateX = item2.legendGroup.translateX;
          orgTranslateY = item2._legendItemPos[1];
          movementX = item2.movementX;
          if (movementX || rtl && item2.ranges) {
            movementX = rtl ? orgTranslateX - item2.options.maxSize / 2 : orgTranslateX + movementX;
            item2.legendGroup.attr({ translateX: movementX });
          }
          if (index > lines[actualLine].step) {
            actualLine++;
          }
          item2.legendGroup.attr({
            translateY: Math.round(orgTranslateY + lines[actualLine].height / 2)
          });
          item2._legendItemPos[1] = orgTranslateY + lines[actualLine].height / 2;
        });
      }
    })(BubbleLegendComposition || (BubbleLegendComposition = {}));
    const BubbleLegendComposition$1 = BubbleLegendComposition;
    var __extends$B = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var ScatterPoint$2 = SeriesRegistry$1.seriesTypes.scatter.prototype.pointClass;
    var extend$C = Utilities.extend;
    var BubblePoint = (
      /** @class */
      function(_super) {
        __extends$B(BubblePoint2, _super);
        function BubblePoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.options = void 0;
          _this.series = void 0;
          return _this;
        }
        BubblePoint2.prototype.haloPath = function(size) {
          return Point$2.prototype.haloPath.call(
            this,
            // #6067
            size === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + size
          );
        };
        return BubblePoint2;
      }(ScatterPoint$2)
    );
    extend$C(BubblePoint.prototype, {
      ttBelow: false
    });
    var __extends$A = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var color$9 = Color.parse;
    var noop$8 = H.noop;
    var _a$b = SeriesRegistry$1.seriesTypes, ColumnSeries$b = _a$b.column, ScatterSeries$3 = _a$b.scatter;
    var arrayMax$2 = Utilities.arrayMax, arrayMin$2 = Utilities.arrayMin, clamp$8 = Utilities.clamp, extend$B = Utilities.extend, isNumber$g = Utilities.isNumber, merge$x = Utilities.merge, pick$C = Utilities.pick, pInt$2 = Utilities.pInt;
    var BubbleSeries$2 = (
      /** @class */
      function(_super) {
        __extends$A(BubbleSeries2, _super);
        function BubbleSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.maxPxSize = void 0;
          _this.minPxSize = void 0;
          _this.options = void 0;
          _this.points = void 0;
          _this.radii = void 0;
          _this.yData = void 0;
          _this.zData = void 0;
          return _this;
        }
        BubbleSeries2.prototype.animate = function(init) {
          if (!init && this.points.length < this.options.animationLimit) {
            this.points.forEach(function(point) {
              var graphic = point.graphic;
              if (graphic && graphic.width) {
                if (!this.hasRendered) {
                  graphic.attr({
                    x: point.plotX,
                    y: point.plotY,
                    width: 1,
                    height: 1
                  });
                }
                graphic.animate(this.markerAttribs(point), this.options.animation);
              }
            }, this);
          }
        };
        BubbleSeries2.prototype.getRadii = function(zMin, zMax, series) {
          var len, i, zData = this.zData, yData = this.yData, minSize = series.minPxSize, maxSize = series.maxPxSize, radii = [], value;
          for (i = 0, len = zData.length; i < len; i++) {
            value = zData[i];
            radii.push(this.getRadius(zMin, zMax, minSize, maxSize, value, yData[i]));
          }
          this.radii = radii;
        };
        BubbleSeries2.prototype.getRadius = function(zMin, zMax, minSize, maxSize, value, yValue) {
          var options = this.options, sizeByArea = options.sizeBy !== "width", zThreshold = options.zThreshold, zRange = zMax - zMin, pos = 0.5;
          if (yValue === null || value === null) {
            return null;
          }
          if (isNumber$g(value)) {
            if (options.sizeByAbsoluteValue) {
              value = Math.abs(value - zThreshold);
              zMax = zRange = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));
              zMin = 0;
            }
            if (value < zMin) {
              return minSize / 2 - 1;
            }
            if (zRange > 0) {
              pos = (value - zMin) / zRange;
            }
          }
          if (sizeByArea && pos >= 0) {
            pos = Math.sqrt(pos);
          }
          return Math.ceil(minSize + pos * (maxSize - minSize)) / 2;
        };
        BubbleSeries2.prototype.hasData = function() {
          return !!this.processedXData.length;
        };
        BubbleSeries2.prototype.pointAttribs = function(point, state) {
          var markerOptions = this.options.marker, fillOpacity = markerOptions.fillOpacity, attr2 = Series$e.prototype.pointAttribs.call(this, point, state);
          if (fillOpacity !== 1) {
            attr2.fill = color$9(attr2.fill).setOpacity(fillOpacity).get("rgba");
          }
          return attr2;
        };
        BubbleSeries2.prototype.translate = function() {
          var i, data = this.data, point, radius, radii = this.radii;
          _super.prototype.translate.call(this);
          i = data.length;
          while (i--) {
            point = data[i];
            radius = radii ? radii[i] : 0;
            if (isNumber$g(radius) && radius >= this.minPxSize / 2) {
              point.marker = extend$B(point.marker, {
                radius,
                width: 2 * radius,
                height: 2 * radius
              });
              point.dlBox = {
                x: point.plotX - radius,
                y: point.plotY - radius,
                width: 2 * radius,
                height: 2 * radius
              };
            } else {
              point.shapeArgs = point.plotY = point.dlBox = void 0;
            }
          }
        };
        BubbleSeries2.compose = BubbleLegendComposition$1.compose;
        BubbleSeries2.defaultOptions = merge$x(ScatterSeries$3.defaultOptions, {
          dataLabels: {
            formatter: function() {
              var numberFormatter = this.series.chart.numberFormatter;
              var z = this.point.z;
              return isNumber$g(z) ? numberFormatter(z, -1) : "";
            },
            inside: true,
            verticalAlign: "middle"
          },
          /**
           * If there are more points in the series than the `animationLimit`, the
           * animation won't run. Animation affects overall performance and
           * doesn't work well with heavy data series.
           *
           * @since 6.1.0
           */
          animationLimit: 250,
          /**
           * Whether to display negative sized bubbles. The threshold is given
           * by the [zThreshold](#plotOptions.bubble.zThreshold) option, and negative
           * bubbles can be visualized by setting
           * [negativeColor](#plotOptions.bubble.negativeColor).
           *
           * @sample {highcharts} highcharts/plotoptions/bubble-negative/
           *         Negative bubbles
           *
           * @type      {boolean}
           * @default   true
           * @since     3.0
           * @apioption plotOptions.bubble.displayNegative
           */
          /**
           * @extends   plotOptions.series.marker
           * @excluding enabled, enabledThreshold, height, radius, width
           */
          marker: {
            lineColor: null,
            lineWidth: 1,
            /**
             * The fill opacity of the bubble markers.
             */
            fillOpacity: 0.5,
            /**
             * In bubble charts, the radius is overridden and determined based
             * on the point's data value.
             *
             * @ignore-option
             */
            radius: null,
            states: {
              hover: {
                radiusPlus: 0
              }
            },
            /**
             * A predefined shape or symbol for the marker. Possible values are
             * "circle", "square", "diamond", "triangle" and "triangle-down".
             *
             * Additionally, the URL to a graphic can be given on the form
             * `url(graphic.png)`. Note that for the image to be applied to
             * exported charts, its URL needs to be accessible by the export
             * server.
             *
             * Custom callbacks for symbol path generation can also be added to
             * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
             * used by its method name, as shown in the demo.
             *
             * @sample {highcharts} highcharts/plotoptions/bubble-symbol/
             *         Bubble chart with various symbols
             * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
             *         General chart with predefined, graphic and custom markers
             *
             * @type  {Highcharts.SymbolKeyValue|string}
             * @since 5.0.11
             */
            symbol: "circle"
          },
          /**
           * Minimum bubble size. Bubbles will automatically size between the
           * `minSize` and `maxSize` to reflect the `z` value of each bubble.
           * Can be either pixels (when no unit is given), or a percentage of
           * the smallest one of the plot width and height.
           *
           * @sample {highcharts} highcharts/plotoptions/bubble-size/
           *         Bubble size
           *
           * @type    {number|string}
           * @since   3.0
           * @product highcharts highstock
           */
          minSize: 8,
          /**
           * Maximum bubble size. Bubbles will automatically size between the
           * `minSize` and `maxSize` to reflect the `z` value of each bubble.
           * Can be either pixels (when no unit is given), or a percentage of
           * the smallest one of the plot width and height.
           *
           * @sample {highcharts} highcharts/plotoptions/bubble-size/
           *         Bubble size
           *
           * @type    {number|string}
           * @since   3.0
           * @product highcharts highstock
           */
          maxSize: "20%",
          /**
           * When a point's Z value is below the
           * [zThreshold](#plotOptions.bubble.zThreshold)
           * setting, this color is used.
           *
           * @sample {highcharts} highcharts/plotoptions/bubble-negative/
           *         Negative bubbles
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @since     3.0
           * @product   highcharts
           * @apioption plotOptions.bubble.negativeColor
           */
          /**
           * Whether the bubble's value should be represented by the area or the
           * width of the bubble. The default, `area`, corresponds best to the
           * human perception of the size of each bubble.
           *
           * @sample {highcharts} highcharts/plotoptions/bubble-sizeby/
           *         Comparison of area and size
           *
           * @type       {Highcharts.BubbleSizeByValue}
           * @default    area
           * @since      3.0.7
           * @apioption  plotOptions.bubble.sizeBy
           */
          /**
           * When this is true, the absolute value of z determines the size of
           * the bubble. This means that with the default `zThreshold` of 0, a
           * bubble of value -1 will have the same size as a bubble of value 1,
           * while a bubble of value 0 will have a smaller size according to
           * `minSize`.
           *
           * @sample    {highcharts} highcharts/plotoptions/bubble-sizebyabsolutevalue/
           *            Size by absolute value, various thresholds
           *
           * @type      {boolean}
           * @default   false
           * @since     4.1.9
           * @product   highcharts
           * @apioption plotOptions.bubble.sizeByAbsoluteValue
           */
          /**
           * When this is true, the series will not cause the Y axis to cross
           * the zero plane (or [threshold](#plotOptions.series.threshold) option)
           * unless the data actually crosses the plane.
           *
           * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
           * 3 will make the Y axis show negative values according to the
           * `minPadding` option. If `softThreshold` is `true`, the Y axis starts
           * at 0.
           *
           * @since   4.1.9
           * @product highcharts
           */
          softThreshold: false,
          states: {
            hover: {
              halo: {
                size: 5
              }
            }
          },
          tooltip: {
            pointFormat: "({point.x}, {point.y}), Size: {point.z}"
          },
          turboThreshold: 0,
          /**
           * The minimum for the Z value range. Defaults to the highest Z value
           * in the data.
           *
           * @see [zMin](#plotOptions.bubble.zMin)
           *
           * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/
           *         Z has a possible range of 0-100
           *
           * @type      {number}
           * @since     4.0.3
           * @product   highcharts
           * @apioption plotOptions.bubble.zMax
           */
          /**
           * @default   z
           * @apioption plotOptions.bubble.colorKey
           */
          /**
           * The minimum for the Z value range. Defaults to the lowest Z value
           * in the data.
           *
           * @see [zMax](#plotOptions.bubble.zMax)
           *
           * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/
           *         Z has a possible range of 0-100
           *
           * @type      {number}
           * @since     4.0.3
           * @product   highcharts
           * @apioption plotOptions.bubble.zMin
           */
          /**
           * When [displayNegative](#plotOptions.bubble.displayNegative) is `false`,
           * bubbles with lower Z values are skipped. When `displayNegative`
           * is `true` and a [negativeColor](#plotOptions.bubble.negativeColor)
           * is given, points with lower Z is colored.
           *
           * @sample {highcharts} highcharts/plotoptions/bubble-negative/
           *         Negative bubbles
           *
           * @since   3.0
           * @product highcharts
           */
          zThreshold: 0,
          zoneAxis: "z"
        });
        return BubbleSeries2;
      }(ScatterSeries$3)
    );
    extend$B(BubbleSeries$2.prototype, {
      alignDataLabel: ColumnSeries$b.prototype.alignDataLabel,
      applyZones: noop$8,
      bubblePadding: true,
      buildKDTree: noop$8,
      directTouch: true,
      isBubble: true,
      pointArrayMap: ["y", "z"],
      pointClass: BubblePoint,
      parallelArrays: ["x", "y", "z"],
      trackerGroups: ["group", "dataLabelsGroup"],
      specialGroup: "group",
      zoneAxis: "z"
    });
    Axis.prototype.beforePadding = function() {
      var axis = this, axisLength = this.len, chart = this.chart, pxMin = 0, pxMax = axisLength, isXAxis = this.isXAxis, dataKey = isXAxis ? "xData" : "yData", min = this.min, extremes = {}, smallestSize = Math.min(chart.plotWidth, chart.plotHeight), zMin = Number.MAX_VALUE, zMax = -Number.MAX_VALUE, range = this.max - min, transA = axisLength / range, activeSeries = [];
      this.series.forEach(function(series) {
        var seriesOptions = series.options, zData;
        if (series.bubblePadding && (series.visible || !chart.options.chart.ignoreHiddenSeries)) {
          axis.allowZoomOutside = true;
          activeSeries.push(series);
          if (isXAxis) {
            ["minSize", "maxSize"].forEach(function(prop) {
              var length = seriesOptions[prop], isPercent = /%$/.test(length);
              length = pInt$2(length);
              extremes[prop] = isPercent ? smallestSize * length / 100 : length;
            });
            series.minPxSize = extremes.minSize;
            series.maxPxSize = Math.max(extremes.maxSize, extremes.minSize);
            zData = series.zData.filter(isNumber$g);
            if (zData.length) {
              zMin = pick$C(seriesOptions.zMin, clamp$8(arrayMin$2(zData), seriesOptions.displayNegative === false ? seriesOptions.zThreshold : -Number.MAX_VALUE, zMin));
              zMax = pick$C(seriesOptions.zMax, Math.max(zMax, arrayMax$2(zData)));
            }
          }
        }
      });
      activeSeries.forEach(function(series) {
        var data = series[dataKey], i = data.length, radius;
        if (isXAxis) {
          series.getRadii(zMin, zMax, series);
        }
        if (range > 0) {
          while (i--) {
            if (isNumber$g(data[i]) && axis.dataMin <= data[i] && data[i] <= axis.max) {
              radius = series.radii ? series.radii[i] : 0;
              pxMin = Math.min((data[i] - min) * transA - radius, pxMin);
              pxMax = Math.max((data[i] - min) * transA + radius, pxMax);
            }
          }
        }
      });
      if (activeSeries.length && range > 0 && !this.logarithmic) {
        pxMax -= axisLength;
        transA *= (axisLength + Math.max(0, pxMin) - // #8901
        Math.min(pxMax, axisLength)) / axisLength;
        [
          ["min", "userMin", pxMin],
          ["max", "userMax", pxMax]
        ].forEach(function(keys2) {
          if (typeof pick$C(axis.options[keys2[0]], axis[keys2[1]]) === "undefined") {
            axis[keys2[0]] += keys2[2] / transA;
          }
        });
      }
    };
    SeriesRegistry$1.registerSeriesType("bubble", BubbleSeries$2);
    var __extends$z = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var _a$a = SeriesRegistry$1.seriesTypes, ColumnPoint = _a$a.column.prototype.pointClass, AreaRangePoint = _a$a.arearange.prototype.pointClass;
    var extend$A = Utilities.extend, isNumber$f = Utilities.isNumber;
    var ColumnRangePoint = (
      /** @class */
      function(_super) {
        __extends$z(ColumnRangePoint2, _super);
        function ColumnRangePoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.series = void 0;
          _this.options = void 0;
          _this.barX = void 0;
          _this.pointWidth = void 0;
          _this.shapeType = void 0;
          return _this;
        }
        ColumnRangePoint2.prototype.isValid = function() {
          return isNumber$f(this.low);
        };
        return ColumnRangePoint2;
      }(AreaRangePoint)
    );
    extend$A(ColumnRangePoint.prototype, {
      setState: ColumnPoint.prototype.setState
    });
    var __extends$y = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var noop$7 = H.noop;
    var _a$9 = SeriesRegistry$1.seriesTypes, AreaRangeSeries$1 = _a$9.arearange, ColumnSeries$a = _a$9.column;
    var columnProto$3 = ColumnSeries$a.prototype;
    var arearangeProto$1 = AreaRangeSeries$1.prototype;
    var clamp$7 = Utilities.clamp, merge$w = Utilities.merge, pick$B = Utilities.pick, extend$z = Utilities.extend;
    var columnRangeOptions = {
      /**
       * Extended data labels for range series types. Range series data labels
       * have no `x` and `y` options. Instead, they have `xLow`, `xHigh`,
       * `yLow` and `yHigh` options to allow the higher and lower data label
       * sets individually.
       *
       * @declare   Highcharts.SeriesAreaRangeDataLabelsOptionsObject
       * @extends   plotOptions.arearange.dataLabels
       * @since     2.3.0
       * @product   highcharts highstock
       * @apioption plotOptions.columnrange.dataLabels
       */
      pointRange: null,
      /** @ignore-option */
      marker: null,
      states: {
        hover: {
          /** @ignore-option */
          halo: false
        }
      }
    };
    var ColumnRangeSeries = (
      /** @class */
      function(_super) {
        __extends$y(ColumnRangeSeries2, _super);
        function ColumnRangeSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.points = void 0;
          _this.options = void 0;
          return _this;
        }
        ColumnRangeSeries2.prototype.setOptions = function() {
          merge$w(true, arguments[0], { stacking: void 0 });
          return arearangeProto$1.setOptions.apply(this, arguments);
        };
        ColumnRangeSeries2.prototype.translate = function() {
          var series = this, yAxis = series.yAxis, xAxis = series.xAxis, startAngleRad = xAxis.startAngleRad, start, chart = series.chart, isRadial = series.xAxis.isRadial, safeDistance = Math.max(chart.chartWidth, chart.chartHeight) + 999, plotHigh;
          function safeBounds(pixelPos) {
            return clamp$7(pixelPos, -safeDistance, safeDistance);
          }
          columnProto$3.translate.apply(series);
          series.points.forEach(function(point) {
            var shapeArgs = point.shapeArgs || {}, minPointLength = series.options.minPointLength, heightDifference, height, y;
            point.plotHigh = plotHigh = safeBounds(yAxis.translate(point.high, 0, 1, 0, 1));
            point.plotLow = safeBounds(point.plotY);
            y = plotHigh;
            height = pick$B(point.rectPlotY, point.plotY) - plotHigh;
            if (Math.abs(height) < minPointLength) {
              heightDifference = minPointLength - height;
              height += heightDifference;
              y -= heightDifference / 2;
            } else if (height < 0) {
              height *= -1;
              y -= height;
            }
            if (isRadial) {
              start = point.barX + startAngleRad;
              point.shapeType = "arc";
              point.shapeArgs = series.polarArc(y + height, y, start, start + point.pointWidth);
            } else {
              shapeArgs.height = height;
              shapeArgs.y = y;
              var _a2 = shapeArgs.x, x = _a2 === void 0 ? 0 : _a2, _b = shapeArgs.width, width = _b === void 0 ? 0 : _b;
              point.tooltipPos = chart.inverted ? [
                yAxis.len + yAxis.pos - chart.plotLeft - y - height / 2,
                xAxis.len + xAxis.pos - chart.plotTop - x - width / 2,
                height
              ] : [
                xAxis.left - chart.plotLeft + x + width / 2,
                yAxis.pos - chart.plotTop + y + height / 2,
                height
              ];
            }
          });
        };
        ColumnRangeSeries2.prototype.crispCol = function() {
          return columnProto$3.crispCol.apply(this, arguments);
        };
        ColumnRangeSeries2.prototype.drawPoints = function() {
          return columnProto$3.drawPoints.apply(this, arguments);
        };
        ColumnRangeSeries2.prototype.drawTracker = function() {
          return columnProto$3.drawTracker.apply(this, arguments);
        };
        ColumnRangeSeries2.prototype.getColumnMetrics = function() {
          return columnProto$3.getColumnMetrics.apply(this, arguments);
        };
        ColumnRangeSeries2.prototype.pointAttribs = function() {
          return columnProto$3.pointAttribs.apply(this, arguments);
        };
        ColumnRangeSeries2.prototype.adjustForMissingColumns = function() {
          return columnProto$3.adjustForMissingColumns.apply(this, arguments);
        };
        ColumnRangeSeries2.prototype.animate = function() {
          return columnProto$3.animate.apply(this, arguments);
        };
        ColumnRangeSeries2.prototype.translate3dPoints = function() {
          return columnProto$3.translate3dPoints.apply(this, arguments);
        };
        ColumnRangeSeries2.prototype.translate3dShapes = function() {
          return columnProto$3.translate3dShapes.apply(this, arguments);
        };
        ColumnRangeSeries2.defaultOptions = merge$w(ColumnSeries$a.defaultOptions, AreaRangeSeries$1.defaultOptions, columnRangeOptions);
        return ColumnRangeSeries2;
      }(AreaRangeSeries$1)
    );
    extend$z(ColumnRangeSeries.prototype, {
      directTouch: true,
      trackerGroups: ["group", "dataLabelsGroup"],
      drawGraph: noop$7,
      getSymbol: noop$7,
      polarArc: function() {
        return columnProto$3.polarArc.apply(this, arguments);
      },
      pointClass: ColumnRangePoint
    });
    SeriesRegistry$1.registerSeriesType("columnrange", ColumnRangeSeries);
    var __extends$x = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var colProto = ColumnSeries$h.prototype;
    var clamp$6 = Utilities.clamp, merge$v = Utilities.merge, pick$A = Utilities.pick;
    var ColumnPyramidSeries = (
      /** @class */
      function(_super) {
        __extends$x(ColumnPyramidSeries2, _super);
        function ColumnPyramidSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        ColumnPyramidSeries2.prototype.translate = function() {
          var series = this, chart = series.chart, options = series.options, dense = series.dense = series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick$A(
            options.borderWidth,
            dense ? 0 : 1
            // #3635
          ), yAxis = series.yAxis, threshold = options.threshold, translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold), minPointLength = pick$A(options.minPointLength, 5), metrics = series.getColumnMetrics(), pointWidth = metrics.width, seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth), pointXOffset = series.pointXOffset = metrics.offset;
          if (chart.inverted) {
            translatedThreshold -= 0.5;
          }
          if (options.pointPadding) {
            seriesBarW = Math.ceil(seriesBarW);
          }
          colProto.translate.apply(series);
          series.points.forEach(function(point) {
            var yBottom = pick$A(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotY = clamp$6(point.plotY, -safeDistance, yAxis.len + safeDistance), barX = point.plotX + pointXOffset, barW = seriesBarW / 2, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, stackTotal, stackHeight, topPointY, topXwidth, bottomXwidth, invBarPos, x1, x2, x3, x4, y1, y2;
            point.barX = barX;
            point.pointWidth = pointWidth;
            point.tooltipPos = chart.inverted ? [
              yAxis.len + yAxis.pos - chart.plotLeft - plotY,
              series.xAxis.len - barX - barW,
              barH
            ] : [
              barX + barW,
              plotY + yAxis.pos - chart.plotTop,
              barH
            ];
            stackTotal = threshold + (point.total || point.y);
            if (options.stacking === "percent") {
              stackTotal = threshold + (point.y < 0) ? -100 : 100;
            }
            topPointY = yAxis.toPixels(stackTotal, true);
            stackHeight = chart.plotHeight - topPointY - (chart.plotHeight - translatedThreshold);
            topXwidth = stackHeight ? barW * (barY - topPointY) / stackHeight : 0;
            bottomXwidth = stackHeight ? barW * (barY + barH - topPointY) / stackHeight : 0;
            x1 = barX - topXwidth + barW;
            x2 = barX + topXwidth + barW;
            x3 = barX + bottomXwidth + barW;
            x4 = barX - bottomXwidth + barW;
            y1 = barY - minPointLength;
            y2 = barY + barH;
            if (point.y < 0) {
              y1 = barY;
              y2 = barY + barH + minPointLength;
            }
            if (chart.inverted) {
              invBarPos = chart.plotWidth - barY;
              stackHeight = topPointY - (chart.plotWidth - translatedThreshold);
              topXwidth = barW * (topPointY - invBarPos) / stackHeight;
              bottomXwidth = barW * (topPointY - (invBarPos - barH)) / stackHeight;
              x1 = barX + barW + topXwidth;
              x2 = x1 - 2 * topXwidth;
              x3 = barX - bottomXwidth + barW;
              x4 = barX + bottomXwidth + barW;
              y1 = barY;
              y2 = barY + barH - minPointLength;
              if (point.y < 0) {
                y2 = barY + barH + minPointLength;
              }
            }
            point.shapeType = "path";
            point.shapeArgs = {
              // args for datalabels positioning
              x: x1,
              y: y1,
              width: x2 - x1,
              height: barH,
              // path of pyramid
              d: [
                ["M", x1, y1],
                ["L", x2, y1],
                ["L", x3, y2],
                ["L", x4, y2],
                ["Z"]
              ]
            };
          });
        };
        ColumnPyramidSeries2.defaultOptions = merge$v(ColumnSeries$h.defaultOptions, {
          // Nothing here
        });
        return ColumnPyramidSeries2;
      }(ColumnSeries$h)
    );
    SeriesRegistry$1.registerSeriesType("columnpyramid", ColumnPyramidSeries);
    var __extends$w = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var AreaRangeSeries = SeriesRegistry$1.seriesTypes.arearange;
    var merge$u = Utilities.merge, extend$y = Utilities.extend;
    var ErrorBarSeries = (
      /** @class */
      function(_super) {
        __extends$w(ErrorBarSeries2, _super);
        function ErrorBarSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        ErrorBarSeries2.prototype.getColumnMetrics = function() {
          return this.linkedParent && this.linkedParent.columnMetrics || ColumnSeries$h.prototype.getColumnMetrics.call(this);
        };
        ErrorBarSeries2.prototype.drawDataLabels = function() {
          var valKey = this.pointValKey;
          if (AreaRangeSeries) {
            AreaRangeSeries.prototype.drawDataLabels.call(this);
            this.data.forEach(function(point) {
              point.y = point[valKey];
            });
          }
        };
        ErrorBarSeries2.prototype.toYData = function(point) {
          return [point.low, point.high];
        };
        ErrorBarSeries2.defaultOptions = merge$u(BoxPlotSeries.defaultOptions, {
          /**
           * The main color of the bars. This can be overridden by
           * [stemColor](#plotOptions.errorbar.stemColor) and
           * [whiskerColor](#plotOptions.errorbar.whiskerColor) individually.
           *
           * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
           *         Error bar styling
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default #000000
           * @since   3.0
           * @product highcharts
           */
          color: palette.neutralColor100,
          grouping: false,
          /**
           * The parent series of the error bar. The default value links it to
           * the previous series. Otherwise, use the id of the parent series.
           *
           * @since   3.0
           * @product highcharts
           */
          linkedTo: ":previous",
          tooltip: {
            pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
          },
          /**
           * The line width of the whiskers, the horizontal lines marking
           * low and high values. When `null`, the general
           * [lineWidth](#plotOptions.errorbar.lineWidth) applies.
           *
           * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
           *         Error bar styling
           *
           * @type    {number}
           * @since   3.0
           * @product highcharts
           */
          whiskerWidth: null
        });
        return ErrorBarSeries2;
      }(BoxPlotSeries)
    );
    extend$y(ErrorBarSeries.prototype, {
      // array point configs are mapped to this
      pointArrayMap: ["low", "high"],
      pointValKey: "high",
      doQuartiles: false
    });
    SeriesRegistry$1.registerSeriesType("errorbar", ErrorBarSeries);
    var __extends$v = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Point$1 = SeriesRegistry$1.series.prototype.pointClass;
    var GaugePoint = (
      /** @class */
      function(_super) {
        __extends$v(GaugePoint2, _super);
        function GaugePoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.options = void 0;
          _this.series = void 0;
          _this.shapeArgs = void 0;
          return _this;
        }
        GaugePoint2.prototype.setState = function(state) {
          this.state = state;
        };
        return GaugePoint2;
      }(Point$1)
    );
    var __extends$u = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var noop$6 = H.noop;
    var Series$a = SeriesRegistry$1.series, ColumnSeries$9 = SeriesRegistry$1.seriesTypes.column;
    var clamp$5 = Utilities.clamp, isNumber$e = Utilities.isNumber, extend$x = Utilities.extend, merge$t = Utilities.merge, pick$z = Utilities.pick, pInt$1 = Utilities.pInt;
    var GaugeSeries$1 = (
      /** @class */
      function(_super) {
        __extends$u(GaugeSeries2, _super);
        function GaugeSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.points = void 0;
          _this.options = void 0;
          _this.yAxis = void 0;
          return _this;
        }
        GaugeSeries2.prototype.translate = function() {
          var series = this, yAxis = series.yAxis, options = series.options, center = yAxis.center;
          series.generatePoints();
          series.points.forEach(function(point) {
            var dialOptions = merge$t(options.dial, point.dial), radius = pInt$1(pick$z(dialOptions.radius, "80%")) * center[2] / 200, baseLength = pInt$1(pick$z(dialOptions.baseLength, "70%")) * radius / 100, rearLength = pInt$1(pick$z(dialOptions.rearLength, "10%")) * radius / 100, baseWidth = dialOptions.baseWidth || 3, topWidth = dialOptions.topWidth || 1, overshoot = options.overshoot, rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true);
            if (isNumber$e(overshoot) || options.wrap === false) {
              overshoot = isNumber$e(overshoot) ? overshoot / 180 * Math.PI : 0;
              rotation = clamp$5(rotation, yAxis.startAngleRad - overshoot, yAxis.endAngleRad + overshoot);
            }
            rotation = rotation * 180 / Math.PI;
            point.shapeType = "path";
            var d = dialOptions.path || [
              ["M", -rearLength, -baseWidth / 2],
              ["L", baseLength, -baseWidth / 2],
              ["L", radius, -topWidth / 2],
              ["L", radius, topWidth / 2],
              ["L", baseLength, baseWidth / 2],
              ["L", -rearLength, baseWidth / 2],
              ["Z"]
            ];
            point.shapeArgs = {
              d,
              translateX: center[0],
              translateY: center[1],
              rotation
            };
            point.plotX = center[0];
            point.plotY = center[1];
          });
        };
        GaugeSeries2.prototype.drawPoints = function() {
          var series = this, chart = series.chart, center = series.yAxis.center, pivot = series.pivot, options = series.options, pivotOptions = options.pivot, renderer = chart.renderer;
          series.points.forEach(function(point) {
            var graphic = point.graphic, shapeArgs = point.shapeArgs, d = shapeArgs.d, dialOptions = merge$t(options.dial, point.dial);
            if (graphic) {
              graphic.animate(shapeArgs);
              shapeArgs.d = d;
            } else {
              point.graphic = renderer[point.shapeType](shapeArgs).attr({
                // required by VML when animation is false
                rotation: shapeArgs.rotation,
                zIndex: 1
              }).addClass("highcharts-dial").add(series.group);
            }
            if (!chart.styledMode) {
              point.graphic[graphic ? "animate" : "attr"]({
                stroke: dialOptions.borderColor || "none",
                "stroke-width": dialOptions.borderWidth || 0,
                fill: dialOptions.backgroundColor || palette.neutralColor100
              });
            }
          });
          if (pivot) {
            pivot.animate({
              translateX: center[0],
              translateY: center[1]
            });
          } else {
            series.pivot = renderer.circle(0, 0, pick$z(pivotOptions.radius, 5)).attr({
              zIndex: 2
            }).addClass("highcharts-pivot").translate(center[0], center[1]).add(series.group);
            if (!chart.styledMode) {
              series.pivot.attr({
                "stroke-width": pivotOptions.borderWidth || 0,
                stroke: pivotOptions.borderColor || palette.neutralColor20,
                fill: pivotOptions.backgroundColor || palette.neutralColor100
              });
            }
          }
        };
        GaugeSeries2.prototype.animate = function(init) {
          var series = this;
          if (!init) {
            series.points.forEach(function(point) {
              var graphic = point.graphic;
              if (graphic) {
                graphic.attr({
                  rotation: series.yAxis.startAngleRad * 180 / Math.PI
                });
                graphic.animate({
                  rotation: point.shapeArgs.rotation
                }, series.options.animation);
              }
            });
          }
        };
        GaugeSeries2.prototype.render = function() {
          this.group = this.plotGroup("group", "series", this.visible ? "visible" : "hidden", this.options.zIndex, this.chart.seriesGroup);
          Series$a.prototype.render.call(this);
          this.group.clip(this.chart.clipRect);
        };
        GaugeSeries2.prototype.setData = function(data, redraw) {
          Series$a.prototype.setData.call(this, data, false);
          this.processData();
          this.generatePoints();
          if (pick$z(redraw, true)) {
            this.chart.redraw();
          }
        };
        GaugeSeries2.prototype.hasData = function() {
          return !!this.points.length;
        };
        GaugeSeries2.defaultOptions = merge$t(Series$a.defaultOptions, {
          /**
           * When this option is `true`, the dial will wrap around the axes.
           * For instance, in a full-range gauge going from 0 to 360, a value
           * of 400 will point to 40\. When `wrap` is `false`, the dial stops
           * at 360.
           *
           * @see [overshoot](#plotOptions.gauge.overshoot)
           *
           * @type      {boolean}
           * @default   true
           * @since     3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.wrap
           */
          /**
           * Data labels for the gauge. For gauges, the data labels are
           * enabled by default and shown in a bordered box below the point.
           *
           * @since   2.3.0
           * @product highcharts
           */
          dataLabels: {
            borderColor: palette.neutralColor20,
            borderRadius: 3,
            borderWidth: 1,
            crop: false,
            defer: false,
            enabled: true,
            verticalAlign: "top",
            y: 15,
            zIndex: 2
          },
          /**
           * Options for the dial or arrow pointer of the gauge.
           *
           * In styled mode, the dial is styled with the
           * `.highcharts-gauge-series .highcharts-dial` rule.
           *
           * @sample {highcharts} highcharts/css/gauge/
           *         Styled mode
           *
           * @type    {*}
           * @since   2.3.0
           * @product highcharts
           */
          dial: {},
          /**
           * The length of the dial's base part, relative to the total radius
           * or length of the dial.
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-dial/
           *         Dial options demonstrated
           *
           * @type      {string}
           * @default   70%
           * @since     2.3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.dial.baseLength
           */
          /**
           * The pixel width of the base of the gauge dial. The base is the
           * part closest to the pivot, defined by baseLength.
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-dial/
           *         Dial options demonstrated
           *
           * @type      {number}
           * @default   3
           * @since     2.3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.dial.baseWidth
           */
          /**
           * The radius or length of the dial, in percentages relative to the
           * radius of the gauge itself.
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-dial/
           *         Dial options demonstrated
           *
           * @type      {string}
           * @default   80%
           * @since     2.3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.dial.radius
           */
          /**
           * The length of the dial's rear end, the part that extends out on
           * the other side of the pivot. Relative to the dial's length.
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-dial/
           *         Dial options demonstrated
           *
           * @type      {string}
           * @default   10%
           * @since     2.3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.dial.rearLength
           */
          /**
           * The width of the top of the dial, closest to the perimeter. The
           * pivot narrows in from the base to the top.
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-dial/
           *         Dial options demonstrated
           *
           * @type      {number}
           * @default   1
           * @since     2.3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.dial.topWidth
           */
          /**
           * The background or fill color of the gauge's dial.
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-dial/
           *         Dial options demonstrated
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default   #000000
           * @since     2.3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.dial.backgroundColor
           */
          /**
           * The border color or stroke of the gauge's dial. By default, the
           * borderWidth is 0, so this must be set in addition to a custom
           * border color.
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-dial/
           *         Dial options demonstrated
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default   #cccccc
           * @since     2.3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.dial.borderColor
           */
          /**
           * The width of the gauge dial border in pixels.
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-dial/
           *         Dial options demonstrated
           *
           * @type      {number}
           * @default   0
           * @since     2.3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.dial.borderWidth
           */
          /**
           * Allow the dial to overshoot the end of the perimeter axis by
           * this many degrees. Say if the gauge axis goes from 0 to 60, a
           * value of 100, or 1000, will show 5 degrees beyond the end of the
           * axis when this option is set to 5.
           *
           * @see [wrap](#plotOptions.gauge.wrap)
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-overshoot/
           *         Allow 5 degrees overshoot
           *
           * @type      {number}
           * @since     3.0.10
           * @product   highcharts
           * @apioption plotOptions.gauge.overshoot
           */
          /**
           * Options for the pivot or the center point of the gauge.
           *
           * In styled mode, the pivot is styled with the
           * `.highcharts-gauge-series .highcharts-pivot` rule.
           *
           * @sample {highcharts} highcharts/css/gauge/
           *         Styled mode
           *
           * @type    {*}
           * @since   2.3.0
           * @product highcharts
           */
          pivot: {},
          /**
           * The pixel radius of the pivot.
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
           *         Pivot options demonstrated
           *
           * @type      {number}
           * @default   5
           * @since     2.3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.pivot.radius
           */
          /**
           * The border or stroke width of the pivot.
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
           *         Pivot options demonstrated
           *
           * @type      {number}
           * @default   0
           * @since     2.3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.pivot.borderWidth
           */
          /**
           * The border or stroke color of the pivot. In able to change this,
           * the borderWidth must also be set to something other than the
           * default 0.
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
           *         Pivot options demonstrated
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default   #cccccc
           * @since     2.3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.pivot.borderColor
           */
          /**
           * The background color or fill of the pivot.
           *
           * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
           *         Pivot options demonstrated
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default   #000000
           * @since     2.3.0
           * @product   highcharts
           * @apioption plotOptions.gauge.pivot.backgroundColor
           */
          tooltip: {
            headerFormat: ""
          },
          /**
           * Whether to display this particular series or series type in the
           * legend. Defaults to false for gauge series.
           *
           * @since   2.3.0
           * @product highcharts
           */
          showInLegend: false
          // Prototype members
        });
        return GaugeSeries2;
      }(Series$a)
    );
    extend$x(GaugeSeries$1.prototype, {
      // chart.angular will be set to true when a gauge series is present,
      // and this will be used on the axes
      angular: true,
      directTouch: true,
      drawGraph: noop$6,
      drawTracker: ColumnSeries$9.prototype.drawTracker,
      fixedBox: true,
      forceDL: true,
      noSharedTooltip: true,
      pointClass: GaugePoint,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    SeriesRegistry$1.registerSeriesType("gauge", GaugeSeries$1);
    var __extends$t = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var BubbleSeries$1 = SeriesRegistry$1.seriesTypes.bubble;
    var PackedBubblePoint = (
      /** @class */
      function(_super) {
        __extends$t(PackedBubblePoint2, _super);
        function PackedBubblePoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.degree = NaN;
          _this.mass = NaN;
          _this.radius = NaN;
          _this.options = void 0;
          _this.series = void 0;
          _this.value = null;
          return _this;
        }
        PackedBubblePoint2.prototype.destroy = function() {
          if (this.series.layout) {
            this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);
          }
          return Point$2.prototype.destroy.apply(this, arguments);
        };
        PackedBubblePoint2.prototype.firePointEvent = function() {
          var series = this.series, seriesOptions = series.options;
          if (this.isParentNode && seriesOptions.parentNode) {
            var temp = seriesOptions.allowPointSelect;
            seriesOptions.allowPointSelect = seriesOptions.parentNode.allowPointSelect;
            Point$2.prototype.firePointEvent.apply(this, arguments);
            seriesOptions.allowPointSelect = temp;
          } else {
            Point$2.prototype.firePointEvent.apply(this, arguments);
          }
        };
        PackedBubblePoint2.prototype.select = function() {
          var point = this, series = this.series, chart = series.chart;
          if (point.isParentNode) {
            chart.getSelectedPoints = chart.getSelectedParentNodes;
            Point$2.prototype.select.apply(this, arguments);
            chart.getSelectedPoints = Chart$1.prototype.getSelectedPoints;
          } else {
            Point$2.prototype.select.apply(this, arguments);
          }
        };
        return PackedBubblePoint2;
      }(BubbleSeries$1.prototype.pointClass)
    );
    var addEvent$n = Utilities.addEvent;
    H.dragNodesMixin = {
      /**
       * Mouse down action, initializing drag&drop mode.
       *
       * @private
       * @param {Highcharts.Point} point The point that event occured.
       * @param {Highcharts.PointerEventObject} event Browser event, before normalization.
       * @return {void}
       */
      onMouseDown: function(point, event) {
        var normalizedEvent = this.chart.pointer.normalize(event);
        point.fixedPosition = {
          chartX: normalizedEvent.chartX,
          chartY: normalizedEvent.chartY,
          plotX: point.plotX,
          plotY: point.plotY
        };
        point.inDragMode = true;
      },
      /**
       * Mouse move action during drag&drop.
       *
       * @private
       *
       * @param {global.Event} event Browser event, before normalization.
       * @param {Highcharts.Point} point The point that event occured.
       *
       * @return {void}
       */
      onMouseMove: function(point, event) {
        if (point.fixedPosition && point.inDragMode) {
          var series = this, chart = series.chart, normalizedEvent = chart.pointer.normalize(event), diffX = point.fixedPosition.chartX - normalizedEvent.chartX, diffY = point.fixedPosition.chartY - normalizedEvent.chartY, newPlotX = void 0, newPlotY = void 0, graphLayoutsLookup = chart.graphLayoutsLookup;
          if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {
            newPlotX = point.fixedPosition.plotX - diffX;
            newPlotY = point.fixedPosition.plotY - diffY;
            if (chart.isInsidePlot(newPlotX, newPlotY)) {
              point.plotX = newPlotX;
              point.plotY = newPlotY;
              point.hasDragged = true;
              this.redrawHalo(point);
              graphLayoutsLookup.forEach(function(layout) {
                layout.restartSimulation();
              });
            }
          }
        }
      },
      /**
       * Mouse up action, finalizing drag&drop.
       *
       * @private
       * @param {Highcharts.Point} point The point that event occured.
       * @return {void}
       */
      onMouseUp: function(point, event) {
        if (point.fixedPosition) {
          if (point.hasDragged) {
            if (this.layout.enableSimulation) {
              this.layout.start();
            } else {
              this.chart.redraw();
            }
          }
          point.inDragMode = point.hasDragged = false;
          if (!this.options.fixedDraggable) {
            delete point.fixedPosition;
          }
        }
      },
      // Draggable mode:
      /**
       * Redraw halo on mousemove during the drag&drop action.
       *
       * @private
       * @param {Highcharts.Point} point The point that should show halo.
       * @return {void}
       */
      redrawHalo: function(point) {
        if (point && this.halo) {
          this.halo.attr({
            d: point.haloPath(this.options.states.hover.halo.size)
          });
        }
      }
    };
    addEvent$n(Chart$1, "load", function() {
      var chart = this, mousedownUnbinder, mousemoveUnbinder, mouseupUnbinder;
      if (chart.container) {
        mousedownUnbinder = addEvent$n(chart.container, "mousedown", function(event) {
          var point = chart.hoverPoint;
          if (point && point.series && point.series.hasDraggableNodes && point.series.options.draggable) {
            point.series.onMouseDown(point, event);
            mousemoveUnbinder = addEvent$n(chart.container, "mousemove", function(e2) {
              return point && point.series && point.series.onMouseMove(point, e2);
            });
            mouseupUnbinder = addEvent$n(chart.container.ownerDocument, "mouseup", function(e2) {
              mousemoveUnbinder();
              mouseupUnbinder();
              return point && point.series && point.series.onMouseUp(point, e2);
            });
          }
        });
      }
      addEvent$n(chart, "destroy", function() {
        mousedownUnbinder();
      });
    });
    H.networkgraphIntegrations = {
      verlet: {
        /**
         * Attractive force funtion. Can be replaced by API's
         * `layoutAlgorithm.attractiveForce`
         *
         * @private
         * @param {number} d current distance between two nodes
         * @param {number} k expected distance between two nodes
         * @return {number} force
         */
        attractiveForceFunction: function(d, k) {
          return (k - d) / d;
        },
        /**
         * Repulsive force funtion. Can be replaced by API's
         * `layoutAlgorithm.repulsiveForce`
         *
         * @private
         * @param {number} d current distance between two nodes
         * @param {number} k expected distance between two nodes
         * @return {number} force
         */
        repulsiveForceFunction: function(d, k) {
          return (k - d) / d * (k > d ? 1 : 0);
        },
        /**
         * Barycenter force. Calculate and applys barycenter forces on the
         * nodes. Making them closer to the center of their barycenter point.
         *
         * In Verlet integration, force is applied on a node immidatelly to it's
         * `plotX` and `plotY` position.
         *
         * @private
         * @return {void}
         */
        barycenter: function() {
          var gravitationalConstant = this.options.gravitationalConstant, xFactor = this.barycenter.xFactor, yFactor = this.barycenter.yFactor;
          xFactor = (xFactor - (this.box.left + this.box.width) / 2) * gravitationalConstant;
          yFactor = (yFactor - (this.box.top + this.box.height) / 2) * gravitationalConstant;
          this.nodes.forEach(function(node) {
            if (!node.fixedPosition) {
              node.plotX -= xFactor / node.mass / node.degree;
              node.plotY -= yFactor / node.mass / node.degree;
            }
          });
        },
        /**
         * Repulsive force.
         *
         * In Verlet integration, force is applied on a node immidatelly to it's
         * `plotX` and `plotY` position.
         *
         * @private
         * @param {Highcharts.Point} node
         *        Node that should be translated by force.
         * @param {number} force
         *        Force calcualated in `repulsiveForceFunction`
         * @param {Highcharts.PositionObject} distance
         *        Distance between two nodes e.g. `{x, y}`
         * @return {void}
         */
        repulsive: function(node, force, distanceXY) {
          var factor = force * this.diffTemperature / node.mass / node.degree;
          if (!node.fixedPosition) {
            node.plotX += distanceXY.x * factor;
            node.plotY += distanceXY.y * factor;
          }
        },
        /**
         * Attractive force.
         *
         * In Verlet integration, force is applied on a node immidatelly to it's
         * `plotX` and `plotY` position.
         *
         * @private
         * @param {Highcharts.Point} link
         *        Link that connects two nodes
         * @param {number} force
         *        Force calcualated in `repulsiveForceFunction`
         * @param {Highcharts.PositionObject} distance
         *        Distance between two nodes e.g. `{x, y}`
         * @return {void}
         */
        attractive: function(link, force, distanceXY) {
          var massFactor = link.getMass(), translatedX = -distanceXY.x * force * this.diffTemperature, translatedY = -distanceXY.y * force * this.diffTemperature;
          if (!link.fromNode.fixedPosition) {
            link.fromNode.plotX -= translatedX * massFactor.fromNode / link.fromNode.degree;
            link.fromNode.plotY -= translatedY * massFactor.fromNode / link.fromNode.degree;
          }
          if (!link.toNode.fixedPosition) {
            link.toNode.plotX += translatedX * massFactor.toNode / link.toNode.degree;
            link.toNode.plotY += translatedY * massFactor.toNode / link.toNode.degree;
          }
        },
        /**
         * Integration method.
         *
         * In Verlet integration, forces are applied on node immidatelly to it's
         * `plotX` and `plotY` position.
         *
         * Verlet without velocity:
         *
         *    x(n+1) = 2 * x(n) - x(n-1) + A(T) * deltaT ^ 2
         *
         * where:
         *     - x(n+1) - new position
         *     - x(n) - current position
         *     - x(n-1) - previous position
         *
         * Assuming A(t) = 0 (no acceleration) and (deltaT = 1) we get:
         *
         *     x(n+1) = x(n) + (x(n) - x(n-1))
         *
         * where:
         *     - (x(n) - x(n-1)) - position change
         *
         * TO DO:
         * Consider Verlet with velocity to support additional
         * forces. Or even Time-Corrected Verlet by Jonathan
         * "lonesock" Dummer
         *
         * @private
         * @param {Highcharts.NetworkgraphLayout} layout layout object
         * @param {Highcharts.Point} node node that should be translated
         * @return {void}
         */
        integrate: function(layout, node) {
          var friction = -layout.options.friction, maxSpeed = layout.options.maxSpeed, prevX = node.prevX, prevY = node.prevY, diffX = (node.plotX + node.dispX - prevX) * friction, diffY = (node.plotY + node.dispY - prevY) * friction, abs = Math.abs, signX = abs(diffX) / (diffX || 1), signY = abs(diffY) / (diffY || 1);
          diffX = signX * Math.min(maxSpeed, Math.abs(diffX));
          diffY = signY * Math.min(maxSpeed, Math.abs(diffY));
          node.prevX = node.plotX + node.dispX;
          node.prevY = node.plotY + node.dispY;
          node.plotX += diffX;
          node.plotY += diffY;
          node.temperature = layout.vectorLength({
            x: diffX,
            y: diffY
          });
        },
        /**
         * Estiamte the best possible distance between two nodes, making graph
         * readable.
         *
         * @private
         * @param {Highcharts.NetworkgraphLayout} layout layout object
         * @return {number}
         */
        getK: function(layout) {
          return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.5);
        }
      },
      euler: {
        /**
         * Attractive force funtion. Can be replaced by API's
         * `layoutAlgorithm.attractiveForce`
         *
         * Other forces that can be used:
         *
         * basic, not recommended:
         *    `function (d, k) { return d / k }`
         *
         * @private
         * @param {number} d current distance between two nodes
         * @param {number} k expected distance between two nodes
         * @return {number} force
         */
        attractiveForceFunction: function(d, k) {
          return d * d / k;
        },
        /**
         * Repulsive force funtion. Can be replaced by API's
         * `layoutAlgorithm.repulsiveForce`.
         *
         * Other forces that can be used:
         *
         * basic, not recommended:
         *    `function (d, k) { return k / d }`
         *
         * standard:
         *    `function (d, k) { return k * k / d }`
         *
         * grid-variant:
         *    `function (d, k) { return k * k / d * (2 * k - d > 0 ? 1 : 0) }`
         *
         * @private
         * @param {number} d current distance between two nodes
         * @param {number} k expected distance between two nodes
         * @return {number} force
         */
        repulsiveForceFunction: function(d, k) {
          return k * k / d;
        },
        /**
         * Barycenter force. Calculate and applys barycenter forces on the
         * nodes. Making them closer to the center of their barycenter point.
         *
         * In Euler integration, force is stored in a node, not changing it's
         * position. Later, in `integrate()` forces are applied on nodes.
         *
         * @private
         * @return {void}
         */
        barycenter: function() {
          var gravitationalConstant = this.options.gravitationalConstant, xFactor = this.barycenter.xFactor, yFactor = this.barycenter.yFactor;
          this.nodes.forEach(function(node) {
            if (!node.fixedPosition) {
              var degree = node.getDegree(), phi = degree * (1 + degree / 2);
              node.dispX += (xFactor - node.plotX) * gravitationalConstant * phi / node.degree;
              node.dispY += (yFactor - node.plotY) * gravitationalConstant * phi / node.degree;
            }
          });
        },
        /**
         * Repulsive force.
         *
         * @private
         * @param {Highcharts.Point} node
         *        Node that should be translated by force.
         * @param {number} force
         *        Force calcualated in `repulsiveForceFunction`
         * @param {Highcharts.PositionObject} distanceXY
         *        Distance between two nodes e.g. `{x, y}`
         * @return {void}
         */
        repulsive: function(node, force, distanceXY, distanceR) {
          node.dispX += distanceXY.x / distanceR * force / node.degree;
          node.dispY += distanceXY.y / distanceR * force / node.degree;
        },
        /**
         * Attractive force.
         *
         * In Euler integration, force is stored in a node, not changing it's
         * position. Later, in `integrate()` forces are applied on nodes.
         *
         * @private
         * @param {Highcharts.Point} link
         *        Link that connects two nodes
         * @param {number} force
         *        Force calcualated in `repulsiveForceFunction`
         * @param {Highcharts.PositionObject} distanceXY
         *        Distance between two nodes e.g. `{x, y}`
         * @param {number} distanceR
         * @return {void}
         */
        attractive: function(link, force, distanceXY, distanceR) {
          var massFactor = link.getMass(), translatedX = distanceXY.x / distanceR * force, translatedY = distanceXY.y / distanceR * force;
          if (!link.fromNode.fixedPosition) {
            link.fromNode.dispX -= translatedX * massFactor.fromNode / link.fromNode.degree;
            link.fromNode.dispY -= translatedY * massFactor.fromNode / link.fromNode.degree;
          }
          if (!link.toNode.fixedPosition) {
            link.toNode.dispX += translatedX * massFactor.toNode / link.toNode.degree;
            link.toNode.dispY += translatedY * massFactor.toNode / link.toNode.degree;
          }
        },
        /**
         * Integration method.
         *
         * In Euler integration, force were stored in a node, not changing it's
         * position. Now, in the integrator method, we apply changes.
         *
         * Euler:
         *
         * Basic form: `x(n+1) = x(n) + v(n)`
         *
         * With Rengoild-Fruchterman we get:
         * `x(n+1) = x(n) + v(n) / length(v(n)) * min(v(n), temperature(n))`
         * where:
         * - `x(n+1)`: next position
         * - `x(n)`: current position
         * - `v(n)`: velocity (comes from net force)
         * - `temperature(n)`: current temperature
         *
         * Known issues:
         * Oscillations when force vector has the same magnitude but opposite
         * direction in the next step. Potentially solved by decreasing force by
         * `v * (1 / node.degree)`
         *
         * Note:
         * Actually `min(v(n), temperature(n))` replaces simulated annealing.
         *
         * @private
         * @param {Highcharts.NetworkgraphLayout} layout
         *        Layout object
         * @param {Highcharts.Point} node
         *        Node that should be translated
         * @return {void}
         */
        integrate: function(layout, node) {
          var distanceR;
          node.dispX += node.dispX * layout.options.friction;
          node.dispY += node.dispY * layout.options.friction;
          distanceR = node.temperature = layout.vectorLength({
            x: node.dispX,
            y: node.dispY
          });
          if (distanceR !== 0) {
            node.plotX += node.dispX / distanceR * Math.min(Math.abs(node.dispX), layout.temperature);
            node.plotY += node.dispY / distanceR * Math.min(Math.abs(node.dispY), layout.temperature);
          }
        },
        /**
         * Estiamte the best possible distance between two nodes, making graph
         * readable.
         *
         * @private
         * @param {object} layout layout object
         * @return {number}
         */
        getK: function(layout) {
          return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.3);
        }
      }
    };
    var extend$w = Utilities.extend;
    var QuadTreeNode = H.QuadTreeNode = function(box) {
      this.box = box;
      this.boxSize = Math.min(box.width, box.height);
      this.nodes = [];
      this.isInternal = false;
      this.body = false;
      this.isEmpty = true;
    };
    extend$w(
      QuadTreeNode.prototype,
      /** @lends Highcharts.QuadTreeNode.prototype */
      {
        /**
         * Insert recursively point(node) into the QuadTree. If the given
         * quadrant is already occupied, divide it into smaller quadrants.
         *
         * @param {Highcharts.Point} point
         *        Point/node to be inserted
         * @param {number} depth
         *        Max depth of the QuadTree
         */
        insert: function(point, depth) {
          var newQuadTreeNode;
          if (this.isInternal) {
            this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);
          } else {
            this.isEmpty = false;
            if (!this.body) {
              this.isInternal = false;
              this.body = point;
            } else {
              if (depth) {
                this.isInternal = true;
                this.divideBox();
                if (this.body !== true) {
                  this.nodes[this.getBoxPosition(this.body)].insert(this.body, depth - 1);
                  this.body = true;
                }
                this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);
              } else {
                newQuadTreeNode = new QuadTreeNode({
                  top: point.plotX,
                  left: point.plotY,
                  // Width/height below 1px
                  width: 0.1,
                  height: 0.1
                });
                newQuadTreeNode.body = point;
                newQuadTreeNode.isInternal = false;
                this.nodes.push(newQuadTreeNode);
              }
            }
          }
        },
        /**
         * Each quad node requires it's mass and center position. That mass and
         * position is used to imitate real node in the layout by approximation.
         */
        updateMassAndCenter: function() {
          var mass = 0, plotX = 0, plotY = 0;
          if (this.isInternal) {
            this.nodes.forEach(function(pointMass) {
              if (!pointMass.isEmpty) {
                mass += pointMass.mass;
                plotX += pointMass.plotX * pointMass.mass;
                plotY += pointMass.plotY * pointMass.mass;
              }
            });
            plotX /= mass;
            plotY /= mass;
          } else if (this.body) {
            mass = this.body.mass;
            plotX = this.body.plotX;
            plotY = this.body.plotY;
          }
          this.mass = mass;
          this.plotX = plotX;
          this.plotY = plotY;
        },
        /**
         * When inserting another node into the box, that already hove one node,
         * divide the available space into another four quadrants.
         *
         * Indexes of quadrants are:
         * ```
         * -------------               -------------
         * |           |               |     |     |
         * |           |               |  0  |  1  |
         * |           |   divide()    |     |     |
         * |     1     | ----------->  -------------
         * |           |               |     |     |
         * |           |               |  3  |  2  |
         * |           |               |     |     |
         * -------------               -------------
         * ```
         */
        divideBox: function() {
          var halfWidth = this.box.width / 2, halfHeight = this.box.height / 2;
          this.nodes[0] = new QuadTreeNode({
            left: this.box.left,
            top: this.box.top,
            width: halfWidth,
            height: halfHeight
          });
          this.nodes[1] = new QuadTreeNode({
            left: this.box.left + halfWidth,
            top: this.box.top,
            width: halfWidth,
            height: halfHeight
          });
          this.nodes[2] = new QuadTreeNode({
            left: this.box.left + halfWidth,
            top: this.box.top + halfHeight,
            width: halfWidth,
            height: halfHeight
          });
          this.nodes[3] = new QuadTreeNode({
            left: this.box.left,
            top: this.box.top + halfHeight,
            width: halfWidth,
            height: halfHeight
          });
        },
        /**
         * Determine which of the quadrants should be used when placing node in
         * the QuadTree. Returned index is always in range `< 0 , 3 >`.
         *
         * @param {Highcharts.Point} point
         * @return {number}
         */
        getBoxPosition: function(point) {
          var left = point.plotX < this.box.left + this.box.width / 2, top = point.plotY < this.box.top + this.box.height / 2, index;
          if (left) {
            if (top) {
              index = 0;
            } else {
              index = 3;
            }
          } else {
            if (top) {
              index = 1;
            } else {
              index = 2;
            }
          }
          return index;
        }
      }
    );
    var QuadTree = H.QuadTree = function(x, y, width, height) {
      this.box = {
        left: x,
        top: y,
        width,
        height
      };
      this.maxDepth = 25;
      this.root = new QuadTreeNode(this.box, "0");
      this.root.isInternal = true;
      this.root.isRoot = true;
      this.root.divideBox();
    };
    extend$w(
      QuadTree.prototype,
      /** @lends Highcharts.QuadTree.prototype */
      {
        /**
         * Insert nodes into the QuadTree
         *
         * @param {Array<Highcharts.Point>} points
         */
        insertNodes: function(points) {
          points.forEach(function(point) {
            this.root.insert(point, this.maxDepth);
          }, this);
        },
        /**
         * Depfth first treversal (DFS). Using `before` and `after` callbacks,
         * we can get two results: preorder and postorder traversals, reminder:
         *
         * ```
         *     (a)
         *     / \
         *   (b) (c)
         *   / \
         * (d) (e)
         * ```
         *
         * DFS (preorder): `a -> b -> d -> e -> c`
         *
         * DFS (postorder): `d -> e -> b -> c -> a`
         *
         * @param {Highcharts.QuadTreeNode|null} node
         * @param {Function} [beforeCallback] function to be called before
         *                      visiting children nodes
         * @param {Function} [afterCallback] function to be called after
         *                      visiting children nodes
         */
        visitNodeRecursive: function(node, beforeCallback, afterCallback) {
          var goFurther;
          if (!node) {
            node = this.root;
          }
          if (node === this.root && beforeCallback) {
            goFurther = beforeCallback(node);
          }
          if (goFurther === false) {
            return;
          }
          node.nodes.forEach(function(qtNode) {
            if (qtNode.isInternal) {
              if (beforeCallback) {
                goFurther = beforeCallback(qtNode);
              }
              if (goFurther === false) {
                return;
              }
              this.visitNodeRecursive(qtNode, beforeCallback, afterCallback);
            } else if (qtNode.body) {
              if (beforeCallback) {
                beforeCallback(qtNode.body);
              }
            }
            if (afterCallback) {
              afterCallback(qtNode);
            }
          }, this);
          if (node === this.root && afterCallback) {
            afterCallback(node);
          }
        },
        /**
         * Calculate mass of the each QuadNode in the tree.
         */
        calculateMassAndCenter: function() {
          this.visitNodeRecursive(null, null, function(node) {
            node.updateMassAndCenter();
          });
        }
      }
    );
    var setAnimation = animationExports.setAnimation;
    var addEvent$m = Utilities.addEvent, clamp$4 = Utilities.clamp, defined$e = Utilities.defined, extend$v = Utilities.extend, isFunction = Utilities.isFunction, pick$y = Utilities.pick;
    H.layouts = {
      "reingold-fruchterman": function() {
      }
    };
    extend$v(
      /**
       * Reingold-Fruchterman algorithm from
       * "Graph Drawing by Force-directed Placement" paper.
       * @private
       */
      H.layouts["reingold-fruchterman"].prototype,
      {
        init: function(options) {
          this.options = options;
          this.nodes = [];
          this.links = [];
          this.series = [];
          this.box = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
          this.setInitialRendering(true);
          this.integration = H.networkgraphIntegrations[options.integration];
          this.enableSimulation = options.enableSimulation;
          this.attractiveForce = pick$y(options.attractiveForce, this.integration.attractiveForceFunction);
          this.repulsiveForce = pick$y(options.repulsiveForce, this.integration.repulsiveForceFunction);
          this.approximation = options.approximation;
        },
        updateSimulation: function(enable) {
          this.enableSimulation = pick$y(enable, this.options.enableSimulation);
        },
        start: function() {
          var layout = this, series = this.series, options = this.options;
          layout.currentStep = 0;
          layout.forces = series[0] && series[0].forces || [];
          layout.chart = series[0] && series[0].chart;
          if (layout.initialRendering) {
            layout.initPositions();
            series.forEach(function(s) {
              s.finishedAnimating = true;
              s.render();
            });
          }
          layout.setK();
          layout.resetSimulation(options);
          if (layout.enableSimulation) {
            layout.step();
          }
        },
        step: function() {
          var layout = this, series = this.series;
          this.options;
          layout.currentStep++;
          if (layout.approximation === "barnes-hut") {
            layout.createQuadTree();
            layout.quadTree.calculateMassAndCenter();
          }
          layout.forces.forEach(function(forceName) {
            layout[forceName + "Forces"](layout.temperature);
          });
          layout.applyLimits(layout.temperature);
          layout.temperature = layout.coolDown(layout.startTemperature, layout.diffTemperature, layout.currentStep);
          layout.prevSystemTemperature = layout.systemTemperature;
          layout.systemTemperature = layout.getSystemTemperature();
          if (layout.enableSimulation) {
            series.forEach(function(s) {
              if (s.chart) {
                s.render();
              }
            });
            if (layout.maxIterations-- && isFinite(layout.temperature) && !layout.isStable()) {
              if (layout.simulation) {
                H.win.cancelAnimationFrame(layout.simulation);
              }
              layout.simulation = H.win.requestAnimationFrame(function() {
                layout.step();
              });
            } else {
              layout.simulation = false;
            }
          }
        },
        stop: function() {
          if (this.simulation) {
            H.win.cancelAnimationFrame(this.simulation);
          }
        },
        setArea: function(x, y, w2, h) {
          this.box = {
            left: x,
            top: y,
            width: w2,
            height: h
          };
        },
        setK: function() {
          this.k = this.options.linkLength || this.integration.getK(this);
        },
        addElementsToCollection: function(elements, collection) {
          elements.forEach(function(elem) {
            if (collection.indexOf(elem) === -1) {
              collection.push(elem);
            }
          });
        },
        removeElementFromCollection: function(element, collection) {
          var index = collection.indexOf(element);
          if (index !== -1) {
            collection.splice(index, 1);
          }
        },
        clear: function() {
          this.nodes.length = 0;
          this.links.length = 0;
          this.series.length = 0;
          this.resetSimulation();
        },
        resetSimulation: function() {
          this.forcedStop = false;
          this.systemTemperature = 0;
          this.setMaxIterations();
          this.setTemperature();
          this.setDiffTemperature();
        },
        restartSimulation: function() {
          if (!this.simulation) {
            this.setInitialRendering(false);
            if (!this.enableSimulation) {
              this.setMaxIterations(1);
            } else {
              this.start();
            }
            if (this.chart) {
              this.chart.redraw();
            }
            this.setInitialRendering(true);
          } else {
            this.resetSimulation();
          }
        },
        setMaxIterations: function(maxIterations) {
          this.maxIterations = pick$y(maxIterations, this.options.maxIterations);
        },
        setTemperature: function() {
          this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);
        },
        setDiffTemperature: function() {
          this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);
        },
        setInitialRendering: function(enable) {
          this.initialRendering = enable;
        },
        createQuadTree: function() {
          this.quadTree = new H.QuadTree(this.box.left, this.box.top, this.box.width, this.box.height);
          this.quadTree.insertNodes(this.nodes);
        },
        initPositions: function() {
          var initialPositions = this.options.initialPositions;
          if (isFunction(initialPositions)) {
            initialPositions.call(this);
            this.nodes.forEach(function(node) {
              if (!defined$e(node.prevX)) {
                node.prevX = node.plotX;
              }
              if (!defined$e(node.prevY)) {
                node.prevY = node.plotY;
              }
              node.dispX = 0;
              node.dispY = 0;
            });
          } else if (initialPositions === "circle") {
            this.setCircularPositions();
          } else {
            this.setRandomPositions();
          }
        },
        setCircularPositions: function() {
          var box = this.box, nodes = this.nodes, nodesLength = nodes.length + 1, angle = 2 * Math.PI / nodesLength, rootNodes = nodes.filter(function(node) {
            return node.linksTo.length === 0;
          }), sortedNodes = [], visitedNodes = {}, radius = this.options.initialPositionRadius;
          function addToNodes(node) {
            node.linksFrom.forEach(function(link) {
              if (!visitedNodes[link.toNode.id]) {
                visitedNodes[link.toNode.id] = true;
                sortedNodes.push(link.toNode);
                addToNodes(link.toNode);
              }
            });
          }
          rootNodes.forEach(function(rootNode) {
            sortedNodes.push(rootNode);
            addToNodes(rootNode);
          });
          if (!sortedNodes.length) {
            sortedNodes = nodes;
          } else {
            nodes.forEach(function(node) {
              if (sortedNodes.indexOf(node) === -1) {
                sortedNodes.push(node);
              }
            });
          }
          sortedNodes.forEach(function(node, index) {
            node.plotX = node.prevX = pick$y(node.plotX, box.width / 2 + radius * Math.cos(index * angle));
            node.plotY = node.prevY = pick$y(node.plotY, box.height / 2 + radius * Math.sin(index * angle));
            node.dispX = 0;
            node.dispY = 0;
          });
        },
        setRandomPositions: function() {
          var box = this.box, nodes = this.nodes, nodesLength = nodes.length + 1;
          function unrandom(n) {
            var rand = n * n / Math.PI;
            rand = rand - Math.floor(rand);
            return rand;
          }
          nodes.forEach(function(node, index) {
            node.plotX = node.prevX = pick$y(node.plotX, box.width * unrandom(index));
            node.plotY = node.prevY = pick$y(node.plotY, box.height * unrandom(nodesLength + index));
            node.dispX = 0;
            node.dispY = 0;
          });
        },
        force: function(name) {
          this.integration[name].apply(this, Array.prototype.slice.call(arguments, 1));
        },
        barycenterForces: function() {
          this.getBarycenter();
          this.force("barycenter");
        },
        getBarycenter: function() {
          var systemMass = 0, cx = 0, cy = 0;
          this.nodes.forEach(function(node) {
            cx += node.plotX * node.mass;
            cy += node.plotY * node.mass;
            systemMass += node.mass;
          });
          this.barycenter = {
            x: cx,
            y: cy,
            xFactor: cx / systemMass,
            yFactor: cy / systemMass
          };
          return this.barycenter;
        },
        barnesHutApproximation: function(node, quadNode) {
          var layout = this, distanceXY = layout.getDistXY(node, quadNode), distanceR = layout.vectorLength(distanceXY), goDeeper, force;
          if (node !== quadNode && distanceR !== 0) {
            if (quadNode.isInternal) {
              if (quadNode.boxSize / distanceR < layout.options.theta && distanceR !== 0) {
                force = layout.repulsiveForce(distanceR, layout.k);
                layout.force("repulsive", node, force * quadNode.mass, distanceXY, distanceR);
                goDeeper = false;
              } else {
                goDeeper = true;
              }
            } else {
              force = layout.repulsiveForce(distanceR, layout.k);
              layout.force("repulsive", node, force * quadNode.mass, distanceXY, distanceR);
            }
          }
          return goDeeper;
        },
        repulsiveForces: function() {
          var layout = this;
          if (layout.approximation === "barnes-hut") {
            layout.nodes.forEach(function(node) {
              layout.quadTree.visitNodeRecursive(null, function(quadNode) {
                return layout.barnesHutApproximation(node, quadNode);
              });
            });
          } else {
            layout.nodes.forEach(function(node) {
              layout.nodes.forEach(function(repNode) {
                var force, distanceR, distanceXY;
                if (
                  // Node can not repulse itself:
                  node !== repNode && // Only close nodes affect each other:
                  // layout.getDistR(node, repNode) < 2 * k &&
                  // Not dragged:
                  !node.fixedPosition
                ) {
                  distanceXY = layout.getDistXY(node, repNode);
                  distanceR = layout.vectorLength(distanceXY);
                  if (distanceR !== 0) {
                    force = layout.repulsiveForce(distanceR, layout.k);
                    layout.force("repulsive", node, force * repNode.mass, distanceXY, distanceR);
                  }
                }
              });
            });
          }
        },
        attractiveForces: function() {
          var layout = this, distanceXY, distanceR, force;
          layout.links.forEach(function(link) {
            if (link.fromNode && link.toNode) {
              distanceXY = layout.getDistXY(link.fromNode, link.toNode);
              distanceR = layout.vectorLength(distanceXY);
              if (distanceR !== 0) {
                force = layout.attractiveForce(distanceR, layout.k);
                layout.force("attractive", link, force, distanceXY, distanceR);
              }
            }
          });
        },
        applyLimits: function() {
          var layout = this, nodes = layout.nodes;
          nodes.forEach(function(node) {
            if (node.fixedPosition) {
              return;
            }
            layout.integration.integrate(layout, node);
            layout.applyLimitBox(node, layout.box);
            node.dispX = 0;
            node.dispY = 0;
          });
        },
        /**
         * External box that nodes should fall. When hitting an edge, node
         * should stop or bounce.
         * @private
         */
        applyLimitBox: function(node, box) {
          var radius = node.radius;
          node.plotX = clamp$4(node.plotX, box.left + radius, box.width - radius);
          node.plotY = clamp$4(node.plotY, box.top + radius, box.height - radius);
        },
        /**
         * From "A comparison of simulated annealing cooling strategies" by
         * Nourani and Andresen work.
         * @private
         */
        coolDown: function(temperature, temperatureStep, currentStep) {
          return temperature - temperatureStep * currentStep;
        },
        isStable: function() {
          return Math.abs(this.systemTemperature - this.prevSystemTemperature) < 1e-5 || this.temperature <= 0;
        },
        getSystemTemperature: function() {
          return this.nodes.reduce(function(value, node) {
            return value + node.temperature;
          }, 0);
        },
        vectorLength: function(vector) {
          return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
        },
        getDistR: function(nodeA, nodeB) {
          var distance = this.getDistXY(nodeA, nodeB);
          return this.vectorLength(distance);
        },
        getDistXY: function(nodeA, nodeB) {
          var xDist = nodeA.plotX - nodeB.plotX, yDist = nodeA.plotY - nodeB.plotY;
          return {
            x: xDist,
            y: yDist,
            absX: Math.abs(xDist),
            absY: Math.abs(yDist)
          };
        }
      }
    );
    addEvent$m(Chart$1, "predraw", function() {
      if (this.graphLayoutsLookup) {
        this.graphLayoutsLookup.forEach(function(layout) {
          layout.stop();
        });
      }
    });
    addEvent$m(Chart$1, "render", function() {
      var systemsStable, afterRender = false;
      function layoutStep(layout) {
        if (layout.maxIterations-- && isFinite(layout.temperature) && !layout.isStable() && !layout.enableSimulation) {
          if (layout.beforeStep) {
            layout.beforeStep();
          }
          layout.step();
          systemsStable = false;
          afterRender = true;
        }
      }
      if (this.graphLayoutsLookup) {
        setAnimation(false, this);
        this.graphLayoutsLookup.forEach(function(layout) {
          layout.start();
        });
        while (!systemsStable) {
          systemsStable = true;
          this.graphLayoutsLookup.forEach(layoutStep);
        }
        if (afterRender) {
          this.series.forEach(function(s) {
            if (s && s.layout) {
              s.render();
            }
          });
        }
      }
    });
    addEvent$m(Chart$1, "beforePrint", function() {
      if (this.graphLayoutsLookup) {
        this.graphLayoutsLookup.forEach(function(layout) {
          layout.updateSimulation(false);
        });
        this.redraw();
      }
    });
    addEvent$m(Chart$1, "afterPrint", function() {
      if (this.graphLayoutsLookup) {
        this.graphLayoutsLookup.forEach(function(layout) {
          layout.updateSimulation();
        });
      }
      this.redraw();
    });
    var Reingold = H.layouts["reingold-fruchterman"];
    var addEvent$l = Utilities.addEvent, extendClass = Utilities.extendClass, pick$x = Utilities.pick;
    Chart$1.prototype.getSelectedParentNodes = function() {
      var chart = this, series = chart.series, selectedParentsNodes = [];
      series.forEach(function(series2) {
        if (series2.parentNode && series2.parentNode.selected) {
          selectedParentsNodes.push(series2.parentNode);
        }
      });
      return selectedParentsNodes;
    };
    H.networkgraphIntegrations.packedbubble = {
      repulsiveForceFunction: function(d, k, node, repNode) {
        return Math.min(d, (node.marker.radius + repNode.marker.radius) / 2);
      },
      barycenter: function() {
        var layout = this, gravitationalConstant = layout.options.gravitationalConstant, box = layout.box, nodes = layout.nodes, centerX, centerY;
        nodes.forEach(function(node) {
          if (layout.options.splitSeries && !node.isParentNode) {
            centerX = node.series.parentNode.plotX;
            centerY = node.series.parentNode.plotY;
          } else {
            centerX = box.width / 2;
            centerY = box.height / 2;
          }
          if (!node.fixedPosition) {
            node.plotX -= (node.plotX - centerX) * gravitationalConstant / (node.mass * Math.sqrt(nodes.length));
            node.plotY -= (node.plotY - centerY) * gravitationalConstant / (node.mass * Math.sqrt(nodes.length));
          }
        });
      },
      repulsive: function(node, force, distanceXY, repNode) {
        var factor = force * this.diffTemperature / node.mass / node.degree, x = distanceXY.x * factor, y = distanceXY.y * factor;
        if (!node.fixedPosition) {
          node.plotX += x;
          node.plotY += y;
        }
        if (!repNode.fixedPosition) {
          repNode.plotX -= x;
          repNode.plotY -= y;
        }
      },
      integrate: H.networkgraphIntegrations.verlet.integrate,
      getK: H.noop
    };
    H.layouts.packedbubble = extendClass(Reingold, {
      beforeStep: function() {
        if (this.options.marker) {
          this.series.forEach(function(series) {
            if (series) {
              series.calculateParentRadius();
            }
          });
        }
      },
      isStable: function() {
        var tempDiff = Math.abs(this.prevSystemTemperature - this.systemTemperature);
        var upScaledTemperature = 10 * this.systemTemperature / Math.sqrt(this.nodes.length);
        return Math.abs(upScaledTemperature) < 1 && tempDiff < 1e-5 || this.temperature <= 0;
      },
      setCircularPositions: function() {
        var layout = this, box = layout.box, nodes = layout.nodes, nodesLength = nodes.length + 1, angle = 2 * Math.PI / nodesLength, centerX, centerY, radius = layout.options.initialPositionRadius;
        nodes.forEach(function(node, index) {
          if (layout.options.splitSeries && !node.isParentNode) {
            centerX = node.series.parentNode.plotX;
            centerY = node.series.parentNode.plotY;
          } else {
            centerX = box.width / 2;
            centerY = box.height / 2;
          }
          node.plotX = node.prevX = pick$x(node.plotX, centerX + radius * Math.cos(node.index || index * angle));
          node.plotY = node.prevY = pick$x(node.plotY, centerY + radius * Math.sin(node.index || index * angle));
          node.dispX = 0;
          node.dispY = 0;
        });
      },
      repulsiveForces: function() {
        var layout = this, force, distanceR, distanceXY, bubblePadding = layout.options.bubblePadding;
        layout.nodes.forEach(function(node) {
          node.degree = node.mass;
          node.neighbours = 0;
          layout.nodes.forEach(function(repNode) {
            force = 0;
            if (
              // Node can not repulse itself:
              node !== repNode && // Only close nodes affect each other:
              // Not dragged:
              !node.fixedPosition && (layout.options.seriesInteraction || node.series === repNode.series)
            ) {
              distanceXY = layout.getDistXY(node, repNode);
              distanceR = layout.vectorLength(distanceXY) - (node.marker.radius + repNode.marker.radius + bubblePadding);
              if (distanceR < 0) {
                node.degree += 0.01;
                node.neighbours++;
                force = layout.repulsiveForce(-distanceR / Math.sqrt(node.neighbours), layout.k, node, repNode);
              }
              layout.force("repulsive", node, force * repNode.mass, distanceXY, repNode, distanceR);
            }
          });
        });
      },
      applyLimitBox: function(node) {
        var layout = this, distanceXY, distanceR, factor = 0.01;
        if (layout.options.splitSeries && !node.isParentNode && layout.options.parentNodeLimit) {
          distanceXY = layout.getDistXY(node, node.series.parentNode);
          distanceR = node.series.parentNodeRadius - node.marker.radius - layout.vectorLength(distanceXY);
          if (distanceR < 0 && distanceR > -2 * node.marker.radius) {
            node.plotX -= distanceXY.x * factor;
            node.plotY -= distanceXY.y * factor;
          }
        }
        Reingold.prototype.applyLimitBox.apply(this, arguments);
      }
    });
    addEvent$l(Chart$1, "beforeRedraw", function() {
      if (this.allDataPoints) {
        delete this.allDataPoints;
      }
    });
    var __extends$s = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var color$8 = Color.parse;
    var Series$9 = SeriesRegistry$1.series, BubbleSeries = SeriesRegistry$1.seriesTypes.bubble;
    var addEvent$k = Utilities.addEvent, clamp$3 = Utilities.clamp, defined$d = Utilities.defined, extend$u = Utilities.extend, fireEvent$6 = Utilities.fireEvent, isArray$4 = Utilities.isArray, isNumber$d = Utilities.isNumber, merge$s = Utilities.merge, pick$w = Utilities.pick;
    var dragNodesMixin = H.dragNodesMixin;
    var PackedBubbleSeries = (
      /** @class */
      function(_super) {
        __extends$s(PackedBubbleSeries2, _super);
        function PackedBubbleSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.chart = void 0;
          _this.data = void 0;
          _this.layout = void 0;
          _this.options = void 0;
          _this.points = void 0;
          _this.xData = void 0;
          return _this;
        }
        PackedBubbleSeries2.prototype.accumulateAllPoints = function(series) {
          var chart = series.chart, allDataPoints = [], i, j;
          for (i = 0; i < chart.series.length; i++) {
            series = chart.series[i];
            if (series.is("packedbubble") && // #13574
            series.visible || !chart.options.chart.ignoreHiddenSeries) {
              for (j = 0; j < series.yData.length; j++) {
                allDataPoints.push([
                  null,
                  null,
                  series.yData[j],
                  series.index,
                  j,
                  {
                    id: j,
                    marker: {
                      radius: 0
                    }
                  }
                ]);
              }
            }
          }
          return allDataPoints;
        };
        PackedBubbleSeries2.prototype.addLayout = function() {
          var series = this, layoutOptions = series.options.layoutAlgorithm, graphLayoutsStorage = series.chart.graphLayoutsStorage, graphLayoutsLookup = series.chart.graphLayoutsLookup, chartOptions = series.chart.options.chart, layout;
          if (!graphLayoutsStorage) {
            series.chart.graphLayoutsStorage = graphLayoutsStorage = {};
            series.chart.graphLayoutsLookup = graphLayoutsLookup = [];
          }
          layout = graphLayoutsStorage[layoutOptions.type];
          if (!layout) {
            layoutOptions.enableSimulation = !defined$d(chartOptions.forExport) ? layoutOptions.enableSimulation : !chartOptions.forExport;
            graphLayoutsStorage[layoutOptions.type] = layout = new H.layouts[layoutOptions.type]();
            layout.init(layoutOptions);
            graphLayoutsLookup.splice(layout.index, 0, layout);
          }
          series.layout = layout;
          series.points.forEach(function(node) {
            node.mass = 2;
            node.degree = 1;
            node.collisionNmb = 1;
          });
          layout.setArea(0, 0, series.chart.plotWidth, series.chart.plotHeight);
          layout.addElementsToCollection([series], layout.series);
          layout.addElementsToCollection(series.points, layout.nodes);
        };
        PackedBubbleSeries2.prototype.addSeriesLayout = function() {
          var series = this, layoutOptions = series.options.layoutAlgorithm, graphLayoutsStorage = series.chart.graphLayoutsStorage, graphLayoutsLookup = series.chart.graphLayoutsLookup, parentNodeOptions = merge$s(layoutOptions, layoutOptions.parentNodeOptions, {
            enableSimulation: series.layout.options.enableSimulation
          }), parentNodeLayout;
          parentNodeLayout = graphLayoutsStorage[layoutOptions.type + "-series"];
          if (!parentNodeLayout) {
            graphLayoutsStorage[layoutOptions.type + "-series"] = parentNodeLayout = new H.layouts[layoutOptions.type]();
            parentNodeLayout.init(parentNodeOptions);
            graphLayoutsLookup.splice(parentNodeLayout.index, 0, parentNodeLayout);
          }
          series.parentNodeLayout = parentNodeLayout;
          this.createParentNodes();
        };
        PackedBubbleSeries2.prototype.calculateParentRadius = function() {
          var series = this, bBox, parentPadding = 20, minParentRadius = 20;
          bBox = series.seriesBox();
          series.parentNodeRadius = clamp$3(Math.sqrt(2 * series.parentNodeMass / Math.PI) + parentPadding, minParentRadius, bBox ? Math.max(Math.sqrt(Math.pow(bBox.width, 2) + Math.pow(bBox.height, 2)) / 2 + parentPadding, minParentRadius) : Math.sqrt(2 * series.parentNodeMass / Math.PI) + parentPadding);
          if (series.parentNode) {
            series.parentNode.marker.radius = series.parentNode.radius = series.parentNodeRadius;
          }
        };
        PackedBubbleSeries2.prototype.calculateZExtremes = function() {
          var chart = this.chart, zMin = this.options.zMin, zMax = this.options.zMax, valMin = Infinity, valMax = -Infinity;
          if (zMin && zMax) {
            return [zMin, zMax];
          }
          chart.series.forEach(function(s) {
            s.yData.forEach(function(p) {
              if (defined$d(p)) {
                if (p > valMax) {
                  valMax = p;
                }
                if (p < valMin) {
                  valMin = p;
                }
              }
            });
          });
          zMin = pick$w(zMin, valMin);
          zMax = pick$w(zMax, valMax);
          return [zMin, zMax];
        };
        PackedBubbleSeries2.prototype.checkOverlap = function(bubble1, bubble2) {
          var diffX = bubble1[0] - bubble2[0], diffY = bubble1[1] - bubble2[1], sumRad = bubble1[2] + bubble2[2];
          return Math.sqrt(diffX * diffX + diffY * diffY) - Math.abs(sumRad) < -1e-3;
        };
        PackedBubbleSeries2.prototype.createParentNodes = function() {
          var series = this, chart = series.chart, parentNodeLayout = series.parentNodeLayout, nodeAdded, parentNode = series.parentNode, PackedBubblePoint2 = series.pointClass;
          series.parentNodeMass = 0;
          series.points.forEach(function(p) {
            series.parentNodeMass += Math.PI * Math.pow(p.marker.radius, 2);
          });
          series.calculateParentRadius();
          parentNodeLayout.nodes.forEach(function(node) {
            if (node.seriesIndex === series.index) {
              nodeAdded = true;
            }
          });
          parentNodeLayout.setArea(0, 0, chart.plotWidth, chart.plotHeight);
          if (!nodeAdded) {
            if (!parentNode) {
              parentNode = new PackedBubblePoint2().init(this, {
                mass: series.parentNodeRadius / 2,
                marker: {
                  radius: series.parentNodeRadius
                },
                dataLabels: {
                  inside: false
                },
                dataLabelOnNull: true,
                degree: series.parentNodeRadius,
                isParentNode: true,
                seriesIndex: series.index
              });
            }
            if (series.parentNode) {
              parentNode.plotX = series.parentNode.plotX;
              parentNode.plotY = series.parentNode.plotY;
            }
            series.parentNode = parentNode;
            parentNodeLayout.addElementsToCollection([series], parentNodeLayout.series);
            parentNodeLayout.addElementsToCollection([parentNode], parentNodeLayout.nodes);
          }
        };
        PackedBubbleSeries2.prototype.deferLayout = function() {
          var series = this, layoutOptions = series.options.layoutAlgorithm;
          if (!series.visible) {
            return;
          }
          series.addLayout();
          if (layoutOptions.splitSeries) {
            series.addSeriesLayout();
          }
        };
        PackedBubbleSeries2.prototype.destroy = function() {
          if (this.chart.graphLayoutsLookup) {
            this.chart.graphLayoutsLookup.forEach(function(layout) {
              layout.removeElementFromCollection(this, layout.series);
            }, this);
          }
          if (this.parentNode && this.parentNodeLayout) {
            this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes);
            if (this.parentNode.dataLabel) {
              this.parentNode.dataLabel = this.parentNode.dataLabel.destroy();
            }
          }
          Series$9.prototype.destroy.apply(this, arguments);
        };
        PackedBubbleSeries2.prototype.drawDataLabels = function() {
          var textPath = this.options.dataLabels.textPath, points = this.points;
          Series$9.prototype.drawDataLabels.apply(this, arguments);
          if (this.parentNode) {
            this.parentNode.formatPrefix = "parentNode";
            this.points = [this.parentNode];
            this.options.dataLabels.textPath = this.options.dataLabels.parentNodeTextPath;
            Series$9.prototype.drawDataLabels.apply(this, arguments);
            this.points = points;
            this.options.dataLabels.textPath = textPath;
          }
        };
        PackedBubbleSeries2.prototype.drawGraph = function() {
          if (!this.layout || !this.layout.options.splitSeries) {
            return;
          }
          var series = this, chart = series.chart, parentAttribs = {}, nodeMarker = this.layout.options.parentNodeOptions.marker, parentOptions = {
            fill: nodeMarker.fillColor || color$8(series.color).brighten(0.4).get(),
            opacity: nodeMarker.fillOpacity,
            stroke: nodeMarker.lineColor || series.color,
            "stroke-width": nodeMarker.lineWidth
          };
          if (!this.parentNodesGroup) {
            series.parentNodesGroup = series.plotGroup("parentNodesGroup", "parentNode", series.visible ? "inherit" : "hidden", 0.1, chart.seriesGroup);
            series.group.attr({
              zIndex: 2
            });
          }
          this.calculateParentRadius();
          parentAttribs = merge$s({
            x: series.parentNode.plotX - series.parentNodeRadius,
            y: series.parentNode.plotY - series.parentNodeRadius,
            width: series.parentNodeRadius * 2,
            height: series.parentNodeRadius * 2
          }, parentOptions);
          if (!series.parentNode.graphic) {
            series.graph = series.parentNode.graphic = chart.renderer.symbol(parentOptions.symbol).add(series.parentNodesGroup);
          }
          series.parentNode.graphic.attr(parentAttribs);
        };
        PackedBubbleSeries2.prototype.drawTracker = function() {
          var series = this, parentNode = series.parentNode;
          var dataLabels;
          _super.prototype.drawTracker.call(this);
          if (parentNode) {
            dataLabels = isArray$4(parentNode.dataLabels) ? parentNode.dataLabels : parentNode.dataLabel ? [parentNode.dataLabel] : [];
            if (parentNode.graphic) {
              parentNode.graphic.element.point = parentNode;
            }
            dataLabels.forEach(function(dataLabel) {
              if (dataLabel.div) {
                dataLabel.div.point = parentNode;
              } else {
                dataLabel.element.point = parentNode;
              }
            });
          }
        };
        PackedBubbleSeries2.prototype.getPointRadius = function() {
          var series = this, chart = series.chart, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, seriesOptions = series.options, useSimulation = seriesOptions.useSimulation, smallestSize = Math.min(plotWidth, plotHeight), extremes = {}, radii = [], allDataPoints = chart.allDataPoints, minSize, maxSize, value, radius, zExtremes;
          ["minSize", "maxSize"].forEach(function(prop) {
            var length = parseInt(seriesOptions[prop], 10), isPercent = /%$/.test(seriesOptions[prop]);
            extremes[prop] = isPercent ? smallestSize * length / 100 : length * Math.sqrt(allDataPoints.length);
          });
          chart.minRadius = minSize = extremes.minSize / Math.sqrt(allDataPoints.length);
          chart.maxRadius = maxSize = extremes.maxSize / Math.sqrt(allDataPoints.length);
          zExtremes = useSimulation ? series.calculateZExtremes() : [minSize, maxSize];
          (allDataPoints || []).forEach(function(point, i) {
            value = useSimulation ? clamp$3(point[2], zExtremes[0], zExtremes[1]) : point[2];
            radius = series.getRadius(zExtremes[0], zExtremes[1], minSize, maxSize, value);
            if (radius === 0) {
              radius = null;
            }
            allDataPoints[i][2] = radius;
            radii.push(radius);
          });
          series.radii = radii;
        };
        PackedBubbleSeries2.prototype.init = function() {
          Series$9.prototype.init.apply(this, arguments);
          this.eventsToUnbind.push(addEvent$k(this, "updatedData", function() {
            this.chart.series.forEach(function(s) {
              if (s.type === this.type) {
                s.isDirty = true;
              }
            }, this);
          }));
          return this;
        };
        PackedBubbleSeries2.prototype.onMouseUp = function(point) {
          if (point.fixedPosition && !point.removed) {
            var distanceXY_1, distanceR_1, layout_1 = this.layout, parentNodeLayout = this.parentNodeLayout;
            if (parentNodeLayout && layout_1.options.dragBetweenSeries) {
              parentNodeLayout.nodes.forEach(function(node) {
                if (point && point.marker && node !== point.series.parentNode) {
                  distanceXY_1 = layout_1.getDistXY(point, node);
                  distanceR_1 = layout_1.vectorLength(distanceXY_1) - node.marker.radius - point.marker.radius;
                  if (distanceR_1 < 0) {
                    node.series.addPoint(merge$s(point.options, {
                      plotX: point.plotX,
                      plotY: point.plotY
                    }), false);
                    layout_1.removeElementFromCollection(point, layout_1.nodes);
                    point.remove();
                  }
                }
              });
            }
            dragNodesMixin.onMouseUp.apply(this, arguments);
          }
        };
        PackedBubbleSeries2.prototype.placeBubbles = function(allDataPoints) {
          var series = this, checkOverlap = series.checkOverlap, positionBubble = series.positionBubble, bubblePos = [], stage = 1, j = 0, k = 0, calculatedBubble, sortedArr, arr = [], i;
          sortedArr = allDataPoints.sort(function(a, b) {
            return b[2] - a[2];
          });
          if (sortedArr.length) {
            bubblePos.push([
              [
                0,
                0,
                sortedArr[0][2],
                sortedArr[0][3],
                sortedArr[0][4]
              ]
              // point index
            ]);
            if (sortedArr.length > 1) {
              bubblePos.push([
                [
                  0,
                  0 - sortedArr[1][2] - sortedArr[0][2],
                  // move bubble above first one
                  sortedArr[1][2],
                  sortedArr[1][3],
                  sortedArr[1][4]
                ]
              ]);
              for (i = 2; i < sortedArr.length; i++) {
                sortedArr[i][2] = sortedArr[i][2] || 1;
                calculatedBubble = positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]);
                if (checkOverlap(calculatedBubble, bubblePos[stage][0])) {
                  bubblePos.push([]);
                  k = 0;
                  bubblePos[stage + 1].push(positionBubble(bubblePos[stage][j], bubblePos[stage][0], sortedArr[i]));
                  stage++;
                  j = 0;
                } else if (stage > 1 && bubblePos[stage - 1][k + 1] && checkOverlap(calculatedBubble, bubblePos[stage - 1][k + 1])) {
                  k++;
                  bubblePos[stage].push(positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]));
                  j++;
                } else {
                  j++;
                  bubblePos[stage].push(calculatedBubble);
                }
              }
            }
            series.chart.stages = bubblePos;
            series.chart.rawPositions = [].concat.apply([], bubblePos);
            series.resizeRadius();
            arr = series.chart.rawPositions;
          }
          return arr;
        };
        PackedBubbleSeries2.prototype.positionBubble = function(lastBubble, newOrigin, nextBubble) {
          var sqrt = Math.sqrt, asin = Math.asin, acos = Math.acos, pow = Math.pow, abs = Math.abs, distance = sqrt(
            // dist between lastBubble and newOrigin
            pow(lastBubble[0] - newOrigin[0], 2) + pow(lastBubble[1] - newOrigin[1], 2)
          ), alfa = acos(
            // from cosinus theorem: alfa is an angle used for
            // calculating correct position
            (pow(distance, 2) + pow(nextBubble[2] + newOrigin[2], 2) - pow(nextBubble[2] + lastBubble[2], 2)) / (2 * (nextBubble[2] + newOrigin[2]) * distance)
          ), beta = asin(
            // from sinus theorem.
            abs(lastBubble[0] - newOrigin[0]) / distance
          ), gamma = lastBubble[1] - newOrigin[1] < 0 ? 0 : Math.PI, delta = (lastBubble[0] - newOrigin[0]) * (lastBubble[1] - newOrigin[1]) < 0 ? 1 : -1, finalAngle = gamma + alfa + beta * delta, cosA = Math.cos(finalAngle), sinA = Math.sin(finalAngle), posX = newOrigin[0] + (newOrigin[2] + nextBubble[2]) * sinA, posY = newOrigin[1] - (newOrigin[2] + nextBubble[2]) * cosA;
          return [
            posX,
            posY,
            nextBubble[2],
            nextBubble[3],
            nextBubble[4]
          ];
        };
        PackedBubbleSeries2.prototype.render = function() {
          var series = this, dataLabels = [];
          Series$9.prototype.render.apply(this, arguments);
          if (!series.options.dataLabels.allowOverlap) {
            series.data.forEach(function(point) {
              if (isArray$4(point.dataLabels)) {
                point.dataLabels.forEach(function(dataLabel) {
                  dataLabels.push(dataLabel);
                });
              }
            });
            if (series.options.useSimulation) {
              series.chart.hideOverlappingLabels(dataLabels);
            }
          }
        };
        PackedBubbleSeries2.prototype.resizeRadius = function() {
          var chart = this.chart, positions = chart.rawPositions, min = Math.min, max = Math.max, plotLeft = chart.plotLeft, plotTop = chart.plotTop, chartHeight = chart.plotHeight, chartWidth = chart.plotWidth, minX, maxX, minY, maxY, radius, bBox, spaceRatio, smallerDimension, i;
          minX = minY = Number.POSITIVE_INFINITY;
          maxX = maxY = Number.NEGATIVE_INFINITY;
          for (i = 0; i < positions.length; i++) {
            radius = positions[i][2];
            minX = min(minX, positions[i][0] - radius);
            maxX = max(maxX, positions[i][0] + radius);
            minY = min(minY, positions[i][1] - radius);
            maxY = max(maxY, positions[i][1] + radius);
          }
          bBox = [maxX - minX, maxY - minY];
          spaceRatio = [
            (chartWidth - plotLeft) / bBox[0],
            (chartHeight - plotTop) / bBox[1]
          ];
          smallerDimension = min.apply([], spaceRatio);
          if (Math.abs(smallerDimension - 1) > 1e-10) {
            for (i = 0; i < positions.length; i++) {
              positions[i][2] *= smallerDimension;
            }
            this.placeBubbles(positions);
          } else {
            chart.diffY = chartHeight / 2 + plotTop - minY - (maxY - minY) / 2;
            chart.diffX = chartWidth / 2 + plotLeft - minX - (maxX - minX) / 2;
          }
        };
        PackedBubbleSeries2.prototype.seriesBox = function() {
          var series = this, chart = series.chart, data = series.data, max = Math.max, min = Math.min, radius, bBox = [
            chart.plotLeft,
            chart.plotLeft + chart.plotWidth,
            chart.plotTop,
            chart.plotTop + chart.plotHeight
          ];
          data.forEach(function(p) {
            if (defined$d(p.plotX) && defined$d(p.plotY) && p.marker.radius) {
              radius = p.marker.radius;
              bBox[0] = min(bBox[0], p.plotX - radius);
              bBox[1] = max(bBox[1], p.plotX + radius);
              bBox[2] = min(bBox[2], p.plotY - radius);
              bBox[3] = max(bBox[3], p.plotY + radius);
            }
          });
          return isNumber$d(bBox.width / bBox.height) ? bBox : null;
        };
        PackedBubbleSeries2.prototype.setVisible = function() {
          var series = this;
          Series$9.prototype.setVisible.apply(series, arguments);
          if (series.parentNodeLayout && series.graph) {
            if (series.visible) {
              series.graph.show();
              if (series.parentNode.dataLabel) {
                series.parentNode.dataLabel.show();
              }
            } else {
              series.graph.hide();
              series.parentNodeLayout.removeElementFromCollection(series.parentNode, series.parentNodeLayout.nodes);
              if (series.parentNode.dataLabel) {
                series.parentNode.dataLabel.hide();
              }
            }
          } else if (series.layout) {
            if (series.visible) {
              series.layout.addElementsToCollection(series.points, series.layout.nodes);
            } else {
              series.points.forEach(function(node) {
                series.layout.removeElementFromCollection(node, series.layout.nodes);
              });
            }
          }
        };
        PackedBubbleSeries2.prototype.translate = function() {
          var series = this, chart = series.chart, data = series.data, index = series.index, point, radius, positions, i, useSimulation = series.options.useSimulation;
          series.processedXData = series.xData;
          series.generatePoints();
          if (!defined$d(chart.allDataPoints)) {
            chart.allDataPoints = series.accumulateAllPoints(series);
            series.getPointRadius();
          }
          if (useSimulation) {
            positions = chart.allDataPoints;
          } else {
            positions = series.placeBubbles(chart.allDataPoints);
            series.options.draggable = false;
          }
          for (i = 0; i < positions.length; i++) {
            if (positions[i][3] === index) {
              point = data[positions[i][4]];
              radius = pick$w(positions[i][2], void 0);
              if (!useSimulation) {
                point.plotX = positions[i][0] - chart.plotLeft + chart.diffX;
                point.plotY = positions[i][1] - chart.plotTop + chart.diffY;
              }
              if (isNumber$d(radius)) {
                point.marker = extend$u(point.marker, {
                  radius,
                  width: 2 * radius,
                  height: 2 * radius
                });
                point.radius = radius;
              }
            }
          }
          if (useSimulation) {
            series.deferLayout();
          }
          fireEvent$6(series, "afterTranslate");
        };
        PackedBubbleSeries2.defaultOptions = merge$s(BubbleSeries.defaultOptions, {
          /**
           * Minimum bubble size. Bubbles will automatically size between the
           * `minSize` and `maxSize` to reflect the value of each bubble.
           * Can be either pixels (when no unit is given), or a percentage of
           * the smallest one of the plot width and height, divided by the square
           * root of total number of points.
           *
           * @sample highcharts/plotoptions/bubble-size/
           *         Bubble size
           *
           * @type {number|string}
           *
           * @private
           */
          minSize: "10%",
          /**
           * Maximum bubble size. Bubbles will automatically size between the
           * `minSize` and `maxSize` to reflect the value of each bubble.
           * Can be either pixels (when no unit is given), or a percentage of
           * the smallest one of the plot width and height, divided by the square
           * root of total number of points.
           *
           * @sample highcharts/plotoptions/bubble-size/
           *         Bubble size
           *
           * @type {number|string}
           *
           * @private
           */
          maxSize: "50%",
          sizeBy: "area",
          zoneAxis: "y",
          crisp: false,
          tooltip: {
            pointFormat: "Value: {point.value}"
          },
          /**
           * Flag to determine if nodes are draggable or not. Available for
           * graph with useSimulation set to true only.
           *
           * @since 7.1.0
           *
           * @private
           */
          draggable: true,
          /**
           * An option is giving a possibility to choose between using simulation
           * for calculating bubble positions. These reflects in both animation
           * and final position of bubbles. Simulation is also adding options to
           * the series graph based on used layout. In case of big data sets, with
           * any performance issues, it is possible to disable animation and pack
           * bubble in a simple circular way.
           *
           * @sample highcharts/series-packedbubble/spiral/
           *         useSimulation set to false
           *
           * @since 7.1.0
           *
           * @private
           */
          useSimulation: true,
          /**
           * Series options for parent nodes.
           *
           * @since 8.1.1
           *
           * @private
           */
          parentNode: {
            /**
             * Allow this series' parent nodes to be selected
             * by clicking on the graph.
             *
             * @since 8.1.1
             */
            allowPointSelect: false
          },
          /**
          /**
           *
           * @declare Highcharts.SeriesPackedBubbleDataLabelsOptionsObject
           *
           * @private
           */
          dataLabels: {
            /**
             * The
             * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
             * specifying what to show for _node_ in the networkgraph. In v7.0
             * defaults to `{key}`, since v7.1 defaults to `undefined` and
             * `formatter` is used instead.
             *
             * @type      {string}
             * @since     7.0.0
             * @apioption plotOptions.packedbubble.dataLabels.format
             */
            // eslint-disable-next-line valid-jsdoc
            /**
             * Callback JavaScript function to format the data label for a node.
             * Note that if a `format` is defined, the format takes precedence
             * and the formatter is ignored.
             *
             * @type  {Highcharts.SeriesPackedBubbleDataLabelsFormatterCallbackFunction}
             * @since 7.0.0
             */
            formatter: function() {
              var numberFormatter = this.series.chart.numberFormatter;
              var value = this.point.value;
              return isNumber$d(value) ? numberFormatter(value, -1) : "";
            },
            /**
             * @type      {string}
             * @since     7.1.0
             * @apioption plotOptions.packedbubble.dataLabels.parentNodeFormat
             */
            // eslint-disable-next-line valid-jsdoc
            /**
             * @type  {Highcharts.SeriesPackedBubbleDataLabelsFormatterCallbackFunction}
             * @since 7.1.0
             */
            parentNodeFormatter: function() {
              return this.name;
            },
            /**
             * @sample {highcharts} highcharts/series-packedbubble/packed-dashboard
             *         Dashboard with dataLabels on parentNodes
             *
             * @declare Highcharts.SeriesPackedBubbleDataLabelsTextPathOptionsObject
             * @since   7.1.0
             */
            parentNodeTextPath: {
              /**
               * Presentation attributes for the text path.
               *
               * @type      {Highcharts.SVGAttributes}
               * @since     7.1.0
               * @apioption plotOptions.packedbubble.dataLabels.attributes
               */
              /**
               * Enable or disable `textPath` option for link's or marker's
               * data labels.
               *
               * @since 7.1.0
               */
              enabled: true
            },
            /**
             * Options for a _node_ label text which should follow marker's
             * shape.
             *
             * **Note:** Only SVG-based renderer supports this option.
             *
             * @extends   plotOptions.series.dataLabels.textPath
             * @apioption plotOptions.packedbubble.dataLabels.textPath
             */
            padding: 0,
            style: {
              transition: "opacity 2000ms"
            }
          },
          /**
           * Options for layout algorithm when simulation is enabled. Inside there
           * are options to change the speed, padding, initial bubbles positions
           * and more.
           *
           * @extends   plotOptions.networkgraph.layoutAlgorithm
           * @excluding approximation, attractiveForce, repulsiveForce, theta
           * @since     7.1.0
           *
           * @private
           */
          layoutAlgorithm: {
            /**
             * Initial layout algorithm for positioning nodes. Can be one of
             * the built-in options ("circle", "random") or a function where
             * positions should be set on each node (`this.nodes`) as
             * `node.plotX` and `node.plotY`.
             *
             * @sample highcharts/series-networkgraph/initial-positions/
             *         Initial positions with callback
             *
             * @type {"circle"|"random"|Function}
             */
            initialPositions: "circle",
            /**
             * @sample highcharts/series-packedbubble/initial-radius/
             *         Initial radius set to 200
             *
             * @extends   plotOptions.networkgraph.layoutAlgorithm.initialPositionRadius
             * @excluding states
             */
            initialPositionRadius: 20,
            /**
             * The distance between two bubbles, when the algorithm starts to
             * treat two bubbles as overlapping. The `bubblePadding` is also the
             * expected distance between all the bubbles on simulation end.
             */
            bubblePadding: 5,
            /**
             * Whether bubbles should interact with their parentNode to keep
             * them inside.
             */
            parentNodeLimit: false,
            /**
             * Whether series should interact with each other or not. When
             * `parentNodeLimit` is set to true, thi option should be set to
             * false to avoid sticking points in wrong series parentNode.
             */
            seriesInteraction: true,
            /**
             * In case of split series, this option allows user to drag and
             * drop points between series, for changing point related series.
             *
             * @sample highcharts/series-packedbubble/packed-dashboard/
             *         Example of drag'n drop bubbles for bubble kanban
             */
            dragBetweenSeries: false,
            /**
             * Layout algorithm options for parent nodes.
             *
             * @extends   plotOptions.networkgraph.layoutAlgorithm
             * @excluding approximation, attractiveForce, enableSimulation,
             *            repulsiveForce, theta
             */
            parentNodeOptions: {
              maxIterations: 400,
              gravitationalConstant: 0.03,
              maxSpeed: 50,
              initialPositionRadius: 100,
              seriesInteraction: true,
              /**
               * Styling options for parentNodes markers. Similar to
               * line.marker options.
               *
               * @sample highcharts/series-packedbubble/parentnode-style/
               *         Bubble size
               *
               * @extends   plotOptions.series.marker
               * @excluding states
               */
              marker: {
                fillColor: null,
                fillOpacity: 1,
                lineWidth: 1,
                lineColor: null,
                symbol: "circle"
              }
            },
            enableSimulation: true,
            /**
             * Type of the algorithm used when positioning bubbles.
             * @ignore-option
             */
            type: "packedbubble",
            /**
             * Integration type. Integration determines how forces are applied
             * on particles. The `packedbubble` integration is based on
             * the networkgraph `verlet` integration, where the new position
             * is based on a previous position without velocity:
             * `newPosition += previousPosition - newPosition`.
             *
             * @sample highcharts/series-networkgraph/forces/
             *
             * @ignore-option
             */
            integration: "packedbubble",
            maxIterations: 1e3,
            /**
             * Whether to split series into individual groups or to mix all
             * series together.
             *
             * @since   7.1.0
             * @default false
             */
            splitSeries: false,
            /**
             * Max speed that node can get in one iteration. In terms of
             * simulation, it's a maximum translation (in pixels) that a node
             * can move (in both, x and y, dimensions). While `friction` is
             * applied on all nodes, max speed is applied only for nodes that
             * move very fast, for example small or disconnected ones.
             *
             * @see [layoutAlgorithm.integration](#series.networkgraph.layoutAlgorithm.integration)
             *
             * @see [layoutAlgorithm.friction](#series.networkgraph.layoutAlgorithm.friction)
             */
            maxSpeed: 5,
            gravitationalConstant: 0.01,
            friction: -0.981
          }
        });
        return PackedBubbleSeries2;
      }(BubbleSeries)
    );
    extend$u(PackedBubbleSeries.prototype, {
      alignDataLabel: Series$9.prototype.alignDataLabel,
      axisTypes: [],
      directTouch: true,
      /**
       * Array of internal forces. Each force should be later defined in
       * integrations.js.
       * @private
       */
      forces: ["barycenter", "repulsive"],
      /**
       * An internal option used for allowing nodes dragging.
       * @private
       */
      hasDraggableNodes: true,
      isCartesian: false,
      noSharedTooltip: true,
      /**
       * Mouse down action, initializing drag&drop mode.
       * @private
       * @param {global.Event} event Browser event, before normalization.
       * @param {Highcharts.Point} point The point that event occured.
       */
      onMouseDown: dragNodesMixin.onMouseDown,
      /**
       * Mouse move action during drag&drop.
       * @private
       * @param {global.Event} event Browser event, before normalization.
       * @param {Highcharts.Point} point The point that event occured.
       */
      onMouseMove: dragNodesMixin.onMouseMove,
      pointArrayMap: ["value"],
      pointClass: PackedBubblePoint,
      pointValKey: "value",
      /**
       * Redraw halo on mousemove during the drag&drop action.
       * @private
       * @param {Highcharts.Point} point The point that should show halo.
       */
      redrawHalo: dragNodesMixin.redrawHalo,
      requireSorting: false,
      // solving #12287
      searchPoint: H.noop,
      trackerGroups: ["group", "dataLabelsGroup", "parentNodesGroup"]
    });
    SeriesRegistry$1.registerSeriesType("packedbubble", PackedBubbleSeries);
    var __extends$r = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var noop$5 = H.noop;
    var Series$8 = SeriesRegistry$1.series, _a$8 = SeriesRegistry$1.seriesTypes, AreaSeries = _a$8.area, LineSeries$2 = _a$8.line, ScatterSeries$2 = _a$8.scatter;
    var extend$t = Utilities.extend, merge$r = Utilities.merge;
    var PolygonSeries = (
      /** @class */
      function(_super) {
        __extends$r(PolygonSeries2, _super);
        function PolygonSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        PolygonSeries2.prototype.getGraphPath = function() {
          var graphPath = LineSeries$2.prototype.getGraphPath.call(this), i = graphPath.length + 1;
          while (i--) {
            if ((i === graphPath.length || graphPath[i][0] === "M") && i > 0) {
              graphPath.splice(i, 0, ["Z"]);
            }
          }
          this.areaPath = graphPath;
          return graphPath;
        };
        PolygonSeries2.prototype.drawGraph = function() {
          this.options.fillColor = this.color;
          AreaSeries.prototype.drawGraph.call(this);
        };
        PolygonSeries2.defaultOptions = merge$r(ScatterSeries$2.defaultOptions, {
          marker: {
            enabled: false,
            states: {
              hover: {
                enabled: false
              }
            }
          },
          stickyTracking: false,
          tooltip: {
            followPointer: true,
            pointFormat: ""
          },
          trackByArea: true
        });
        return PolygonSeries2;
      }(ScatterSeries$2)
    );
    extend$t(PolygonSeries.prototype, {
      type: "polygon",
      drawLegendSymbol: LegendSymbol$1.drawRectangle,
      drawTracker: Series$8.prototype.drawTracker,
      setStackedPoints: noop$5
      // No stacking points on polygons (#5310)
    });
    SeriesRegistry$1.registerSeriesType("polygon", PolygonSeries);
    var addEvent$j = Utilities.addEvent, objectEach$8 = Utilities.objectEach;
    var WaterfallAxis;
    (function(WaterfallAxis2) {
      var Composition = (
        /** @class */
        function() {
          function Composition2(axis) {
            this.axis = axis;
            this.stacks = {
              changed: false
            };
          }
          Composition2.prototype.renderStackTotals = function() {
            var yAxis = this.axis, waterfallStacks = yAxis.waterfall.stacks, stackTotalGroup = yAxis.stacking && yAxis.stacking.stackTotalGroup, dummyStackItem = new StackItem$1(yAxis, yAxis.options.stackLabels, false, 0, void 0);
            this.dummyStackItem = dummyStackItem;
            objectEach$8(waterfallStacks, function(type) {
              objectEach$8(type, function(stackItem) {
                dummyStackItem.total = stackItem.stackTotal;
                if (stackItem.label) {
                  dummyStackItem.label = stackItem.label;
                }
                StackItem$1.prototype.render.call(dummyStackItem, stackTotalGroup);
                stackItem.label = dummyStackItem.label;
                delete dummyStackItem.label;
              });
            });
            dummyStackItem.total = null;
          };
          return Composition2;
        }()
      );
      WaterfallAxis2.Composition = Composition;
      function compose(AxisClass, ChartClass) {
        addEvent$j(AxisClass, "init", onInit);
        addEvent$j(AxisClass, "afterBuildStacks", onAfterBuildStacks);
        addEvent$j(AxisClass, "afterRender", onAfterRender);
        addEvent$j(ChartClass, "beforeRedraw", onBeforeRedraw);
      }
      WaterfallAxis2.compose = compose;
      function onAfterBuildStacks() {
        var axis = this;
        var stacks = axis.waterfall.stacks;
        if (stacks) {
          stacks.changed = false;
          delete stacks.alreadyChanged;
        }
      }
      function onAfterRender() {
        var axis = this;
        var stackLabelOptions = axis.options.stackLabels;
        if (stackLabelOptions && stackLabelOptions.enabled && axis.waterfall.stacks) {
          axis.waterfall.renderStackTotals();
        }
      }
      function onBeforeRedraw() {
        var axes = this.axes, series = this.series, i = series.length;
        while (i--) {
          if (series[i].options.stacking) {
            axes.forEach(function(axis) {
              if (!axis.isXAxis) {
                axis.waterfall.stacks.changed = true;
              }
            });
            i = 0;
          }
        }
      }
      function onInit() {
        var axis = this;
        if (!axis.waterfall) {
          axis.waterfall = new Composition(axis);
        }
      }
    })(WaterfallAxis || (WaterfallAxis = {}));
    const WaterfallAxis$1 = WaterfallAxis;
    var __extends$q = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var isNumber$c = Utilities.isNumber;
    var WaterfallPoint = (
      /** @class */
      function(_super) {
        __extends$q(WaterfallPoint2, _super);
        function WaterfallPoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.options = void 0;
          _this.series = void 0;
          return _this;
        }
        WaterfallPoint2.prototype.getClassName = function() {
          var className = Point$2.prototype.getClassName.call(this);
          if (this.isSum) {
            className += " highcharts-sum";
          } else if (this.isIntermediateSum) {
            className += " highcharts-intermediate-sum";
          }
          return className;
        };
        WaterfallPoint2.prototype.isValid = function() {
          return isNumber$c(this.y) || this.isSum || Boolean(this.isIntermediateSum);
        };
        return WaterfallPoint2;
      }(ColumnSeries$h.prototype.pointClass)
    );
    var __extends$p = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var _a$7 = SeriesRegistry$1.seriesTypes, ColumnSeries$8 = _a$7.column, LineSeries$1 = _a$7.line;
    var arrayMax$1 = Utilities.arrayMax, arrayMin$1 = Utilities.arrayMin, correctFloat$2 = Utilities.correctFloat, extend$s = Utilities.extend, isNumber$b = Utilities.isNumber, merge$q = Utilities.merge, objectEach$7 = Utilities.objectEach, pick$v = Utilities.pick;
    function ownProp(obj, key) {
      return Object.hasOwnProperty.call(obj, key);
    }
    var WaterfallSeries = (
      /** @class */
      function(_super) {
        __extends$p(WaterfallSeries2, _super);
        function WaterfallSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.chart = void 0;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          _this.stackedYNeg = void 0;
          _this.stackedYPos = void 0;
          _this.stackKey = void 0;
          _this.xData = void 0;
          _this.yAxis = void 0;
          _this.yData = void 0;
          return _this;
        }
        WaterfallSeries2.prototype.generatePoints = function() {
          var point, len, i, y;
          ColumnSeries$8.prototype.generatePoints.apply(this);
          for (i = 0, len = this.points.length; i < len; i++) {
            point = this.points[i];
            y = this.processedYData[i];
            if (point.isIntermediateSum || point.isSum) {
              point.y = correctFloat$2(y);
            }
          }
        };
        WaterfallSeries2.prototype.translate = function() {
          var series = this, options = series.options, yAxis = series.yAxis, y, minPointLength = pick$v(options.minPointLength, 5), halfMinPointLength = minPointLength / 2, threshold = options.threshold || 0, previousY = threshold, previousIntermediate = threshold, stacking = options.stacking, actualStack = yAxis.waterfall.stacks[series.stackKey], total, yPos, hPos;
          ColumnSeries$8.prototype.translate.apply(series);
          var points = series.points;
          for (var i = 0; i < points.length; i++) {
            var point = points[i];
            var yValue = series.processedYData[i];
            var shapeArgs = point.shapeArgs;
            if (!shapeArgs || !isNumber$b(yValue)) {
              continue;
            }
            var range = [0, yValue];
            var pointY = point.y;
            if (stacking) {
              if (actualStack) {
                var actualStackX = actualStack[i];
                if (stacking === "overlap") {
                  total = actualStackX.stackState[actualStackX.stateIndex--];
                  y = pointY >= 0 ? total : total - pointY;
                  if (ownProp(actualStackX, "absolutePos")) {
                    delete actualStackX.absolutePos;
                  }
                  if (ownProp(actualStackX, "absoluteNeg")) {
                    delete actualStackX.absoluteNeg;
                  }
                } else {
                  if (pointY >= 0) {
                    total = actualStackX.threshold + actualStackX.posTotal;
                    actualStackX.posTotal -= pointY;
                    y = total;
                  } else {
                    total = actualStackX.threshold + actualStackX.negTotal;
                    actualStackX.negTotal -= pointY;
                    y = total - pointY;
                  }
                  if (!actualStackX.posTotal) {
                    if (ownProp(actualStackX, "absolutePos")) {
                      actualStackX.posTotal = actualStackX.absolutePos;
                      delete actualStackX.absolutePos;
                    }
                  }
                  if (!actualStackX.negTotal) {
                    if (ownProp(actualStackX, "absoluteNeg")) {
                      actualStackX.negTotal = actualStackX.absoluteNeg;
                      delete actualStackX.absoluteNeg;
                    }
                  }
                }
                if (!point.isSum) {
                  actualStackX.connectorThreshold = actualStackX.threshold + actualStackX.stackTotal;
                }
                if (yAxis.reversed) {
                  yPos = pointY >= 0 ? y - pointY : y + pointY;
                  hPos = y;
                } else {
                  yPos = y;
                  hPos = y - pointY;
                }
                point.below = yPos <= threshold;
                shapeArgs.y = yAxis.translate(yPos, false, true, false, true) || 0;
                shapeArgs.height = Math.abs(shapeArgs.y - (yAxis.translate(hPos, false, true, false, true) || 0));
                var dummyStackItem = yAxis.waterfall.dummyStackItem;
                if (dummyStackItem) {
                  dummyStackItem.x = i;
                  dummyStackItem.label = actualStack[i].label;
                  dummyStackItem.setOffset(series.pointXOffset || 0, series.barW || 0, series.stackedYNeg[i], series.stackedYPos[i]);
                }
              }
            } else {
              y = Math.max(previousY, previousY + pointY) + range[0];
              shapeArgs.y = yAxis.translate(y, false, true, false, true) || 0;
              if (point.isSum) {
                shapeArgs.y = yAxis.translate(range[1], false, true, false, true) || 0;
                shapeArgs.height = Math.min(yAxis.translate(range[0], false, true, false, true) || 0, yAxis.len) - shapeArgs.y;
                point.below = range[1] <= threshold;
              } else if (point.isIntermediateSum) {
                if (pointY >= 0) {
                  yPos = range[1] + previousIntermediate;
                  hPos = previousIntermediate;
                } else {
                  yPos = previousIntermediate;
                  hPos = range[1] + previousIntermediate;
                }
                if (yAxis.reversed) {
                  yPos ^= hPos;
                  hPos ^= yPos;
                  yPos ^= hPos;
                }
                shapeArgs.y = yAxis.translate(yPos, false, true, false, true) || 0;
                shapeArgs.height = Math.abs(shapeArgs.y - Math.min(yAxis.translate(hPos, false, true, false, true) || 0, yAxis.len));
                previousIntermediate += range[1];
                point.below = yPos <= threshold;
              } else {
                shapeArgs.height = yValue > 0 ? (yAxis.translate(previousY, false, true, false, true) || 0) - shapeArgs.y : (yAxis.translate(previousY, false, true, false, true) || 0) - (yAxis.translate(previousY - yValue, false, true, false, true) || 0);
                previousY += yValue;
                point.below = previousY < threshold;
              }
              if (shapeArgs.height < 0) {
                shapeArgs.y += shapeArgs.height;
                shapeArgs.height *= -1;
              }
            }
            point.plotY = shapeArgs.y = Math.round(shapeArgs.y || 0) - series.borderWidth % 2 / 2;
            shapeArgs.height = Math.max(Math.round(shapeArgs.height || 0), 1e-3);
            point.yBottom = shapeArgs.y + shapeArgs.height;
            if (shapeArgs.height <= minPointLength && !point.isNull) {
              shapeArgs.height = minPointLength;
              shapeArgs.y -= halfMinPointLength;
              point.plotY = shapeArgs.y;
              if (point.y < 0) {
                point.minPointLengthOffset = -halfMinPointLength;
              } else {
                point.minPointLengthOffset = halfMinPointLength;
              }
            } else {
              if (point.isNull) {
                shapeArgs.width = 0;
              }
              point.minPointLengthOffset = 0;
            }
            var tooltipY = point.plotY + (point.negative ? shapeArgs.height : 0);
            if (point.below) {
              point.plotY += shapeArgs.height;
            }
            if (point.tooltipPos) {
              if (series.chart.inverted) {
                point.tooltipPos[0] = yAxis.len - tooltipY;
              } else {
                point.tooltipPos[1] = tooltipY;
              }
            }
          }
        };
        WaterfallSeries2.prototype.processData = function(force) {
          var series = this, options = series.options, yData = series.yData, points = options.data, point, dataLength = yData.length, threshold = options.threshold || 0, subSum, sum, dataMin, dataMax, y, i;
          sum = subSum = dataMin = dataMax = 0;
          for (i = 0; i < dataLength; i++) {
            y = yData[i];
            point = points && points[i] ? points[i] : {};
            if (y === "sum" || point.isSum) {
              yData[i] = correctFloat$2(sum);
            } else if (y === "intermediateSum" || point.isIntermediateSum) {
              yData[i] = correctFloat$2(subSum);
              subSum = 0;
            } else {
              sum += y;
              subSum += y;
            }
            dataMin = Math.min(sum, dataMin);
            dataMax = Math.max(sum, dataMax);
          }
          _super.prototype.processData.call(this, force);
          if (!options.stacking) {
            series.dataMin = dataMin + threshold;
            series.dataMax = dataMax;
          }
          return;
        };
        WaterfallSeries2.prototype.toYData = function(pt) {
          if (pt.isSum) {
            return "sum";
          }
          if (pt.isIntermediateSum) {
            return "intermediateSum";
          }
          return pt.y;
        };
        WaterfallSeries2.prototype.updateParallelArrays = function(point, i) {
          _super.prototype.updateParallelArrays.call(this, point, i);
          if (this.yData[0] === "sum" || this.yData[0] === "intermediateSum") {
            this.yData[0] = null;
          }
        };
        WaterfallSeries2.prototype.pointAttribs = function(point, state) {
          var upColor = this.options.upColor, attr2;
          if (upColor && !point.options.color) {
            point.color = point.y > 0 ? upColor : null;
          }
          attr2 = ColumnSeries$8.prototype.pointAttribs.call(this, point, state);
          delete attr2.dashstyle;
          return attr2;
        };
        WaterfallSeries2.prototype.getGraphPath = function() {
          return [["M", 0, 0]];
        };
        WaterfallSeries2.prototype.getCrispPath = function() {
          var data = this.data, yAxis = this.yAxis, length = data.length, graphNormalizer = Math.round(this.graph.strokeWidth()) % 2 / 2, borderNormalizer = Math.round(this.borderWidth) % 2 / 2, reversedXAxis = this.xAxis.reversed, reversedYAxis = this.yAxis.reversed, stacking = this.options.stacking, path = [], connectorThreshold, prevStack, prevStackX, prevPoint, yPos, isPos, prevArgs, pointArgs, i;
          for (i = 1; i < length; i++) {
            pointArgs = data[i].shapeArgs;
            prevPoint = data[i - 1];
            prevArgs = data[i - 1].shapeArgs;
            prevStack = yAxis.waterfall.stacks[this.stackKey];
            isPos = prevPoint.y > 0 ? -prevArgs.height : 0;
            if (prevStack && prevArgs && pointArgs) {
              prevStackX = prevStack[i - 1];
              if (stacking) {
                connectorThreshold = prevStackX.connectorThreshold;
                yPos = Math.round(yAxis.translate(connectorThreshold, 0, 1, 0, 1) + (reversedYAxis ? isPos : 0)) - graphNormalizer;
              } else {
                yPos = prevArgs.y + prevPoint.minPointLengthOffset + borderNormalizer - graphNormalizer;
              }
              path.push([
                "M",
                (prevArgs.x || 0) + (reversedXAxis ? 0 : prevArgs.width || 0),
                yPos
              ], [
                "L",
                (pointArgs.x || 0) + (reversedXAxis ? pointArgs.width || 0 : 0),
                yPos
              ]);
            }
            if (prevArgs && path.length && (!stacking && prevPoint.y < 0 && !reversedYAxis || prevPoint.y > 0 && reversedYAxis)) {
              var nextLast = path[path.length - 2];
              if (nextLast && typeof nextLast[2] === "number") {
                nextLast[2] += prevArgs.height || 0;
              }
              var last = path[path.length - 1];
              if (last && typeof last[2] === "number") {
                last[2] += prevArgs.height || 0;
              }
            }
          }
          return path;
        };
        WaterfallSeries2.prototype.drawGraph = function() {
          LineSeries$1.prototype.drawGraph.call(this);
          this.graph.attr({
            d: this.getCrispPath()
          });
        };
        WaterfallSeries2.prototype.setStackedPoints = function() {
          var series = this, options = series.options, waterfallStacks = series.yAxis.waterfall.stacks, seriesThreshold = options.threshold, stackThreshold = seriesThreshold || 0, interSum = stackThreshold, stackKey = series.stackKey, xData = series.xData, xLength = xData.length, actualStack, actualStackX, totalYVal, actualSum, prevSum, statesLen, posTotal, negTotal, xPoint, yVal, x, alreadyChanged, changed;
          function calculateStackState(firstS, nextS, sInx, sOff) {
            if (!statesLen) {
              actualStackX.stackState[0] = firstS;
              statesLen = actualStackX.stackState.length;
            } else {
              for (sInx; sInx < statesLen; sInx++) {
                actualStackX.stackState[sInx] += sOff;
              }
            }
            actualStackX.stackState.push(actualStackX.stackState[statesLen - 1] + nextS);
          }
          series.yAxis.stacking.usePercentage = false;
          totalYVal = actualSum = prevSum = stackThreshold;
          if (series.visible || !series.chart.options.chart.ignoreHiddenSeries) {
            changed = waterfallStacks.changed;
            alreadyChanged = waterfallStacks.alreadyChanged;
            if (alreadyChanged && alreadyChanged.indexOf(stackKey) < 0) {
              changed = true;
            }
            if (!waterfallStacks[stackKey]) {
              waterfallStacks[stackKey] = {};
            }
            actualStack = waterfallStacks[stackKey];
            for (var i = 0; i < xLength; i++) {
              x = xData[i];
              if (!actualStack[x] || changed) {
                actualStack[x] = {
                  negTotal: 0,
                  posTotal: 0,
                  stackTotal: 0,
                  threshold: 0,
                  stateIndex: 0,
                  stackState: [],
                  label: changed && actualStack[x] ? actualStack[x].label : void 0
                };
              }
              actualStackX = actualStack[x];
              yVal = series.yData[i];
              if (yVal >= 0) {
                actualStackX.posTotal += yVal;
              } else {
                actualStackX.negTotal += yVal;
              }
              xPoint = options.data[i];
              posTotal = actualStackX.absolutePos = actualStackX.posTotal;
              negTotal = actualStackX.absoluteNeg = actualStackX.negTotal;
              actualStackX.stackTotal = posTotal + negTotal;
              statesLen = actualStackX.stackState.length;
              if (xPoint && xPoint.isIntermediateSum) {
                calculateStackState(prevSum, actualSum, 0, prevSum);
                prevSum = actualSum;
                actualSum = seriesThreshold;
                stackThreshold ^= interSum;
                interSum ^= stackThreshold;
                stackThreshold ^= interSum;
              } else if (xPoint && xPoint.isSum) {
                calculateStackState(seriesThreshold, totalYVal, statesLen);
                stackThreshold = seriesThreshold;
              } else {
                calculateStackState(stackThreshold, yVal, 0, totalYVal);
                if (xPoint) {
                  totalYVal += yVal;
                  actualSum += yVal;
                }
              }
              actualStackX.stateIndex++;
              actualStackX.threshold = stackThreshold;
              stackThreshold += actualStackX.stackTotal;
            }
            waterfallStacks.changed = false;
            if (!waterfallStacks.alreadyChanged) {
              waterfallStacks.alreadyChanged = [];
            }
            waterfallStacks.alreadyChanged.push(stackKey);
          }
        };
        WaterfallSeries2.prototype.getExtremes = function() {
          var stacking = this.options.stacking, yAxis, waterfallStacks, stackedYNeg, stackedYPos;
          if (stacking) {
            yAxis = this.yAxis;
            waterfallStacks = yAxis.waterfall.stacks;
            stackedYNeg = this.stackedYNeg = [];
            stackedYPos = this.stackedYPos = [];
            if (stacking === "overlap") {
              objectEach$7(waterfallStacks[this.stackKey], function(stackX) {
                stackedYNeg.push(arrayMin$1(stackX.stackState));
                stackedYPos.push(arrayMax$1(stackX.stackState));
              });
            } else {
              objectEach$7(waterfallStacks[this.stackKey], function(stackX) {
                stackedYNeg.push(stackX.negTotal + stackX.threshold);
                stackedYPos.push(stackX.posTotal + stackX.threshold);
              });
            }
            return {
              dataMin: arrayMin$1(stackedYNeg),
              dataMax: arrayMax$1(stackedYPos)
            };
          }
          return {
            dataMin: this.dataMin,
            dataMax: this.dataMax
          };
        };
        WaterfallSeries2.defaultOptions = merge$q(ColumnSeries$8.defaultOptions, {
          /**
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @apioption plotOptions.waterfall.color
           */
          /**
           * The color used specifically for positive point columns. When not
           * specified, the general series color is used.
           *
           * In styled mode, the waterfall colors can be set with the
           * `.highcharts-point-negative`, `.highcharts-sum` and
           * `.highcharts-intermediate-sum` classes.
           *
           * @sample {highcharts} highcharts/demo/waterfall/
           *         Waterfall
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @product   highcharts
           * @apioption plotOptions.waterfall.upColor
           */
          dataLabels: {
            inside: true
          },
          /**
           * The width of the line connecting waterfall columns.
           *
           * @product highcharts
           */
          lineWidth: 1,
          /**
           * The color of the line that connects columns in a waterfall series.
           *
           * In styled mode, the stroke can be set with the `.highcharts-graph`
           * class.
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @since   3.0
           * @product highcharts
           */
          lineColor: palette.neutralColor80,
          /**
           * A name for the dash style to use for the line connecting the columns
           * of the waterfall series. Possible values: Dash, DashDot, Dot,
           * LongDash, LongDashDot, LongDashDotDot, ShortDash, ShortDashDot,
           * ShortDashDotDot, ShortDot, Solid
           *
           * In styled mode, the stroke dash-array can be set with the
           * `.highcharts-graph` class.
           *
           * @type    {Highcharts.DashStyleValue}
           * @since   3.0
           * @product highcharts
           */
          dashStyle: "Dot",
          /**
           * The color of the border of each waterfall column.
           *
           * In styled mode, the border stroke can be set with the
           * `.highcharts-point` class.
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @since   3.0
           * @product highcharts
           */
          borderColor: palette.neutralColor80,
          states: {
            hover: {
              lineWidthPlus: 0
              // #3126
            }
          }
        });
        return WaterfallSeries2;
      }(ColumnSeries$8)
    );
    extend$s(WaterfallSeries.prototype, {
      getZonesGraphs: LineSeries$1.prototype.getZonesGraphs,
      pointValKey: "y",
      // Property needed to prevent lines between the columns from disappearing
      // when negativeColor is used.
      showLine: true,
      pointClass: WaterfallPoint
    });
    SeriesRegistry$1.registerSeriesType("waterfall", WaterfallSeries);
    WaterfallAxis$1.compose(Axis, Chart$1);
    var animObject$2 = animationExports.animObject;
    var seriesTypes$3 = SeriesRegistry$1.seriesTypes;
    var addEvent$i = Utilities.addEvent, defined$c = Utilities.defined, find$4 = Utilities.find, isNumber$a = Utilities.isNumber, pick$u = Utilities.pick, splat$3 = Utilities.splat, uniqueKey$1 = Utilities.uniqueKey, wrap$6 = Utilities.wrap;
    var seriesProto = Series$e.prototype, pointerProto = Pointer.prototype, columnProto$2, arearangeProto;
    seriesProto.searchPointByAngle = function(e2) {
      var series = this, chart = series.chart, xAxis = series.xAxis, center = xAxis.pane.center, plotX = e2.chartX - center[0] - chart.plotLeft, plotY = e2.chartY - center[1] - chart.plotTop;
      return this.searchKDTree({
        clientX: 180 + Math.atan2(plotX, plotY) * (-180 / Math.PI)
      });
    };
    seriesProto.getConnectors = function(segment, index, calculateNeighbours, connectEnds) {
      var i, prevPointInd, nextPointInd, previousPoint, nextPoint, previousX, previousY, nextX, nextY, plotX, plotY, ret, smoothing = 1.5, denom = smoothing + 1, leftContX, leftContY, rightContX, rightContY, dLControlPoint, dRControlPoint, leftContAngle, rightContAngle, jointAngle, addedNumber = connectEnds ? 1 : 0;
      if (index >= 0 && index <= segment.length - 1) {
        i = index;
      } else if (index < 0) {
        i = segment.length - 1 + index;
      } else {
        i = 0;
      }
      prevPointInd = i - 1 < 0 ? segment.length - (1 + addedNumber) : i - 1;
      nextPointInd = i + 1 > segment.length - 1 ? addedNumber : i + 1;
      previousPoint = segment[prevPointInd];
      nextPoint = segment[nextPointInd];
      previousX = previousPoint.plotX;
      previousY = previousPoint.plotY;
      nextX = nextPoint.plotX;
      nextY = nextPoint.plotY;
      plotX = segment[i].plotX;
      plotY = segment[i].plotY;
      leftContX = (smoothing * plotX + previousX) / denom;
      leftContY = (smoothing * plotY + previousY) / denom;
      rightContX = (smoothing * plotX + nextX) / denom;
      rightContY = (smoothing * plotY + nextY) / denom;
      dLControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2));
      dRControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2));
      leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX);
      rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);
      jointAngle = Math.PI / 2 + (leftContAngle + rightContAngle) / 2;
      if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {
        jointAngle -= Math.PI;
      }
      leftContX = plotX + Math.cos(jointAngle) * dLControlPoint;
      leftContY = plotY + Math.sin(jointAngle) * dLControlPoint;
      rightContX = plotX + Math.cos(Math.PI + jointAngle) * dRControlPoint;
      rightContY = plotY + Math.sin(Math.PI + jointAngle) * dRControlPoint;
      ret = {
        rightContX,
        rightContY,
        leftContX,
        leftContY,
        plotX,
        plotY
      };
      if (calculateNeighbours) {
        ret.prevPointCont = this.getConnectors(segment, prevPointInd, false, connectEnds);
      }
      return ret;
    };
    seriesProto.toXY = function(point) {
      var chart = this.chart, xAxis = this.xAxis, yAxis = this.yAxis, plotX = point.plotX, plotY = point.plotY, series = point.series, inverted = chart.inverted, pointY = point.y, radius = inverted ? plotX : yAxis.len - plotY, clientX;
      if (inverted && series && !series.isRadialBar) {
        point.plotY = plotY = typeof pointY === "number" ? yAxis.translate(pointY) || 0 : 0;
      }
      point.rectPlotX = plotX;
      point.rectPlotY = plotY;
      if (yAxis.center) {
        radius += yAxis.center[3] / 2;
      }
      if (isNumber$a(plotY)) {
        var xy = inverted ? yAxis.postTranslate(plotY, radius) : xAxis.postTranslate(plotX, radius);
        point.plotX = point.polarPlotX = xy.x - chart.plotLeft;
        point.plotY = point.polarPlotY = xy.y - chart.plotTop;
      }
      if (this.kdByAngle) {
        clientX = (plotX / Math.PI * 180 + xAxis.pane.options.startAngle) % 360;
        if (clientX < 0) {
          clientX += 360;
        }
        point.clientX = clientX;
      } else {
        point.clientX = point.plotX;
      }
    };
    if (seriesTypes$3.spline) {
      wrap$6(seriesTypes$3.spline.prototype, "getPointSpline", function(proceed, segment, point, i) {
        var ret, connectors;
        if (this.chart.polar) {
          if (!i) {
            ret = ["M", point.plotX, point.plotY];
          } else {
            connectors = this.getConnectors(segment, i, true, this.connectEnds);
            var rightContX = connectors.prevPointCont && connectors.prevPointCont.rightContX;
            var rightContY = connectors.prevPointCont && connectors.prevPointCont.rightContY;
            ret = [
              "C",
              isNumber$a(rightContX) ? rightContX : connectors.plotX,
              isNumber$a(rightContY) ? rightContY : connectors.plotY,
              isNumber$a(connectors.leftContX) ? connectors.leftContX : connectors.plotX,
              isNumber$a(connectors.leftContY) ? connectors.leftContY : connectors.plotY,
              connectors.plotX,
              connectors.plotY
            ];
          }
        } else {
          ret = proceed.call(this, segment, point, i);
        }
        return ret;
      });
      if (seriesTypes$3.areasplinerange) {
        seriesTypes$3.areasplinerange.prototype.getPointSpline = seriesTypes$3.spline.prototype.getPointSpline;
      }
    }
    addEvent$i(Series$e, "afterTranslate", function() {
      var series = this;
      var chart = series.chart;
      if (chart.polar && series.xAxis) {
        series.kdByAngle = chart.tooltip && chart.tooltip.shared;
        if (series.kdByAngle) {
          series.searchPoint = series.searchPointByAngle;
        } else {
          series.options.findNearestPointBy = "xy";
        }
        if (!series.preventPostTranslate) {
          var points = series.points;
          var i = points.length;
          while (i--) {
            series.toXY(points[i]);
            if (!chart.hasParallelCoordinates && !series.yAxis.reversed && points[i].y < series.yAxis.min) {
              points[i].isNull = true;
            }
          }
        }
        if (!this.hasClipCircleSetter) {
          this.hasClipCircleSetter = !!series.eventsToUnbind.push(addEvent$i(series, "afterRender", function() {
            var circ;
            if (chart.polar) {
              circ = this.yAxis.pane.center;
              if (!this.clipCircle) {
                this.clipCircle = chart.renderer.clipCircle(circ[0], circ[1], circ[2] / 2, circ[3] / 2);
              } else {
                this.clipCircle.animate({
                  x: circ[0],
                  y: circ[1],
                  r: circ[2] / 2,
                  innerR: circ[3] / 2
                });
              }
              this.group.clip(this.clipCircle);
              this.setClip = H.noop;
            }
          }));
        }
      }
    }, { order: 2 });
    wrap$6(seriesTypes$3.line.prototype, "getGraphPath", function(proceed, points) {
      var series = this, i, firstValid, popLastPoint;
      if (this.chart.polar) {
        points = points || this.points;
        for (i = 0; i < points.length; i++) {
          if (!points[i].isNull) {
            firstValid = i;
            break;
          }
        }
        if (this.options.connectEnds !== false && typeof firstValid !== "undefined") {
          this.connectEnds = true;
          points.splice(points.length, 0, points[firstValid]);
          popLastPoint = true;
        }
        points.forEach(function(point) {
          if (typeof point.polarPlotY === "undefined") {
            series.toXY(point);
          }
        });
      }
      var ret = proceed.apply(this, [].slice.call(arguments, 1));
      if (popLastPoint) {
        points.pop();
      }
      return ret;
    });
    var polarAnimate = function(proceed, init) {
      var series = this, chart = this.chart, animation = this.options.animation, group = this.group, markerGroup = this.markerGroup, center = this.xAxis.center, plotLeft = chart.plotLeft, plotTop = chart.plotTop, attribs, paneInnerR, graphic, shapeArgs, r, innerR;
      if (chart.polar) {
        if (series.isRadialBar) {
          if (!init) {
            series.startAngleRad = pick$u(series.translatedThreshold, series.xAxis.startAngleRad);
            H.seriesTypes.pie.prototype.animate.call(series, init);
          }
        } else {
          if (chart.renderer.isSVG) {
            animation = animObject$2(animation);
            if (series.is("column")) {
              if (!init) {
                paneInnerR = center[3] / 2;
                series.points.forEach(function(point) {
                  graphic = point.graphic;
                  shapeArgs = point.shapeArgs;
                  r = shapeArgs && shapeArgs.r;
                  innerR = shapeArgs && shapeArgs.innerR;
                  if (graphic && shapeArgs) {
                    graphic.attr({
                      r: paneInnerR,
                      innerR: paneInnerR
                    });
                    graphic.animate({
                      r,
                      innerR
                    }, series.options.animation);
                  }
                });
              }
            } else {
              if (init) {
                attribs = {
                  translateX: center[0] + plotLeft,
                  translateY: center[1] + plotTop,
                  scaleX: 1e-3,
                  scaleY: 1e-3
                };
                group.attr(attribs);
                if (markerGroup) {
                  markerGroup.attr(attribs);
                }
              } else {
                attribs = {
                  translateX: plotLeft,
                  translateY: plotTop,
                  scaleX: 1,
                  scaleY: 1
                };
                group.animate(attribs, animation);
                if (markerGroup) {
                  markerGroup.animate(attribs, animation);
                }
              }
            }
          }
        }
      } else {
        proceed.call(this, init);
      }
    };
    wrap$6(seriesProto, "animate", polarAnimate);
    if (seriesTypes$3.column) {
      arearangeProto = seriesTypes$3.arearange.prototype;
      columnProto$2 = seriesTypes$3.column.prototype;
      columnProto$2.polarArc = function(low, high, start, end) {
        var center = this.xAxis.center, len = this.yAxis.len, paneInnerR = center[3] / 2, r = len - high + paneInnerR, innerR = len - pick$u(low, len) + paneInnerR;
        if (this.yAxis.reversed) {
          if (r < 0) {
            r = paneInnerR;
          }
          if (innerR < 0) {
            innerR = paneInnerR;
          }
        }
        return {
          x: center[0],
          y: center[1],
          r,
          innerR,
          start,
          end
        };
      };
      wrap$6(columnProto$2, "animate", polarAnimate);
      wrap$6(columnProto$2, "translate", function(proceed) {
        var series = this, options = series.options, threshold = options.threshold, stacking = options.stacking, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis, reversed = yAxis.reversed, center = yAxis.center, startAngleRad = xAxis.startAngleRad, endAngleRad = xAxis.endAngleRad, visibleRange = endAngleRad - startAngleRad, thresholdAngleRad, points, point, i, yMin, yMax, start, end, tooltipPos, pointX, pointY, stackValues, stack, barX, innerR, r;
        series.preventPostTranslate = true;
        proceed.call(series);
        if (xAxis.isRadial) {
          points = series.points;
          i = points.length;
          yMin = yAxis.translate(yAxis.min);
          yMax = yAxis.translate(yAxis.max);
          threshold = options.threshold || 0;
          if (chart.inverted) {
            if (isNumber$a(threshold)) {
              thresholdAngleRad = yAxis.translate(threshold);
              if (defined$c(thresholdAngleRad)) {
                if (thresholdAngleRad < 0) {
                  thresholdAngleRad = 0;
                } else if (thresholdAngleRad > visibleRange) {
                  thresholdAngleRad = visibleRange;
                }
                series.translatedThreshold = thresholdAngleRad + startAngleRad;
              }
            }
          }
          while (i--) {
            point = points[i];
            barX = point.barX;
            pointX = point.x;
            pointY = point.y;
            point.shapeType = "arc";
            if (chart.inverted) {
              point.plotY = yAxis.translate(pointY);
              if (stacking && yAxis.stacking) {
                stack = yAxis.stacking.stacks[(pointY < 0 ? "-" : "") + series.stackKey];
                if (series.visible && stack && stack[pointX]) {
                  if (!point.isNull) {
                    stackValues = stack[pointX].points[series.getStackIndicator(void 0, pointX, series.index).key];
                    start = yAxis.translate(stackValues[0]);
                    end = yAxis.translate(stackValues[1]);
                    if (defined$c(start)) {
                      start = Utilities.clamp(start, 0, visibleRange);
                    }
                  }
                }
              } else {
                start = thresholdAngleRad;
                end = point.plotY;
              }
              if (start > end) {
                end = [start, start = end][0];
              }
              if (!reversed) {
                if (start < yMin) {
                  start = yMin;
                } else if (end > yMax) {
                  end = yMax;
                } else if (end < yMin || start > yMax) {
                  start = end = 0;
                }
              } else {
                if (end > yMin) {
                  end = yMin;
                } else if (start < yMax) {
                  start = yMax;
                } else if (start > yMin || end < yMax) {
                  start = end = visibleRange;
                }
              }
              if (yAxis.min > yAxis.max) {
                start = end = reversed ? visibleRange : 0;
              }
              start += startAngleRad;
              end += startAngleRad;
              if (center) {
                point.barX = barX += center[3] / 2;
              }
              innerR = Math.max(barX, 0);
              r = Math.max(barX + point.pointWidth, 0);
              point.shapeArgs = {
                x: center && center[0],
                y: center && center[1],
                r,
                innerR,
                start,
                end
              };
              point.opacity = start === end ? 0 : void 0;
              point.plotY = (defined$c(series.translatedThreshold) && (start < series.translatedThreshold ? start : end)) - startAngleRad;
            } else {
              start = barX + startAngleRad;
              point.shapeArgs = series.polarArc(point.yBottom, point.plotY, start, start + point.pointWidth);
            }
            series.toXY(point);
            if (chart.inverted) {
              tooltipPos = yAxis.postTranslate(point.rectPlotY, barX + point.pointWidth / 2);
              point.tooltipPos = [
                tooltipPos.x - chart.plotLeft,
                tooltipPos.y - chart.plotTop
              ];
            } else {
              point.tooltipPos = [point.plotX, point.plotY];
            }
            if (center) {
              point.ttBelow = point.plotY > center[1];
            }
          }
        }
      });
      columnProto$2.findAlignments = function(angle, options) {
        var align, verticalAlign;
        if (options.align === null) {
          if (angle > 20 && angle < 160) {
            align = "left";
          } else if (angle > 200 && angle < 340) {
            align = "right";
          } else {
            align = "center";
          }
          options.align = align;
        }
        if (options.verticalAlign === null) {
          if (angle < 45 || angle > 315) {
            verticalAlign = "bottom";
          } else if (angle > 135 && angle < 225) {
            verticalAlign = "top";
          } else {
            verticalAlign = "middle";
          }
          options.verticalAlign = verticalAlign;
        }
        return options;
      };
      if (arearangeProto) {
        arearangeProto.findAlignments = columnProto$2.findAlignments;
      }
      wrap$6(columnProto$2, "alignDataLabel", function(proceed, point, dataLabel, options, alignTo, isNew) {
        var chart = this.chart, inside = pick$u(options.inside, !!this.options.stacking), angle, shapeArgs, labelPos;
        if (chart.polar) {
          angle = point.rectPlotX / Math.PI * 180;
          if (!chart.inverted) {
            if (this.findAlignments) {
              options = this.findAlignments(angle, options);
            }
          } else {
            this.forceDL = chart.isInsidePlot(point.plotX, Math.round(point.plotY));
            if (inside && point.shapeArgs) {
              shapeArgs = point.shapeArgs;
              labelPos = this.yAxis.postTranslate(
                // angle
                ((shapeArgs.start || 0) + (shapeArgs.end || 0)) / 2 - this.xAxis.startAngleRad,
                // radius
                point.barX + point.pointWidth / 2
              );
              alignTo = {
                x: labelPos.x - chart.plotLeft,
                y: labelPos.y - chart.plotTop
              };
            } else if (point.tooltipPos) {
              alignTo = {
                x: point.tooltipPos[0],
                y: point.tooltipPos[1]
              };
            }
            options.align = pick$u(options.align, "center");
            options.verticalAlign = pick$u(options.verticalAlign, "middle");
          }
          seriesProto.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
          if (this.isRadialBar && point.shapeArgs && point.shapeArgs.start === point.shapeArgs.end) {
            dataLabel.hide(true);
          }
        } else {
          proceed.call(this, point, dataLabel, options, alignTo, isNew);
        }
      });
    }
    wrap$6(pointerProto, "getCoordinates", function(proceed, e2) {
      var chart = this.chart, ret = {
        xAxis: [],
        yAxis: []
      };
      if (chart.polar) {
        chart.axes.forEach(function(axis) {
          var isXAxis = axis.isXAxis, center = axis.center, x, y;
          if (axis.coll === "colorAxis") {
            return;
          }
          x = e2.chartX - center[0] - chart.plotLeft;
          y = e2.chartY - center[1] - chart.plotTop;
          ret[isXAxis ? "xAxis" : "yAxis"].push({
            axis,
            value: axis.translate(isXAxis ? Math.PI - Math.atan2(x, y) : (
              // angle
              // distance from center
              Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))
            ), true)
          });
        });
      } else {
        ret = proceed.call(this, e2);
      }
      return ret;
    });
    SVGRenderer.prototype.clipCircle = function(x, y, r, innerR) {
      var wrapper, id = uniqueKey$1(), clipPath = this.createElement("clipPath").attr({
        id
      }).add(this.defs);
      wrapper = innerR ? this.arc(x, y, r, innerR, 0, 2 * Math.PI).add(clipPath) : this.circle(x, y, r).add(clipPath);
      wrapper.id = id;
      wrapper.clipPath = clipPath;
      return wrapper;
    };
    addEvent$i(Chart$1, "getAxes", function() {
      if (!this.pane) {
        this.pane = [];
      }
      this.options.pane = splat$3(this.options.pane);
      this.options.pane.forEach(function(paneOptions) {
        new Pane$1(
          // eslint-disable-line no-new
          paneOptions,
          this
        );
      }, this);
    });
    addEvent$i(Chart$1, "afterDrawChartBox", function() {
      this.pane.forEach(function(pane) {
        pane.render();
      });
    });
    addEvent$i(Series$e, "afterInit", function() {
      var chart = this.chart;
      if (chart.inverted && chart.polar) {
        this.isRadialSeries = true;
        if (this.is("column")) {
          this.isRadialBar = true;
        }
      }
    });
    wrap$6(Chart$1.prototype, "get", function(proceed, id) {
      return find$4(this.pane || [], function(pane) {
        return pane.options.id === id;
      }) || proceed.call(this, id);
    });
    /**
     * @license Highcharts JS v9.2.2 (2021-08-24)
     * @module highcharts/highcharts-more
     * @requires highcharts
     *
     * (c) 2009-2021 Torstein Honsi
     *
     * License: www.highcharts.com/license
     */
    var G$4 = H;
    RadialAxis$1.compose(G$4.Axis, G$4.Tick);
    BubbleSeries$2.compose(G$4.Chart, G$4.Legend, G$4.Series);
    var pick$t = Utilities.pick;
    var deg2rad$3 = H.deg2rad;
    function rotate3D(x, y, z, angles) {
      return {
        x: angles.cosB * x - angles.sinB * z,
        y: -angles.sinA * angles.sinB * x + angles.cosA * y - angles.cosB * angles.sinA * z,
        z: angles.cosA * angles.sinB * x + angles.sinA * y + angles.cosA * angles.cosB * z
      };
    }
    function perspective3D$1(coordinate, origin, distance) {
      var projection = distance > 0 && distance < Number.POSITIVE_INFINITY ? distance / (coordinate.z + origin.z + distance) : 1;
      return {
        x: coordinate.x * projection,
        y: coordinate.y * projection
      };
    }
    H.perspective3D = perspective3D$1;
    function perspective$6(points, chart, insidePlotArea, useInvertedPersp) {
      var options3d = chart.options.chart.options3d, inverted = pick$t(useInvertedPersp, insidePlotArea ? chart.inverted : false), origin = {
        x: chart.plotWidth / 2,
        y: chart.plotHeight / 2,
        z: options3d.depth / 2,
        vd: pick$t(options3d.depth, 1) * pick$t(options3d.viewDistance, 0)
      }, scale = chart.scale3d || 1, beta = deg2rad$3 * options3d.beta * (inverted ? -1 : 1), alpha = deg2rad$3 * options3d.alpha * (inverted ? -1 : 1), angles = {
        cosA: Math.cos(alpha),
        cosB: Math.cos(-beta),
        sinA: Math.sin(alpha),
        sinB: Math.sin(-beta)
      };
      if (!insidePlotArea) {
        origin.x += chart.plotLeft;
        origin.y += chart.plotTop;
      }
      return points.map(function(point) {
        var rotated = rotate3D((inverted ? point.y : point.x) - origin.x, (inverted ? point.x : point.y) - origin.y, (point.z || 0) - origin.z, angles), coordinate = perspective3D$1(rotated, origin, origin.vd);
        coordinate.x = coordinate.x * scale + origin.x;
        coordinate.y = coordinate.y * scale + origin.y;
        coordinate.z = rotated.z * scale + origin.z;
        return {
          x: inverted ? coordinate.y : coordinate.x,
          y: inverted ? coordinate.x : coordinate.y,
          z: coordinate.z
        };
      });
    }
    H.perspective = perspective$6;
    function pointCameraDistance$1(coordinates, chart) {
      var options3d = chart.options.chart.options3d, cameraPosition = {
        x: chart.plotWidth / 2,
        y: chart.plotHeight / 2,
        z: pick$t(options3d.depth, 1) * pick$t(options3d.viewDistance, 0) + options3d.depth
      }, distance = Math.sqrt(Math.pow(cameraPosition.x - pick$t(coordinates.plotX, coordinates.x), 2) + Math.pow(cameraPosition.y - pick$t(coordinates.plotY, coordinates.y), 2) + Math.pow(cameraPosition.z - pick$t(coordinates.plotZ, coordinates.z), 2));
      return distance;
    }
    H.pointCameraDistance = pointCameraDistance$1;
    function shapeArea$2(vertexes) {
      var area = 0, i, j;
      for (i = 0; i < vertexes.length; i++) {
        j = (i + 1) % vertexes.length;
        area += vertexes[i].x * vertexes[j].y - vertexes[j].x * vertexes[i].y;
      }
      return area / 2;
    }
    H.shapeArea = shapeArea$2;
    function shapeArea3D$1(vertexes, chart, insidePlotArea) {
      return shapeArea$2(perspective$6(vertexes, chart, insidePlotArea));
    }
    H.shapeArea3d = shapeArea3D$1;
    var mathModule = {
      perspective: perspective$6,
      perspective3D: perspective3D$1,
      pointCameraDistance: pointCameraDistance$1,
      shapeArea: shapeArea$2,
      shapeArea3D: shapeArea3D$1
    };
    var color$7 = Color.parse;
    var defined$b = Utilities.defined, merge$p = Utilities.merge, objectEach$6 = Utilities.objectEach, pick$s = Utilities.pick;
    var SVGElement3D = {};
    SVGElement3D.base = {
      /* eslint-disable valid-jsdoc */
      /**
       * The init is used by base - renderer.Element
       * @private
       */
      initArgs: function(args) {
        var elem3d = this, renderer = elem3d.renderer, paths = renderer[elem3d.pathType + "Path"](args), zIndexes = paths.zIndexes;
        elem3d.parts.forEach(function(part) {
          elem3d[part] = renderer.path(paths[part]).attr({
            "class": "highcharts-3d-" + part,
            zIndex: zIndexes[part] || 0
          }).add(elem3d);
        });
        elem3d.attr({
          "stroke-linejoin": "round",
          zIndex: zIndexes.group
        });
        elem3d.originalDestroy = elem3d.destroy;
        elem3d.destroy = elem3d.destroyParts;
        elem3d.forcedSides = paths.forcedSides;
      },
      /**
       * Single property setter that applies options to each part
       * @private
       */
      singleSetterForParts: function(prop, val, values, verb, duration, complete) {
        var elem3d = this, newAttr = {}, optionsToApply = [null, null, verb || "attr", duration, complete], hasZIndexes = values && values.zIndexes;
        if (!values) {
          newAttr[prop] = val;
          optionsToApply[0] = newAttr;
        } else {
          if (hasZIndexes && hasZIndexes.group) {
            this.attr({
              zIndex: hasZIndexes.group
            });
          }
          objectEach$6(values, function(partVal, part) {
            newAttr[part] = {};
            newAttr[part][prop] = partVal;
            if (hasZIndexes) {
              newAttr[part].zIndex = values.zIndexes[part] || 0;
            }
          });
          optionsToApply[1] = newAttr;
        }
        return elem3d.processParts.apply(elem3d, optionsToApply);
      },
      /**
       * Calls function for each part. Used for attr, animate and destroy.
       * @private
       */
      processParts: function(props, partsProps, verb, duration, complete) {
        var elem3d = this;
        elem3d.parts.forEach(function(part) {
          if (partsProps) {
            props = pick$s(partsProps[part], false);
          }
          if (props !== false) {
            elem3d[part][verb](props, duration, complete);
          }
        });
        return elem3d;
      },
      /**
       * Destroy all parts
       * @private
       */
      destroyParts: function() {
        this.processParts(null, null, "destroy");
        return this.originalDestroy();
      }
      /* eslint-enable valid-jsdoc */
    };
    SVGElement3D.cuboid = merge$p(SVGElement3D.base, {
      parts: ["front", "top", "side"],
      pathType: "cuboid",
      attr: function(args, val, complete, continueAnimation) {
        if (typeof args === "string" && typeof val !== "undefined") {
          var key = args;
          args = {};
          args[key] = val;
        }
        if (args.shapeArgs || defined$b(args.x)) {
          return this.singleSetterForParts("d", null, this.renderer[this.pathType + "Path"](args.shapeArgs || args));
        }
        return SVGElement.prototype.attr.call(this, args, void 0, complete, continueAnimation);
      },
      animate: function(args, duration, complete) {
        if (defined$b(args.x) && defined$b(args.y)) {
          var paths = this.renderer[this.pathType + "Path"](args), forcedSides = paths.forcedSides;
          this.singleSetterForParts("d", null, paths, "animate", duration, complete);
          this.attr({
            zIndex: paths.zIndexes.group
          });
          if (forcedSides !== this.forcedSides) {
            this.forcedSides = forcedSides;
            SVGElement3D.cuboid.fillSetter.call(this, this.fill);
          }
        } else {
          SVGElement.prototype.animate.call(this, args, duration, complete);
        }
        return this;
      },
      fillSetter: function(fill) {
        var elem3d = this;
        elem3d.forcedSides = elem3d.forcedSides || [];
        elem3d.singleSetterForParts("fill", null, {
          front: fill,
          // Do not change color if side was forced to render.
          top: color$7(fill).brighten(elem3d.forcedSides.indexOf("top") >= 0 ? 0 : 0.1).get(),
          side: color$7(fill).brighten(elem3d.forcedSides.indexOf("side") >= 0 ? 0 : -0.1).get()
        });
        elem3d.color = elem3d.fill = fill;
        return elem3d;
      }
    });
    var __extends$o = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var animObject$1 = animationExports.animObject;
    var color$6 = Color.parse;
    var charts = H.charts, deg2rad$2 = H.deg2rad;
    var perspective$5 = mathModule.perspective, shapeArea$1 = mathModule.shapeArea;
    var defined$a = Utilities.defined, extend$r = Utilities.extend, merge$o = Utilities.merge, pick$r = Utilities.pick;
    var cos = Math.cos, sin = Math.sin, PI = Math.PI, dFactor = 4 * (Math.sqrt(2) - 1) / 3 / (PI / 2);
    var SVGRenderer3D = (
      /** @class */
      function(_super) {
        __extends$o(SVGRenderer3D2, _super);
        function SVGRenderer3D2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        SVGRenderer3D2.compose = function(SVGRendererClass) {
          var svgRendererProto = SVGRendererClass.prototype, svgRenderer3dProto = SVGRenderer3D2.prototype;
          svgRendererProto.elements3d = SVGElement3D;
          svgRendererProto.arc3d = svgRenderer3dProto.arc3d;
          svgRendererProto.arc3dPath = svgRenderer3dProto.arc3dPath;
          svgRendererProto.cuboid = svgRenderer3dProto.cuboid;
          svgRendererProto.cuboidPath = svgRenderer3dProto.cuboidPath;
          svgRendererProto.element3d = svgRenderer3dProto.element3d;
          svgRendererProto.face3d = svgRenderer3dProto.face3d;
          svgRendererProto.polyhedron = svgRenderer3dProto.polyhedron;
          svgRendererProto.toLinePath = svgRenderer3dProto.toLinePath;
          svgRendererProto.toLineSegments = svgRenderer3dProto.toLineSegments;
        };
        SVGRenderer3D2.curveTo = function(cx, cy, rx, ry, start, end, dx, dy) {
          var result2 = [], arcAngle = end - start;
          if (end > start && end - start > Math.PI / 2 + 1e-4) {
            result2 = result2.concat(this.curveTo(cx, cy, rx, ry, start, start + Math.PI / 2, dx, dy));
            result2 = result2.concat(this.curveTo(cx, cy, rx, ry, start + Math.PI / 2, end, dx, dy));
            return result2;
          }
          if (end < start && start - end > Math.PI / 2 + 1e-4) {
            result2 = result2.concat(this.curveTo(cx, cy, rx, ry, start, start - Math.PI / 2, dx, dy));
            result2 = result2.concat(this.curveTo(cx, cy, rx, ry, start - Math.PI / 2, end, dx, dy));
            return result2;
          }
          return [[
            "C",
            cx + rx * Math.cos(start) - rx * dFactor * arcAngle * Math.sin(start) + dx,
            cy + ry * Math.sin(start) + ry * dFactor * arcAngle * Math.cos(start) + dy,
            cx + rx * Math.cos(end) + rx * dFactor * arcAngle * Math.sin(end) + dx,
            cy + ry * Math.sin(end) - ry * dFactor * arcAngle * Math.cos(end) + dy,
            cx + rx * Math.cos(end) + dx,
            cy + ry * Math.sin(end) + dy
          ]];
        };
        SVGRenderer3D2.prototype.toLinePath = function(points, closed) {
          var result2 = [];
          points.forEach(function(point) {
            result2.push(["L", point.x, point.y]);
          });
          if (points.length) {
            result2[0][0] = "M";
            if (closed) {
              result2.push(["Z"]);
            }
          }
          return result2;
        };
        SVGRenderer3D2.prototype.toLineSegments = function(points) {
          var result2 = [], m = true;
          points.forEach(function(point) {
            result2.push(m ? ["M", point.x, point.y] : ["L", point.x, point.y]);
            m = !m;
          });
          return result2;
        };
        SVGRenderer3D2.prototype.face3d = function(args) {
          var renderer = this, ret = this.createElement("path");
          ret.vertexes = [];
          ret.insidePlotArea = false;
          ret.enabled = true;
          ret.attr = function(hash) {
            if (typeof hash === "object" && (defined$a(hash.enabled) || defined$a(hash.vertexes) || defined$a(hash.insidePlotArea))) {
              this.enabled = pick$r(hash.enabled, this.enabled);
              this.vertexes = pick$r(hash.vertexes, this.vertexes);
              this.insidePlotArea = pick$r(hash.insidePlotArea, this.insidePlotArea);
              delete hash.enabled;
              delete hash.vertexes;
              delete hash.insidePlotArea;
              var chart = charts[renderer.chartIndex], vertexes2d = perspective$5(this.vertexes, chart, this.insidePlotArea), path = renderer.toLinePath(vertexes2d, true), area = shapeArea$1(vertexes2d);
              hash.d = path;
              hash.visibility = this.enabled && area > 0 ? "visible" : "hidden";
            }
            return SVGElement.prototype.attr.apply(this, arguments);
          };
          ret.animate = function(params) {
            if (typeof params === "object" && (defined$a(params.enabled) || defined$a(params.vertexes) || defined$a(params.insidePlotArea))) {
              this.enabled = pick$r(params.enabled, this.enabled);
              this.vertexes = pick$r(params.vertexes, this.vertexes);
              this.insidePlotArea = pick$r(params.insidePlotArea, this.insidePlotArea);
              delete params.enabled;
              delete params.vertexes;
              delete params.insidePlotArea;
              var chart = charts[renderer.chartIndex], vertexes2d = perspective$5(this.vertexes, chart, this.insidePlotArea), path = renderer.toLinePath(vertexes2d, true), area = shapeArea$1(vertexes2d), visibility = this.enabled && area > 0 ? "visible" : "hidden";
              params.d = path;
              this.attr("visibility", visibility);
            }
            return SVGElement.prototype.animate.apply(this, arguments);
          };
          return ret.attr(args);
        };
        SVGRenderer3D2.prototype.polyhedron = function(args) {
          var renderer = this, result2 = this.g(), destroy = result2.destroy;
          if (!this.styledMode) {
            result2.attr({
              "stroke-linejoin": "round"
            });
          }
          result2.faces = [];
          result2.destroy = function() {
            for (var i = 0; i < result2.faces.length; i++) {
              result2.faces[i].destroy();
            }
            return destroy.call(this);
          };
          result2.attr = function(hash, val, complete, continueAnimation) {
            if (typeof hash === "object" && defined$a(hash.faces)) {
              while (result2.faces.length > hash.faces.length) {
                result2.faces.pop().destroy();
              }
              while (result2.faces.length < hash.faces.length) {
                result2.faces.push(renderer.face3d().add(result2));
              }
              for (var i = 0; i < hash.faces.length; i++) {
                if (renderer.styledMode) {
                  delete hash.faces[i].fill;
                }
                result2.faces[i].attr(hash.faces[i], null, complete, continueAnimation);
              }
              delete hash.faces;
            }
            return SVGElement.prototype.attr.apply(this, arguments);
          };
          result2.animate = function(params, duration, complete) {
            if (params && params.faces) {
              while (result2.faces.length > params.faces.length) {
                result2.faces.pop().destroy();
              }
              while (result2.faces.length < params.faces.length) {
                result2.faces.push(renderer.face3d().add(result2));
              }
              for (var i = 0; i < params.faces.length; i++) {
                result2.faces[i].animate(params.faces[i], duration, complete);
              }
              delete params.faces;
            }
            return SVGElement.prototype.animate.apply(this, arguments);
          };
          return result2.attr(args);
        };
        SVGRenderer3D2.prototype.element3d = function(type, shapeArgs) {
          var ret = this.g();
          extend$r(ret, this.elements3d[type]);
          ret.initArgs(shapeArgs);
          return ret;
        };
        SVGRenderer3D2.prototype.cuboid = function(shapeArgs) {
          return this.element3d("cuboid", shapeArgs);
        };
        SVGRenderer3D2.prototype.cuboidPath = function(shapeArgs) {
          var x = shapeArgs.x || 0, y = shapeArgs.y || 0, z = shapeArgs.z || 0, h = shapeArgs.height || 0, w2 = shapeArgs.width || 0, d = shapeArgs.depth || 0, chart = charts[this.chartIndex], front, back, top, bottom, left, right, shape, path1, path2, path3, isFront, isTop, isRight, options3d = chart.options.chart.options3d, alpha = options3d.alpha, incrementX = 1e6, incrementY = 10, incrementZ = 100, zIndex = 0, pArr = [{
            x,
            y,
            z
          }, {
            x: x + w2,
            y,
            z
          }, {
            x: x + w2,
            y: y + h,
            z
          }, {
            x,
            y: y + h,
            z
          }, {
            x,
            y: y + h,
            z: z + d
          }, {
            x: x + w2,
            y: y + h,
            z: z + d
          }, {
            x: x + w2,
            y,
            z: z + d
          }, {
            x,
            y,
            z: z + d
          }], forcedSides = [], pickShape;
          pArr = perspective$5(pArr, chart, shapeArgs.insidePlotArea);
          function mapSidePath(i) {
            if (h === 0 && i > 1 && i < 6) {
              return {
                x: pArr[i].x,
                // when height is 0 instead of cuboid we render plane
                // so it is needed to add fake 10 height to imitate cuboid
                // for side calculation
                y: pArr[i].y + 10,
                z: pArr[i].z
              };
            }
            if (pArr[0].x === pArr[7].x && i >= 4) {
              return {
                x: pArr[i].x + 10,
                // when height is 0 instead of cuboid we render plane
                // so it is needed to add fake 10 height to imitate cuboid
                // for side calculation
                y: pArr[i].y,
                z: pArr[i].z
              };
            }
            if (d === 0 && i < 2 || i > 5) {
              return {
                x: pArr[i].x,
                // when height is 0 instead of cuboid we render plane
                // so it is needed to add fake 10 height to imitate cuboid
                // for side calculation
                y: pArr[i].y,
                z: pArr[i].z + 10
              };
            }
            return pArr[i];
          }
          function mapPath(i) {
            return pArr[i];
          }
          pickShape = function(verticesIndex1, verticesIndex2, side) {
            var ret = [[], -1], face1 = verticesIndex1.map(mapPath), face2 = verticesIndex2.map(mapPath), dummyFace1 = verticesIndex1.map(mapSidePath), dummyFace2 = verticesIndex2.map(mapSidePath);
            if (shapeArea$1(face1) < 0) {
              ret = [face1, 0];
            } else if (shapeArea$1(face2) < 0) {
              ret = [face2, 1];
            } else if (side) {
              forcedSides.push(side);
              if (shapeArea$1(dummyFace1) < 0) {
                ret = [face1, 0];
              } else if (shapeArea$1(dummyFace2) < 0) {
                ret = [face2, 1];
              } else {
                ret = [face1, 0];
              }
            }
            return ret;
          };
          front = [3, 2, 1, 0];
          back = [7, 6, 5, 4];
          shape = pickShape(front, back, "front");
          path1 = shape[0];
          isFront = shape[1];
          top = [1, 6, 7, 0];
          bottom = [4, 5, 2, 3];
          shape = pickShape(top, bottom, "top");
          path2 = shape[0];
          isTop = shape[1];
          right = [1, 2, 5, 6];
          left = [0, 7, 4, 3];
          shape = pickShape(right, left, "side");
          path3 = shape[0];
          isRight = shape[1];
          if (isRight === 1) {
            zIndex += incrementX * (chart.plotWidth - x);
          } else if (!isRight) {
            zIndex += incrementX * x;
          }
          zIndex += incrementY * (!isTop || // Numbers checked empirically
          (alpha >= 0 && alpha <= 180 || alpha < 360 && alpha > 357.5) ? chart.plotHeight - y : 10 + y);
          if (isFront === 1) {
            zIndex += incrementZ * z;
          } else if (!isFront) {
            zIndex += incrementZ * (1e3 - z);
          }
          return {
            front: this.toLinePath(path1, true),
            top: this.toLinePath(path2, true),
            side: this.toLinePath(path3, true),
            zIndexes: {
              group: Math.round(zIndex)
            },
            forcedSides,
            // additional info about zIndexes
            isFront,
            isTop
          };
        };
        SVGRenderer3D2.prototype.arc3d = function(attribs) {
          var wrapper = this.g(), renderer = wrapper.renderer, customAttribs = ["x", "y", "r", "innerR", "start", "end", "depth"];
          function suckOutCustom(params) {
            var hasCA = false, ca = {}, key;
            params = merge$o(params);
            for (key in params) {
              if (customAttribs.indexOf(key) !== -1) {
                ca[key] = params[key];
                delete params[key];
                hasCA = true;
              }
            }
            return hasCA ? [ca, params] : false;
          }
          attribs = merge$o(attribs);
          attribs.alpha = (attribs.alpha || 0) * deg2rad$2;
          attribs.beta = (attribs.beta || 0) * deg2rad$2;
          wrapper.top = renderer.path();
          wrapper.side1 = renderer.path();
          wrapper.side2 = renderer.path();
          wrapper.inn = renderer.path();
          wrapper.out = renderer.path();
          wrapper.onAdd = function() {
            var parent = wrapper.parentGroup, className = wrapper.attr("class");
            wrapper.top.add(wrapper);
            ["out", "inn", "side1", "side2"].forEach(function(face) {
              wrapper[face].attr({
                "class": className + " highcharts-3d-side"
              }).add(parent);
            });
          };
          ["addClass", "removeClass"].forEach(function(fn) {
            wrapper[fn] = function() {
              var args = arguments;
              ["top", "out", "inn", "side1", "side2"].forEach(function(face) {
                wrapper[face][fn].apply(wrapper[face], args);
              });
            };
          });
          wrapper.setPaths = function(attribs2) {
            var paths = wrapper.renderer.arc3dPath(attribs2), zIndex = paths.zTop * 100;
            wrapper.attribs = attribs2;
            wrapper.top.attr({ d: paths.top, zIndex: paths.zTop });
            wrapper.inn.attr({ d: paths.inn, zIndex: paths.zInn });
            wrapper.out.attr({ d: paths.out, zIndex: paths.zOut });
            wrapper.side1.attr({ d: paths.side1, zIndex: paths.zSide1 });
            wrapper.side2.attr({ d: paths.side2, zIndex: paths.zSide2 });
            wrapper.zIndex = zIndex;
            wrapper.attr({ zIndex });
            if (attribs2.center) {
              wrapper.top.setRadialReference(attribs2.center);
              delete attribs2.center;
            }
          };
          wrapper.setPaths(attribs);
          wrapper.fillSetter = function(value) {
            var darker = color$6(value).brighten(-0.1).get();
            this.fill = value;
            this.side1.attr({ fill: darker });
            this.side2.attr({ fill: darker });
            this.inn.attr({ fill: darker });
            this.out.attr({ fill: darker });
            this.top.attr({ fill: value });
            return this;
          };
          ["opacity", "translateX", "translateY", "visibility"].forEach(function(setter) {
            wrapper[setter + "Setter"] = function(value, key) {
              wrapper[key] = value;
              ["out", "inn", "side1", "side2", "top"].forEach(function(el) {
                wrapper[el].attr(key, value);
              });
            };
          });
          wrapper.attr = function(params) {
            var ca, paramArr;
            if (typeof params === "object") {
              paramArr = suckOutCustom(params);
              if (paramArr) {
                ca = paramArr[0];
                arguments[0] = paramArr[1];
                extend$r(wrapper.attribs, ca);
                wrapper.setPaths(wrapper.attribs);
              }
            }
            return SVGElement.prototype.attr.apply(wrapper, arguments);
          };
          wrapper.animate = function(params, animation, complete) {
            var paramArr, from = this.attribs, to, anim, randomProp = "data-" + Math.random().toString(26).substring(2, 9);
            delete params.center;
            delete params.z;
            delete params.alpha;
            delete params.beta;
            anim = animObject$1(pick$r(animation, this.renderer.globalAnimation));
            if (anim.duration) {
              paramArr = suckOutCustom(params);
              wrapper[randomProp] = 0;
              params[randomProp] = 1;
              wrapper[randomProp + "Setter"] = H.noop;
              if (paramArr) {
                to = paramArr[0];
                anim.step = function(a, fx) {
                  function interpolate(key) {
                    return from[key] + (pick$r(to[key], from[key]) - from[key]) * fx.pos;
                  }
                  if (fx.prop === randomProp) {
                    fx.elem.setPaths(merge$o(from, {
                      x: interpolate("x"),
                      y: interpolate("y"),
                      r: interpolate("r"),
                      innerR: interpolate("innerR"),
                      start: interpolate("start"),
                      end: interpolate("end"),
                      depth: interpolate("depth")
                    }));
                  }
                };
              }
              animation = anim;
            }
            return SVGElement.prototype.animate.call(this, params, animation, complete);
          };
          wrapper.destroy = function() {
            this.top.destroy();
            this.out.destroy();
            this.inn.destroy();
            this.side1.destroy();
            this.side2.destroy();
            return SVGElement.prototype.destroy.call(this);
          };
          wrapper.hide = function() {
            this.top.hide();
            this.out.hide();
            this.inn.hide();
            this.side1.hide();
            this.side2.hide();
          };
          wrapper.show = function(inherit) {
            this.top.show(inherit);
            this.out.show(inherit);
            this.inn.show(inherit);
            this.side1.show(inherit);
            this.side2.show(inherit);
          };
          return wrapper;
        };
        SVGRenderer3D2.prototype.arc3dPath = function(shapeArgs) {
          var cx = shapeArgs.x || 0, cy = shapeArgs.y || 0, start = shapeArgs.start || 0, end = (shapeArgs.end || 0) - 1e-5, r = shapeArgs.r || 0, ir = shapeArgs.innerR || 0, d = shapeArgs.depth || 0, alpha = shapeArgs.alpha || 0, beta = shapeArgs.beta || 0;
          var cs = Math.cos(start), ss = Math.sin(start), ce = Math.cos(end), se = Math.sin(end), rx = r * Math.cos(beta), ry = r * Math.cos(alpha), irx = ir * Math.cos(beta), iry = ir * Math.cos(alpha), dx = d * Math.sin(beta), dy = d * Math.sin(alpha);
          var top = [
            ["M", cx + rx * cs, cy + ry * ss]
          ];
          top = top.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, start, end, 0, 0));
          top.push([
            "L",
            cx + irx * ce,
            cy + iry * se
          ]);
          top = top.concat(SVGRenderer3D2.curveTo(cx, cy, irx, iry, end, start, 0, 0));
          top.push(["Z"]);
          var b = beta > 0 ? Math.PI / 2 : 0, a = alpha > 0 ? 0 : Math.PI / 2;
          var start2 = start > -b ? start : end > -b ? -b : start, end2 = end < PI - a ? end : start < PI - a ? PI - a : end, midEnd = 2 * PI - a;
          var out = [
            ["M", cx + rx * cos(start2), cy + ry * sin(start2)]
          ];
          out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, start2, end2, 0, 0));
          if (end > midEnd && start < midEnd) {
            out.push([
              "L",
              cx + rx * cos(end2) + dx,
              cy + ry * sin(end2) + dy
            ]);
            out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end2, midEnd, dx, dy));
            out.push([
              "L",
              cx + rx * cos(midEnd),
              cy + ry * sin(midEnd)
            ]);
            out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, midEnd, end, 0, 0));
            out.push([
              "L",
              cx + rx * cos(end) + dx,
              cy + ry * sin(end) + dy
            ]);
            out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end, midEnd, dx, dy));
            out.push([
              "L",
              cx + rx * cos(midEnd),
              cy + ry * sin(midEnd)
            ]);
            out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, midEnd, end2, 0, 0));
          } else if (end > PI - a && start < PI - a) {
            out.push([
              "L",
              cx + rx * Math.cos(end2) + dx,
              cy + ry * Math.sin(end2) + dy
            ]);
            out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end2, end, dx, dy));
            out.push([
              "L",
              cx + rx * Math.cos(end),
              cy + ry * Math.sin(end)
            ]);
            out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end, end2, 0, 0));
          }
          out.push([
            "L",
            cx + rx * Math.cos(end2) + dx,
            cy + ry * Math.sin(end2) + dy
          ]);
          out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end2, start2, dx, dy));
          out.push(["Z"]);
          var inn = [
            ["M", cx + irx * cs, cy + iry * ss]
          ];
          inn = inn.concat(SVGRenderer3D2.curveTo(cx, cy, irx, iry, start, end, 0, 0));
          inn.push([
            "L",
            cx + irx * Math.cos(end) + dx,
            cy + iry * Math.sin(end) + dy
          ]);
          inn = inn.concat(SVGRenderer3D2.curveTo(cx, cy, irx, iry, end, start, dx, dy));
          inn.push(["Z"]);
          var side1 = [
            ["M", cx + rx * cs, cy + ry * ss],
            ["L", cx + rx * cs + dx, cy + ry * ss + dy],
            ["L", cx + irx * cs + dx, cy + iry * ss + dy],
            ["L", cx + irx * cs, cy + iry * ss],
            ["Z"]
          ];
          var side2 = [
            ["M", cx + rx * ce, cy + ry * se],
            ["L", cx + rx * ce + dx, cy + ry * se + dy],
            ["L", cx + irx * ce + dx, cy + iry * se + dy],
            ["L", cx + irx * ce, cy + iry * se],
            ["Z"]
          ];
          var angleCorr = Math.atan2(dy, -dx), angleEnd = Math.abs(end + angleCorr), angleStart = Math.abs(start + angleCorr), angleMid = Math.abs((start + end) / 2 + angleCorr);
          function toZeroPIRange(angle) {
            angle = angle % (2 * Math.PI);
            if (angle > Math.PI) {
              angle = 2 * Math.PI - angle;
            }
            return angle;
          }
          angleEnd = toZeroPIRange(angleEnd);
          angleStart = toZeroPIRange(angleStart);
          angleMid = toZeroPIRange(angleMid);
          var incPrecision = 1e5, a1 = angleMid * incPrecision, a2 = angleStart * incPrecision, a3 = angleEnd * incPrecision;
          return {
            top,
            // max angle is PI, so this is always higher
            zTop: Math.PI * incPrecision + 1,
            out,
            zOut: Math.max(a1, a2, a3),
            inn,
            zInn: Math.max(a1, a2, a3),
            side1,
            zSide1: a3 * 0.99,
            side2,
            zSide2: a2 * 0.99
          };
        };
        return SVGRenderer3D2;
      }(SVGRenderer)
    );
    var color$5 = Color.parse;
    var perspective$4 = mathModule.perspective, shapeArea3D = mathModule.shapeArea3D;
    var genericDefaultOptions = DefaultOptions.defaultOptions;
    var addEvent$h = Utilities.addEvent, isArray$3 = Utilities.isArray, merge$n = Utilities.merge, pick$q = Utilities.pick, wrap$5 = Utilities.wrap;
    var Chart3D;
    (function(Chart3D2) {
      var Composition = (
        /** @class */
        function() {
          function Composition2(chart) {
            this.frame3d = void 0;
            this.chart = chart;
          }
          Composition2.prototype.get3dFrame = function() {
            var chart = this.chart, options3d = chart.options.chart.options3d, frameOptions = options3d.frame, xm = chart.plotLeft, xp = chart.plotLeft + chart.plotWidth, ym = chart.plotTop, yp = chart.plotTop + chart.plotHeight, zm = 0, zp = options3d.depth, faceOrientation = function(vertexes) {
              var area = shapeArea3D(vertexes, chart);
              if (area > 0.5) {
                return 1;
              }
              if (area < -0.5) {
                return -1;
              }
              return 0;
            }, bottomOrientation = faceOrientation([
              { x: xm, y: yp, z: zp },
              { x: xp, y: yp, z: zp },
              { x: xp, y: yp, z: zm },
              { x: xm, y: yp, z: zm }
            ]), topOrientation = faceOrientation([
              { x: xm, y: ym, z: zm },
              { x: xp, y: ym, z: zm },
              { x: xp, y: ym, z: zp },
              { x: xm, y: ym, z: zp }
            ]), leftOrientation = faceOrientation([
              { x: xm, y: ym, z: zm },
              { x: xm, y: ym, z: zp },
              { x: xm, y: yp, z: zp },
              { x: xm, y: yp, z: zm }
            ]), rightOrientation = faceOrientation([
              { x: xp, y: ym, z: zp },
              { x: xp, y: ym, z: zm },
              { x: xp, y: yp, z: zm },
              { x: xp, y: yp, z: zp }
            ]), frontOrientation = faceOrientation([
              { x: xm, y: yp, z: zm },
              { x: xp, y: yp, z: zm },
              { x: xp, y: ym, z: zm },
              { x: xm, y: ym, z: zm }
            ]), backOrientation = faceOrientation([
              { x: xm, y: ym, z: zp },
              { x: xp, y: ym, z: zp },
              { x: xp, y: yp, z: zp },
              { x: xm, y: yp, z: zp }
            ]), defaultShowFront = false, defaultShowBack = true;
            var defaultShowBottom = false, defaultShowTop = false, defaultShowLeft = false, defaultShowRight = false;
            [].concat(chart.xAxis, chart.yAxis, chart.zAxis).forEach(function(axis) {
              if (axis) {
                if (axis.horiz) {
                  if (axis.opposite) {
                    defaultShowTop = true;
                  } else {
                    defaultShowBottom = true;
                  }
                } else {
                  if (axis.opposite) {
                    defaultShowRight = true;
                  } else {
                    defaultShowLeft = true;
                  }
                }
              }
            });
            var getFaceOptions = function(sources, faceOrientation2, defaultVisible) {
              var faceAttrs = ["size", "color", "visible"], options = {};
              for (var i = 0; i < faceAttrs.length; i++) {
                var attr2 = faceAttrs[i];
                for (var j = 0; j < sources.length; j++) {
                  if (typeof sources[j] === "object") {
                    var val = sources[j][attr2];
                    if (typeof val !== "undefined" && val !== null) {
                      options[attr2] = val;
                      break;
                    }
                  }
                }
              }
              var isVisible = defaultVisible;
              if (options.visible === true || options.visible === false) {
                isVisible = options.visible;
              } else if (options.visible === "auto") {
                isVisible = faceOrientation2 > 0;
              }
              return {
                size: pick$q(options.size, 1),
                color: pick$q(options.color, "none"),
                frontFacing: faceOrientation2 > 0,
                visible: isVisible
              };
            };
            var ret = {
              axes: {},
              // FIXME: Previously, left/right, top/bottom and front/back
              // pairs shared size and color.
              // For compatibility and consistency sake, when one face have
              // size/color/visibility set, the opposite face will default to
              // the same values. Also, left/right used to be called 'side',
              // so that's also added as a fallback.
              bottom: getFaceOptions([frameOptions.bottom, frameOptions.top, frameOptions], bottomOrientation, defaultShowBottom),
              top: getFaceOptions([frameOptions.top, frameOptions.bottom, frameOptions], topOrientation, defaultShowTop),
              left: getFaceOptions([
                frameOptions.left,
                frameOptions.right,
                frameOptions.side,
                frameOptions
              ], leftOrientation, defaultShowLeft),
              right: getFaceOptions([
                frameOptions.right,
                frameOptions.left,
                frameOptions.side,
                frameOptions
              ], rightOrientation, defaultShowRight),
              back: getFaceOptions([frameOptions.back, frameOptions.front, frameOptions], backOrientation, defaultShowBack),
              front: getFaceOptions([frameOptions.front, frameOptions.back, frameOptions], frontOrientation, defaultShowFront)
            };
            if (options3d.axisLabelPosition === "auto") {
              var isValidEdge = function(face1, face2) {
                return face1.visible !== face2.visible || face1.visible && face2.visible && face1.frontFacing !== face2.frontFacing;
              };
              var yEdges = [];
              if (isValidEdge(ret.left, ret.front)) {
                yEdges.push({
                  y: (ym + yp) / 2,
                  x: xm,
                  z: zm,
                  xDir: { x: 1, y: 0, z: 0 }
                });
              }
              if (isValidEdge(ret.left, ret.back)) {
                yEdges.push({
                  y: (ym + yp) / 2,
                  x: xm,
                  z: zp,
                  xDir: { x: 0, y: 0, z: -1 }
                });
              }
              if (isValidEdge(ret.right, ret.front)) {
                yEdges.push({
                  y: (ym + yp) / 2,
                  x: xp,
                  z: zm,
                  xDir: { x: 0, y: 0, z: 1 }
                });
              }
              if (isValidEdge(ret.right, ret.back)) {
                yEdges.push({
                  y: (ym + yp) / 2,
                  x: xp,
                  z: zp,
                  xDir: { x: -1, y: 0, z: 0 }
                });
              }
              var xBottomEdges = [];
              if (isValidEdge(ret.bottom, ret.front)) {
                xBottomEdges.push({
                  x: (xm + xp) / 2,
                  y: yp,
                  z: zm,
                  xDir: { x: 1, y: 0, z: 0 }
                });
              }
              if (isValidEdge(ret.bottom, ret.back)) {
                xBottomEdges.push({
                  x: (xm + xp) / 2,
                  y: yp,
                  z: zp,
                  xDir: { x: -1, y: 0, z: 0 }
                });
              }
              var xTopEdges = [];
              if (isValidEdge(ret.top, ret.front)) {
                xTopEdges.push({
                  x: (xm + xp) / 2,
                  y: ym,
                  z: zm,
                  xDir: { x: 1, y: 0, z: 0 }
                });
              }
              if (isValidEdge(ret.top, ret.back)) {
                xTopEdges.push({
                  x: (xm + xp) / 2,
                  y: ym,
                  z: zp,
                  xDir: { x: -1, y: 0, z: 0 }
                });
              }
              var zBottomEdges = [];
              if (isValidEdge(ret.bottom, ret.left)) {
                zBottomEdges.push({
                  z: (zm + zp) / 2,
                  y: yp,
                  x: xm,
                  xDir: { x: 0, y: 0, z: -1 }
                });
              }
              if (isValidEdge(ret.bottom, ret.right)) {
                zBottomEdges.push({
                  z: (zm + zp) / 2,
                  y: yp,
                  x: xp,
                  xDir: { x: 0, y: 0, z: 1 }
                });
              }
              var zTopEdges = [];
              if (isValidEdge(ret.top, ret.left)) {
                zTopEdges.push({
                  z: (zm + zp) / 2,
                  y: ym,
                  x: xm,
                  xDir: { x: 0, y: 0, z: -1 }
                });
              }
              if (isValidEdge(ret.top, ret.right)) {
                zTopEdges.push({
                  z: (zm + zp) / 2,
                  y: ym,
                  x: xp,
                  xDir: { x: 0, y: 0, z: 1 }
                });
              }
              var pickEdge = function(edges, axis, mult) {
                if (edges.length === 0) {
                  return null;
                }
                if (edges.length === 1) {
                  return edges[0];
                }
                var projections = perspective$4(edges, chart, false);
                var best = 0;
                for (var i = 1; i < projections.length; i++) {
                  if (mult * projections[i][axis] > mult * projections[best][axis]) {
                    best = i;
                  } else if (mult * projections[i][axis] === mult * projections[best][axis] && projections[i].z < projections[best].z) {
                    best = i;
                  }
                }
                return edges[best];
              };
              ret.axes = {
                y: {
                  "left": pickEdge(yEdges, "x", -1),
                  "right": pickEdge(yEdges, "x", 1)
                },
                x: {
                  "top": pickEdge(xTopEdges, "y", -1),
                  "bottom": pickEdge(xBottomEdges, "y", 1)
                },
                z: {
                  "top": pickEdge(zTopEdges, "y", -1),
                  "bottom": pickEdge(zBottomEdges, "y", 1)
                }
              };
            } else {
              ret.axes = {
                y: {
                  "left": { x: xm, z: zm, xDir: { x: 1, y: 0, z: 0 } },
                  "right": { x: xp, z: zm, xDir: { x: 0, y: 0, z: 1 } }
                },
                x: {
                  "top": { y: ym, z: zm, xDir: { x: 1, y: 0, z: 0 } },
                  "bottom": { y: yp, z: zm, xDir: { x: 1, y: 0, z: 0 } }
                },
                z: {
                  "top": {
                    x: defaultShowLeft ? xp : xm,
                    y: ym,
                    xDir: defaultShowLeft ? { x: 0, y: 0, z: 1 } : { x: 0, y: 0, z: -1 }
                  },
                  "bottom": {
                    x: defaultShowLeft ? xp : xm,
                    y: yp,
                    xDir: defaultShowLeft ? { x: 0, y: 0, z: 1 } : { x: 0, y: 0, z: -1 }
                  }
                }
              };
            }
            return ret;
          };
          Composition2.prototype.getScale = function(depth) {
            var chart = this.chart, plotLeft = chart.plotLeft, plotRight = chart.plotWidth + plotLeft, plotTop = chart.plotTop, plotBottom = chart.plotHeight + plotTop, originX = plotLeft + chart.plotWidth / 2, originY = plotTop + chart.plotHeight / 2, bbox3d = {
              minX: Number.MAX_VALUE,
              maxX: -Number.MAX_VALUE,
              minY: Number.MAX_VALUE,
              maxY: -Number.MAX_VALUE
            };
            var corners, scale = 1;
            corners = [{
              x: plotLeft,
              y: plotTop,
              z: 0
            }, {
              x: plotLeft,
              y: plotTop,
              z: depth
            }];
            [0, 1].forEach(function(i) {
              corners.push({
                x: plotRight,
                y: corners[i].y,
                z: corners[i].z
              });
            });
            [0, 1, 2, 3].forEach(function(i) {
              corners.push({
                x: corners[i].x,
                y: plotBottom,
                z: corners[i].z
              });
            });
            corners = perspective$4(corners, chart, false);
            corners.forEach(function(corner) {
              bbox3d.minX = Math.min(bbox3d.minX, corner.x);
              bbox3d.maxX = Math.max(bbox3d.maxX, corner.x);
              bbox3d.minY = Math.min(bbox3d.minY, corner.y);
              bbox3d.maxY = Math.max(bbox3d.maxY, corner.y);
            });
            if (plotLeft > bbox3d.minX) {
              scale = Math.min(scale, 1 - Math.abs((plotLeft + originX) / (bbox3d.minX + originX)) % 1);
            }
            if (plotRight < bbox3d.maxX) {
              scale = Math.min(scale, (plotRight - originX) / (bbox3d.maxX - originX));
            }
            if (plotTop > bbox3d.minY) {
              if (bbox3d.minY < 0) {
                scale = Math.min(scale, (plotTop + originY) / (-bbox3d.minY + plotTop + originY));
              } else {
                scale = Math.min(scale, 1 - (plotTop + originY) / (bbox3d.minY + originY) % 1);
              }
            }
            if (plotBottom < bbox3d.maxY) {
              scale = Math.min(scale, Math.abs((plotBottom - originY) / (bbox3d.maxY - originY)));
            }
            return scale;
          };
          return Composition2;
        }()
      );
      Chart3D2.Composition = Composition;
      Chart3D2.defaultOptions = {
        chart: {
          /**
           * Options to render charts in 3 dimensions. This feature requires
           * `highcharts-3d.js`, found in the download package or online at
           * [code.highcharts.com/highcharts-3d.js](https://code.highcharts.com/highcharts-3d.js).
           *
           * @since    4.0
           * @product  highcharts
           * @requires highcharts-3d
           */
          options3d: {
            /**
             * Wether to render the chart using the 3D functionality.
             *
             * @since   4.0
             * @product highcharts
             */
            enabled: false,
            /**
             * One of the two rotation angles for the chart.
             *
             * @since   4.0
             * @product highcharts
             */
            alpha: 0,
            /**
             * One of the two rotation angles for the chart.
             *
             * @since   4.0
             * @product highcharts
             */
            beta: 0,
            /**
             * The total depth of the chart.
             *
             * @since   4.0
             * @product highcharts
             */
            depth: 100,
            /**
             * Whether the 3d box should automatically adjust to the chart
             * plot area.
             *
             * @since   4.2.4
             * @product highcharts
             */
            fitToPlot: true,
            /**
             * Defines the distance the viewer is standing in front of the
             * chart, this setting is important to calculate the perspective
             * effect in column and scatter charts. It is not used for 3D
             * pie charts.
             *
             * @since   4.0
             * @product highcharts
             */
            viewDistance: 25,
            /**
             * Set it to `"auto"` to automatically move the labels to the
             * best edge.
             *
             * @type    {"auto"|null}
             * @since   5.0.12
             * @product highcharts
             */
            axisLabelPosition: null,
            /**
             * Provides the option to draw a frame around the charts by
             * defining a bottom, front and back panel.
             *
             * @since    4.0
             * @product  highcharts
             * @requires highcharts-3d
             */
            frame: {
              /**
               * Whether the frames are visible.
               */
              visible: "default",
              /**
               * General pixel thickness for the frame faces.
               */
              size: 1,
              /**
               * The bottom of the frame around a 3D chart.
               *
               * @since    4.0
               * @product  highcharts
               * @requires highcharts-3d
               */
              /**
               * The color of the panel.
               *
               * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @default   transparent
               * @since     4.0
               * @product   highcharts
               * @apioption chart.options3d.frame.bottom.color
               */
              /**
               * The thickness of the panel.
               *
               * @type      {number}
               * @default   1
               * @since     4.0
               * @product   highcharts
               * @apioption chart.options3d.frame.bottom.size
               */
              /**
               * Whether to display the frame. Possible values are `true`,
               * `false`, `"auto"` to display only the frames behind the
               * data, and `"default"` to display faces behind the data
               * based on the axis layout, ignoring the point of view.
               *
               * @sample {highcharts} highcharts/3d/scatter-frame/
               *         Auto frames
               *
               * @type      {boolean|"default"|"auto"}
               * @default   default
               * @since     5.0.12
               * @product   highcharts
               * @apioption chart.options3d.frame.bottom.visible
               */
              /**
               * The bottom of the frame around a 3D chart.
               */
              bottom: {},
              /**
               * The top of the frame around a 3D chart.
               *
               * @extends chart.options3d.frame.bottom
               */
              top: {},
              /**
               * The left side of the frame around a 3D chart.
               *
               * @extends chart.options3d.frame.bottom
               */
              left: {},
              /**
               * The right of the frame around a 3D chart.
               *
               * @extends chart.options3d.frame.bottom
               */
              right: {},
              /**
               * The back side of the frame around a 3D chart.
               *
               * @extends chart.options3d.frame.bottom
               */
              back: {},
              /**
               * The front of the frame around a 3D chart.
               *
               * @extends chart.options3d.frame.bottom
               */
              front: {}
            }
          }
        }
      };
      function compose(ChartClass, FxClass) {
        var chartProto2 = ChartClass.prototype;
        var fxProto = FxClass.prototype;
        chartProto2.is3d = function() {
          return Boolean(this.options.chart.options3d && this.options.chart.options3d.enabled);
        };
        chartProto2.propsRequireDirtyBox.push("chart.options3d");
        chartProto2.propsRequireUpdateSeries.push("chart.options3d");
        fxProto.matrixSetter = function() {
          var interpolated;
          if (this.pos < 1 && (isArray$3(this.start) || isArray$3(this.end))) {
            var start = this.start || [1, 0, 0, 1, 0, 0], end = this.end || [1, 0, 0, 1, 0, 0];
            interpolated = [];
            for (var i = 0; i < 6; i++) {
              interpolated.push(this.pos * end[i] + (1 - this.pos) * start[i]);
            }
          } else {
            interpolated = this.end;
          }
          this.elem.attr(this.prop, interpolated, null, true);
        };
        merge$n(true, genericDefaultOptions, Chart3D2.defaultOptions);
        addEvent$h(ChartClass, "init", onInit);
        addEvent$h(ChartClass, "addSeries", onAddSeries);
        addEvent$h(ChartClass, "afterDrawChartBox", onAfterDrawChartBox);
        addEvent$h(ChartClass, "afterGetContainer", onAfterGetContainer);
        addEvent$h(ChartClass, "afterInit", onAfterInit);
        addEvent$h(ChartClass, "afterSetChartSize", onAfterSetChartSize);
        addEvent$h(ChartClass, "beforeRedraw", onBeforeRedraw);
        addEvent$h(ChartClass, "beforeRender", onBeforeRender);
        wrap$5(chartProto2, "isInsidePlot", wrapIsInsidePlot);
        wrap$5(ChartClass, "renderSeries", wrapRenderSeries);
        wrap$5(ChartClass, "setClassName", wrapSetClassName);
      }
      Chart3D2.compose = compose;
      function onAddSeries(e2) {
        if (this.is3d()) {
          if (e2.options.type === "scatter") {
            e2.options.type = "scatter3d";
          }
        }
      }
      function onAfterDrawChartBox() {
        if (this.chart3d && this.is3d()) {
          var chart = this, renderer = chart.renderer, options3d = chart.options.chart.options3d, frame = chart.chart3d.get3dFrame(), xm = chart.plotLeft, xp = chart.plotLeft + chart.plotWidth, ym = chart.plotTop, yp = chart.plotTop + chart.plotHeight, zm = 0, zp = options3d.depth, xmm = xm - (frame.left.visible ? frame.left.size : 0), xpp = xp + (frame.right.visible ? frame.right.size : 0), ymm = ym - (frame.top.visible ? frame.top.size : 0), ypp = yp + (frame.bottom.visible ? frame.bottom.size : 0), zmm = zm - (frame.front.visible ? frame.front.size : 0), zpp = zp + (frame.back.visible ? frame.back.size : 0), verb = chart.hasRendered ? "animate" : "attr";
          chart.chart3d.frame3d = frame;
          if (!chart.frameShapes) {
            chart.frameShapes = {
              bottom: renderer.polyhedron().add(),
              top: renderer.polyhedron().add(),
              left: renderer.polyhedron().add(),
              right: renderer.polyhedron().add(),
              back: renderer.polyhedron().add(),
              front: renderer.polyhedron().add()
            };
          }
          chart.frameShapes.bottom[verb]({
            "class": "highcharts-3d-frame highcharts-3d-frame-bottom",
            zIndex: frame.bottom.frontFacing ? -1e3 : 1e3,
            faces: [
              {
                fill: color$5(frame.bottom.color).brighten(0.1).get(),
                vertexes: [{
                  x: xmm,
                  y: ypp,
                  z: zmm
                }, {
                  x: xpp,
                  y: ypp,
                  z: zmm
                }, {
                  x: xpp,
                  y: ypp,
                  z: zpp
                }, {
                  x: xmm,
                  y: ypp,
                  z: zpp
                }],
                enabled: frame.bottom.visible
              },
              {
                fill: color$5(frame.bottom.color).brighten(0.1).get(),
                vertexes: [{
                  x: xm,
                  y: yp,
                  z: zp
                }, {
                  x: xp,
                  y: yp,
                  z: zp
                }, {
                  x: xp,
                  y: yp,
                  z: zm
                }, {
                  x: xm,
                  y: yp,
                  z: zm
                }],
                enabled: frame.bottom.visible
              },
              {
                fill: color$5(frame.bottom.color).brighten(-0.1).get(),
                vertexes: [{
                  x: xmm,
                  y: ypp,
                  z: zmm
                }, {
                  x: xmm,
                  y: ypp,
                  z: zpp
                }, {
                  x: xm,
                  y: yp,
                  z: zp
                }, {
                  x: xm,
                  y: yp,
                  z: zm
                }],
                enabled: frame.bottom.visible && !frame.left.visible
              },
              {
                fill: color$5(frame.bottom.color).brighten(-0.1).get(),
                vertexes: [{
                  x: xpp,
                  y: ypp,
                  z: zpp
                }, {
                  x: xpp,
                  y: ypp,
                  z: zmm
                }, {
                  x: xp,
                  y: yp,
                  z: zm
                }, {
                  x: xp,
                  y: yp,
                  z: zp
                }],
                enabled: frame.bottom.visible && !frame.right.visible
              },
              {
                fill: color$5(frame.bottom.color).get(),
                vertexes: [{
                  x: xpp,
                  y: ypp,
                  z: zmm
                }, {
                  x: xmm,
                  y: ypp,
                  z: zmm
                }, {
                  x: xm,
                  y: yp,
                  z: zm
                }, {
                  x: xp,
                  y: yp,
                  z: zm
                }],
                enabled: frame.bottom.visible && !frame.front.visible
              },
              {
                fill: color$5(frame.bottom.color).get(),
                vertexes: [{
                  x: xmm,
                  y: ypp,
                  z: zpp
                }, {
                  x: xpp,
                  y: ypp,
                  z: zpp
                }, {
                  x: xp,
                  y: yp,
                  z: zp
                }, {
                  x: xm,
                  y: yp,
                  z: zp
                }],
                enabled: frame.bottom.visible && !frame.back.visible
              }
            ]
          });
          chart.frameShapes.top[verb]({
            "class": "highcharts-3d-frame highcharts-3d-frame-top",
            zIndex: frame.top.frontFacing ? -1e3 : 1e3,
            faces: [
              {
                fill: color$5(frame.top.color).brighten(0.1).get(),
                vertexes: [{
                  x: xmm,
                  y: ymm,
                  z: zpp
                }, {
                  x: xpp,
                  y: ymm,
                  z: zpp
                }, {
                  x: xpp,
                  y: ymm,
                  z: zmm
                }, {
                  x: xmm,
                  y: ymm,
                  z: zmm
                }],
                enabled: frame.top.visible
              },
              {
                fill: color$5(frame.top.color).brighten(0.1).get(),
                vertexes: [{
                  x: xm,
                  y: ym,
                  z: zm
                }, {
                  x: xp,
                  y: ym,
                  z: zm
                }, {
                  x: xp,
                  y: ym,
                  z: zp
                }, {
                  x: xm,
                  y: ym,
                  z: zp
                }],
                enabled: frame.top.visible
              },
              {
                fill: color$5(frame.top.color).brighten(-0.1).get(),
                vertexes: [{
                  x: xmm,
                  y: ymm,
                  z: zpp
                }, {
                  x: xmm,
                  y: ymm,
                  z: zmm
                }, {
                  x: xm,
                  y: ym,
                  z: zm
                }, {
                  x: xm,
                  y: ym,
                  z: zp
                }],
                enabled: frame.top.visible && !frame.left.visible
              },
              {
                fill: color$5(frame.top.color).brighten(-0.1).get(),
                vertexes: [{
                  x: xpp,
                  y: ymm,
                  z: zmm
                }, {
                  x: xpp,
                  y: ymm,
                  z: zpp
                }, {
                  x: xp,
                  y: ym,
                  z: zp
                }, {
                  x: xp,
                  y: ym,
                  z: zm
                }],
                enabled: frame.top.visible && !frame.right.visible
              },
              {
                fill: color$5(frame.top.color).get(),
                vertexes: [{
                  x: xmm,
                  y: ymm,
                  z: zmm
                }, {
                  x: xpp,
                  y: ymm,
                  z: zmm
                }, {
                  x: xp,
                  y: ym,
                  z: zm
                }, {
                  x: xm,
                  y: ym,
                  z: zm
                }],
                enabled: frame.top.visible && !frame.front.visible
              },
              {
                fill: color$5(frame.top.color).get(),
                vertexes: [{
                  x: xpp,
                  y: ymm,
                  z: zpp
                }, {
                  x: xmm,
                  y: ymm,
                  z: zpp
                }, {
                  x: xm,
                  y: ym,
                  z: zp
                }, {
                  x: xp,
                  y: ym,
                  z: zp
                }],
                enabled: frame.top.visible && !frame.back.visible
              }
            ]
          });
          chart.frameShapes.left[verb]({
            "class": "highcharts-3d-frame highcharts-3d-frame-left",
            zIndex: frame.left.frontFacing ? -1e3 : 1e3,
            faces: [
              {
                fill: color$5(frame.left.color).brighten(0.1).get(),
                vertexes: [{
                  x: xmm,
                  y: ypp,
                  z: zmm
                }, {
                  x: xm,
                  y: yp,
                  z: zm
                }, {
                  x: xm,
                  y: yp,
                  z: zp
                }, {
                  x: xmm,
                  y: ypp,
                  z: zpp
                }],
                enabled: frame.left.visible && !frame.bottom.visible
              },
              {
                fill: color$5(frame.left.color).brighten(0.1).get(),
                vertexes: [{
                  x: xmm,
                  y: ymm,
                  z: zpp
                }, {
                  x: xm,
                  y: ym,
                  z: zp
                }, {
                  x: xm,
                  y: ym,
                  z: zm
                }, {
                  x: xmm,
                  y: ymm,
                  z: zmm
                }],
                enabled: frame.left.visible && !frame.top.visible
              },
              {
                fill: color$5(frame.left.color).brighten(-0.1).get(),
                vertexes: [{
                  x: xmm,
                  y: ypp,
                  z: zpp
                }, {
                  x: xmm,
                  y: ymm,
                  z: zpp
                }, {
                  x: xmm,
                  y: ymm,
                  z: zmm
                }, {
                  x: xmm,
                  y: ypp,
                  z: zmm
                }],
                enabled: frame.left.visible
              },
              {
                fill: color$5(frame.left.color).brighten(-0.1).get(),
                vertexes: [{
                  x: xm,
                  y: ym,
                  z: zp
                }, {
                  x: xm,
                  y: yp,
                  z: zp
                }, {
                  x: xm,
                  y: yp,
                  z: zm
                }, {
                  x: xm,
                  y: ym,
                  z: zm
                }],
                enabled: frame.left.visible
              },
              {
                fill: color$5(frame.left.color).get(),
                vertexes: [{
                  x: xmm,
                  y: ypp,
                  z: zmm
                }, {
                  x: xmm,
                  y: ymm,
                  z: zmm
                }, {
                  x: xm,
                  y: ym,
                  z: zm
                }, {
                  x: xm,
                  y: yp,
                  z: zm
                }],
                enabled: frame.left.visible && !frame.front.visible
              },
              {
                fill: color$5(frame.left.color).get(),
                vertexes: [{
                  x: xmm,
                  y: ymm,
                  z: zpp
                }, {
                  x: xmm,
                  y: ypp,
                  z: zpp
                }, {
                  x: xm,
                  y: yp,
                  z: zp
                }, {
                  x: xm,
                  y: ym,
                  z: zp
                }],
                enabled: frame.left.visible && !frame.back.visible
              }
            ]
          });
          chart.frameShapes.right[verb]({
            "class": "highcharts-3d-frame highcharts-3d-frame-right",
            zIndex: frame.right.frontFacing ? -1e3 : 1e3,
            faces: [
              {
                fill: color$5(frame.right.color).brighten(0.1).get(),
                vertexes: [{
                  x: xpp,
                  y: ypp,
                  z: zpp
                }, {
                  x: xp,
                  y: yp,
                  z: zp
                }, {
                  x: xp,
                  y: yp,
                  z: zm
                }, {
                  x: xpp,
                  y: ypp,
                  z: zmm
                }],
                enabled: frame.right.visible && !frame.bottom.visible
              },
              {
                fill: color$5(frame.right.color).brighten(0.1).get(),
                vertexes: [{
                  x: xpp,
                  y: ymm,
                  z: zmm
                }, {
                  x: xp,
                  y: ym,
                  z: zm
                }, {
                  x: xp,
                  y: ym,
                  z: zp
                }, {
                  x: xpp,
                  y: ymm,
                  z: zpp
                }],
                enabled: frame.right.visible && !frame.top.visible
              },
              {
                fill: color$5(frame.right.color).brighten(-0.1).get(),
                vertexes: [{
                  x: xp,
                  y: ym,
                  z: zm
                }, {
                  x: xp,
                  y: yp,
                  z: zm
                }, {
                  x: xp,
                  y: yp,
                  z: zp
                }, {
                  x: xp,
                  y: ym,
                  z: zp
                }],
                enabled: frame.right.visible
              },
              {
                fill: color$5(frame.right.color).brighten(-0.1).get(),
                vertexes: [{
                  x: xpp,
                  y: ypp,
                  z: zmm
                }, {
                  x: xpp,
                  y: ymm,
                  z: zmm
                }, {
                  x: xpp,
                  y: ymm,
                  z: zpp
                }, {
                  x: xpp,
                  y: ypp,
                  z: zpp
                }],
                enabled: frame.right.visible
              },
              {
                fill: color$5(frame.right.color).get(),
                vertexes: [{
                  x: xpp,
                  y: ymm,
                  z: zmm
                }, {
                  x: xpp,
                  y: ypp,
                  z: zmm
                }, {
                  x: xp,
                  y: yp,
                  z: zm
                }, {
                  x: xp,
                  y: ym,
                  z: zm
                }],
                enabled: frame.right.visible && !frame.front.visible
              },
              {
                fill: color$5(frame.right.color).get(),
                vertexes: [{
                  x: xpp,
                  y: ypp,
                  z: zpp
                }, {
                  x: xpp,
                  y: ymm,
                  z: zpp
                }, {
                  x: xp,
                  y: ym,
                  z: zp
                }, {
                  x: xp,
                  y: yp,
                  z: zp
                }],
                enabled: frame.right.visible && !frame.back.visible
              }
            ]
          });
          chart.frameShapes.back[verb]({
            "class": "highcharts-3d-frame highcharts-3d-frame-back",
            zIndex: frame.back.frontFacing ? -1e3 : 1e3,
            faces: [
              {
                fill: color$5(frame.back.color).brighten(0.1).get(),
                vertexes: [{
                  x: xpp,
                  y: ypp,
                  z: zpp
                }, {
                  x: xmm,
                  y: ypp,
                  z: zpp
                }, {
                  x: xm,
                  y: yp,
                  z: zp
                }, {
                  x: xp,
                  y: yp,
                  z: zp
                }],
                enabled: frame.back.visible && !frame.bottom.visible
              },
              {
                fill: color$5(frame.back.color).brighten(0.1).get(),
                vertexes: [{
                  x: xmm,
                  y: ymm,
                  z: zpp
                }, {
                  x: xpp,
                  y: ymm,
                  z: zpp
                }, {
                  x: xp,
                  y: ym,
                  z: zp
                }, {
                  x: xm,
                  y: ym,
                  z: zp
                }],
                enabled: frame.back.visible && !frame.top.visible
              },
              {
                fill: color$5(frame.back.color).brighten(-0.1).get(),
                vertexes: [{
                  x: xmm,
                  y: ypp,
                  z: zpp
                }, {
                  x: xmm,
                  y: ymm,
                  z: zpp
                }, {
                  x: xm,
                  y: ym,
                  z: zp
                }, {
                  x: xm,
                  y: yp,
                  z: zp
                }],
                enabled: frame.back.visible && !frame.left.visible
              },
              {
                fill: color$5(frame.back.color).brighten(-0.1).get(),
                vertexes: [{
                  x: xpp,
                  y: ymm,
                  z: zpp
                }, {
                  x: xpp,
                  y: ypp,
                  z: zpp
                }, {
                  x: xp,
                  y: yp,
                  z: zp
                }, {
                  x: xp,
                  y: ym,
                  z: zp
                }],
                enabled: frame.back.visible && !frame.right.visible
              },
              {
                fill: color$5(frame.back.color).get(),
                vertexes: [{
                  x: xm,
                  y: ym,
                  z: zp
                }, {
                  x: xp,
                  y: ym,
                  z: zp
                }, {
                  x: xp,
                  y: yp,
                  z: zp
                }, {
                  x: xm,
                  y: yp,
                  z: zp
                }],
                enabled: frame.back.visible
              },
              {
                fill: color$5(frame.back.color).get(),
                vertexes: [{
                  x: xmm,
                  y: ypp,
                  z: zpp
                }, {
                  x: xpp,
                  y: ypp,
                  z: zpp
                }, {
                  x: xpp,
                  y: ymm,
                  z: zpp
                }, {
                  x: xmm,
                  y: ymm,
                  z: zpp
                }],
                enabled: frame.back.visible
              }
            ]
          });
          chart.frameShapes.front[verb]({
            "class": "highcharts-3d-frame highcharts-3d-frame-front",
            zIndex: frame.front.frontFacing ? -1e3 : 1e3,
            faces: [
              {
                fill: color$5(frame.front.color).brighten(0.1).get(),
                vertexes: [{
                  x: xmm,
                  y: ypp,
                  z: zmm
                }, {
                  x: xpp,
                  y: ypp,
                  z: zmm
                }, {
                  x: xp,
                  y: yp,
                  z: zm
                }, {
                  x: xm,
                  y: yp,
                  z: zm
                }],
                enabled: frame.front.visible && !frame.bottom.visible
              },
              {
                fill: color$5(frame.front.color).brighten(0.1).get(),
                vertexes: [{
                  x: xpp,
                  y: ymm,
                  z: zmm
                }, {
                  x: xmm,
                  y: ymm,
                  z: zmm
                }, {
                  x: xm,
                  y: ym,
                  z: zm
                }, {
                  x: xp,
                  y: ym,
                  z: zm
                }],
                enabled: frame.front.visible && !frame.top.visible
              },
              {
                fill: color$5(frame.front.color).brighten(-0.1).get(),
                vertexes: [{
                  x: xmm,
                  y: ymm,
                  z: zmm
                }, {
                  x: xmm,
                  y: ypp,
                  z: zmm
                }, {
                  x: xm,
                  y: yp,
                  z: zm
                }, {
                  x: xm,
                  y: ym,
                  z: zm
                }],
                enabled: frame.front.visible && !frame.left.visible
              },
              {
                fill: color$5(frame.front.color).brighten(-0.1).get(),
                vertexes: [{
                  x: xpp,
                  y: ypp,
                  z: zmm
                }, {
                  x: xpp,
                  y: ymm,
                  z: zmm
                }, {
                  x: xp,
                  y: ym,
                  z: zm
                }, {
                  x: xp,
                  y: yp,
                  z: zm
                }],
                enabled: frame.front.visible && !frame.right.visible
              },
              {
                fill: color$5(frame.front.color).get(),
                vertexes: [{
                  x: xp,
                  y: ym,
                  z: zm
                }, {
                  x: xm,
                  y: ym,
                  z: zm
                }, {
                  x: xm,
                  y: yp,
                  z: zm
                }, {
                  x: xp,
                  y: yp,
                  z: zm
                }],
                enabled: frame.front.visible
              },
              {
                fill: color$5(frame.front.color).get(),
                vertexes: [{
                  x: xpp,
                  y: ypp,
                  z: zmm
                }, {
                  x: xmm,
                  y: ypp,
                  z: zmm
                }, {
                  x: xmm,
                  y: ymm,
                  z: zmm
                }, {
                  x: xpp,
                  y: ymm,
                  z: zmm
                }],
                enabled: frame.front.visible
              }
            ]
          });
        }
      }
      function onAfterGetContainer() {
        if (this.styledMode) {
          this.renderer.definition({
            tagName: "style",
            textContent: ".highcharts-3d-top{filter: url(#highcharts-brighter)}\n.highcharts-3d-side{filter: url(#highcharts-darker)}\n"
          });
          [{
            name: "darker",
            slope: 0.6
          }, {
            name: "brighter",
            slope: 1.4
          }].forEach(function(cfg) {
            this.renderer.definition({
              tagName: "filter",
              attributes: {
                id: "highcharts-" + cfg.name
              },
              children: [{
                tagName: "feComponentTransfer",
                children: [{
                  tagName: "feFuncR",
                  attributes: {
                    type: "linear",
                    slope: cfg.slope
                  }
                }, {
                  tagName: "feFuncG",
                  attributes: {
                    type: "linear",
                    slope: cfg.slope
                  }
                }, {
                  tagName: "feFuncB",
                  attributes: {
                    type: "linear",
                    slope: cfg.slope
                  }
                }]
              }]
            });
          }, this);
        }
      }
      function onAfterInit() {
        var options = this.options;
        if (this.is3d()) {
          (options.series || []).forEach(function(s) {
            var type = s.type || options.chart.type || options.chart.defaultSeriesType;
            if (type === "scatter") {
              s.type = "scatter3d";
            }
          });
        }
      }
      function onAfterSetChartSize() {
        var chart = this, options3d = chart.options.chart.options3d;
        if (chart.chart3d && chart.is3d()) {
          if (options3d) {
            options3d.alpha = options3d.alpha % 360 + (options3d.alpha >= 0 ? 0 : 360);
            options3d.beta = options3d.beta % 360 + (options3d.beta >= 0 ? 0 : 360);
          }
          var inverted = chart.inverted, clipBox = chart.clipBox, margin = chart.margin, x = inverted ? "y" : "x", y = inverted ? "x" : "y", w2 = inverted ? "height" : "width", h = inverted ? "width" : "height";
          clipBox[x] = -(margin[3] || 0);
          clipBox[y] = -(margin[0] || 0);
          clipBox[w2] = chart.chartWidth + (margin[3] || 0) + (margin[1] || 0);
          clipBox[h] = chart.chartHeight + (margin[0] || 0) + (margin[2] || 0);
          chart.scale3d = 1;
          if (options3d.fitToPlot === true) {
            chart.scale3d = chart.chart3d.getScale(options3d.depth);
          }
          chart.chart3d.frame3d = chart.chart3d.get3dFrame();
        }
      }
      function onBeforeRedraw() {
        if (this.is3d()) {
          this.isDirtyBox = true;
        }
      }
      function onBeforeRender() {
        if (this.chart3d && this.is3d()) {
          this.chart3d.frame3d = this.chart3d.get3dFrame();
        }
      }
      function onInit() {
        if (!this.chart3d) {
          this.chart3d = new Composition(this);
        }
      }
      function wrapIsInsidePlot(proceed) {
        return this.is3d() || proceed.apply(this, [].slice.call(arguments, 1));
      }
      function wrapRenderSeries(proceed) {
        var series, i = this.series.length;
        if (this.is3d()) {
          while (i--) {
            series = this.series[i];
            series.translate();
            series.render();
          }
        } else {
          proceed.call(this);
        }
      }
      function wrapSetClassName(proceed) {
        proceed.apply(this, [].slice.call(arguments, 1));
        if (this.is3d()) {
          this.container.className += " highcharts-3d-chart";
        }
      }
    })(Chart3D || (Chart3D = {}));
    const Chart3D$1 = Chart3D;
    var __extends$n = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var addEvent$g = Utilities.addEvent, merge$m = Utilities.merge, pick$p = Utilities.pick, splat$2 = Utilities.splat;
    var ZChart = (
      /** @class */
      function() {
        function ZChart2() {
        }
        ZChart2.compose = function(ChartClass) {
          addEvent$g(ChartClass, "afterGetAxes", ZChart2.onAfterGetAxes);
          var chartProto2 = ChartClass.prototype;
          chartProto2.addZAxis = ZChart2.wrapAddZAxis;
          chartProto2.collectionsWithInit.zAxis = [chartProto2.addZAxis];
          chartProto2.collectionsWithUpdate.push("zAxis");
        };
        ZChart2.onAfterGetAxes = function() {
          var chart = this;
          var options = this.options;
          var zAxisOptions = options.zAxis = splat$2(options.zAxis || {});
          if (!chart.is3d()) {
            return;
          }
          chart.zAxis = [];
          zAxisOptions.forEach(function(axisOptions, i) {
            axisOptions.index = i;
            axisOptions.isX = true;
            chart.addZAxis(axisOptions).setScale();
          });
        };
        ZChart2.wrapAddZAxis = function(options) {
          return new ZAxis(this, options);
        };
        return ZChart2;
      }()
    );
    var ZAxis = (
      /** @class */
      function(_super) {
        __extends$n(ZAxis2, _super);
        function ZAxis2(chart, userOptions) {
          var _this = _super.call(this, chart, userOptions) || this;
          _this.isZAxis = true;
          return _this;
        }
        ZAxis2.prototype.getSeriesExtremes = function() {
          var axis = this;
          var chart = axis.chart;
          axis.hasVisibleSeries = false;
          axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = void 0;
          if (axis.stacking) {
            axis.stacking.buildStacks();
          }
          axis.series.forEach(function(series) {
            if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
              var seriesOptions = series.options, zData = void 0, threshold = seriesOptions.threshold;
              axis.hasVisibleSeries = true;
              if (axis.positiveValuesOnly && threshold <= 0) {
                threshold = void 0;
              }
              zData = series.zData;
              if (zData.length) {
                axis.dataMin = Math.min(pick$p(axis.dataMin, zData[0]), Math.min.apply(null, zData));
                axis.dataMax = Math.max(pick$p(axis.dataMax, zData[0]), Math.max.apply(null, zData));
              }
            }
          });
        };
        ZAxis2.prototype.setAxisSize = function() {
          var axis = this;
          var chart = axis.chart;
          _super.prototype.setAxisSize.call(this);
          axis.width = axis.len = chart.options.chart.options3d && chart.options.chart.options3d.depth || 0;
          axis.right = chart.chartWidth - axis.width - axis.left;
        };
        ZAxis2.prototype.setOptions = function(userOptions) {
          userOptions = merge$m({
            offset: 0,
            lineWidth: 0
          }, userOptions);
          this.isZAxis = true;
          _super.prototype.setOptions.call(this, userOptions);
          this.coll = "zAxis";
        };
        ZAxis2.ZChartComposition = ZChart;
        return ZAxis2;
      }(Axis)
    );
    var addEvent$f = Utilities.addEvent, extend$q = Utilities.extend, wrap$4 = Utilities.wrap;
    var Tick3D = (
      /** @class */
      function() {
        function Tick3D2() {
        }
        Tick3D2.compose = function(TickClass) {
          addEvent$f(TickClass, "afterGetLabelPosition", Tick3D2.onAfterGetLabelPosition);
          var tickProto = TickClass.prototype;
          wrap$4(tickProto, "getMarkPath", Tick3D2.wrapGetMarkPath);
        };
        Tick3D2.onAfterGetLabelPosition = function(e2) {
          var axis3D = this.axis.axis3D;
          if (axis3D) {
            extend$q(e2.pos, axis3D.fix3dPosition(e2.pos));
          }
        };
        Tick3D2.wrapGetMarkPath = function(proceed) {
          this.axis.chart;
          var axis3D = this.axis.axis3D;
          var path = proceed.apply(this, [].slice.call(arguments, 1));
          if (axis3D) {
            var start = path[0];
            var end = path[1];
            if (start[0] === "M" && end[0] === "L") {
              var pArr = [
                axis3D.fix3dPosition({ x: start[1], y: start[2], z: 0 }),
                axis3D.fix3dPosition({ x: end[1], y: end[2], z: 0 })
              ];
              return this.axis.chart.renderer.toLineSegments(pArr);
            }
          }
          return path;
        };
        return Tick3D2;
      }()
    );
    var deg2rad$1 = H.deg2rad;
    var perspective$3 = mathModule.perspective, perspective3D = mathModule.perspective3D, shapeArea = mathModule.shapeArea;
    var addEvent$e = Utilities.addEvent, merge$l = Utilities.merge, pick$o = Utilities.pick, wrap$3 = Utilities.wrap;
    var Axis3DAdditions = (
      /** @class */
      function() {
        function Axis3DAdditions2(axis) {
          this.axis = axis;
        }
        Axis3DAdditions2.prototype.fix3dPosition = function(pos, isTitle) {
          var axis3D = this;
          var axis = axis3D.axis;
          var chart = axis.chart;
          if (axis.coll === "colorAxis" || !chart.chart3d || !chart.is3d()) {
            return pos;
          }
          var alpha = deg2rad$1 * chart.options.chart.options3d.alpha, beta = deg2rad$1 * chart.options.chart.options3d.beta, positionMode = pick$o(isTitle && axis.options.title.position3d, axis.options.labels.position3d), skew = pick$o(isTitle && axis.options.title.skew3d, axis.options.labels.skew3d), frame = chart.chart3d.frame3d, plotLeft = chart.plotLeft, plotRight = chart.plotWidth + plotLeft, plotTop = chart.plotTop, plotBottom = chart.plotHeight + plotTop;
          var offsetX = 0, offsetY = 0, vecX, vecY = { x: 0, y: 1, z: 0 }, reverseFlap = false;
          pos = axis.axis3D.swapZ({ x: pos.x, y: pos.y, z: 0 });
          if (axis.isZAxis) {
            if (axis.opposite) {
              if (frame.axes.z.top === null) {
                return {};
              }
              offsetY = pos.y - plotTop;
              pos.x = frame.axes.z.top.x;
              pos.y = frame.axes.z.top.y;
              vecX = frame.axes.z.top.xDir;
              reverseFlap = !frame.top.frontFacing;
            } else {
              if (frame.axes.z.bottom === null) {
                return {};
              }
              offsetY = pos.y - plotBottom;
              pos.x = frame.axes.z.bottom.x;
              pos.y = frame.axes.z.bottom.y;
              vecX = frame.axes.z.bottom.xDir;
              reverseFlap = !frame.bottom.frontFacing;
            }
          } else if (axis.horiz) {
            if (axis.opposite) {
              if (frame.axes.x.top === null) {
                return {};
              }
              offsetY = pos.y - plotTop;
              pos.y = frame.axes.x.top.y;
              pos.z = frame.axes.x.top.z;
              vecX = frame.axes.x.top.xDir;
              reverseFlap = !frame.top.frontFacing;
            } else {
              if (frame.axes.x.bottom === null) {
                return {};
              }
              offsetY = pos.y - plotBottom;
              pos.y = frame.axes.x.bottom.y;
              pos.z = frame.axes.x.bottom.z;
              vecX = frame.axes.x.bottom.xDir;
              reverseFlap = !frame.bottom.frontFacing;
            }
          } else {
            if (axis.opposite) {
              if (frame.axes.y.right === null) {
                return {};
              }
              offsetX = pos.x - plotRight;
              pos.x = frame.axes.y.right.x;
              pos.z = frame.axes.y.right.z;
              vecX = frame.axes.y.right.xDir;
              vecX = { x: vecX.z, y: vecX.y, z: -vecX.x };
            } else {
              if (frame.axes.y.left === null) {
                return {};
              }
              offsetX = pos.x - plotLeft;
              pos.x = frame.axes.y.left.x;
              pos.z = frame.axes.y.left.z;
              vecX = frame.axes.y.left.xDir;
            }
          }
          if (positionMode === "chart") ;
          else if (positionMode === "flap") {
            if (!axis.horiz) {
              vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };
            } else {
              var sin2 = Math.sin(alpha);
              var cos2 = Math.cos(alpha);
              if (axis.opposite) {
                sin2 = -sin2;
              }
              if (reverseFlap) {
                sin2 = -sin2;
              }
              vecY = { x: vecX.z * sin2, y: cos2, z: -vecX.x * sin2 };
            }
          } else if (positionMode === "ortho") {
            if (!axis.horiz) {
              vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };
            } else {
              var sina = Math.sin(alpha);
              var cosa = Math.cos(alpha);
              var sinb = Math.sin(beta);
              var cosb = Math.cos(beta);
              var vecZ = { x: sinb * cosa, y: -sina, z: -cosa * cosb };
              vecY = {
                x: vecX.y * vecZ.z - vecX.z * vecZ.y,
                y: vecX.z * vecZ.x - vecX.x * vecZ.z,
                z: vecX.x * vecZ.y - vecX.y * vecZ.x
              };
              var scale = 1 / Math.sqrt(vecY.x * vecY.x + vecY.y * vecY.y + vecY.z * vecY.z);
              if (reverseFlap) {
                scale = -scale;
              }
              vecY = { x: scale * vecY.x, y: scale * vecY.y, z: scale * vecY.z };
            }
          } else {
            if (!axis.horiz) {
              vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };
            } else {
              vecY = {
                x: Math.sin(beta) * Math.sin(alpha),
                y: Math.cos(alpha),
                z: -Math.cos(beta) * Math.sin(alpha)
              };
            }
          }
          pos.x += offsetX * vecX.x + offsetY * vecY.x;
          pos.y += offsetX * vecX.y + offsetY * vecY.y;
          pos.z += offsetX * vecX.z + offsetY * vecY.z;
          var projected = perspective$3([pos], axis.chart)[0];
          if (skew) {
            var isMirrored = shapeArea(perspective$3([
              pos,
              { x: pos.x + vecX.x, y: pos.y + vecX.y, z: pos.z + vecX.z },
              { x: pos.x + vecY.x, y: pos.y + vecY.y, z: pos.z + vecY.z }
            ], axis.chart)) < 0;
            if (isMirrored) {
              vecX = { x: -vecX.x, y: -vecX.y, z: -vecX.z };
            }
            var pointsProjected = perspective$3([
              { x: pos.x, y: pos.y, z: pos.z },
              { x: pos.x + vecX.x, y: pos.y + vecX.y, z: pos.z + vecX.z },
              { x: pos.x + vecY.x, y: pos.y + vecY.y, z: pos.z + vecY.z }
            ], axis.chart);
            projected.matrix = [
              pointsProjected[1].x - pointsProjected[0].x,
              pointsProjected[1].y - pointsProjected[0].y,
              pointsProjected[2].x - pointsProjected[0].x,
              pointsProjected[2].y - pointsProjected[0].y,
              projected.x,
              projected.y
            ];
            projected.matrix[4] -= projected.x * projected.matrix[0] + projected.y * projected.matrix[2];
            projected.matrix[5] -= projected.x * projected.matrix[1] + projected.y * projected.matrix[3];
          }
          return projected;
        };
        Axis3DAdditions2.prototype.swapZ = function(p, insidePlotArea) {
          var axis = this.axis;
          if (axis.isZAxis) {
            var plotLeft = insidePlotArea ? 0 : axis.chart.plotLeft;
            return {
              x: plotLeft + p.z,
              y: p.y,
              z: p.x - plotLeft
            };
          }
          return p;
        };
        return Axis3DAdditions2;
      }()
    );
    var Axis3D = (
      /** @class */
      function() {
        function Axis3D2() {
        }
        Axis3D2.compose = function(AxisClass) {
          merge$l(true, AxisClass.defaultOptions, Axis3D2.defaultOptions);
          AxisClass.keepProps.push("axis3D");
          addEvent$e(AxisClass, "init", Axis3D2.onInit);
          addEvent$e(AxisClass, "afterSetOptions", Axis3D2.onAfterSetOptions);
          addEvent$e(AxisClass, "drawCrosshair", Axis3D2.onDrawCrosshair);
          var axisProto = AxisClass.prototype;
          wrap$3(axisProto, "getLinePath", Axis3D2.wrapGetLinePath);
          wrap$3(axisProto, "getPlotBandPath", Axis3D2.wrapGetPlotBandPath);
          wrap$3(axisProto, "getPlotLinePath", Axis3D2.wrapGetPlotLinePath);
          wrap$3(axisProto, "getSlotWidth", Axis3D2.wrapGetSlotWidth);
          wrap$3(axisProto, "getTitlePosition", Axis3D2.wrapGetTitlePosition);
          Tick3D.compose(Tick);
        };
        Axis3D2.onAfterSetOptions = function() {
          var axis = this;
          var chart = axis.chart;
          var options = axis.options;
          if (chart.is3d && chart.is3d() && axis.coll !== "colorAxis") {
            options.tickWidth = pick$o(options.tickWidth, 0);
            options.gridLineWidth = pick$o(options.gridLineWidth, 1);
          }
        };
        Axis3D2.onDrawCrosshair = function(e2) {
          var axis = this;
          if (axis.chart.is3d() && axis.coll !== "colorAxis") {
            if (e2.point) {
              e2.point.crosshairPos = axis.isXAxis ? e2.point.axisXpos : axis.len - e2.point.axisYpos;
            }
          }
        };
        Axis3D2.onInit = function() {
          var axis = this;
          if (!axis.axis3D) {
            axis.axis3D = new Axis3DAdditions(axis);
          }
        };
        Axis3D2.wrapGetLinePath = function(proceed) {
          var axis = this;
          if (!axis.chart.is3d() || axis.coll === "colorAxis") {
            return proceed.apply(axis, [].slice.call(arguments, 1));
          }
          return [];
        };
        Axis3D2.wrapGetPlotBandPath = function(proceed) {
          if (!this.chart.is3d() || this.coll === "colorAxis") {
            return proceed.apply(this, [].slice.call(arguments, 1));
          }
          var args = arguments, from = args[1], to = args[2], path = [], fromPath = this.getPlotLinePath({ value: from }), toPath = this.getPlotLinePath({ value: to });
          if (fromPath && toPath) {
            for (var i = 0; i < fromPath.length; i += 2) {
              var fromStartSeg = fromPath[i], fromEndSeg = fromPath[i + 1], toStartSeg = toPath[i], toEndSeg = toPath[i + 1];
              if (fromStartSeg[0] === "M" && fromEndSeg[0] === "L" && toStartSeg[0] === "M" && toEndSeg[0] === "L") {
                path.push(
                  fromStartSeg,
                  fromEndSeg,
                  toEndSeg,
                  // lineTo instead of moveTo
                  ["L", toStartSeg[1], toStartSeg[2]],
                  ["Z"]
                );
              }
            }
          }
          return path;
        };
        Axis3D2.wrapGetPlotLinePath = function(proceed) {
          var axis = this, axis3D = axis.axis3D, chart = axis.chart, path = proceed.apply(axis, [].slice.call(arguments, 1));
          if (axis.coll === "colorAxis" || !chart.chart3d || !chart.is3d()) {
            return path;
          }
          if (path === null) {
            return path;
          }
          var options3d = chart.options.chart.options3d, d = axis.isZAxis ? chart.plotWidth : options3d.depth, frame = chart.chart3d.frame3d, startSegment = path[0], endSegment = path[1];
          var pArr, pathSegments = [];
          if (startSegment[0] === "M" && endSegment[0] === "L") {
            pArr = [
              axis3D.swapZ({ x: startSegment[1], y: startSegment[2], z: 0 }),
              axis3D.swapZ({ x: startSegment[1], y: startSegment[2], z: d }),
              axis3D.swapZ({ x: endSegment[1], y: endSegment[2], z: 0 }),
              axis3D.swapZ({ x: endSegment[1], y: endSegment[2], z: d })
            ];
            if (!this.horiz) {
              if (frame.front.visible) {
                pathSegments.push(pArr[0], pArr[2]);
              }
              if (frame.back.visible) {
                pathSegments.push(pArr[1], pArr[3]);
              }
              if (frame.left.visible) {
                pathSegments.push(pArr[0], pArr[1]);
              }
              if (frame.right.visible) {
                pathSegments.push(pArr[2], pArr[3]);
              }
            } else if (this.isZAxis) {
              if (frame.left.visible) {
                pathSegments.push(pArr[0], pArr[2]);
              }
              if (frame.right.visible) {
                pathSegments.push(pArr[1], pArr[3]);
              }
              if (frame.top.visible) {
                pathSegments.push(pArr[0], pArr[1]);
              }
              if (frame.bottom.visible) {
                pathSegments.push(pArr[2], pArr[3]);
              }
            } else {
              if (frame.front.visible) {
                pathSegments.push(pArr[0], pArr[2]);
              }
              if (frame.back.visible) {
                pathSegments.push(pArr[1], pArr[3]);
              }
              if (frame.top.visible) {
                pathSegments.push(pArr[0], pArr[1]);
              }
              if (frame.bottom.visible) {
                pathSegments.push(pArr[2], pArr[3]);
              }
            }
            pathSegments = perspective$3(pathSegments, this.chart, false);
          }
          return chart.renderer.toLineSegments(pathSegments);
        };
        Axis3D2.wrapGetSlotWidth = function(proceed, tick) {
          var axis = this, chart = axis.chart, ticks = axis.ticks, gridGroup = axis.gridGroup;
          if (axis.categories && chart.frameShapes && chart.is3d() && gridGroup && tick && tick.label) {
            var firstGridLine = gridGroup.element.childNodes[0].getBBox(), frame3DLeft = chart.frameShapes.left.getBBox(), options3d = chart.options.chart.options3d, origin_1 = {
              x: chart.plotWidth / 2,
              y: chart.plotHeight / 2,
              z: options3d.depth / 2,
              vd: pick$o(options3d.depth, 1) * pick$o(options3d.viewDistance, 0)
            }, tickId = tick.pos, prevTick = ticks[tickId - 1], nextTick = ticks[tickId + 1];
            var labelPos = void 0, prevLabelPos = void 0, nextLabelPos = void 0;
            if (tickId !== 0 && prevTick && prevTick.label && prevTick.label.xy) {
              prevLabelPos = perspective3D({
                x: prevTick.label.xy.x,
                y: prevTick.label.xy.y,
                z: null
              }, origin_1, origin_1.vd);
            }
            if (nextTick && nextTick.label && nextTick.label.xy) {
              nextLabelPos = perspective3D({
                x: nextTick.label.xy.x,
                y: nextTick.label.xy.y,
                z: null
              }, origin_1, origin_1.vd);
            }
            labelPos = {
              x: tick.label.xy.x,
              y: tick.label.xy.y,
              z: null
            };
            labelPos = perspective3D(labelPos, origin_1, origin_1.vd);
            return Math.abs(prevLabelPos ? labelPos.x - prevLabelPos.x : nextLabelPos ? nextLabelPos.x - labelPos.x : firstGridLine.x - frame3DLeft.x);
          }
          return proceed.apply(axis, [].slice.call(arguments, 1));
        };
        Axis3D2.wrapGetTitlePosition = function(proceed) {
          var pos = proceed.apply(this, [].slice.call(arguments, 1));
          return this.axis3D ? this.axis3D.fix3dPosition(pos, true) : pos;
        };
        Axis3D2.defaultOptions = {
          labels: {
            /**
             * Defines how the labels are be repositioned according to the 3D
             * chart orientation.
             *
             * - `'offset'`: Maintain a fixed horizontal/vertical distance from
             *   the tick marks, despite the chart orientation. This is the
             *   backwards compatible behavior, and causes skewing of X and Z
             *   axes.
             *
             * - `'chart'`: Preserve 3D position relative to the chart. This
             *   looks nice, but hard to read if the text isn't forward-facing.
             *
             * - `'flap'`: Rotated text along the axis to compensate for the
             *   chart orientation. This tries to maintain text as legible as
             *   possible on all orientations.
             *
             * - `'ortho'`: Rotated text along the axis direction so that the
             *   labels are orthogonal to the axis. This is very similar to
             *   `'flap'`, but prevents skewing the labels (X and Y scaling are
             *   still present).
             *
             * @sample highcharts/3d/skewed-labels/
             *         Skewed labels
             *
             * @since      5.0.15
             * @validvalue ['offset', 'chart', 'flap', 'ortho']
             * @product    highcharts
             * @requires   highcharts-3d
             */
            position3d: "offset",
            /**
             * If enabled, the axis labels will skewed to follow the
             * perspective.
             *
             * This will fix overlapping labels and titles, but texts become
             * less legible due to the distortion.
             *
             * The final appearance depends heavily on `labels.position3d`.
             *
             * @sample highcharts/3d/skewed-labels/
             *         Skewed labels
             *
             * @since    5.0.15
             * @product  highcharts
             * @requires highcharts-3d
             */
            skew3d: false
          },
          title: {
            /**
             * Defines how the title is repositioned according to the 3D chart
             * orientation.
             *
             * - `'offset'`: Maintain a fixed horizontal/vertical distance from
             *   the tick marks, despite the chart orientation. This is the
             *   backwards compatible behavior, and causes skewing of X and Z
             *   axes.
             *
             * - `'chart'`: Preserve 3D position relative to the chart. This
             *   looks nice, but hard to read if the text isn't forward-facing.
             *
             * - `'flap'`: Rotated text along the axis to compensate for the
             *   chart orientation. This tries to maintain text as legible as
             *   possible on all orientations.
             *
             * - `'ortho'`: Rotated text along the axis direction so that the
             *   labels are orthogonal to the axis. This is very similar to
             *   `'flap'`, but prevents skewing the labels (X and Y scaling are
             *   still present).
             *
             * - `undefined`: Will use the config from `labels.position3d`
             *
             * @sample highcharts/3d/skewed-labels/
             *         Skewed labels
             *
             * @type     {"offset"|"chart"|"flap"|"ortho"|null}
             * @since    5.0.15
             * @product  highcharts
             * @requires highcharts-3d
             */
            position3d: null,
            /**
             * If enabled, the axis title will skewed to follow the perspective.
             *
             * This will fix overlapping labels and titles, but texts become
             * less legible due to the distortion.
             *
             * The final appearance depends heavily on `title.position3d`.
             *
             * A `null` value will use the config from `labels.skew3d`.
             *
             * @sample highcharts/3d/skewed-labels/
             *         Skewed labels
             *
             * @type     {boolean|null}
             * @since    5.0.15
             * @product  highcharts
             * @requires highcharts-3d
             */
            skew3d: null
          }
        };
        return Axis3D2;
      }()
    );
    var __extends$m = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var perspective$2 = mathModule.perspective;
    var addEvent$d = Utilities.addEvent, extend$p = Utilities.extend, merge$k = Utilities.merge, pick$n = Utilities.pick, isNumber$9 = Utilities.isNumber;
    var Series3D = (
      /** @class */
      function(_super) {
        __extends$m(Series3D2, _super);
        function Series3D2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        Series3D2.prototype.translate = function() {
          _super.prototype.translate.apply(this, arguments);
          if (this.chart.is3d()) {
            this.translate3dPoints();
          }
        };
        Series3D2.prototype.translate3dPoints = function() {
          var series = this, seriesOptions = series.options, chart = series.chart, zAxis = pick$n(series.zAxis, chart.options.zAxis[0]), rawPoints = [], rawPoint, projectedPoints, projectedPoint, zValue, i, rawPointsX = [], stack = seriesOptions.stacking ? isNumber$9(seriesOptions.stack) ? seriesOptions.stack : 0 : series.index || 0;
          series.zPadding = stack * (seriesOptions.depth || 0 + (seriesOptions.groupZPadding || 1));
          for (i = 0; i < series.data.length; i++) {
            rawPoint = series.data[i];
            if (zAxis && zAxis.translate) {
              zValue = zAxis.logarithmic && zAxis.val2lin ? zAxis.val2lin(rawPoint.z) : rawPoint.z;
              rawPoint.plotZ = zAxis.translate(zValue);
              rawPoint.isInside = rawPoint.isInside ? zValue >= zAxis.min && zValue <= zAxis.max : false;
            } else {
              rawPoint.plotZ = series.zPadding;
            }
            rawPoint.axisXpos = rawPoint.plotX;
            rawPoint.axisYpos = rawPoint.plotY;
            rawPoint.axisZpos = rawPoint.plotZ;
            rawPoints.push({
              x: rawPoint.plotX,
              y: rawPoint.plotY,
              z: rawPoint.plotZ
            });
            rawPointsX.push(rawPoint.plotX || 0);
          }
          series.rawPointsX = rawPointsX;
          projectedPoints = perspective$2(rawPoints, chart, true);
          for (i = 0; i < series.data.length; i++) {
            rawPoint = series.data[i];
            projectedPoint = projectedPoints[i];
            rawPoint.plotX = projectedPoint.x;
            rawPoint.plotY = projectedPoint.y;
            rawPoint.plotZ = projectedPoint.z;
          }
        };
        Series3D2.defaultOptions = merge$k(Series$e.defaultOptions);
        return Series3D2;
      }(Series$e)
    );
    addEvent$d(Series$e, "afterTranslate", function() {
      if (this.chart.is3d()) {
        this.translate3dPoints();
      }
    });
    extend$p(Series$e.prototype, {
      translate3dPoints: Series3D.prototype.translate3dPoints
    });
    var columnProto$1 = ColumnSeries$h.prototype;
    var svg$1 = H.svg;
    var perspective$1 = mathModule.perspective;
    var addEvent$c = Utilities.addEvent, pick$m = Utilities.pick, wrap$2 = Utilities.wrap;
    function retrieveStacks(chart, stacking) {
      var series = chart.series, stacks = { totalStacks: 0 };
      var stackNumber, i = 1;
      series.forEach(function(s) {
        stackNumber = pick$m(s.options.stack, stacking ? 0 : series.length - 1 - s.index);
        if (!stacks[stackNumber]) {
          stacks[stackNumber] = { series: [s], position: i };
          i++;
        } else {
          stacks[stackNumber].series.push(s);
        }
      });
      stacks.totalStacks = i + 1;
      return stacks;
    }
    wrap$2(columnProto$1, "translate", function(proceed) {
      proceed.apply(this, [].slice.call(arguments, 1));
      if (this.chart.is3d()) {
        this.translate3dShapes();
      }
    });
    wrap$2(Series$e.prototype, "justifyDataLabel", function(proceed) {
      return !arguments[2].outside3dPlot ? proceed.apply(this, [].slice.call(arguments, 1)) : false;
    });
    columnProto$1.translate3dPoints = function() {
    };
    columnProto$1.translate3dShapes = function() {
      var series = this, chart = series.chart, seriesOptions = series.options, depth = seriesOptions.depth, stack = seriesOptions.stacking ? seriesOptions.stack || 0 : series.index, z = stack * (depth + (seriesOptions.groupZPadding || 1)), borderCrisp = series.borderWidth % 2 ? 0.5 : 0, point2dPos;
      if (chart.inverted && !series.yAxis.reversed) {
        borderCrisp *= -1;
      }
      if (seriesOptions.grouping !== false) {
        z = 0;
      }
      z += seriesOptions.groupZPadding || 1;
      series.data.forEach(function(point) {
        point.outside3dPlot = null;
        if (point.y !== null) {
          var shapeArgs_1 = point.shapeArgs, tooltipPos = point.tooltipPos, dimensions = [["x", "width"], ["y", "height"]], borderlessBase_1;
          dimensions.forEach(function(d) {
            borderlessBase_1 = shapeArgs_1[d[0]] - borderCrisp;
            if (borderlessBase_1 < 0) {
              shapeArgs_1[d[1]] += shapeArgs_1[d[0]] + borderCrisp;
              shapeArgs_1[d[0]] = -borderCrisp;
              borderlessBase_1 = 0;
            }
            if (borderlessBase_1 + shapeArgs_1[d[1]] > series[d[0] + "Axis"].len && // Do not change height/width of column if 0 (#6708)
            shapeArgs_1[d[1]] !== 0) {
              shapeArgs_1[d[1]] = series[d[0] + "Axis"].len - shapeArgs_1[d[0]];
            }
            if (
              // Do not remove columns with zero height/width.
              shapeArgs_1[d[1]] !== 0 && (shapeArgs_1[d[0]] >= series[d[0] + "Axis"].len || shapeArgs_1[d[0]] + shapeArgs_1[d[1]] <= borderCrisp)
            ) {
              for (var key in shapeArgs_1) {
                shapeArgs_1[key] = key === "y" ? -9999 : 0;
              }
              point.outside3dPlot = true;
            }
          });
          if (point.shapeType === "rect") {
            point.shapeType = "cuboid";
          }
          shapeArgs_1.z = z;
          shapeArgs_1.depth = depth;
          shapeArgs_1.insidePlotArea = true;
          point2dPos = {
            x: shapeArgs_1.x + shapeArgs_1.width / 2,
            y: shapeArgs_1.y,
            z: z + depth / 2
            // The center of column in Z dimension
          };
          if (chart.inverted) {
            point2dPos.x = shapeArgs_1.height;
            point2dPos.y = point.clientX;
          }
          point.plot3d = perspective$1([point2dPos], chart, true, false)[0];
          tooltipPos = perspective$1([{
            x: tooltipPos[0],
            y: tooltipPos[1],
            z: z + depth / 2
            // The center of column in Z dimension
          }], chart, true, false)[0];
          point.tooltipPos = [tooltipPos.x, tooltipPos.y];
        }
      });
      series.z = z;
    };
    wrap$2(columnProto$1, "animate", function(proceed) {
      if (!this.chart.is3d()) {
        proceed.apply(this, [].slice.call(arguments, 1));
      } else {
        var args = arguments, init = args[1], yAxis_1 = this.yAxis, series_1 = this, reversed_1 = this.yAxis.reversed;
        if (svg$1) {
          if (init) {
            series_1.data.forEach(function(point) {
              if (point.y !== null) {
                point.height = point.shapeArgs.height;
                point.shapey = point.shapeArgs.y;
                point.shapeArgs.height = 1;
                if (!reversed_1) {
                  if (point.stackY) {
                    point.shapeArgs.y = point.plotY + yAxis_1.translate(point.stackY);
                  } else {
                    point.shapeArgs.y = point.plotY + (point.negative ? -point.height : point.height);
                  }
                }
              }
            });
          } else {
            series_1.data.forEach(function(point) {
              if (point.y !== null) {
                point.shapeArgs.height = point.height;
                point.shapeArgs.y = point.shapey;
                if (point.graphic) {
                  point.graphic[point.outside3dPlot ? "attr" : "animate"](point.shapeArgs, series_1.options.animation);
                }
              }
            });
            this.drawDataLabels();
          }
        }
      }
    });
    wrap$2(columnProto$1, "plotGroup", function(proceed, prop, _name, _visibility, _zIndex, parent) {
      if (prop !== "dataLabelsGroup") {
        if (this.chart.is3d()) {
          if (this[prop]) {
            delete this[prop];
          }
          if (parent) {
            if (!this.chart.columnGroup) {
              this.chart.columnGroup = this.chart.renderer.g("columnGroup").add(parent);
            }
            this[prop] = this.chart.columnGroup;
            this.chart.columnGroup.attr(this.getPlotBox());
            this[prop].survive = true;
            if (prop === "group" || prop === "markerGroup") {
              arguments[3] = "visible";
            }
          }
        }
      }
      return proceed.apply(this, Array.prototype.slice.call(arguments, 1));
    });
    wrap$2(columnProto$1, "setVisible", function(proceed, vis) {
      var series = this;
      if (series.chart.is3d()) {
        series.data.forEach(function(point) {
          point.visible = point.options.visible = vis = typeof vis === "undefined" ? !pick$m(series.visible, point.visible) : vis;
          series.options.data[series.data.indexOf(point)] = point.options;
          if (point.graphic) {
            point.graphic.attr({
              visibility: vis ? "visible" : "hidden"
            });
          }
        });
      }
      proceed.apply(this, Array.prototype.slice.call(arguments, 1));
    });
    addEvent$c(ColumnSeries$h, "afterInit", function() {
      if (this.chart.is3d()) {
        var series = this, seriesOptions = this.options, grouping = seriesOptions.grouping, stacking = seriesOptions.stacking, reversedStacks = this.yAxis.options.reversedStacks, z = 0;
        if (!(typeof grouping !== "undefined" && !grouping)) {
          var stacks = retrieveStacks(this.chart, stacking), stack = seriesOptions.stack || 0, i = (
            // position within the stack
            void 0
          );
          for (i = 0; i < stacks[stack].series.length; i++) {
            if (stacks[stack].series[i] === this) {
              break;
            }
          }
          z = 10 * (stacks.totalStacks - stacks[stack].position) + (reversedStacks ? i : -i);
          if (!this.xAxis.reversed) {
            z = stacks.totalStacks * 10 - z;
          }
        }
        seriesOptions.depth = seriesOptions.depth || 25;
        series.z = series.z || 0;
        seriesOptions.zIndex = z;
      }
    });
    function pointAttribs(proceed) {
      var attr2 = proceed.apply(this, [].slice.call(arguments, 1));
      if (this.chart.is3d && this.chart.is3d()) {
        attr2.stroke = this.options.edgeColor || attr2.fill;
        attr2["stroke-width"] = pick$m(this.options.edgeWidth, 1);
      }
      return attr2;
    }
    function setState(proceed, state, inherit) {
      var is3d = this.chart.is3d && this.chart.is3d();
      if (is3d) {
        this.options.inactiveOtherPoints = true;
      }
      proceed.call(this, state, inherit);
      if (is3d) {
        this.options.inactiveOtherPoints = false;
      }
    }
    function hasNewShapeType(proceed) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      return this.series.chart.is3d() ? this.graphic && this.graphic.element.nodeName !== "g" : proceed.apply(this, args);
    }
    wrap$2(columnProto$1, "pointAttribs", pointAttribs);
    wrap$2(columnProto$1, "setState", setState);
    wrap$2(columnProto$1.pointClass.prototype, "hasNewShapeType", hasNewShapeType);
    if (SeriesRegistry$1.seriesTypes.columnRange) {
      var columnRangeProto = SeriesRegistry$1.seriesTypes.columnrange.prototype;
      wrap$2(columnRangeProto, "pointAttribs", pointAttribs);
      wrap$2(columnRangeProto, "setState", setState);
      wrap$2(columnRangeProto.pointClass.prototype, "hasNewShapeType", hasNewShapeType);
      columnRangeProto.plotGroup = columnProto$1.plotGroup;
      columnRangeProto.setVisible = columnProto$1.setVisible;
    }
    wrap$2(Series$e.prototype, "alignDataLabel", function(proceed, point, dataLabel, options, alignTo) {
      var chart = this.chart;
      options.outside3dPlot = point.outside3dPlot;
      if (chart.is3d() && this.is("column")) {
        var series = this, seriesOptions = series.options, inside = pick$m(options.inside, !!series.options.stacking), options3d = chart.options.chart.options3d, xOffset = point.pointWidth / 2 || 0;
        var dLPosition = {
          x: alignTo.x + xOffset,
          y: alignTo.y,
          z: series.z + seriesOptions.depth / 2
        };
        if (chart.inverted) {
          if (inside) {
            alignTo.width = 0;
            dLPosition.x += point.shapeArgs.height / 2;
          }
          if (options3d.alpha >= 90 && options3d.alpha <= 270) {
            dLPosition.y += point.shapeArgs.width;
          }
        }
        dLPosition = perspective$1([dLPosition], chart, true, false)[0];
        alignTo.x = dLPosition.x - xOffset;
        alignTo.y = point.outside3dPlot ? -9e9 : dLPosition.y;
      }
      proceed.apply(this, [].slice.call(arguments, 1));
    });
    wrap$2(StackItem$1.prototype, "getStackBox", function(proceed, chart, stackItem, x, y, xWidth, h, axis) {
      var stackBox = proceed.apply(this, [].slice.call(arguments, 1));
      if (chart.is3d() && stackItem.base) {
        var baseSeriesInd = +stackItem.base.split(",")[0];
        var columnSeries = chart.series[baseSeriesInd];
        var options3d = chart.options.chart.options3d;
        if (columnSeries && columnSeries instanceof SeriesRegistry$1.seriesTypes.column) {
          var dLPosition = {
            x: stackBox.x + (chart.inverted ? h : xWidth / 2),
            y: stackBox.y,
            z: columnSeries.options.depth / 2
          };
          if (chart.inverted) {
            stackBox.width = 0;
            if (options3d.alpha >= 90 && options3d.alpha <= 270) {
              dLPosition.y += xWidth;
            }
          }
          dLPosition = perspective$1([dLPosition], chart, true, false)[0];
          stackBox.x = dLPosition.x - xWidth / 2;
          stackBox.y = dLPosition.y;
        }
      }
      return stackBox;
    });
    var __extends$l = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var PiePoint$2 = SeriesRegistry$1.seriesTypes.pie.prototype.pointClass;
    var superHaloPath = PiePoint$2.prototype.haloPath;
    var Pie3DPoint = (
      /** @class */
      function(_super) {
        __extends$l(Pie3DPoint2, _super);
        function Pie3DPoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.series = void 0;
          return _this;
        }
        Pie3DPoint2.prototype.haloPath = function() {
          return this.series.chart.is3d() ? [] : superHaloPath.apply(this, arguments);
        };
        return Pie3DPoint2;
      }(PiePoint$2)
    );
    var __extends$k = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var deg2rad = H.deg2rad, svg = H.svg;
    var PieSeries$2 = SeriesRegistry$1.seriesTypes.pie;
    var extend$o = Utilities.extend, pick$l = Utilities.pick;
    var Pie3DSeries = (
      /** @class */
      function(_super) {
        __extends$k(Pie3DSeries2, _super);
        function Pie3DSeries2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        Pie3DSeries2.prototype.addPoint = function() {
          _super.prototype.addPoint.apply(this, arguments);
          if (this.chart.is3d()) {
            this.update(this.userOptions, true);
          }
        };
        Pie3DSeries2.prototype.animate = function(init) {
          if (!this.chart.is3d()) {
            _super.prototype.animate.apply(this, arguments);
          } else {
            var animation = this.options.animation, attribs = void 0, center = this.center, group = this.group, markerGroup = this.markerGroup;
            if (svg) {
              if (animation === true) {
                animation = {};
              }
              if (init) {
                group.oldtranslateX = pick$l(group.oldtranslateX, group.translateX);
                group.oldtranslateY = pick$l(group.oldtranslateY, group.translateY);
                attribs = {
                  translateX: center[0],
                  translateY: center[1],
                  scaleX: 1e-3,
                  scaleY: 1e-3
                };
                group.attr(attribs);
                if (markerGroup) {
                  markerGroup.attrSetters = group.attrSetters;
                  markerGroup.attr(attribs);
                }
              } else {
                attribs = {
                  translateX: group.oldtranslateX,
                  translateY: group.oldtranslateY,
                  scaleX: 1,
                  scaleY: 1
                };
                group.animate(attribs, animation);
                if (markerGroup) {
                  markerGroup.animate(attribs, animation);
                }
              }
            }
          }
        };
        Pie3DSeries2.prototype.drawDataLabels = function() {
          if (this.chart.is3d()) {
            var series = this, chart = series.chart, options3d_1 = chart.options.chart.options3d;
            series.data.forEach(function(point) {
              var shapeArgs = point.shapeArgs, r = shapeArgs.r, a1 = (shapeArgs.alpha || options3d_1.alpha) * deg2rad, b1 = (shapeArgs.beta || options3d_1.beta) * deg2rad, a2 = (shapeArgs.start + shapeArgs.end) / 2, labelPosition = point.labelPosition, connectorPosition = labelPosition.connectorPosition, yOffset = -r * (1 - Math.cos(a1)) * Math.sin(a2), xOffset = r * (Math.cos(b1) - 1) * Math.cos(a2);
              [
                labelPosition.natural,
                connectorPosition.breakAt,
                connectorPosition.touchingSliceAt
              ].forEach(function(coordinates) {
                coordinates.x += xOffset;
                coordinates.y += yOffset;
              });
            });
          }
          _super.prototype.drawDataLabels.apply(this, arguments);
        };
        Pie3DSeries2.prototype.pointAttribs = function(point) {
          var attr2 = _super.prototype.pointAttribs.apply(this, arguments), options = this.options;
          if (this.chart.is3d() && !this.chart.styledMode) {
            attr2.stroke = options.edgeColor || point.color || this.color;
            attr2["stroke-width"] = pick$l(options.edgeWidth, 1);
          }
          return attr2;
        };
        Pie3DSeries2.prototype.translate = function() {
          _super.prototype.translate.apply(this, arguments);
          if (!this.chart.is3d()) {
            return;
          }
          var series = this, seriesOptions = series.options, depth = seriesOptions.depth || 0, options3d = series.chart.options.chart.options3d, alpha = options3d.alpha, beta = options3d.beta, z = seriesOptions.stacking ? (seriesOptions.stack || 0) * depth : series._i * depth;
          z += depth / 2;
          if (seriesOptions.grouping !== false) {
            z = 0;
          }
          series.data.forEach(function(point) {
            var shapeArgs = point.shapeArgs, angle;
            point.shapeType = "arc3d";
            shapeArgs.z = z;
            shapeArgs.depth = depth * 0.75;
            shapeArgs.alpha = alpha;
            shapeArgs.beta = beta;
            shapeArgs.center = series.center;
            angle = (shapeArgs.end + shapeArgs.start) / 2;
            point.slicedTranslation = {
              translateX: Math.round(Math.cos(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad)),
              translateY: Math.round(Math.sin(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad))
            };
          });
        };
        return Pie3DSeries2;
      }(PieSeries$2)
    );
    extend$o(Pie3DSeries.prototype, {
      pointClass: Pie3DPoint
    });
    SeriesRegistry$1.seriesTypes.pie.prototype.pointClass.prototype.haloPath = Pie3DPoint.prototype.haloPath;
    SeriesRegistry$1.seriesTypes.pie = Pie3DSeries;
    var __extends$j = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var defined$9 = Utilities.defined;
    var Scatter3DPoint = (
      /** @class */
      function(_super) {
        __extends$j(Scatter3DPoint2, _super);
        function Scatter3DPoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.options = void 0;
          _this.series = void 0;
          return _this;
        }
        Scatter3DPoint2.prototype.applyOptions = function() {
          _super.prototype.applyOptions.apply(this, arguments);
          if (!defined$9(this.z)) {
            this.z = 0;
          }
          return this;
        };
        return Scatter3DPoint2;
      }(ScatterSeries$4.prototype.pointClass)
    );
    var __extends$i = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var pointCameraDistance = mathModule.pointCameraDistance;
    var extend$n = Utilities.extend, merge$j = Utilities.merge;
    var Scatter3DSeries = (
      /** @class */
      function(_super) {
        __extends$i(Scatter3DSeries2, _super);
        function Scatter3DSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        Scatter3DSeries2.prototype.pointAttribs = function(point) {
          var attribs = _super.prototype.pointAttribs.apply(this, arguments);
          if (this.chart.is3d() && point) {
            attribs.zIndex = pointCameraDistance(point, this.chart);
          }
          return attribs;
        };
        Scatter3DSeries2.defaultOptions = merge$j(ScatterSeries$4.defaultOptions, {
          tooltip: {
            pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>"
          }
        });
        return Scatter3DSeries2;
      }(ScatterSeries$4)
    );
    extend$n(Scatter3DSeries.prototype, {
      axisTypes: ["xAxis", "yAxis", "zAxis"],
      // Require direct touch rather than using the k-d-tree, because the
      // k-d-tree currently doesn't take the xyz coordinate system into
      // account (#4552)
      directTouch: true,
      parallelArrays: ["x", "y", "z"],
      pointArrayMap: ["x", "y", "z"],
      pointClass: Scatter3DPoint
    });
    SeriesRegistry$1.registerSeriesType("scatter3d", Scatter3DSeries);
    var perspective = mathModule.perspective;
    var _a$6 = SeriesRegistry$1.seriesTypes, AreaSeriesClass = _a$6.area, LineSeriesClass = _a$6.line;
    var pick$k = Utilities.pick, wrap$1 = Utilities.wrap;
    wrap$1(AreaSeriesClass.prototype, "getGraphPath", function(proceed) {
      var series = this, svgPath = proceed.apply(series, [].slice.call(arguments, 1));
      if (!series.chart.is3d()) {
        return svgPath;
      }
      var getGraphPath = LineSeriesClass.prototype.getGraphPath, options = series.options, stacking = options.stacking, bottomPath, bottomPoints = [], graphPoints = [], areaPath, connectNulls = pick$k(
        // #10574
        options.connectNulls,
        stacking === "percent"
      ), translatedThreshold = Math.round(
        // #10909
        series.yAxis.getThreshold(options.threshold)
      ), options3d;
      if (series.rawPointsX) {
        for (var i_1 = 0; i_1 < series.points.length; i_1++) {
          bottomPoints.push({
            x: series.rawPointsX[i_1],
            y: options.stacking ? series.points[i_1].yBottom : translatedThreshold,
            z: series.zPadding
          });
        }
      }
      options3d = series.chart.options.chart.options3d;
      bottomPoints = perspective(bottomPoints, series.chart, true).map(function(point) {
        return { plotX: point.x, plotY: point.y, plotZ: point.z };
      });
      if (series.group && options3d && options3d.depth && options3d.beta) {
        if (series.markerGroup) {
          series.markerGroup.add(series.group);
          series.markerGroup.attr({
            translateX: 0,
            translateY: 0
          });
        }
        series.group.attr({
          zIndex: Math.max(1, options3d.beta > 270 || options3d.beta < 90 ? options3d.depth - Math.round(series.zPadding || 0) : Math.round(series.zPadding || 0))
        });
      }
      bottomPoints.reversed = true;
      bottomPath = getGraphPath.call(series, bottomPoints, true, true);
      if (bottomPath[0] && bottomPath[0][0] === "M") {
        bottomPath[0] = ["L", bottomPath[0][1], bottomPath[0][2]];
      }
      if (series.areaPath) {
        areaPath = series.areaPath.splice(0, series.areaPath.length / 2).concat(bottomPath);
        areaPath.xMap = series.areaPath.xMap;
        series.areaPath = areaPath;
        getGraphPath.call(series, graphPoints, false, connectNulls);
      }
      return svgPath;
    });
    /**
     * @license Highcharts JS v9.2.2 (2021-08-24)
     * @module highcharts/highcharts-3d
     * @requires highcharts
     *
     * 3D features for Highcharts JS
     *
     * License: www.highcharts.com/license
     */
    var G$3 = H;
    SVGRenderer3D.compose(G$3.SVGRenderer);
    Chart3D$1.compose(G$3.Chart, G$3.Fx);
    ZAxis.ZChartComposition.compose(G$3.Chart);
    Axis3D.compose(G$3.Axis);
    var doc$2 = H.doc;
    var createElement$1 = Utilities.createElement, discardElement$1 = Utilities.discardElement, merge$i = Utilities.merge, objectEach$5 = Utilities.objectEach;
    function ajax$1(attr2) {
      var options = merge$i(true, {
        url: false,
        type: "get",
        dataType: "json",
        success: false,
        error: false,
        data: false,
        headers: {}
      }, attr2), headers = {
        json: "application/json",
        xml: "application/xml",
        text: "text/plain",
        octet: "application/octet-stream"
      }, r = new XMLHttpRequest();
      function handleError(xhr, err) {
        if (options.error) {
          options.error(xhr, err);
        }
      }
      if (!options.url) {
        return false;
      }
      r.open(options.type.toUpperCase(), options.url, true);
      if (!options.headers["Content-Type"]) {
        r.setRequestHeader("Content-Type", headers[options.dataType] || headers.text);
      }
      objectEach$5(options.headers, function(val, key) {
        r.setRequestHeader(key, val);
      });
      r.onreadystatechange = function() {
        var res;
        if (r.readyState === 4) {
          if (r.status === 200) {
            res = r.responseText;
            if (options.dataType === "json") {
              try {
                res = JSON.parse(res);
              } catch (e2) {
                return handleError(r, e2);
              }
            }
            return options.success && options.success(res);
          }
          handleError(r, r.responseText);
        }
      };
      try {
        options.data = JSON.stringify(options.data);
      } catch (e2) {
      }
      r.send(options.data || true);
    }
    function getJSON(url, success) {
      exports$2.ajax({
        url,
        success,
        dataType: "json",
        headers: {
          // Override the Content-Type to avoid preflight problems with CORS
          // in the Highcharts demos
          "Content-Type": "text/plain"
        }
      });
    }
    function post(url, data, formAttributes) {
      var form = createElement$1("form", merge$i({
        method: "post",
        action: url,
        enctype: "multipart/form-data"
      }, formAttributes), {
        display: "none"
      }, doc$2.body);
      objectEach$5(data, function(val, name) {
        createElement$1("input", {
          type: "hidden",
          name,
          value: val
        }, null, form);
      });
      form.submit();
      discardElement$1(form);
    }
    var exports$2 = {
      ajax: ajax$1,
      getJSON,
      post
    };
    var doc$1 = H.doc;
    var ajax = exports$2.ajax;
    var seriesTypes$2 = SeriesRegistry$1.seriesTypes;
    var addEvent$b = Utilities.addEvent, defined$8 = Utilities.defined, extend$m = Utilities.extend, fireEvent$5 = Utilities.fireEvent, isNumber$8 = Utilities.isNumber, merge$h = Utilities.merge, objectEach$4 = Utilities.objectEach, pick$j = Utilities.pick, splat$1 = Utilities.splat;
    var Data = (
      /** @class */
      function() {
        function Data2(dataOptions, chartOptions, chart) {
          this.chart = void 0;
          this.chartOptions = void 0;
          this.firstRowAsNames = void 0;
          this.rawColumns = void 0;
          this.options = void 0;
          this.dateFormats = {
            "YYYY/mm/dd": {
              regex: /^([0-9]{4})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{1,2})$/,
              parser: function(match2) {
                return match2 ? Date.UTC(+match2[1], match2[2] - 1, +match2[3]) : NaN;
              }
            },
            "dd/mm/YYYY": {
              regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/,
              parser: function(match2) {
                return match2 ? Date.UTC(+match2[3], match2[2] - 1, +match2[1]) : NaN;
              },
              alternative: "mm/dd/YYYY"
              // different format with the same regex
            },
            "mm/dd/YYYY": {
              regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/,
              parser: function(match2) {
                return match2 ? Date.UTC(+match2[3], match2[1] - 1, +match2[2]) : NaN;
              }
            },
            "dd/mm/YY": {
              regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/,
              parser: function(match2) {
                if (!match2) {
                  return NaN;
                }
                var year = +match2[3], d = /* @__PURE__ */ new Date();
                if (year > d.getFullYear() - 2e3) {
                  year += 1900;
                } else {
                  year += 2e3;
                }
                return Date.UTC(year, match2[2] - 1, +match2[1]);
              },
              alternative: "mm/dd/YY"
              // different format with the same regex
            },
            "mm/dd/YY": {
              regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/,
              parser: function(match2) {
                return match2 ? Date.UTC(+match2[3] + 2e3, match2[1] - 1, +match2[2]) : NaN;
              }
            }
          };
          this.init(dataOptions, chartOptions, chart);
        }
        Data2.prototype.init = function(options, chartOptions, chart) {
          var decimalPoint = options.decimalPoint, hasData;
          if (chartOptions) {
            this.chartOptions = chartOptions;
          }
          if (chart) {
            this.chart = chart;
          }
          if (decimalPoint !== "." && decimalPoint !== ",") {
            decimalPoint = void 0;
          }
          this.options = options;
          this.columns = options.columns || this.rowsToColumns(options.rows) || [];
          this.firstRowAsNames = pick$j(options.firstRowAsNames, this.firstRowAsNames, true);
          this.decimalRegex = decimalPoint && new RegExp("^(-?[0-9]+)" + decimalPoint + "([0-9]+)$");
          this.rawColumns = [];
          if (this.columns.length) {
            this.dataFound();
            hasData = true;
          }
          if (this.hasURLOption(options)) {
            clearTimeout(this.liveDataTimeout);
            hasData = false;
          }
          if (!hasData) {
            hasData = this.fetchLiveData();
          }
          if (!hasData) {
            hasData = Boolean(this.parseCSV().length);
          }
          if (!hasData) {
            hasData = Boolean(this.parseTable().length);
          }
          if (!hasData) {
            hasData = this.parseGoogleSpreadsheet();
          }
          if (!hasData && options.afterComplete) {
            options.afterComplete();
          }
        };
        Data2.prototype.hasURLOption = function(options) {
          return Boolean(options && (options.rowsURL || options.csvURL || options.columnsURL));
        };
        Data2.prototype.getColumnDistribution = function() {
          var chartOptions = this.chartOptions, options = this.options, xColumns = [], getValueCount = function(type) {
            return (seriesTypes$2[type || "line"].prototype.pointArrayMap || [0]).length;
          }, getPointArrayMap = function(type) {
            return seriesTypes$2[type || "line"].prototype.pointArrayMap;
          }, globalType = chartOptions && chartOptions.chart && chartOptions.chart.type, individualCounts = [], seriesBuilders = [], seriesIndex = 0, seriesMapping = options && options.seriesMapping || chartOptions && chartOptions.series && chartOptions.series.map(function() {
            return { x: 0 };
          }) || [], i;
          (chartOptions && chartOptions.series || []).forEach(function(series) {
            individualCounts.push(getValueCount(series.type || globalType));
          });
          seriesMapping.forEach(function(mapping) {
            xColumns.push(mapping.x || 0);
          });
          if (xColumns.length === 0) {
            xColumns.push(0);
          }
          seriesMapping.forEach(function(mapping) {
            var builder = new SeriesBuilder(), numberOfValueColumnsNeeded = individualCounts[seriesIndex] || getValueCount(globalType), seriesArr = chartOptions && chartOptions.series || [], series = seriesArr[seriesIndex] || {}, defaultPointArrayMap = getPointArrayMap(series.type || globalType), pointArrayMap = defaultPointArrayMap || ["y"];
            if (
              // User-defined x.mapping
              defined$8(mapping.x) || // All non cartesian don't need 'x'
              series.isCartesian || // Except pie series:
              !defaultPointArrayMap
            ) {
              builder.addColumnReader(mapping.x, "x");
            }
            objectEach$4(mapping, function(val, name) {
              if (name !== "x") {
                builder.addColumnReader(val, name);
              }
            });
            for (i = 0; i < numberOfValueColumnsNeeded; i++) {
              if (!builder.hasReader(pointArrayMap[i])) {
                builder.addColumnReader(void 0, pointArrayMap[i]);
              }
            }
            seriesBuilders.push(builder);
            seriesIndex++;
          });
          var globalPointArrayMap = getPointArrayMap(globalType);
          if (typeof globalPointArrayMap === "undefined") {
            globalPointArrayMap = ["y"];
          }
          this.valueCount = {
            global: getValueCount(globalType),
            xColumns,
            individual: individualCounts,
            seriesBuilders,
            globalPointArrayMap
          };
        };
        Data2.prototype.dataFound = function() {
          if (this.options.switchRowsAndColumns) {
            this.columns = this.rowsToColumns(this.columns);
          }
          this.getColumnDistribution();
          this.parseTypes();
          if (this.parsed() !== false) {
            this.complete();
          }
        };
        Data2.prototype.parseCSV = function(inOptions) {
          var self = this, options = inOptions || this.options, csv = options.csv, columns, startRow = typeof options.startRow !== "undefined" && options.startRow ? options.startRow : 0, endRow = options.endRow || Number.MAX_VALUE, startColumn = typeof options.startColumn !== "undefined" && options.startColumn ? options.startColumn : 0, endColumn = options.endColumn || Number.MAX_VALUE, itemDelimiter, lines, rowIt = 0, dataTypes = [], potDelimiters = {
            ",": 0,
            ";": 0,
            "	": 0
          };
          columns = this.columns = [];
          function parseRow(columnStr, rowNumber, noAdd, callbacks) {
            var i = 0, c = "", cl = "", cn = "", token = "", actualColumn = 0, column = 0;
            function read(j) {
              c = columnStr[j];
              cl = columnStr[j - 1];
              cn = columnStr[j + 1];
            }
            function pushType(type) {
              if (dataTypes.length < column + 1) {
                dataTypes.push([type]);
              }
              if (dataTypes[column][dataTypes[column].length - 1] !== type) {
                dataTypes[column].push(type);
              }
            }
            function push() {
              if (startColumn > actualColumn || actualColumn > endColumn) {
                ++actualColumn;
                token = "";
                return;
              }
              if (!isNaN(parseFloat(token)) && isFinite(token)) {
                token = parseFloat(token);
                pushType("number");
              } else if (!isNaN(Date.parse(token))) {
                token = token.replace(/\//g, "-");
                pushType("date");
              } else {
                pushType("string");
              }
              if (columns.length < column + 1) {
                columns.push([]);
              }
              {
                columns[column][rowNumber] = token;
              }
              token = "";
              ++column;
              ++actualColumn;
            }
            if (!columnStr.trim().length) {
              return;
            }
            if (columnStr.trim()[0] === "#") {
              return;
            }
            for (; i < columnStr.length; i++) {
              read(i);
              if (c === '"') {
                read(++i);
                while (i < columnStr.length) {
                  if (c === '"' && cl !== '"' && cn !== '"') {
                    break;
                  }
                  if (c !== '"' || c === '"' && cl !== '"') {
                    token += c;
                  }
                  read(++i);
                }
              } else if (c === itemDelimiter) {
                push();
              } else {
                token += c;
              }
            }
            push();
          }
          function guessDelimiter(lines2) {
            var points = 0, commas = 0, guessed = false;
            lines2.some(function(columnStr, i) {
              var inStr = false, c, cn, cl, token = "";
              if (i > 13) {
                return true;
              }
              for (var j = 0; j < columnStr.length; j++) {
                c = columnStr[j];
                cn = columnStr[j + 1];
                cl = columnStr[j - 1];
                if (c === "#") {
                  return;
                }
                if (c === '"') {
                  if (inStr) {
                    if (cl !== '"' && cn !== '"') {
                      while (cn === " " && j < columnStr.length) {
                        cn = columnStr[++j];
                      }
                      if (typeof potDelimiters[cn] !== "undefined") {
                        potDelimiters[cn]++;
                      }
                      inStr = false;
                    }
                  } else {
                    inStr = true;
                  }
                } else if (typeof potDelimiters[c] !== "undefined") {
                  token = token.trim();
                  if (!isNaN(Date.parse(token))) {
                    potDelimiters[c]++;
                  } else if (isNaN(token) || !isFinite(token)) {
                    potDelimiters[c]++;
                  }
                  token = "";
                } else {
                  token += c;
                }
                if (c === ",") {
                  commas++;
                }
                if (c === ".") {
                  points++;
                }
              }
            });
            if (potDelimiters[";"] > potDelimiters[","]) {
              guessed = ";";
            } else if (potDelimiters[","] > potDelimiters[";"]) {
              guessed = ",";
            } else {
              guessed = ",";
            }
            if (!options.decimalPoint) {
              if (points > commas) {
                options.decimalPoint = ".";
              } else {
                options.decimalPoint = ",";
              }
              self.decimalRegex = new RegExp("^(-?[0-9]+)" + options.decimalPoint + "([0-9]+)$");
            }
            return guessed;
          }
          function deduceDateFormat(data, limit) {
            var format2 = "YYYY/mm/dd", thing, guessedFormat = [], calculatedFormat, i = 0, madeDeduction = false, stable = [], max = [], j;
            if (!limit || limit > data.length) {
              limit = data.length;
            }
            for (; i < limit; i++) {
              if (typeof data[i] !== "undefined" && data[i] && data[i].length) {
                thing = data[i].trim().replace(/\//g, " ").replace(/\-/g, " ").replace(/\./g, " ").split(" ");
                guessedFormat = [
                  "",
                  "",
                  ""
                ];
                for (j = 0; j < thing.length; j++) {
                  if (j < guessedFormat.length) {
                    thing[j] = parseInt(thing[j], 10);
                    if (thing[j]) {
                      max[j] = !max[j] || max[j] < thing[j] ? thing[j] : max[j];
                      if (typeof stable[j] !== "undefined") {
                        if (stable[j] !== thing[j]) {
                          stable[j] = false;
                        }
                      } else {
                        stable[j] = thing[j];
                      }
                      if (thing[j] > 31) {
                        if (thing[j] < 100) {
                          guessedFormat[j] = "YY";
                        } else {
                          guessedFormat[j] = "YYYY";
                        }
                      } else if (thing[j] > 12 && thing[j] <= 31) {
                        guessedFormat[j] = "dd";
                        madeDeduction = true;
                      } else if (!guessedFormat[j].length) {
                        guessedFormat[j] = "mm";
                      }
                    }
                  }
                }
              }
            }
            if (madeDeduction) {
              for (j = 0; j < stable.length; j++) {
                if (stable[j] !== false) {
                  if (max[j] > 12 && guessedFormat[j] !== "YY" && guessedFormat[j] !== "YYYY") {
                    guessedFormat[j] = "YY";
                  }
                } else if (max[j] > 12 && guessedFormat[j] === "mm") {
                  guessedFormat[j] = "dd";
                }
              }
              if (guessedFormat.length === 3 && guessedFormat[1] === "dd" && guessedFormat[2] === "dd") {
                guessedFormat[2] = "YY";
              }
              calculatedFormat = guessedFormat.join("/");
              if (!(options.dateFormats || self.dateFormats)[calculatedFormat]) {
                fireEvent$5("deduceDateFailed");
                return format2;
              }
              return calculatedFormat;
            }
            return format2;
          }
          if (csv && options.beforeParse) {
            csv = options.beforeParse.call(this, csv);
          }
          if (csv) {
            lines = csv.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split(options.lineDelimiter || "\n");
            if (!startRow || startRow < 0) {
              startRow = 0;
            }
            if (!endRow || endRow >= lines.length) {
              endRow = lines.length - 1;
            }
            if (options.itemDelimiter) {
              itemDelimiter = options.itemDelimiter;
            } else {
              itemDelimiter = null;
              itemDelimiter = guessDelimiter(lines);
            }
            var offset2 = 0;
            for (rowIt = startRow; rowIt <= endRow; rowIt++) {
              if (lines[rowIt][0] === "#") {
                offset2++;
              } else {
                parseRow(lines[rowIt], rowIt - startRow - offset2);
              }
            }
            if ((!options.columnTypes || options.columnTypes.length === 0) && dataTypes.length && dataTypes[0].length && dataTypes[0][1] === "date" && !options.dateFormat) {
              options.dateFormat = deduceDateFormat(columns[0]);
            }
            this.dataFound();
          }
          return columns;
        };
        Data2.prototype.parseTable = function() {
          var options = this.options, table = options.table, columns = this.columns || [], startRow = options.startRow || 0, endRow = options.endRow || Number.MAX_VALUE, startColumn = options.startColumn || 0, endColumn = options.endColumn || Number.MAX_VALUE;
          if (table) {
            if (typeof table === "string") {
              table = doc$1.getElementById(table);
            }
            [].forEach.call(table.getElementsByTagName("tr"), function(tr, rowNo) {
              if (rowNo >= startRow && rowNo <= endRow) {
                [].forEach.call(tr.children, function(item2, colNo) {
                  var row = columns[colNo - startColumn];
                  var i = 1;
                  if ((item2.tagName === "TD" || item2.tagName === "TH") && colNo >= startColumn && colNo <= endColumn) {
                    if (!columns[colNo - startColumn]) {
                      columns[colNo - startColumn] = [];
                    }
                    columns[colNo - startColumn][rowNo - startRow] = item2.innerHTML;
                    while (rowNo - startRow >= i && row[rowNo - startRow - i] === void 0) {
                      row[rowNo - startRow - i] = null;
                      i++;
                    }
                  }
                });
              }
            });
            this.dataFound();
          }
          return columns;
        };
        Data2.prototype.fetchLiveData = function() {
          var data = this, chart = this.chart, options = this.options, maxRetries = 3, currentRetries = 0, pollingEnabled = options.enablePolling, updateIntervalMs = (options.dataRefreshRate || 2) * 1e3, originalOptions = merge$h(options);
          if (!this.hasURLOption(options)) {
            return false;
          }
          if (updateIntervalMs < 1e3) {
            updateIntervalMs = 1e3;
          }
          delete options.csvURL;
          delete options.rowsURL;
          delete options.columnsURL;
          function performFetch(initialFetch) {
            function request(url, done, tp) {
              if (!url || !/^(http|\/|\.\/|\.\.\/)/.test(url)) {
                if (url && options.error) {
                  options.error("Invalid URL");
                }
                return false;
              }
              if (initialFetch) {
                clearTimeout(data.liveDataTimeout);
                chart.liveDataURL = url;
              }
              function poll() {
                if (pollingEnabled && chart.liveDataURL === url) {
                  data.liveDataTimeout = setTimeout(performFetch, updateIntervalMs);
                }
              }
              ajax({
                url,
                dataType: tp || "json",
                success: function(res) {
                  if (chart && chart.series) {
                    done(res);
                  }
                  poll();
                },
                error: function(xhr, text) {
                  if (++currentRetries < maxRetries) {
                    poll();
                  }
                  return options.error && options.error(text, xhr);
                }
              });
              return true;
            }
            if (!request(originalOptions.csvURL, function(res) {
              chart.update({
                data: {
                  csv: res
                }
              });
            }, "text")) {
              if (!request(originalOptions.rowsURL, function(res) {
                chart.update({
                  data: {
                    rows: res
                  }
                });
              })) {
                request(originalOptions.columnsURL, function(res) {
                  chart.update({
                    data: {
                      columns: res
                    }
                  });
                });
              }
            }
          }
          performFetch(true);
          return this.hasURLOption(options);
        };
        Data2.prototype.parseGoogleSpreadsheet = function() {
          var data = this, options = this.options, googleSpreadsheetKey = options.googleSpreadsheetKey, chart = this.chart, refreshRate = Math.max((options.dataRefreshRate || 2) * 1e3, 4e3);
          var getRange = function() {
            if (options.googleSpreadsheetRange) {
              return options.googleSpreadsheetRange;
            }
            var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            var start = (alphabet.charAt(options.startColumn || 0) || "A") + ((options.startRow || 0) + 1);
            var end = alphabet.charAt(pick$j(options.endColumn, -1)) || "ZZ";
            if (defined$8(options.endRow)) {
              end += options.endRow + 1;
            }
            return start + ":" + end;
          };
          function fetchSheet(fn) {
            var url = [
              "https://sheets.googleapis.com/v4/spreadsheets",
              googleSpreadsheetKey,
              "values",
              getRange(),
              "?alt=json&majorDimension=COLUMNS&valueRenderOption=UNFORMATTED_VALUE&dateTimeRenderOption=FORMATTED_STRING&key=" + options.googleAPIKey
            ].join("/");
            ajax({
              url,
              dataType: "json",
              success: function(json) {
                fn(json);
                if (options.enablePolling) {
                  setTimeout(function() {
                    fetchSheet(fn);
                  }, refreshRate);
                }
              },
              error: function(xhr, text) {
                return options.error && options.error(text, xhr);
              }
            });
          }
          if (googleSpreadsheetKey) {
            delete options.googleSpreadsheetKey;
            fetchSheet(function(json) {
              var columns = json.values;
              if (!columns || columns.length === 0) {
                return false;
              }
              var rowCount = columns.reduce(function(rowCount2, column) {
                return Math.max(rowCount2, column.length);
              }, 0);
              columns.forEach(function(column) {
                for (var i = 0; i < rowCount; i++) {
                  if (typeof column[i] === "undefined") {
                    column[i] = null;
                  }
                }
              });
              if (chart && chart.series) {
                chart.update({
                  data: {
                    columns
                  }
                });
              } else {
                data.columns = columns;
                data.dataFound();
              }
            });
          }
          return false;
        };
        Data2.prototype.trim = function(str, inside) {
          if (typeof str === "string") {
            str = str.replace(/^\s+|\s+$/g, "");
            if (inside && /^[0-9\s]+$/.test(str)) {
              str = str.replace(/\s/g, "");
            }
            if (this.decimalRegex) {
              str = str.replace(this.decimalRegex, "$1.$2");
            }
          }
          return str;
        };
        Data2.prototype.parseTypes = function() {
          var columns = this.columns, col = columns.length;
          while (col--) {
            this.parseColumn(columns[col], col);
          }
        };
        Data2.prototype.parseColumn = function(column, col) {
          var rawColumns = this.rawColumns, columns = this.columns, row = column.length, val, floatVal, trimVal, trimInsideVal, firstRowAsNames = this.firstRowAsNames, isXColumn = this.valueCount.xColumns.indexOf(col) !== -1, dateVal, backup = [], diff, chartOptions = this.chartOptions, descending, columnTypes = this.options.columnTypes || [], columnType = columnTypes[col], forceCategory = isXColumn && (chartOptions && chartOptions.xAxis && splat$1(chartOptions.xAxis)[0].type === "category" || columnType === "string");
          if (!rawColumns[col]) {
            rawColumns[col] = [];
          }
          while (row--) {
            val = backup[row] || column[row];
            trimVal = this.trim(val);
            trimInsideVal = this.trim(val, true);
            floatVal = parseFloat(trimInsideVal);
            if (typeof rawColumns[col][row] === "undefined") {
              rawColumns[col][row] = trimVal;
            }
            if (forceCategory || row === 0 && firstRowAsNames) {
              column[row] = "" + trimVal;
            } else if (+trimInsideVal === floatVal) {
              column[row] = floatVal;
              if (floatVal > 365 * 24 * 3600 * 1e3 && columnType !== "float") {
                column.isDatetime = true;
              } else {
                column.isNumeric = true;
              }
              if (typeof column[row + 1] !== "undefined") {
                descending = floatVal > column[row + 1];
              }
            } else {
              if (trimVal && trimVal.length) {
                dateVal = this.parseDate(val);
              }
              if (isXColumn && isNumber$8(dateVal) && columnType !== "float") {
                backup[row] = val;
                column[row] = dateVal;
                column.isDatetime = true;
                if (typeof column[row + 1] !== "undefined") {
                  diff = dateVal > column[row + 1];
                  if (diff !== descending && typeof descending !== "undefined") {
                    if (this.alternativeFormat) {
                      this.dateFormat = this.alternativeFormat;
                      row = column.length;
                      this.alternativeFormat = this.dateFormats[this.dateFormat].alternative;
                    } else {
                      column.unsorted = true;
                    }
                  }
                  descending = diff;
                }
              } else {
                column[row] = trimVal === "" ? null : trimVal;
                if (row !== 0 && (column.isDatetime || column.isNumeric)) {
                  column.mixed = true;
                }
              }
            }
          }
          if (isXColumn && column.mixed) {
            columns[col] = rawColumns[col];
          }
          if (isXColumn && descending && this.options.sort) {
            for (col = 0; col < columns.length; col++) {
              columns[col].reverse();
              if (firstRowAsNames) {
                columns[col].unshift(columns[col].pop());
              }
            }
          }
        };
        Data2.prototype.parseDate = function(val) {
          var parseDate2 = this.options.parseDate;
          var ret, key, format2, dateFormat2 = this.options.dateFormat || this.dateFormat, match2;
          if (parseDate2) {
            ret = parseDate2(val);
          } else if (typeof val === "string") {
            if (!dateFormat2) {
              for (key in this.dateFormats) {
                format2 = this.dateFormats[key];
                match2 = val.match(format2.regex);
                if (match2) {
                  this.dateFormat = dateFormat2 = key;
                  this.alternativeFormat = format2.alternative;
                  ret = format2.parser(match2);
                  break;
                }
              }
            } else {
              format2 = this.dateFormats[dateFormat2];
              if (!format2) {
                format2 = this.dateFormats["YYYY/mm/dd"];
              }
              match2 = val.match(format2.regex);
              if (match2) {
                ret = format2.parser(match2);
              }
            }
            if (!match2) {
              if (val.match(/:.+(GMT|UTC|[Z+-])/)) {
                val = val.replace(/\s*(?:GMT|UTC)?([+-])(\d\d)(\d\d)$/, "$1$2:$3").replace(/(?:\s+|GMT|UTC)([+-])/, "$1").replace(/(\d)\s*(?:GMT|UTC|Z)$/, "$1+00:00");
              }
              match2 = Date.parse(val);
              if (typeof match2 === "object" && match2 !== null && match2.getTime) {
                ret = match2.getTime() - match2.getTimezoneOffset() * 6e4;
              } else if (isNumber$8(match2)) {
                ret = match2 - new Date(match2).getTimezoneOffset() * 6e4;
              }
            }
          }
          return ret;
        };
        Data2.prototype.rowsToColumns = function(rows) {
          var row, rowsLength, col, colsLength, columns;
          if (rows) {
            columns = [];
            rowsLength = rows.length;
            for (row = 0; row < rowsLength; row++) {
              colsLength = rows[row].length;
              for (col = 0; col < colsLength; col++) {
                if (!columns[col]) {
                  columns[col] = [];
                }
                columns[col][row] = rows[row][col];
              }
            }
          }
          return columns;
        };
        Data2.prototype.getData = function() {
          if (this.columns) {
            return this.rowsToColumns(this.columns).slice(1);
          }
        };
        Data2.prototype.parsed = function() {
          if (this.options.parsed) {
            return this.options.parsed.call(this, this.columns);
          }
        };
        Data2.prototype.getFreeIndexes = function(numberOfColumns, seriesBuilders) {
          var s, i, freeIndexes = [], freeIndexValues = [], referencedIndexes;
          for (i = 0; i < numberOfColumns; i = i + 1) {
            freeIndexes.push(true);
          }
          for (s = 0; s < seriesBuilders.length; s = s + 1) {
            referencedIndexes = seriesBuilders[s].getReferencedColumnIndexes();
            for (i = 0; i < referencedIndexes.length; i = i + 1) {
              freeIndexes[referencedIndexes[i]] = false;
            }
          }
          for (i = 0; i < freeIndexes.length; i = i + 1) {
            if (freeIndexes[i]) {
              freeIndexValues.push(i);
            }
          }
          return freeIndexValues;
        };
        Data2.prototype.complete = function() {
          var columns = this.columns, type, options = this.options, series, data, i, j, r, seriesIndex, chartOptions, allSeriesBuilders = [], builder, freeIndexes, typeCol, index;
          columns.length;
          if (options.complete || options.afterComplete) {
            if (this.firstRowAsNames) {
              for (i = 0; i < columns.length; i++) {
                columns[i].name = columns[i].shift();
              }
            }
            series = [];
            freeIndexes = this.getFreeIndexes(columns.length, this.valueCount.seriesBuilders);
            for (seriesIndex = 0; seriesIndex < this.valueCount.seriesBuilders.length; seriesIndex++) {
              builder = this.valueCount.seriesBuilders[seriesIndex];
              if (builder.populateColumns(freeIndexes)) {
                allSeriesBuilders.push(builder);
              }
            }
            while (freeIndexes.length > 0) {
              builder = new SeriesBuilder();
              builder.addColumnReader(0, "x");
              index = freeIndexes.indexOf(0);
              if (index !== -1) {
                freeIndexes.splice(index, 1);
              }
              for (i = 0; i < this.valueCount.global; i++) {
                builder.addColumnReader(void 0, this.valueCount.globalPointArrayMap[i]);
              }
              if (builder.populateColumns(freeIndexes)) {
                allSeriesBuilders.push(builder);
              }
            }
            if (allSeriesBuilders.length > 0 && allSeriesBuilders[0].readers.length > 0) {
              typeCol = columns[allSeriesBuilders[0].readers[0].columnIndex];
              if (typeof typeCol !== "undefined") {
                if (typeCol.isDatetime) {
                  type = "datetime";
                } else if (!typeCol.isNumeric) {
                  type = "category";
                }
              }
            }
            if (type === "category") {
              for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {
                builder = allSeriesBuilders[seriesIndex];
                for (r = 0; r < builder.readers.length; r++) {
                  if (builder.readers[r].configName === "x") {
                    builder.readers[r].configName = "name";
                  }
                }
              }
            }
            for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {
              builder = allSeriesBuilders[seriesIndex];
              data = [];
              for (j = 0; j < columns[0].length; j++) {
                data[j] = builder.read(columns, j);
              }
              series[seriesIndex] = {
                data
              };
              if (builder.name) {
                series[seriesIndex].name = builder.name;
              }
              if (type === "category") {
                series[seriesIndex].turboThreshold = 0;
              }
            }
            chartOptions = {
              series
            };
            if (type) {
              chartOptions.xAxis = {
                type
              };
              if (type === "category") {
                chartOptions.xAxis.uniqueNames = false;
              }
            }
            if (options.complete) {
              options.complete(chartOptions);
            }
            if (options.afterComplete) {
              options.afterComplete(chartOptions);
            }
          }
        };
        Data2.prototype.update = function(options, redraw) {
          var chart = this.chart;
          if (options) {
            options.afterComplete = function(dataOptions) {
              if (dataOptions) {
                if (dataOptions.xAxis && chart.xAxis[0] && dataOptions.xAxis.type === chart.xAxis[0].options.type) {
                  delete dataOptions.xAxis;
                }
                chart.update(dataOptions, redraw, true);
              }
            };
            merge$h(true, chart.options.data, options);
            this.init(chart.options.data);
          }
        };
        return Data2;
      }()
    );
    H.data = function(dataOptions, chartOptions, chart) {
      return new H.Data(dataOptions, chartOptions, chart);
    };
    addEvent$b(Chart$1, "init", function(e2) {
      var chart = this, userOptions = e2.args[0] || {}, callback = e2.args[1];
      if (userOptions && userOptions.data && !chart.hasDataDef) {
        chart.hasDataDef = true;
        chart.data = new H.Data(extend$m(userOptions.data, {
          afterComplete: function(dataOptions) {
            var i, series;
            if (Object.hasOwnProperty.call(userOptions, "series")) {
              if (typeof userOptions.series === "object") {
                i = Math.max(userOptions.series.length, dataOptions && dataOptions.series ? dataOptions.series.length : 0);
                while (i--) {
                  series = userOptions.series[i] || {};
                  userOptions.series[i] = merge$h(series, dataOptions && dataOptions.series ? dataOptions.series[i] : {});
                }
              } else {
                delete userOptions.series;
              }
            }
            userOptions = merge$h(dataOptions, userOptions);
            chart.init(userOptions, callback);
          }
        }), userOptions, chart);
        e2.preventDefault();
      }
    });
    var SeriesBuilder = (
      /** @class */
      function() {
        function SeriesBuilder2() {
          this.readers = [];
          this.pointIsArray = true;
          this.name = void 0;
        }
        SeriesBuilder2.prototype.populateColumns = function(freeIndexes) {
          var builder = this, enoughColumns = true;
          builder.readers.forEach(function(reader) {
            if (typeof reader.columnIndex === "undefined") {
              reader.columnIndex = freeIndexes.shift();
            }
          });
          builder.readers.forEach(function(reader) {
            if (typeof reader.columnIndex === "undefined") {
              enoughColumns = false;
            }
          });
          return enoughColumns;
        };
        SeriesBuilder2.prototype.read = function(columns, rowIndex) {
          var builder = this, pointIsArray = builder.pointIsArray, point = pointIsArray ? [] : {}, columnIndexes;
          builder.readers.forEach(function(reader) {
            var value = columns[reader.columnIndex][rowIndex];
            if (pointIsArray) {
              point.push(value);
            } else {
              if (reader.configName.indexOf(".") > 0) {
                Point$2.prototype.setNestedProperty(point, value, reader.configName);
              } else {
                point[reader.configName] = value;
              }
            }
          });
          if (typeof this.name === "undefined" && builder.readers.length >= 2) {
            columnIndexes = builder.getReferencedColumnIndexes();
            if (columnIndexes.length >= 2) {
              columnIndexes.shift();
              columnIndexes.sort(function(a, b) {
                return a - b;
              });
              this.name = columns[columnIndexes.shift()].name;
            }
          }
          return point;
        };
        SeriesBuilder2.prototype.addColumnReader = function(columnIndex, configName) {
          this.readers.push({
            columnIndex,
            configName
          });
          if (!(configName === "x" || configName === "y" || typeof configName === "undefined")) {
            this.pointIsArray = false;
          }
        };
        SeriesBuilder2.prototype.getReferencedColumnIndexes = function() {
          var i, referencedColumnIndexes = [], columnReader;
          for (i = 0; i < this.readers.length; i = i + 1) {
            columnReader = this.readers[i];
            if (typeof columnReader.columnIndex !== "undefined") {
              referencedColumnIndexes.push(columnReader.columnIndex);
            }
          }
          return referencedColumnIndexes;
        };
        SeriesBuilder2.prototype.hasReader = function(configName) {
          var i, columnReader;
          for (i = 0; i < this.readers.length; i = i + 1) {
            columnReader = this.readers[i];
            if (columnReader.configName === configName) {
              return true;
            }
          }
        };
        return SeriesBuilder2;
      }()
    );
    H.Data = Data;
    H.Data;
    /**
     * @license Highcharts JS v9.2.2 (2021-08-24)
     * @module highcharts/modules/data
     * @requires highcharts
     *
     * Data module
     *
     * (c) 2012-2021 Torstein Honsi
     *
     * License: www.highcharts.com/license
     */
    var G$2 = H;
    G$2.HttpUtilities = exports$2;
    G$2.ajax = exports$2.ajax;
    G$2.getJSON = exports$2.getJSON;
    G$2.post = exports$2.post;
    var animObject = animationExports.animObject;
    var format$1 = FormatUtilities.format;
    var noop$4 = H.noop;
    var defaultOptions$3 = DefaultOptions.defaultOptions;
    var seriesTypes$1 = SeriesRegistry$1.seriesTypes;
    var addEvent$a = Utilities.addEvent, removeEvent$1 = Utilities.removeEvent, extend$l = Utilities.extend, fireEvent$4 = Utilities.fireEvent, merge$g = Utilities.merge, objectEach$3 = Utilities.objectEach, pick$i = Utilities.pick, syncTimeout = Utilities.syncTimeout;
    var PieSeries$1 = seriesTypes$1.pie, ddSeriesId = 1;
    extend$l(
      defaultOptions$3.lang,
      /**
       * @optionparent lang
       */
      {
        /**
         * The text for the button that appears when drilling down, linking back
         * to the parent series. The parent series' name is inserted for
         * `{series.name}`.
         *
         * @since    3.0.8
         * @product  highcharts highmaps
         * @requires modules/drilldown
         *
         * @private
         */
        drillUpText: " Back to {series.name}"
      }
    );
    defaultOptions$3.drilldown = {
      /**
       * When this option is false, clicking a single point will drill down
       * all points in the same category, equivalent to clicking the X axis
       * label.
       *
       * @sample {highcharts} highcharts/drilldown/allowpointdrilldown-false/
       *         Don't allow point drilldown
       *
       * @type      {boolean}
       * @default   true
       * @since     4.1.7
       * @product   highcharts
       * @apioption drilldown.allowPointDrilldown
       */
      /**
       * An array of series configurations for the drill down. Each series
       * configuration uses the same syntax as the [series](#series) option set.
       * These drilldown series are hidden by default. The drilldown series is
       * linked to the parent series' point by its `id`.
       *
       * @type      {Array<Highcharts.SeriesOptionsType>}
       * @since     3.0.8
       * @product   highcharts highmaps
       * @apioption drilldown.series
       */
      /**
       * Additional styles to apply to the X axis label for a point that
       * has drilldown data. By default it is underlined and blue to invite
       * to interaction.
       *
       * In styled mode, active label styles can be set with the
       * `.highcharts-drilldown-axis-label` class.
       *
       * @sample {highcharts} highcharts/drilldown/labels/
       *         Label styles
       *
       * @type    {Highcharts.CSSObject}
       * @default { "cursor": "pointer", "color": "#003399", "fontWeight": "bold", "textDecoration": "underline" }
       * @since   3.0.8
       * @product highcharts highmaps
       */
      activeAxisLabelStyle: {
        /** @ignore-option */
        cursor: "pointer",
        /** @ignore-option */
        color: palette.highlightColor100,
        /** @ignore-option */
        fontWeight: "bold",
        /** @ignore-option */
        textDecoration: "underline"
      },
      /**
       * Additional styles to apply to the data label of a point that has
       * drilldown data. By default it is underlined and blue to invite to
       * interaction.
       *
       * In styled mode, active data label styles can be applied with the
       * `.highcharts-drilldown-data-label` class.
       *
       * @sample {highcharts} highcharts/drilldown/labels/
       *         Label styles
       *
       * @type    {Highcharts.CSSObject}
       * @default { "cursor": "pointer", "color": "#003399", "fontWeight": "bold", "textDecoration": "underline" }
       * @since   3.0.8
       * @product highcharts highmaps
       */
      activeDataLabelStyle: {
        cursor: "pointer",
        color: palette.highlightColor100,
        fontWeight: "bold",
        textDecoration: "underline"
      },
      /**
       * Set the animation for all drilldown animations. Animation of a drilldown
       * occurs when drilling between a column point and a column series,
       * or a pie slice and a full pie series. Drilldown can still be used
       * between series and points of different types, but animation will
       * not occur.
       *
       * The animation can either be set as a boolean or a configuration
       * object. If `true`, it will use the 'swing' jQuery easing and a duration
       * of 500 ms. If used as a configuration object, the following properties
       * are supported:
       *
       * - `duration`: The duration of the animation in milliseconds.
       *
       * - `easing`: A string reference to an easing function set on the `Math`
       *   object. See
       *   [the easing demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).
       *
       * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}
       * @since   3.0.8
       * @product highcharts highmaps
       */
      animation: {
        /** @internal */
        duration: 500
      },
      /**
       * Options for the drill up button that appears when drilling down on a
       * series. The text for the button is defined in
       * [lang.drillUpText](#lang.drillUpText).
       *
       * @sample {highcharts} highcharts/drilldown/drillupbutton/
       *         Drill up button
       * @sample {highmaps} highcharts/drilldown/drillupbutton/
       *         Drill up button
       *
       * @since   3.0.8
       * @product highcharts highmaps
       */
      drillUpButton: {
        /**
         * What box to align the button to. Can be either `plotBox` or
         * `spacingBox`.
         *
         * @type       {Highcharts.ButtonRelativeToValue}
         * @default    plotBox
         * @since      3.0.8
         * @product    highcharts highmaps
         * @apioption  drilldown.drillUpButton.relativeTo
         */
        /**
         * A collection of attributes for the button. The object takes SVG
         * attributes like `fill`, `stroke`, `stroke-width` or `r`, the border
         * radius. The theme also supports `style`, a collection of CSS
         * properties for the text. Equivalent attributes for the hover state
         * are given in `theme.states.hover`.
         *
         * In styled mode, drill-up button styles can be applied with the
         * `.highcharts-drillup-button` class.
         *
         * @sample {highcharts} highcharts/drilldown/drillupbutton/
         *         Button theming
         * @sample {highmaps} highcharts/drilldown/drillupbutton/
         *         Button theming
         *
         * @type      {object}
         * @since     3.0.8
         * @product   highcharts highmaps
         * @apioption drilldown.drillUpButton.theme
         */
        /**
         * Positioning options for the button within the `relativeTo` box.
         * Available properties are `x`, `y`, `align` and `verticalAlign`.
         *
         * @type    {Highcharts.AlignObject}
         * @since   3.0.8
         * @product highcharts highmaps
         */
        position: {
          /**
           * Vertical alignment of the button.
           *
           * @type      {Highcharts.VerticalAlignValue}
           * @default   top
           * @product   highcharts highmaps
           * @apioption drilldown.drillUpButton.position.verticalAlign
           */
          /**
           * Horizontal alignment.
           *
           * @type {Highcharts.AlignValue}
           */
          align: "right",
          /**
           * The X offset of the button.
           */
          x: -10,
          /**
           * The Y offset of the button.
           */
          y: 10
        }
      }
    };
    SVGRenderer.prototype.Element.prototype.fadeIn = function(animation) {
      this.attr({
        opacity: 0.1,
        visibility: "inherit"
      }).animate({
        opacity: pick$i(this.newOpacity, 1)
        // newOpacity used in maps
      }, animation || {
        duration: 250
      });
    };
    Chart$1.prototype.addSeriesAsDrilldown = function(point, options) {
      this.addSingleSeriesAsDrilldown(point, options);
      this.applyDrilldown();
    };
    Chart$1.prototype.addSingleSeriesAsDrilldown = function(point, ddOptions) {
      var oldSeries = point.series, xAxis = oldSeries.xAxis, yAxis = oldSeries.yAxis, newSeries, pointIndex, levelSeries = [], levelSeriesOptions = [], level, levelNumber, last, colorProp;
      colorProp = this.styledMode ? { colorIndex: pick$i(point.colorIndex, oldSeries.colorIndex) } : { color: point.color || oldSeries.color };
      if (!this.drilldownLevels) {
        this.drilldownLevels = [];
      }
      levelNumber = oldSeries.options._levelNumber || 0;
      last = this.drilldownLevels[this.drilldownLevels.length - 1];
      if (last && last.levelNumber !== levelNumber) {
        last = void 0;
      }
      ddOptions = extend$l(extend$l({
        _ddSeriesId: ddSeriesId++
      }, colorProp), ddOptions);
      pointIndex = oldSeries.points.indexOf(point);
      oldSeries.chart.series.forEach(function(series) {
        if (series.xAxis === xAxis && !series.isDrilling) {
          series.options._ddSeriesId = series.options._ddSeriesId || ddSeriesId++;
          series.options._colorIndex = series.userOptions._colorIndex;
          series.options._levelNumber = series.options._levelNumber || levelNumber;
          if (last) {
            levelSeries = last.levelSeries;
            levelSeriesOptions = last.levelSeriesOptions;
          } else {
            levelSeries.push(series);
            series.purgedOptions = merge$g({
              _ddSeriesId: series.options._ddSeriesId,
              _levelNumber: series.options._levelNumber,
              selected: series.options.selected
            }, series.userOptions);
            levelSeriesOptions.push(series.purgedOptions);
          }
        }
      });
      level = extend$l({
        levelNumber,
        seriesOptions: oldSeries.options,
        seriesPurgedOptions: oldSeries.purgedOptions,
        levelSeriesOptions,
        levelSeries,
        shapeArgs: point.shapeArgs,
        // no graphic in line series with markers disabled
        bBox: point.graphic ? point.graphic.getBBox() : {},
        color: point.isNull ? Color.parse(colorProp.color).setOpacity(0).get() : colorProp.color,
        lowerSeriesOptions: ddOptions,
        pointOptions: oldSeries.options.data[pointIndex],
        pointIndex,
        oldExtremes: {
          xMin: xAxis && xAxis.userMin,
          xMax: xAxis && xAxis.userMax,
          yMin: yAxis && yAxis.userMin,
          yMax: yAxis && yAxis.userMax
        },
        resetZoomButton: this.resetZoomButton
      }, colorProp);
      this.drilldownLevels.push(level);
      if (xAxis && xAxis.names) {
        xAxis.names.length = 0;
      }
      newSeries = level.lowerSeries = this.addSeries(ddOptions, false);
      newSeries.options._levelNumber = levelNumber + 1;
      if (xAxis) {
        xAxis.oldPos = xAxis.pos;
        xAxis.userMin = xAxis.userMax = null;
        yAxis.userMin = yAxis.userMax = null;
      }
      if (oldSeries.type === newSeries.type) {
        newSeries.animate = newSeries.animateDrilldown || noop$4;
        newSeries.options.animation = true;
      }
    };
    Chart$1.prototype.applyDrilldown = function() {
      var drilldownLevels = this.drilldownLevels, levelToRemove;
      if (drilldownLevels && drilldownLevels.length > 0) {
        levelToRemove = drilldownLevels[drilldownLevels.length - 1].levelNumber;
        this.drilldownLevels.forEach(function(level) {
          if (level.levelNumber === levelToRemove) {
            level.levelSeries.forEach(function(series) {
              if (series.options && series.options._levelNumber === levelToRemove) {
                series.remove(false);
              }
            });
          }
        });
      }
      if (this.resetZoomButton) {
        this.resetZoomButton.hide();
        delete this.resetZoomButton;
      }
      this.pointer.reset();
      this.redraw();
      this.showDrillUpButton();
      fireEvent$4(this, "afterDrilldown");
    };
    Chart$1.prototype.getDrilldownBackText = function() {
      var drilldownLevels = this.drilldownLevels, lastLevel;
      if (drilldownLevels && drilldownLevels.length > 0) {
        lastLevel = drilldownLevels[drilldownLevels.length - 1];
        lastLevel.series = lastLevel.seriesOptions;
        return format$1(this.options.lang.drillUpText || "", lastLevel);
      }
    };
    Chart$1.prototype.showDrillUpButton = function() {
      var chart = this, backText = this.getDrilldownBackText(), buttonOptions = chart.options.drilldown.drillUpButton, attr2, states, alignTo = buttonOptions.relativeTo === "chart" || buttonOptions.relativeTo === "spacingBox" ? null : "scrollablePlotBox";
      if (!this.drillUpButton) {
        attr2 = buttonOptions.theme;
        states = attr2 && attr2.states;
        this.drillUpButton = this.renderer.button(backText, null, null, function() {
          chart.drillUp();
        }, attr2, states && states.hover, states && states.select).addClass("highcharts-drillup-button").attr({
          align: buttonOptions.position.align,
          zIndex: 7
        }).add().align(buttonOptions.position, false, alignTo);
      } else {
        this.drillUpButton.attr({
          text: backText
        }).align();
      }
    };
    Chart$1.prototype.drillUp = function() {
      if (!this.drilldownLevels || this.drilldownLevels.length === 0) {
        return;
      }
      var chart = this, drilldownLevels = chart.drilldownLevels, levelNumber = drilldownLevels[drilldownLevels.length - 1].levelNumber, i = drilldownLevels.length, chartSeries = chart.series, seriesI, level, oldSeries, newSeries, oldExtremes, addSeries = function(seriesOptions) {
        var addedSeries;
        chartSeries.forEach(function(series) {
          if (series.options._ddSeriesId === seriesOptions._ddSeriesId) {
            addedSeries = series;
          }
        });
        addedSeries = addedSeries || chart.addSeries(seriesOptions, false);
        if (addedSeries.type === oldSeries.type && addedSeries.animateDrillupTo) {
          addedSeries.animate = addedSeries.animateDrillupTo;
        }
        if (seriesOptions === level.seriesPurgedOptions) {
          newSeries = addedSeries;
        }
      };
      while (i--) {
        level = drilldownLevels[i];
        if (level.levelNumber === levelNumber) {
          drilldownLevels.pop();
          oldSeries = level.lowerSeries;
          if (!oldSeries.chart) {
            seriesI = chartSeries.length;
            while (seriesI--) {
              if (chartSeries[seriesI].options.id === level.lowerSeriesOptions.id && chartSeries[seriesI].options._levelNumber === levelNumber + 1) {
                oldSeries = chartSeries[seriesI];
                break;
              }
            }
          }
          oldSeries.xData = [];
          level.levelSeriesOptions.forEach(addSeries);
          fireEvent$4(chart, "drillup", {
            seriesOptions: level.seriesPurgedOptions || level.seriesOptions
          });
          this.resetZoomButton && this.resetZoomButton.destroy();
          if (newSeries.type === oldSeries.type) {
            newSeries.drilldownLevel = level;
            newSeries.options.animation = chart.options.drilldown.animation;
            if (oldSeries.animateDrillupFrom && oldSeries.chart) {
              oldSeries.animateDrillupFrom(level);
            }
          }
          newSeries.options._levelNumber = levelNumber;
          oldSeries.remove(false);
          if (newSeries.xAxis) {
            oldExtremes = level.oldExtremes;
            newSeries.xAxis.setExtremes(oldExtremes.xMin, oldExtremes.xMax, false);
            newSeries.yAxis.setExtremes(oldExtremes.yMin, oldExtremes.yMax, false);
          }
          if (level.resetZoomButton) {
            chart.resetZoomButton = level.resetZoomButton;
            chart.resetZoomButton.show();
          }
        }
      }
      this.redraw();
      if (this.drilldownLevels.length === 0) {
        this.drillUpButton = this.drillUpButton.destroy();
      } else {
        this.drillUpButton.attr({
          text: this.getDrilldownBackText()
        }).align();
      }
      this.ddDupes.length = [];
      fireEvent$4(chart, "drillupall");
    };
    addEvent$a(Chart$1, "afterInit", function() {
      var chart = this;
      chart.drilldown = {
        update: function(options, redraw) {
          merge$g(true, chart.options.drilldown, options);
          if (pick$i(redraw, true)) {
            chart.redraw();
          }
        }
      };
    });
    addEvent$a(Chart$1, "afterShowResetZoom", function() {
      var chart = this, bbox = chart.resetZoomButton && chart.resetZoomButton.getBBox(), buttonOptions = chart.options.drilldown && chart.options.drilldown.drillUpButton;
      if (this.drillUpButton && bbox && buttonOptions && buttonOptions.position && buttonOptions.position.x) {
        this.drillUpButton.align({
          x: buttonOptions.position.x - bbox.width - 10,
          y: buttonOptions.position.y,
          align: buttonOptions.position.align
        }, false, buttonOptions.relativeTo || "plotBox");
      }
    });
    addEvent$a(Chart$1, "render", function() {
      (this.xAxis || []).forEach(function(axis) {
        axis.ddPoints = {};
        axis.series.forEach(function(series) {
          var i, xData = series.xData || [], points = series.points, p;
          for (i = 0; i < xData.length; i++) {
            p = series.options.data[i];
            if (typeof p !== "number") {
              p = series.pointClass.prototype.optionsToObject.call({ series }, p);
              if (p.drilldown) {
                if (!axis.ddPoints[xData[i]]) {
                  axis.ddPoints[xData[i]] = [];
                }
                var index = i - (series.cropStart || 0);
                axis.ddPoints[xData[i]].push(points && index >= 0 && index < points.length ? points[index] : true);
              }
            }
          }
        });
        objectEach$3(axis.ticks, Tick.prototype.drillable);
      });
    });
    ColumnSeries$h.prototype.animateDrillupTo = function(init) {
      if (!init) {
        var newSeries_1 = this, level_1 = newSeries_1.drilldownLevel;
        this.points.forEach(function(point) {
          var dataLabel = point.dataLabel;
          if (point.graphic) {
            point.graphic.hide();
          }
          if (dataLabel) {
            dataLabel.hidden = dataLabel.attr("visibility") === "hidden";
            if (!dataLabel.hidden) {
              dataLabel.hide();
              if (point.connector) {
                point.connector.hide();
              }
            }
          }
        });
        syncTimeout(function() {
          if (newSeries_1.points) {
            var pointsWithNodes_1 = [];
            newSeries_1.data.forEach(function(el) {
              pointsWithNodes_1.push(el);
            });
            if (newSeries_1.nodes) {
              pointsWithNodes_1 = pointsWithNodes_1.concat(newSeries_1.nodes);
            }
            pointsWithNodes_1.forEach(function(point, i) {
              var verb = i === (level_1 && level_1.pointIndex) ? "show" : "fadeIn", inherit = verb === "show" ? true : void 0, dataLabel = point.dataLabel;
              if (point.graphic) {
                point.graphic[verb](inherit);
              }
              if (dataLabel && !dataLabel.hidden) {
                dataLabel.fadeIn();
                if (point.connector) {
                  point.connector.fadeIn();
                }
              }
            });
          }
        }, Math.max(this.chart.options.drilldown.animation.duration - 50, 0));
        delete this.animate;
      }
    };
    ColumnSeries$h.prototype.animateDrilldown = function(init) {
      var series = this, chart = this.chart, drilldownLevels = chart.drilldownLevels, animateFrom, animationOptions = animObject(chart.options.drilldown.animation), xAxis = this.xAxis, styledMode = chart.styledMode;
      if (!init) {
        drilldownLevels.forEach(function(level) {
          if (series.options._ddSeriesId === level.lowerSeriesOptions._ddSeriesId) {
            animateFrom = level.shapeArgs;
            if (!styledMode) {
              animateFrom.fill = level.color;
            }
          }
        });
        animateFrom.x += pick$i(xAxis.oldPos, xAxis.pos) - xAxis.pos;
        this.points.forEach(function(point) {
          var animateTo = point.shapeArgs;
          if (!styledMode) {
            animateTo.fill = point.color;
          }
          if (point.graphic) {
            point.graphic.attr(animateFrom).animate(extend$l(point.shapeArgs, { fill: point.color || series.color }), animationOptions);
          }
          if (point.dataLabel) {
            point.dataLabel.fadeIn(animationOptions);
          }
        });
        delete this.animate;
      }
    };
    ColumnSeries$h.prototype.animateDrillupFrom = function(level) {
      var animationOptions = animObject(this.chart.options.drilldown.animation), group = this.group, removeGroup = group !== this.chart.columnGroup, series = this;
      series.trackerGroups.forEach(function(key) {
        if (series[key]) {
          series[key].on("mouseover");
        }
      });
      if (removeGroup) {
        delete this.group;
      }
      this.points.forEach(function(point) {
        var graphic = point.graphic, animateTo = level.shapeArgs, complete = function() {
          graphic.destroy();
          if (group && removeGroup) {
            group = group.destroy();
          }
        };
        if (graphic && animateTo) {
          delete point.graphic;
          if (!series.chart.styledMode) {
            animateTo.fill = level.color;
          }
          if (animationOptions.duration) {
            graphic.animate(animateTo, merge$g(animationOptions, { complete }));
          } else {
            graphic.attr(animateTo);
            complete();
          }
        }
      });
    };
    if (PieSeries$1) {
      extend$l(PieSeries$1.prototype, {
        animateDrillupTo: ColumnSeries$h.prototype.animateDrillupTo,
        animateDrillupFrom: ColumnSeries$h.prototype.animateDrillupFrom,
        animateDrilldown: function(init) {
          var level = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1], animationOptions = this.chart.options.drilldown.animation;
          if (this.is("item")) {
            animationOptions.duration = 0;
          }
          if (this.center) {
            var animateFrom_1 = level.shapeArgs, start_1 = animateFrom_1.start, angle = animateFrom_1.end - start_1, startAngle_1 = angle / this.points.length, styledMode_1 = this.chart.styledMode;
            if (!init) {
              this.points.forEach(function(point, i) {
                var animateTo = point.shapeArgs;
                if (!styledMode_1) {
                  animateFrom_1.fill = level.color;
                  animateTo.fill = point.color;
                }
                if (point.graphic) {
                  point.graphic.attr(merge$g(animateFrom_1, {
                    start: start_1 + i * startAngle_1,
                    end: start_1 + (i + 1) * startAngle_1
                  }))[animationOptions ? "animate" : "attr"](animateTo, animationOptions);
                }
              });
              delete this.animate;
            }
          }
        }
      });
    }
    Point$2.prototype.doDrilldown = function() {
      this.runDrilldown();
    };
    Point$2.prototype.runDrilldown = function(holdRedraw, category, originalEvent) {
      var series = this.series, chart = series.chart, drilldown = chart.options.drilldown;
      var i = (drilldown.series || []).length, seriesOptions;
      if (!chart.ddDupes) {
        chart.ddDupes = [];
      }
      while (i-- && !seriesOptions) {
        if (drilldown.series[i].id === this.drilldown && chart.ddDupes.indexOf(this.drilldown) === -1) {
          seriesOptions = drilldown.series[i];
          chart.ddDupes.push(this.drilldown);
        }
      }
      fireEvent$4(chart, "drilldown", {
        point: this,
        seriesOptions,
        category,
        originalEvent,
        points: typeof category !== "undefined" && this.series.xAxis.getDDPoints(category).slice(0)
      }, function(e2) {
        var chart2 = e2.point.series && e2.point.series.chart, seriesOptions2 = e2.seriesOptions;
        if (chart2 && seriesOptions2) {
          if (holdRedraw) {
            chart2.addSingleSeriesAsDrilldown(e2.point, seriesOptions2);
          } else {
            chart2.addSeriesAsDrilldown(e2.point, seriesOptions2);
          }
        }
      });
    };
    Axis.prototype.drilldownCategory = function(x, originalEvent) {
      this.getDDPoints(x).forEach(function(point) {
        if (point && point.series && point.series.visible && point.runDrilldown) {
          point.runDrilldown(true, x, originalEvent);
        }
      });
      this.chart.applyDrilldown();
    };
    Axis.prototype.getDDPoints = function(x) {
      return this.ddPoints && this.ddPoints[x] || [];
    };
    Tick.prototype.drillable = function() {
      var pos = this.pos, label = this.label, axis = this.axis, isDrillable = axis.coll === "xAxis" && axis.getDDPoints, ddPointsX = isDrillable && axis.getDDPoints(pos), styledMode = axis.chart.styledMode;
      if (isDrillable) {
        if (label && ddPointsX && ddPointsX.length) {
          label.drillable = true;
          if (!label.basicStyles && !styledMode) {
            label.basicStyles = merge$g(label.styles);
          }
          label.addClass("highcharts-drilldown-axis-label");
          if (label.removeOnDrillableClick) {
            removeEvent$1(label.element, "click");
          }
          label.removeOnDrillableClick = addEvent$a(label.element, "click", function(e2) {
            e2.preventDefault();
            axis.drilldownCategory(pos, e2);
          });
          if (!styledMode) {
            label.css(axis.chart.options.drilldown.activeAxisLabelStyle);
          }
        } else if (label && label.drillable && label.removeOnDrillableClick) {
          if (!styledMode) {
            label.styles = {};
            label.css(label.basicStyles);
          }
          label.removeOnDrillableClick();
          label.removeClass("highcharts-drilldown-axis-label");
        }
      }
    };
    addEvent$a(Point$2, "afterInit", function() {
      var point = this;
      if (point.drilldown && !point.unbindDrilldownClick) {
        point.unbindDrilldownClick = addEvent$a(point, "click", handlePointClick);
      }
      return point;
    });
    addEvent$a(Point$2, "update", function(e2) {
      var point = this, options = e2.options || {};
      if (options.drilldown && !point.unbindDrilldownClick) {
        point.unbindDrilldownClick = addEvent$a(point, "click", handlePointClick);
      } else if (!options.drilldown && options.drilldown !== void 0 && point.unbindDrilldownClick) {
        point.unbindDrilldownClick = point.unbindDrilldownClick();
      }
    });
    var handlePointClick = function(e2) {
      var point = this, series = point.series;
      if (series.xAxis && series.chart.options.drilldown.allowPointDrilldown === false) {
        series.xAxis.drilldownCategory(point.x, e2);
      } else {
        point.runDrilldown(void 0, void 0, e2);
      }
    };
    addEvent$a(Series$e, "afterDrawDataLabels", function() {
      var css2 = this.chart.options.drilldown.activeDataLabelStyle, renderer = this.chart.renderer, styledMode = this.chart.styledMode;
      this.points.forEach(function(point) {
        var dataLabelsOptions = point.options.dataLabels, pointCSS = pick$i(point.dlOptions, dataLabelsOptions && dataLabelsOptions.style, {});
        if (point.drilldown && point.dataLabel) {
          if (css2.color === "contrast" && !styledMode) {
            pointCSS.color = renderer.getContrast(point.color || this.color);
          }
          if (dataLabelsOptions && dataLabelsOptions.color) {
            pointCSS.color = dataLabelsOptions.color;
          }
          point.dataLabel.addClass("highcharts-drilldown-data-label");
          if (!styledMode) {
            point.dataLabel.css(css2).css(pointCSS);
          }
        }
      }, this);
    });
    var applyCursorCSS = function(element, cursor, addClass2, styledMode) {
      element[addClass2 ? "addClass" : "removeClass"]("highcharts-drilldown-point");
      if (!styledMode) {
        element.css({ cursor });
      }
    };
    addEvent$a(Series$e, "afterDrawTracker", function() {
      var styledMode = this.chart.styledMode;
      this.points.forEach(function(point) {
        if (point.drilldown && point.graphic) {
          applyCursorCSS(point.graphic, "pointer", true, styledMode);
        }
      });
    });
    addEvent$a(Point$2, "afterSetState", function() {
      var styledMode = this.series.chart.styledMode;
      if (this.drilldown && this.series.halo && this.state === "hover") {
        applyCursorCSS(this.series.halo, "pointer", true, styledMode);
      } else if (this.series.halo) {
        applyCursorCSS(this.series.halo, "auto", false, styledMode);
      }
    });
    addEvent$a(Chart$1, "selection", function(event) {
      if (event.resetSelection === true && this.drillUpButton) {
        var buttonOptions = this.options.drilldown && this.options.drilldown.drillUpButton;
        if (buttonOptions && buttonOptions.position) {
          this.drillUpButton.align({
            x: buttonOptions.position.x,
            y: buttonOptions.position.y,
            align: buttonOptions.position.align
          }, false, buttonOptions.relativeTo || "plotBox");
        }
      }
    });
    addEvent$a(Chart$1, "drillup", function() {
      if (this.resetZoomButton) {
        this.resetZoomButton = this.resetZoomButton.destroy();
      }
    });
    H.doc;
    var addEvent$9 = Utilities.addEvent;
    var Fullscreen = (
      /** @class */
      function() {
        function Fullscreen2(chart) {
          this.chart = chart;
          this.isOpen = false;
          var container = chart.renderTo;
          if (!this.browserProps) {
            if (typeof container.requestFullscreen === "function") {
              this.browserProps = {
                fullscreenChange: "fullscreenchange",
                requestFullscreen: "requestFullscreen",
                exitFullscreen: "exitFullscreen"
              };
            } else if (container.mozRequestFullScreen) {
              this.browserProps = {
                fullscreenChange: "mozfullscreenchange",
                requestFullscreen: "mozRequestFullScreen",
                exitFullscreen: "mozCancelFullScreen"
              };
            } else if (container.webkitRequestFullScreen) {
              this.browserProps = {
                fullscreenChange: "webkitfullscreenchange",
                requestFullscreen: "webkitRequestFullScreen",
                exitFullscreen: "webkitExitFullscreen"
              };
            } else if (container.msRequestFullscreen) {
              this.browserProps = {
                fullscreenChange: "MSFullscreenChange",
                requestFullscreen: "msRequestFullscreen",
                exitFullscreen: "msExitFullscreen"
              };
            }
          }
        }
        Fullscreen2.prototype.close = function() {
          var fullscreen = this, chart = fullscreen.chart, optionsChart = chart.options.chart;
          if (fullscreen.isOpen && fullscreen.browserProps && chart.container.ownerDocument instanceof Document) {
            chart.container.ownerDocument[fullscreen.browserProps.exitFullscreen]();
          }
          if (fullscreen.unbindFullscreenEvent) {
            fullscreen.unbindFullscreenEvent = fullscreen.unbindFullscreenEvent();
          }
          chart.setSize(fullscreen.origWidth, fullscreen.origHeight, false);
          fullscreen.origWidth = void 0;
          fullscreen.origHeight = void 0;
          optionsChart.width = fullscreen.origWidthOption;
          optionsChart.height = fullscreen.origHeightOption;
          fullscreen.origWidthOption = void 0;
          fullscreen.origHeightOption = void 0;
          fullscreen.isOpen = false;
          fullscreen.setButtonText();
        };
        Fullscreen2.prototype.open = function() {
          var fullscreen = this, chart = fullscreen.chart, optionsChart = chart.options.chart;
          if (optionsChart) {
            fullscreen.origWidthOption = optionsChart.width;
            fullscreen.origHeightOption = optionsChart.height;
          }
          fullscreen.origWidth = chart.chartWidth;
          fullscreen.origHeight = chart.chartHeight;
          if (fullscreen.browserProps) {
            var unbindChange_1 = addEvent$9(
              chart.container.ownerDocument,
              // chart's document
              fullscreen.browserProps.fullscreenChange,
              function() {
                if (fullscreen.isOpen) {
                  fullscreen.isOpen = false;
                  fullscreen.close();
                } else {
                  chart.setSize(null, null, false);
                  fullscreen.isOpen = true;
                  fullscreen.setButtonText();
                }
              }
            );
            var unbindDestroy_1 = addEvent$9(chart, "destroy", unbindChange_1);
            fullscreen.unbindFullscreenEvent = function() {
              unbindChange_1();
              unbindDestroy_1();
            };
            var promise = chart.renderTo[fullscreen.browserProps.requestFullscreen]();
            if (promise) {
              promise["catch"](function() {
                alert(
                  // eslint-disable-line no-alert
                  "Full screen is not supported inside a frame."
                );
              });
            }
          }
        };
        Fullscreen2.prototype.setButtonText = function() {
          var chart = this.chart, exportDivElements = chart.exportDivElements, exportingOptions = chart.options.exporting, menuItems = exportingOptions && exportingOptions.buttons && exportingOptions.buttons.contextButton.menuItems, lang2 = chart.options.lang;
          if (exportingOptions && exportingOptions.menuItemDefinitions && lang2 && lang2.exitFullscreen && lang2.viewFullscreen && menuItems && exportDivElements) {
            var exportDivElement = exportDivElements[menuItems.indexOf("viewFullscreen")];
            if (exportDivElement) {
              AST.setElementHTML(exportDivElement, !this.isOpen ? exportingOptions.menuItemDefinitions.viewFullscreen.text || lang2.viewFullscreen : lang2.exitFullscreen);
            }
          }
        };
        Fullscreen2.prototype.toggle = function() {
          var fullscreen = this;
          if (!fullscreen.isOpen) {
            fullscreen.open();
          } else {
            fullscreen.close();
          }
        };
        return Fullscreen2;
      }()
    );
    H.Fullscreen = Fullscreen;
    H.Fullscreen;
    addEvent$9(Chart$1, "beforeRender", function() {
      this.fullscreen = new H.Fullscreen(this);
    });
    var isTouchDevice = H.isTouchDevice;
    var exporting = {
      /**
       * Experimental setting to allow HTML inside the chart (added through
       * the `useHTML` options), directly in the exported image. This allows
       * you to preserve complicated HTML structures like tables or bi-directional
       * text in exported charts.
       *
       * Disclaimer: The HTML is rendered in a `foreignObject` tag in the
       * generated SVG. The official export server is based on PhantomJS,
       * which supports this, but other SVG clients, like Batik, does not
       * support it. This also applies to downloaded SVG that you want to
       * open in a desktop client.
       *
       * @type      {boolean}
       * @default   false
       * @since     4.1.8
       * @apioption exporting.allowHTML
       */
      /**
       * Additional chart options to be merged into the chart before exporting to
       * an image format. This does not apply to printing the chart via the export
       * menu.
       *
       * For example, a common use case is to add data labels to improve
       * readability of the exported chart, or to add a printer-friendly color
       * scheme to exported PDFs.
       *
       * @sample {highcharts} highcharts/exporting/chartoptions-data-labels/
       *         Added data labels
       * @sample {highstock} highcharts/exporting/chartoptions-data-labels/
       *         Added data labels
       *
       * @type      {Highcharts.Options}
       * @apioption exporting.chartOptions
       */
      /**
       * Whether to enable the exporting module. Disabling the module will
       * hide the context button, but API methods will still be available.
       *
       * @sample {highcharts} highcharts/exporting/enabled-false/
       *         Exporting module is loaded but disabled
       * @sample {highstock} highcharts/exporting/enabled-false/
       *         Exporting module is loaded but disabled
       *
       * @type      {boolean}
       * @default   true
       * @since     2.0
       * @apioption exporting.enabled
       */
      /**
       * Function to call if the offline-exporting module fails to export
       * a chart on the client side, and [fallbackToExportServer](
       * #exporting.fallbackToExportServer) is disabled. If left undefined, an
       * exception is thrown instead. Receives two parameters, the exporting
       * options, and the error from the module.
       *
       * @see [fallbackToExportServer](#exporting.fallbackToExportServer)
       *
       * @type      {Highcharts.ExportingErrorCallbackFunction}
       * @since     5.0.0
       * @requires  modules/exporting
       * @requires  modules/offline-exporting
       * @apioption exporting.error
       */
      /**
       * Whether or not to fall back to the export server if the offline-exporting
       * module is unable to export the chart on the client side. This happens for
       * certain browsers, and certain features (e.g.
       * [allowHTML](#exporting.allowHTML)), depending on the image type exporting
       * to. For very complex charts, it is possible that export can fail in
       * browsers that don't support Blob objects, due to data URL length limits.
       * It is recommended to define the [exporting.error](#exporting.error)
       * handler if disabling fallback, in order to notify users in case export
       * fails.
       *
       * @type      {boolean}
       * @default   true
       * @since     4.1.8
       * @requires  modules/exporting
       * @requires  modules/offline-exporting
       * @apioption exporting.fallbackToExportServer
       */
      /**
       * The filename, without extension, to use for the exported chart.
       *
       * @sample {highcharts} highcharts/exporting/filename/
       *         Custom file name
       * @sample {highstock} highcharts/exporting/filename/
       *         Custom file name
       *
       * @type      {string}
       * @default   chart
       * @since     2.0
       * @apioption exporting.filename
       */
      /**
       * An object containing additional key value data for the POST form that
       * sends the SVG to the export server. For example, a `target` can be set to
       * make sure the generated image is received in another frame, or a custom
       * `enctype` or `encoding` can be set.
       *
       * @type      {Highcharts.HTMLAttributes}
       * @since     3.0.8
       * @apioption exporting.formAttributes
       */
      /**
       * Path where Highcharts will look for export module dependencies to
       * load on demand if they don't already exist on `window`. Should currently
       * point to location of [CanVG](https://github.com/canvg/canvg) library,
       * [jsPDF](https://github.com/yWorks/jsPDF) and
       * [svg2pdf.js](https://github.com/yWorks/svg2pdf.js), required for client
       * side export in certain browsers.
       *
       * @type      {string}
       * @default   https://code.highcharts.com/{version}/lib
       * @since     5.0.0
       * @apioption exporting.libURL
       */
      /**
       * Analogous to [sourceWidth](#exporting.sourceWidth).
       *
       * @type      {number}
       * @since     3.0
       * @apioption exporting.sourceHeight
       */
      /**
       * The width of the original chart when exported, unless an explicit
       * [chart.width](#chart.width) is set, or a pixel width is set on the
       * container. The width exported raster image is then multiplied by
       * [scale](#exporting.scale).
       *
       * @sample {highcharts} highcharts/exporting/sourcewidth/
       *         Source size demo
       * @sample {highstock} highcharts/exporting/sourcewidth/
       *         Source size demo
       * @sample {highmaps} maps/exporting/sourcewidth/
       *         Source size demo
       *
       * @type      {number}
       * @since     3.0
       * @apioption exporting.sourceWidth
       */
      /**
       * The pixel width of charts exported to PNG or JPG. As of Highcharts
       * 3.0, the default pixel width is a function of the [chart.width](
       * #chart.width) or [exporting.sourceWidth](#exporting.sourceWidth) and the
       * [exporting.scale](#exporting.scale).
       *
       * @sample {highcharts} highcharts/exporting/width/
       *         Export to 200px wide images
       * @sample {highstock} highcharts/exporting/width/
       *         Export to 200px wide images
       *
       * @type      {number}
       * @since     2.0
       * @apioption exporting.width
       */
      /**
       * Default MIME type for exporting if `chart.exportChart()` is called
       * without specifying a `type` option. Possible values are `image/png`,
       *  `image/jpeg`, `application/pdf` and `image/svg+xml`.
       *
       * @type  {Highcharts.ExportingMimeTypeValue}
       * @since 2.0
       */
      type: "image/png",
      /**
       * The URL for the server module converting the SVG string to an image
       * format. By default this points to Highchart's free web service.
       *
       * @since 2.0
       */
      url: "https://export.highcharts.com/",
      /**
       * When printing the chart from the menu item in the burger menu, if
       * the on-screen chart exceeds this width, it is resized. After printing
       * or cancelled, it is restored. The default width makes the chart
       * fit into typical paper format. Note that this does not affect the
       * chart when printing the web page as a whole.
       *
       * @since 4.2.5
       */
      printMaxWidth: 780,
      /**
       * Defines the scale or zoom factor for the exported image compared
       * to the on-screen display. While for instance a 600px wide chart
       * may look good on a website, it will look bad in print. The default
       * scale of 2 makes this chart export to a 1200px PNG or JPG.
       *
       * @see [chart.width](#chart.width)
       * @see [exporting.sourceWidth](#exporting.sourceWidth)
       *
       * @sample {highcharts} highcharts/exporting/scale/
       *         Scale demonstrated
       * @sample {highstock} highcharts/exporting/scale/
       *         Scale demonstrated
       * @sample {highmaps} maps/exporting/scale/
       *         Scale demonstrated
       *
       * @since 3.0
       */
      scale: 2,
      /**
       * Options for the export related buttons, print and export. In addition
       * to the default buttons listed here, custom buttons can be added.
       * See [navigation.buttonOptions](#navigation.buttonOptions) for general
       * options.
       *
       * @type     {Highcharts.Dictionary<*>}
       * @requires modules/exporting
       */
      buttons: {
        /**
         * Options for the export button.
         *
         * In styled mode, export button styles can be applied with the
         * `.highcharts-contextbutton` class.
         *
         * @declare  Highcharts.ExportingButtonsOptionsObject
         * @extends  navigation.buttonOptions
         * @requires modules/exporting
         */
        contextButton: {
          /**
           * A click handler callback to use on the button directly instead of
           * the popup menu.
           *
           * @sample highcharts/exporting/buttons-contextbutton-onclick/
           *         Skip the menu and export the chart directly
           *
           * @type      {Function}
           * @since     2.0
           * @apioption exporting.buttons.contextButton.onclick
           */
          /**
           * See [navigation.buttonOptions.symbolFill](
           * #navigation.buttonOptions.symbolFill).
           *
           * @type      {Highcharts.ColorString}
           * @default   #666666
           * @since     2.0
           * @apioption exporting.buttons.contextButton.symbolFill
           */
          /**
           * The horizontal position of the button relative to the `align`
           * option.
           *
           * @type      {number}
           * @default   -10
           * @since     2.0
           * @apioption exporting.buttons.contextButton.x
           */
          /**
           * The class name of the context button.
           */
          className: "highcharts-contextbutton",
          /**
           * The class name of the menu appearing from the button.
           */
          menuClassName: "highcharts-contextmenu",
          /**
           * The symbol for the button. Points to a definition function in
           * the `Highcharts.Renderer.symbols` collection. The default
           * `menu` function is part of the exporting module. Possible
           * values are "circle", "square", "diamond", "triangle",
           * "triangle-down", "menu", "menuball" or custom shape.
           *
           * @sample highcharts/exporting/buttons-contextbutton-symbol/
           *         Use a circle for symbol
           * @sample highcharts/exporting/buttons-contextbutton-symbol-custom/
           *         Custom shape as symbol
           *
           * @type  {Highcharts.SymbolKeyValue|"menu"|"menuball"|string}
           * @since 2.0
           */
          symbol: "menu",
          /**
           * The key to a [lang](#lang) option setting that is used for the
           * button's title tooltip. When the key is `contextButtonTitle`, it
           * refers to [lang.contextButtonTitle](#lang.contextButtonTitle)
           * that defaults to "Chart context menu".
           *
           * @since 6.1.4
           */
          titleKey: "contextButtonTitle",
          /**
           * This option is deprecated, use
           * [titleKey](#exporting.buttons.contextButton.titleKey) instead.
           *
           * @deprecated
           * @type      {string}
           * @apioption exporting.buttons.contextButton._titleKey
           */
          /**
           * A collection of strings pointing to config options for the menu
           * items. The config options are defined in the
           * `menuItemDefinitions` option.
           *
           * By default, there is the "View in full screen" and "Print" menu
           * items, plus one menu item for each of the available export types.
           *
           * @sample {highcharts} highcharts/exporting/menuitemdefinitions/
           *         Menu item definitions
           * @sample {highstock} highcharts/exporting/menuitemdefinitions/
           *         Menu item definitions
           * @sample {highmaps} highcharts/exporting/menuitemdefinitions/
           *         Menu item definitions
           *
           * @type    {Array<string>}
           * @default ["viewFullscreen", "printChart", "separator", "downloadPNG", "downloadJPEG", "downloadPDF", "downloadSVG"]
           * @since   2.0
           */
          menuItems: [
            "viewFullscreen",
            "printChart",
            "separator",
            "downloadPNG",
            "downloadJPEG",
            "downloadPDF",
            "downloadSVG"
          ]
        }
      },
      /**
       * An object consisting of definitions for the menu items in the context
       * menu. Each key value pair has a `key` that is referenced in the
       * [menuItems](#exporting.buttons.contextButton.menuItems) setting,
       * and a `value`, which is an object with the following properties:
       *
       * - **onclick:** The click handler for the menu item
       *
       * - **text:** The text for the menu item
       *
       * - **textKey:** If internationalization is required, the key to a language
       *   string
       *
       * Custom text for the "exitFullScreen" can be set only in lang options
       * (it is not a separate button).
       *
       * @sample {highcharts} highcharts/exporting/menuitemdefinitions/
       *         Menu item definitions
       * @sample {highstock} highcharts/exporting/menuitemdefinitions/
       *         Menu item definitions
       * @sample {highmaps} highcharts/exporting/menuitemdefinitions/
       *         Menu item definitions
       *
       *
       * @type    {Highcharts.Dictionary<Highcharts.ExportingMenuObject>}
       * @default {"viewFullscreen": {}, "printChart": {}, "separator": {}, "downloadPNG": {}, "downloadJPEG": {}, "downloadPDF": {}, "downloadSVG": {}}
       * @since   5.0.13
       */
      menuItemDefinitions: {
        /**
         * @ignore
         */
        viewFullscreen: {
          textKey: "viewFullscreen",
          onclick: function() {
            this.fullscreen.toggle();
          }
        },
        /**
         * @ignore
         */
        printChart: {
          textKey: "printChart",
          onclick: function() {
            this.print();
          }
        },
        /**
         * @ignore
         */
        separator: {
          separator: true
        },
        /**
         * @ignore
         */
        downloadPNG: {
          textKey: "downloadPNG",
          onclick: function() {
            this.exportChart();
          }
        },
        /**
         * @ignore
         */
        downloadJPEG: {
          textKey: "downloadJPEG",
          onclick: function() {
            this.exportChart({
              type: "image/jpeg"
            });
          }
        },
        /**
         * @ignore
         */
        downloadPDF: {
          textKey: "downloadPDF",
          onclick: function() {
            this.exportChart({
              type: "application/pdf"
            });
          }
        },
        /**
         * @ignore
         */
        downloadSVG: {
          textKey: "downloadSVG",
          onclick: function() {
            this.exportChart({
              type: "image/svg+xml"
            });
          }
        }
      }
    };
    var lang = {
      /**
       * Exporting module only. The text for the menu item to view the chart
       * in full screen.
       *
       * @since 8.0.1
       *
       * @private
       */
      viewFullscreen: "View in full screen",
      /**
       * Exporting module only. The text for the menu item to exit the chart
       * from full screen.
       *
       * @since 8.0.1
       *
       * @private
       */
      exitFullscreen: "Exit from full screen",
      /**
       * Exporting module only. The text for the menu item to print the chart.
       *
       * @since    3.0.1
       * @requires modules/exporting
       *
       * @private
       */
      printChart: "Print chart",
      /**
       * Exporting module only. The text for the PNG download menu item.
       *
       * @since    2.0
       * @requires modules/exporting
       *
       * @private
       */
      downloadPNG: "Download PNG image",
      /**
       * Exporting module only. The text for the JPEG download menu item.
       *
       * @since    2.0
       * @requires modules/exporting
       *
       * @private
       */
      downloadJPEG: "Download JPEG image",
      /**
       * Exporting module only. The text for the PDF download menu item.
       *
       * @since    2.0
       * @requires modules/exporting
       *
       * @private
       */
      downloadPDF: "Download PDF document",
      /**
       * Exporting module only. The text for the SVG download menu item.
       *
       * @since    2.0
       * @requires modules/exporting
       *
       * @private
       */
      downloadSVG: "Download SVG vector image",
      /**
       * Exporting module menu. The tooltip title for the context menu holding
       * print and export menu items.
       *
       * @since    3.0
       * @requires modules/exporting
       *
       * @private
       */
      contextButtonTitle: "Chart context menu"
    };
    var navigation = {
      /**
       * A collection of options for buttons appearing in the exporting
       * module.
       *
       * In styled mode, the buttons are styled with the
       * `.highcharts-contextbutton` and `.highcharts-button-symbol` classes.
       *
       * @requires modules/exporting
       *
       * @private
       */
      buttonOptions: {
        /**
         * Whether to enable buttons.
         *
         * @sample highcharts/navigation/buttonoptions-enabled/
         *         Exporting module loaded but buttons disabled
         *
         * @type      {boolean}
         * @default   true
         * @since     2.0
         * @apioption navigation.buttonOptions.enabled
         */
        /**
         * The pixel size of the symbol on the button.
         *
         * @sample highcharts/navigation/buttonoptions-height/
         *         Bigger buttons
         *
         * @since 2.0
         */
        symbolSize: 14,
        /**
         * The x position of the center of the symbol inside the button.
         *
         * @sample highcharts/navigation/buttonoptions-height/
         *         Bigger buttons
         *
         * @since 2.0
         */
        symbolX: 12.5,
        /**
         * The y position of the center of the symbol inside the button.
         *
         * @sample highcharts/navigation/buttonoptions-height/
         *         Bigger buttons
         *
         * @since 2.0
         */
        symbolY: 10.5,
        /**
         * Alignment for the buttons.
         *
         * @sample highcharts/navigation/buttonoptions-align/
         *         Center aligned
         *
         * @type  {Highcharts.AlignValue}
         * @since 2.0
         */
        align: "right",
        /**
         * The pixel spacing between buttons.
         *
         * @since 2.0
         */
        buttonSpacing: 3,
        /**
         * Pixel height of the buttons.
         *
         * @sample highcharts/navigation/buttonoptions-height/
         *         Bigger buttons
         *
         * @since 2.0
         */
        height: 22,
        /**
         * A text string to add to the individual button.
         *
         * @sample highcharts/exporting/buttons-text/
         *         Full text button
         * @sample highcharts/exporting/buttons-text-symbol/
         *         Combined symbol and text
         *
         * @type      {string}
         * @default   null
         * @since     3.0
         * @apioption navigation.buttonOptions.text
         */
        /**
         * The vertical offset of the button's position relative to its
         * `verticalAlign`.
         *
         * @sample highcharts/navigation/buttonoptions-verticalalign/
         *         Buttons at lower right
         *
         * @type      {number}
         * @default   0
         * @since     2.0
         * @apioption navigation.buttonOptions.y
         */
        /**
         * The vertical alignment of the buttons. Can be one of `"top"`,
         * `"middle"` or `"bottom"`.
         *
         * @sample highcharts/navigation/buttonoptions-verticalalign/
         *         Buttons at lower right
         *
         * @type  {Highcharts.VerticalAlignValue}
         * @since 2.0
         */
        verticalAlign: "top",
        /**
         * The pixel width of the button.
         *
         * @sample highcharts/navigation/buttonoptions-height/
         *         Bigger buttons
         *
         * @since 2.0
         */
        width: 24,
        /**
         * Fill color for the symbol within the button.
         *
         * @sample highcharts/navigation/buttonoptions-symbolfill/
         *         Blue symbol stroke for one of the buttons
         *
         * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @since 2.0
         */
        symbolFill: palette.neutralColor60,
        /**
         * The color of the symbol's stroke or line.
         *
         * @sample highcharts/navigation/buttonoptions-symbolstroke/
         *         Blue symbol stroke
         *
         * @type  {Highcharts.ColorString}
         * @since 2.0
         */
        symbolStroke: palette.neutralColor60,
        /**
         * The pixel stroke width of the symbol on the button.
         *
         * @sample highcharts/navigation/buttonoptions-height/
         *         Bigger buttons
         *
         * @since 2.0
         */
        symbolStrokeWidth: 3,
        /**
         * A configuration object for the button theme. The object accepts
         * SVG properties like `stroke-width`, `stroke` and `fill`.
         * Tri-state button styles are supported by the `states.hover` and
         * `states.select` objects.
         *
         * @sample highcharts/navigation/buttonoptions-theme/
         *         Theming the buttons
         *
         * @requires modules/exporting
         *
         * @since 3.0
         */
        theme: {
          /**
           * The default fill exists only to capture hover events.
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default   ${palette.backgroundColor}
           * @apioption navigation.buttonOptions.theme.fill
           */
          /**
           * Default stroke for the buttons.
           * @type      {Highcharts.ColorString}
           * @default   none
           * @apioption navigation.buttonOptions.theme.stroke
           */
          /**
           * Padding for the button.
           */
          padding: 5
        }
      },
      /**
       * CSS styles for the popup menu appearing by default when the export
       * icon is clicked. This menu is rendered in HTML.
       *
       * @see In styled mode, the menu is styled with the `.highcharts-menu`
       *      class.
       *
       * @sample highcharts/navigation/menustyle/
       *         Light gray menu background
       *
       * @type    {Highcharts.CSSObject}
       * @default {"border": "1px solid #999999", "background": "#ffffff", "padding": "5px 0"}
       * @since   2.0
       *
       * @private
       */
      menuStyle: {
        /** @ignore-option */
        border: "1px solid " + palette.neutralColor40,
        /** @ignore-option */
        background: palette.backgroundColor,
        /** @ignore-option */
        padding: "5px 0"
      },
      /**
       * CSS styles for the individual items within the popup menu appearing
       * by default when the export icon is clicked. The menu items are
       * rendered in HTML. Font size defaults to `11px` on desktop and `14px`
       * on touch devices.
       *
       * @see In styled mode, the menu items are styled with the
       *      `.highcharts-menu-item` class.
       *
       * @sample {highcharts} highcharts/navigation/menuitemstyle/
       *         Add a grey stripe to the left
       *
       * @type    {Highcharts.CSSObject}
       * @default {"padding": "0.5em 1em", "color": "#333333", "background": "none", "fontSize": "11px/14px", "transition": "background 250ms, color 250ms"}
       * @since   2.0
       *
       * @private
       */
      menuItemStyle: {
        /** @ignore-option */
        padding: "0.5em 1em",
        /** @ignore-option */
        color: palette.neutralColor80,
        /** @ignore-option */
        background: "none",
        /** @ignore-option */
        fontSize: isTouchDevice ? "14px" : "11px",
        /** @ignore-option */
        transition: "background 250ms, color 250ms"
      },
      /**
       * CSS styles for the hover state of the individual items within the
       * popup menu appearing by default when the export icon is clicked. The
       * menu items are rendered in HTML.
       *
       * @see In styled mode, the menu items are styled with the
       *      `.highcharts-menu-item` class.
       *
       * @sample highcharts/navigation/menuitemhoverstyle/
       *         Bold text on hover
       *
       * @type    {Highcharts.CSSObject}
       * @default {"background": "#335cad", "color": "#ffffff"}
       * @since   2.0
       *
       * @private
       */
      menuItemHoverStyle: {
        /** @ignore-option */
        background: palette.highlightColor80,
        /** @ignore-option */
        color: palette.backgroundColor
      }
    };
    var ExportingDefaults = {
      exporting,
      lang,
      navigation
    };
    var ExportingSymbols;
    (function(ExportingSymbols2) {
      var modifiedClasses = [];
      function compose(SVGRendererClass) {
        if (modifiedClasses.indexOf(SVGRendererClass) === -1) {
          modifiedClasses.push(SVGRendererClass);
          var symbols2 = SVGRendererClass.prototype.symbols;
          symbols2.menu = menu;
          symbols2.menuball = menuball.bind(symbols2);
        }
      }
      ExportingSymbols2.compose = compose;
      function menu(x, y, width, height) {
        var arr = [
          ["M", x, y + 2.5],
          ["L", x + width, y + 2.5],
          ["M", x, y + height / 2 + 0.5],
          ["L", x + width, y + height / 2 + 0.5],
          ["M", x, y + height - 1.5],
          ["L", x + width, y + height - 1.5]
        ];
        return arr;
      }
      function menuball(x, y, width, height) {
        var h = height / 3 - 2;
        var path = [];
        path = path.concat(this.circle(width - h, y, h, h), this.circle(width - h, y + h + 4, h, h), this.circle(width - h, y + 2 * (h + 4), h, h));
        return path;
      }
    })(ExportingSymbols || (ExportingSymbols = {}));
    const ExportingSymbols$1 = ExportingSymbols;
    var defaultOptions$2 = DefaultOptions.defaultOptions;
    var doc = H.doc, win$1 = H.win;
    var addEvent$8 = Utilities.addEvent, css$1 = Utilities.css, createElement = Utilities.createElement, discardElement = Utilities.discardElement, extend$k = Utilities.extend, find$3 = Utilities.find, fireEvent$3 = Utilities.fireEvent, isObject$4 = Utilities.isObject, merge$f = Utilities.merge, objectEach$2 = Utilities.objectEach, pick$h = Utilities.pick, removeEvent = Utilities.removeEvent, uniqueKey = Utilities.uniqueKey;
    var Exporting;
    (function(Exporting2) {
      var composedClasses2 = [];
      var inlineBlacklist = [
        /-/,
        /^(clipPath|cssText|d|height|width)$/,
        /^font$/,
        /[lL]ogical(Width|Height)$/,
        /perspective/,
        /TapHighlightColor/,
        /^transition/,
        /^length$/
        // #7700
        // /^text (border|color|cursor|height|webkitBorder)/
      ];
      var inlineToAttributes = [
        "fill",
        "stroke",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "textAnchor",
        "x",
        "y"
      ];
      Exporting2.inlineWhitelist = [];
      var unstyledElements = [
        "clipPath",
        "defs",
        "desc"
      ];
      var printingChart;
      function addButton(options) {
        var chart = this, renderer = chart.renderer, btnOptions = merge$f(chart.options.navigation.buttonOptions, options), onclick = btnOptions.onclick, menuItems = btnOptions.menuItems, symbolSize = btnOptions.symbolSize || 12;
        var symbol;
        if (!chart.btnCount) {
          chart.btnCount = 0;
        }
        if (!chart.exportDivElements) {
          chart.exportDivElements = [];
          chart.exportSVGElements = [];
        }
        if (btnOptions.enabled === false || !btnOptions.theme) {
          return;
        }
        var attr2 = btnOptions.theme, states = attr2.states, hover = states && states.hover, select = states && states.select;
        var callback;
        if (!chart.styledMode) {
          attr2.fill = pick$h(attr2.fill, palette.backgroundColor);
          attr2.stroke = pick$h(attr2.stroke, "none");
        }
        delete attr2.states;
        if (onclick) {
          callback = function(e2) {
            if (e2) {
              e2.stopPropagation();
            }
            onclick.call(chart, e2);
          };
        } else if (menuItems) {
          callback = function(e2) {
            if (e2) {
              e2.stopPropagation();
            }
            chart.contextMenu(button2.menuClassName, menuItems, button2.translateX, button2.translateY, button2.width, button2.height, button2);
            button2.setState(2);
          };
        }
        if (btnOptions.text && btnOptions.symbol) {
          attr2.paddingLeft = pick$h(attr2.paddingLeft, 30);
        } else if (!btnOptions.text) {
          extend$k(attr2, {
            width: btnOptions.width,
            height: btnOptions.height,
            padding: 0
          });
        }
        if (!chart.styledMode) {
          attr2["stroke-linecap"] = "round";
          attr2.fill = pick$h(attr2.fill, palette.backgroundColor);
          attr2.stroke = pick$h(attr2.stroke, "none");
        }
        var button2 = renderer.button(btnOptions.text, 0, 0, callback, attr2, hover, select).addClass(options.className).attr({
          title: pick$h(chart.options.lang[btnOptions._titleKey || btnOptions.titleKey], "")
        });
        button2.menuClassName = options.menuClassName || "highcharts-menu-" + chart.btnCount++;
        if (btnOptions.symbol) {
          symbol = renderer.symbol(
            btnOptions.symbol,
            btnOptions.symbolX - symbolSize / 2,
            btnOptions.symbolY - symbolSize / 2,
            symbolSize,
            symbolSize,
            {
              width: symbolSize,
              height: symbolSize
            }
          ).addClass("highcharts-button-symbol").attr({
            zIndex: 1
          }).add(button2);
          if (!chart.styledMode) {
            symbol.attr({
              stroke: btnOptions.symbolStroke,
              fill: btnOptions.symbolFill,
              "stroke-width": btnOptions.symbolStrokeWidth || 1
            });
          }
        }
        button2.add(chart.exportingGroup).align(extend$k(btnOptions, {
          width: button2.width,
          x: pick$h(btnOptions.x, chart.buttonOffset)
          // #1654
        }), true, "spacingBox");
        chart.buttonOffset += (button2.width + btnOptions.buttonSpacing) * (btnOptions.align === "right" ? -1 : 1);
        chart.exportSVGElements.push(button2, symbol);
      }
      function afterPrint() {
        var chart = this;
        if (!chart.printReverseInfo) {
          return void 0;
        }
        var _a2 = chart.printReverseInfo, childNodes = _a2.childNodes, origDisplay = _a2.origDisplay, resetParams = _a2.resetParams;
        chart.moveContainers(chart.renderTo);
        [].forEach.call(childNodes, function(node, i) {
          if (node.nodeType === 1) {
            node.style.display = origDisplay[i] || "";
          }
        });
        chart.isPrinting = false;
        if (resetParams) {
          chart.setSize.apply(chart, resetParams);
        }
        delete chart.printReverseInfo;
        printingChart = void 0;
        fireEvent$3(chart, "afterPrint");
      }
      function beforePrint() {
        var chart = this, body = doc.body, printMaxWidth = chart.options.exporting.printMaxWidth, printReverseInfo = {
          childNodes: body.childNodes,
          origDisplay: [],
          resetParams: void 0
        };
        chart.isPrinting = true;
        chart.pointer.reset(null, 0);
        fireEvent$3(chart, "beforePrint");
        var handleMaxWidth = printMaxWidth && chart.chartWidth > printMaxWidth;
        if (handleMaxWidth) {
          printReverseInfo.resetParams = [
            chart.options.chart.width,
            void 0,
            false
          ];
          chart.setSize(printMaxWidth, void 0, false);
        }
        [].forEach.call(printReverseInfo.childNodes, function(node, i) {
          if (node.nodeType === 1) {
            printReverseInfo.origDisplay[i] = node.style.display;
            node.style.display = "none";
          }
        });
        chart.moveContainers(body);
        chart.printReverseInfo = printReverseInfo;
      }
      function chartCallback(chart) {
        var composition = chart;
        composition.renderExporting();
        addEvent$8(chart, "redraw", composition.renderExporting);
        addEvent$8(chart, "destroy", composition.destroyExport);
      }
      function compose(ChartClass, SVGRendererClass) {
        ExportingSymbols$1.compose(SVGRendererClass);
        if (composedClasses2.indexOf(ChartClass) === -1) {
          composedClasses2.push(ChartClass);
          var chartProto2 = ChartClass.prototype;
          chartProto2.afterPrint = afterPrint;
          chartProto2.exportChart = exportChart;
          chartProto2.inlineStyles = inlineStyles;
          chartProto2.print = print;
          chartProto2.sanitizeSVG = sanitizeSVG;
          chartProto2.getChartHTML = getChartHTML;
          chartProto2.getSVG = getSVG;
          chartProto2.getSVGForExport = getSVGForExport;
          chartProto2.getFilename = getFilename;
          chartProto2.moveContainers = moveContainers;
          chartProto2.beforePrint = beforePrint;
          chartProto2.contextMenu = contextMenu;
          chartProto2.addButton = addButton;
          chartProto2.destroyExport = destroyExport;
          chartProto2.renderExporting = renderExporting;
          chartProto2.callbacks.push(chartCallback);
          addEvent$8(ChartClass, "init", onChartInit);
          if (H.isSafari) {
            H.win.matchMedia("print").addListener(function(mqlEvent) {
              if (!printingChart) {
                return void 0;
              }
              if (mqlEvent.matches) {
                printingChart.beforePrint();
              } else {
                printingChart.afterPrint();
              }
            });
          }
        }
      }
      Exporting2.compose = compose;
      function contextMenu(className, items, x, y, width, height, button2) {
        var chart = this, navOptions = chart.options.navigation, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, cacheName = "cache-" + className, menuPadding = Math.max(width, height);
        var innerMenu, menu = chart[cacheName];
        if (!menu) {
          chart.exportContextMenu = chart[cacheName] = menu = createElement("div", {
            className
          }, {
            position: "absolute",
            zIndex: 1e3,
            padding: menuPadding + "px",
            pointerEvents: "auto"
          }, chart.fixedDiv || chart.container);
          innerMenu = createElement("ul", { className: "highcharts-menu" }, {
            listStyle: "none",
            margin: 0,
            padding: 0
          }, menu);
          if (!chart.styledMode) {
            css$1(innerMenu, extend$k({
              MozBoxShadow: "3px 3px 10px #888",
              WebkitBoxShadow: "3px 3px 10px #888",
              boxShadow: "3px 3px 10px #888"
            }, navOptions.menuStyle));
          }
          menu.hideMenu = function() {
            css$1(menu, { display: "none" });
            if (button2) {
              button2.setState(0);
            }
            chart.openMenu = false;
            css$1(chart.renderTo, { overflow: "hidden" });
            css$1(chart.container, { overflow: "hidden" });
            Utilities.clearTimeout(menu.hideTimer);
            fireEvent$3(chart, "exportMenuHidden");
          };
          chart.exportEvents.push(
            addEvent$8(menu, "mouseleave", function() {
              menu.hideTimer = win$1.setTimeout(menu.hideMenu, 500);
            }),
            addEvent$8(menu, "mouseenter", function() {
              Utilities.clearTimeout(menu.hideTimer);
            }),
            // Hide it on clicking or touching outside the menu (#2258,
            // #2335, #2407)
            addEvent$8(doc, "mouseup", function(e2) {
              if (!chart.pointer.inClass(e2.target, className)) {
                menu.hideMenu();
              }
            }),
            addEvent$8(menu, "click", function() {
              if (chart.openMenu) {
                menu.hideMenu();
              }
            })
          );
          items.forEach(function(item2) {
            if (typeof item2 === "string") {
              item2 = chart.options.exporting.menuItemDefinitions[item2];
            }
            if (isObject$4(item2, true)) {
              var element = void 0;
              if (item2.separator) {
                element = createElement("hr", void 0, void 0, innerMenu);
              } else {
                if (item2.textKey === "viewData" && chart.isDataTableVisible) {
                  item2.textKey = "hideData";
                }
                element = createElement("li", {
                  className: "highcharts-menu-item",
                  onclick: function(e2) {
                    if (e2) {
                      e2.stopPropagation();
                    }
                    menu.hideMenu();
                    if (item2.onclick) {
                      item2.onclick.apply(chart, arguments);
                    }
                  }
                }, void 0, innerMenu);
                AST.setElementHTML(element, item2.text || chart.options.lang[item2.textKey]);
                if (!chart.styledMode) {
                  element.onmouseover = function() {
                    css$1(this, navOptions.menuItemHoverStyle);
                  };
                  element.onmouseout = function() {
                    css$1(this, navOptions.menuItemStyle);
                  };
                  css$1(element, extend$k({
                    cursor: "pointer"
                  }, navOptions.menuItemStyle));
                }
              }
              chart.exportDivElements.push(element);
            }
          });
          chart.exportDivElements.push(innerMenu, menu);
          chart.exportMenuWidth = menu.offsetWidth;
          chart.exportMenuHeight = menu.offsetHeight;
        }
        var menuStyle = { display: "block" };
        if (x + chart.exportMenuWidth > chartWidth) {
          menuStyle.right = chartWidth - x - width - menuPadding + "px";
        } else {
          menuStyle.left = x - menuPadding + "px";
        }
        if (y + height + chart.exportMenuHeight > chartHeight && button2.alignOptions.verticalAlign !== "top") {
          menuStyle.bottom = chartHeight - y - menuPadding + "px";
        } else {
          menuStyle.top = y + height - menuPadding + "px";
        }
        css$1(menu, menuStyle);
        css$1(chart.renderTo, { overflow: "" });
        css$1(chart.container, { overflow: "" });
        chart.openMenu = true;
        fireEvent$3(chart, "exportMenuShown");
      }
      function destroyExport(e2) {
        var chart = e2 ? e2.target : this, exportSVGElements = chart.exportSVGElements, exportDivElements = chart.exportDivElements, exportEvents = chart.exportEvents;
        var cacheName;
        if (exportSVGElements) {
          exportSVGElements.forEach(function(elem, i) {
            if (elem) {
              elem.onclick = elem.ontouchstart = null;
              cacheName = "cache-" + elem.menuClassName;
              if (chart[cacheName]) {
                delete chart[cacheName];
              }
              exportSVGElements[i] = elem.destroy();
            }
          });
          exportSVGElements.length = 0;
        }
        if (chart.exportingGroup) {
          chart.exportingGroup.destroy();
          delete chart.exportingGroup;
        }
        if (exportDivElements) {
          exportDivElements.forEach(function(elem, i) {
            if (elem) {
              Utilities.clearTimeout(elem.hideTimer);
              removeEvent(elem, "mouseleave");
              exportDivElements[i] = elem.onmouseout = elem.onmouseover = elem.ontouchstart = elem.onclick = null;
              discardElement(elem);
            }
          });
          exportDivElements.length = 0;
        }
        if (exportEvents) {
          exportEvents.forEach(function(unbind) {
            unbind();
          });
          exportEvents.length = 0;
        }
      }
      function exportChart(exportingOptions, chartOptions) {
        var svg2 = this.getSVGForExport(exportingOptions, chartOptions);
        exportingOptions = merge$f(this.options.exporting, exportingOptions);
        exports$2.post(exportingOptions.url, {
          filename: exportingOptions.filename ? exportingOptions.filename.replace(/\//g, "-") : this.getFilename(),
          type: exportingOptions.type,
          // IE8 fails to post undefined correctly, so use 0
          width: exportingOptions.width || 0,
          scale: exportingOptions.scale,
          svg: svg2
        }, exportingOptions.formAttributes);
      }
      function getChartHTML() {
        if (this.styledMode) {
          this.inlineStyles();
        }
        return this.container.innerHTML;
      }
      function getFilename() {
        var s = this.userOptions.title && this.userOptions.title.text;
        var filename = this.options.exporting.filename;
        if (filename) {
          return filename.replace(/\//g, "-");
        }
        if (typeof s === "string") {
          filename = s.toLowerCase().replace(/<\/?[^>]+(>|$)/g, "").replace(/[\s_]+/g, "-").replace(/[^a-z0-9\-]/g, "").replace(/^[\-]+/g, "").replace(/[\-]+/g, "-").substr(0, 24).replace(/[\-]+$/g, "");
        }
        if (!filename || filename.length < 5) {
          filename = "chart";
        }
        return filename;
      }
      function getSVG(chartOptions) {
        var chart = this;
        var svg2, seriesOptions, options = merge$f(chart.options, chartOptions);
        options.plotOptions = merge$f(chart.userOptions.plotOptions, chartOptions && chartOptions.plotOptions);
        options.time = merge$f(chart.userOptions.time, chartOptions && chartOptions.time);
        var sandbox = createElement("div", null, {
          position: "absolute",
          top: "-9999em",
          width: chart.chartWidth + "px",
          height: chart.chartHeight + "px"
        }, doc.body);
        var cssWidth = chart.renderTo.style.width, cssHeight = chart.renderTo.style.height, sourceWidth = options.exporting.sourceWidth || options.chart.width || /px$/.test(cssWidth) && parseInt(cssWidth, 10) || (options.isGantt ? 800 : 600), sourceHeight = options.exporting.sourceHeight || options.chart.height || /px$/.test(cssHeight) && parseInt(cssHeight, 10) || 400;
        extend$k(options.chart, {
          animation: false,
          renderTo: sandbox,
          forExport: true,
          renderer: "SVGRenderer",
          width: sourceWidth,
          height: sourceHeight
        });
        options.exporting.enabled = false;
        delete options.data;
        options.series = [];
        chart.series.forEach(function(serie) {
          seriesOptions = merge$f(serie.userOptions, {
            animation: false,
            enableMouseTracking: false,
            showCheckbox: false,
            visible: serie.visible
          });
          if (!seriesOptions.isInternal) {
            options.series.push(seriesOptions);
          }
        });
        var colls = {};
        chart.axes.forEach(function(axis) {
          if (!axis.userOptions.internalKey) {
            axis.userOptions.internalKey = uniqueKey();
          }
          if (!axis.options.isInternal) {
            if (!colls[axis.coll]) {
              colls[axis.coll] = true;
              options[axis.coll] = [];
            }
            options[axis.coll].push(merge$f(axis.userOptions, {
              visible: axis.visible
            }));
          }
        });
        var chartCopy = new Chart$1(options, chart.callback);
        if (chartOptions) {
          ["xAxis", "yAxis", "series"].forEach(function(coll) {
            var collOptions = {};
            if (chartOptions[coll]) {
              collOptions[coll] = chartOptions[coll];
              chartCopy.update(collOptions);
            }
          });
        }
        chart.axes.forEach(function(axis) {
          var axisCopy = find$3(chartCopy.axes, function(copy) {
            return copy.options.internalKey === axis.userOptions.internalKey;
          }), extremes = axis.getExtremes(), userMin = extremes.userMin, userMax = extremes.userMax;
          if (axisCopy && (typeof userMin !== "undefined" && userMin !== axisCopy.min || typeof userMax !== "undefined" && userMax !== axisCopy.max)) {
            axisCopy.setExtremes(userMin, userMax, true, false);
          }
        });
        svg2 = chartCopy.getChartHTML();
        fireEvent$3(this, "getSVG", { chartCopy });
        svg2 = chart.sanitizeSVG(svg2, options);
        options = null;
        chartCopy.destroy();
        discardElement(sandbox);
        return svg2;
      }
      function getSVGForExport(options, chartOptions) {
        var chartExportingOptions = this.options.exporting;
        return this.getSVG(merge$f({ chart: { borderRadius: 0 } }, chartExportingOptions.chartOptions, chartOptions, {
          exporting: {
            sourceWidth: options && options.sourceWidth || chartExportingOptions.sourceWidth,
            sourceHeight: options && options.sourceHeight || chartExportingOptions.sourceHeight
          }
        }));
      }
      function hyphenate(prop) {
        return prop.replace(/([A-Z])/g, function(a, b) {
          return "-" + b.toLowerCase();
        });
      }
      function inlineStyles() {
        var blacklist = inlineBlacklist, whitelist = Exporting2.inlineWhitelist, defaultStyles = {};
        var dummySVG;
        var iframe = doc.createElement("iframe");
        css$1(iframe, {
          width: "1px",
          height: "1px",
          visibility: "hidden"
        });
        doc.body.appendChild(iframe);
        var iframeDoc = iframe.contentWindow.document;
        iframeDoc.open();
        iframeDoc.write('<svg xmlns="http://www.w3.org/2000/svg"></svg>');
        iframeDoc.close();
        function recurse(node) {
          var styles, parentStyles, cssText = "", dummy, styleAttr, blacklisted, whitelisted, i;
          function filterStyles(val, prop) {
            blacklisted = whitelisted = false;
            if (whitelist.length) {
              i = whitelist.length;
              while (i-- && !whitelisted) {
                whitelisted = whitelist[i].test(prop);
              }
              blacklisted = !whitelisted;
            }
            if (prop === "transform" && val === "none") {
              blacklisted = true;
            }
            i = blacklist.length;
            while (i-- && !blacklisted) {
              blacklisted = blacklist[i].test(prop) || typeof val === "function";
            }
            if (!blacklisted) {
              if ((parentStyles[prop] !== val || node.nodeName === "svg") && defaultStyles[node.nodeName][prop] !== val) {
                if (!inlineToAttributes || inlineToAttributes.indexOf(prop) !== -1) {
                  if (val) {
                    node.setAttribute(hyphenate(prop), val);
                  }
                } else {
                  cssText += hyphenate(prop) + ":" + val + ";";
                }
              }
            }
          }
          if (node.nodeType === 1 && unstyledElements.indexOf(node.nodeName) === -1) {
            styles = win$1.getComputedStyle(node, null);
            parentStyles = node.nodeName === "svg" ? {} : win$1.getComputedStyle(node.parentNode, null);
            if (!defaultStyles[node.nodeName]) {
              dummySVG = iframeDoc.getElementsByTagName("svg")[0];
              dummy = iframeDoc.createElementNS(node.namespaceURI, node.nodeName);
              dummySVG.appendChild(dummy);
              defaultStyles[node.nodeName] = merge$f(win$1.getComputedStyle(dummy, null));
              if (node.nodeName === "text") {
                delete defaultStyles.text.fill;
              }
              dummySVG.removeChild(dummy);
            }
            if (H.isFirefox || H.isMS) {
              for (var p in styles) {
                filterStyles(styles[p], p);
              }
            } else {
              objectEach$2(styles, filterStyles);
            }
            if (cssText) {
              styleAttr = node.getAttribute("style");
              node.setAttribute("style", (styleAttr ? styleAttr + ";" : "") + cssText);
            }
            if (node.nodeName === "svg") {
              node.setAttribute("stroke-width", "1px");
            }
            if (node.nodeName === "text") {
              return;
            }
            [].forEach.call(node.children || node.childNodes, recurse);
          }
        }
        function tearDown() {
          dummySVG.parentNode.removeChild(dummySVG);
          iframe.parentNode.removeChild(iframe);
        }
        recurse(this.container.querySelector("svg"));
        tearDown();
      }
      function moveContainers(moveTo) {
        var chart = this;
        (chart.fixedDiv ? (
          // When scrollablePlotArea is active (#9533)
          [chart.fixedDiv, chart.scrollingContainer]
        ) : [chart.container]).forEach(function(div) {
          moveTo.appendChild(div);
        });
      }
      function onChartInit() {
        var chart = this, update = function(prop, options, redraw) {
          chart.isDirtyExporting = true;
          merge$f(true, chart.options[prop], options);
          if (pick$h(redraw, true)) {
            chart.redraw();
          }
        };
        chart.exporting = {
          update: function(options, redraw) {
            update("exporting", options, redraw);
          }
        };
        chartNavigation.addUpdate(function(options, redraw) {
          update("navigation", options, redraw);
        }, chart);
      }
      function print() {
        var chart = this;
        if (chart.isPrinting) {
          return;
        }
        printingChart = chart;
        if (!H.isSafari) {
          chart.beforePrint();
        }
        setTimeout(function() {
          win$1.focus();
          win$1.print();
          if (!H.isSafari) {
            setTimeout(function() {
              chart.afterPrint();
            }, 1e3);
          }
        }, 1);
      }
      function renderExporting() {
        var chart = this, exportingOptions = chart.options.exporting, buttons = exportingOptions.buttons, isDirty = chart.isDirtyExporting || !chart.exportSVGElements;
        chart.buttonOffset = 0;
        if (chart.isDirtyExporting) {
          chart.destroyExport();
        }
        if (isDirty && exportingOptions.enabled !== false) {
          chart.exportEvents = [];
          chart.exportingGroup = chart.exportingGroup || chart.renderer.g("exporting-group").attr({
            zIndex: 3
            // #4955, // #8392
          }).add();
          objectEach$2(buttons, function(button2) {
            chart.addButton(button2);
          });
          chart.isDirtyExporting = false;
        }
      }
      function sanitizeSVG(svg2, options) {
        var split = svg2.indexOf("</svg>") + 6;
        var html2 = svg2.substr(split);
        svg2 = svg2.substr(0, split);
        if (options && options.exporting && options.exporting.allowHTML) {
          if (html2) {
            html2 = '<foreignObject x="0" y="0" width="' + options.chart.width + '" height="' + options.chart.height + '"><body xmlns="http://www.w3.org/1999/xhtml">' + // Some tags needs to be closed in xhtml (#13726)
            html2.replace(/(<(?:img|br).*?(?=\>))>/g, "$1 />") + "</body></foreignObject>";
            svg2 = svg2.replace("</svg>", html2 + "</svg>");
          }
        }
        svg2 = svg2.replace(/zIndex="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\(("|&quot;)(.*?)("|&quot;)\;?\)/g, "url($2)").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (|NS[0-9]+\:)href=/g, " xlink:href=").replace(/\n/, " ").replace(
          /(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g,
          // eslint-disable-line max-len
          '$1="rgb($2)" $1-opacity="$3"'
        ).replace(/&nbsp;/g, "").replace(/&shy;/g, "");
        if (this.ieSanitizeSVG) {
          svg2 = this.ieSanitizeSVG(svg2);
        }
        return svg2;
      }
    })(Exporting || (Exporting = {}));
    defaultOptions$2.exporting = merge$f(ExportingDefaults.exporting, defaultOptions$2.exporting);
    defaultOptions$2.lang = merge$f(ExportingDefaults.lang, defaultOptions$2.lang);
    defaultOptions$2.navigation = merge$f(ExportingDefaults.navigation, defaultOptions$2.navigation);
    const Exporting$1 = Exporting;
    /**
     * @license Highcharts JS v9.2.2 (2021-08-24)
     * @module highcharts/modules/exporting
     * @requires highcharts
     *
     * Exporting module
     *
     * (c) 2010-2021 Torstein Honsi
     *
     * License: www.highcharts.com/license
     */
    var G$1 = H;
    G$1.HttpUtilities = exports$2;
    G$1.ajax = exports$2.ajax;
    G$1.getJSON = exports$2.getJSON;
    G$1.post = exports$2.post;
    Exporting$1.compose(G$1.Chart, G$1.Renderer);
    var __extends$h = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var noop$3 = H.noop;
    var Series$7 = SeriesRegistry$1.series, PieSeries = SeriesRegistry$1.seriesTypes.pie;
    var addEvent$7 = Utilities.addEvent, extend$j = Utilities.extend, fireEvent$2 = Utilities.fireEvent, isArray$2 = Utilities.isArray, merge$e = Utilities.merge, pick$g = Utilities.pick;
    var FunnelSeries = (
      /** @class */
      function(_super) {
        __extends$h(FunnelSeries2, _super);
        function FunnelSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        FunnelSeries2.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {
          var series = point.series, reversed = series.options.reversed, dlBox = point.dlBox || point.shapeArgs, align = options.align, verticalAlign = options.verticalAlign, inside = ((series.options || {}).dataLabels || {}).inside, centerY = series.center[1], pointPlotY = reversed ? 2 * centerY - point.plotY : point.plotY, widthAtLabel = series.getWidthAt(pointPlotY - dlBox.height / 2 + dataLabel.height), offset2 = verticalAlign === "middle" ? (dlBox.topWidth - dlBox.bottomWidth) / 4 : (widthAtLabel - dlBox.bottomWidth) / 2, y = dlBox.y, x = dlBox.x;
          if (verticalAlign === "middle") {
            y = dlBox.y - dlBox.height / 2 + dataLabel.height / 2;
          } else if (verticalAlign === "top") {
            y = dlBox.y - dlBox.height + dataLabel.height + options.padding;
          }
          if (verticalAlign === "top" && !reversed || verticalAlign === "bottom" && reversed || verticalAlign === "middle") {
            if (align === "right") {
              x = dlBox.x - options.padding + offset2;
            } else if (align === "left") {
              x = dlBox.x + options.padding - offset2;
            }
          }
          alignTo = {
            x,
            y: reversed ? y - dlBox.height : y,
            width: dlBox.bottomWidth,
            height: dlBox.height
          };
          options.verticalAlign = "bottom";
          if (!inside || point.visible) {
            Series$7.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
          }
          if (inside) {
            if (!point.visible && point.dataLabel) {
              point.dataLabel.placed = false;
            }
            if (point.contrastColor) {
              dataLabel.css({
                color: point.contrastColor
              });
            }
          }
        };
        FunnelSeries2.prototype.drawDataLabels = function() {
          var series = this, data = series.data, labelDistance = series.options.dataLabels.distance, leftSide, sign, point, i = data.length, x, y;
          series.center[2] -= 2 * labelDistance;
          while (i--) {
            point = data[i];
            leftSide = point.half;
            sign = leftSide ? 1 : -1;
            y = point.plotY;
            point.labelDistance = pick$g(point.options.dataLabels && point.options.dataLabels.distance, labelDistance);
            series.maxLabelDistance = Math.max(point.labelDistance, series.maxLabelDistance || 0);
            x = series.getX(y, leftSide, point);
            point.labelPosition = {
              // initial position of the data label - it's utilized for
              // finding the final position for the label
              natural: {
                x: 0,
                y
              },
              "final": {
                // used for generating connector path -
                // initialized later in drawDataLabels function
                // x: undefined,
                // y: undefined
              },
              // left - funnel on the left side of the data label
              // right - funnel on the right side of the data label
              alignment: leftSide ? "right" : "left",
              connectorPosition: {
                breakAt: {
                  x: x + (point.labelDistance - 5) * sign,
                  y
                },
                touchingSliceAt: {
                  x: x + point.labelDistance * sign,
                  y
                }
              }
            };
          }
          SeriesRegistry$1.seriesTypes[series.options.dataLabels.inside ? "column" : "pie"].prototype.drawDataLabels.call(this);
        };
        FunnelSeries2.prototype.translate = function() {
          var sum = 0, series = this, chart = series.chart, options = series.options, reversed = options.reversed, ignoreHiddenPoint = options.ignoreHiddenPoint, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, cumulative = 0, center = options.center, centerX = getLength(center[0], plotWidth), centerY = getLength(center[1], plotHeight), width = getLength(options.width, plotWidth), tempWidth, height = getLength(options.height, plotHeight), neckWidth = getLength(options.neckWidth, plotWidth), neckHeight = getLength(options.neckHeight, plotHeight), neckY = centerY - height / 2 + height - neckHeight, data = series.data, path, fraction, half = options.dataLabels.position === "left" ? 1 : 0, x1, y1, x2, x3, y3, x4, y5;
          function getLength(length, relativeTo) {
            return /%$/.test(length) ? relativeTo * parseInt(length, 10) / 100 : parseInt(length, 10);
          }
          series.getWidthAt = function(y) {
            var top = centerY - height / 2;
            return y > neckY || height === neckHeight ? neckWidth : neckWidth + (width - neckWidth) * (1 - (y - top) / (height - neckHeight));
          };
          series.getX = function(y, half2, point) {
            return centerX + (half2 ? -1 : 1) * (series.getWidthAt(reversed ? 2 * centerY - y : y) / 2 + point.labelDistance);
          };
          series.center = [centerX, centerY, height];
          series.centerX = centerX;
          data.forEach(function(point) {
            if (!ignoreHiddenPoint || point.visible !== false) {
              sum += point.y;
            }
          });
          data.forEach(function(point) {
            y5 = null;
            fraction = sum ? point.y / sum : 0;
            y1 = centerY - height / 2 + cumulative * height;
            y3 = y1 + fraction * height;
            tempWidth = series.getWidthAt(y1);
            x1 = centerX - tempWidth / 2;
            x2 = x1 + tempWidth;
            tempWidth = series.getWidthAt(y3);
            x3 = centerX - tempWidth / 2;
            x4 = x3 + tempWidth;
            if (y1 > neckY) {
              x1 = x3 = centerX - neckWidth / 2;
              x2 = x4 = centerX + neckWidth / 2;
            } else if (y3 > neckY) {
              y5 = y3;
              tempWidth = series.getWidthAt(neckY);
              x3 = centerX - tempWidth / 2;
              x4 = x3 + tempWidth;
              y3 = neckY;
            }
            if (reversed) {
              y1 = 2 * centerY - y1;
              y3 = 2 * centerY - y3;
              if (y5 !== null) {
                y5 = 2 * centerY - y5;
              }
            }
            path = [
              ["M", x1, y1],
              ["L", x2, y1],
              ["L", x4, y3]
            ];
            if (y5 !== null) {
              path.push(["L", x4, y5], ["L", x3, y5]);
            }
            path.push(["L", x3, y3], ["Z"]);
            point.shapeType = "path";
            point.shapeArgs = { d: path };
            point.percentage = fraction * 100;
            point.plotX = centerX;
            point.plotY = (y1 + (y5 || y3)) / 2;
            point.tooltipPos = [
              centerX,
              point.plotY
            ];
            point.dlBox = {
              x: x3,
              y: y1,
              topWidth: x2 - x1,
              bottomWidth: x4 - x3,
              height: Math.abs(pick$g(y5, y3) - y1),
              width: NaN
            };
            point.slice = noop$3;
            point.half = half;
            if (!ignoreHiddenPoint || point.visible !== false) {
              cumulative += fraction;
            }
          });
          fireEvent$2(series, "afterTranslate");
        };
        FunnelSeries2.prototype.sortByAngle = function(points) {
          points.sort(function(a, b) {
            return a.plotY - b.plotY;
          });
        };
        FunnelSeries2.defaultOptions = merge$e(PieSeries.defaultOptions, {
          /**
           * Initial animation is by default disabled for the funnel chart.
           */
          animation: false,
          /**
           * The center of the series. By default, it is centered in the middle
           * of the plot area, so it fills the plot area height.
           *
           * @type    {Array<number|string>}
           * @default ["50%", "50%"]
           * @since   3.0
           */
          center: ["50%", "50%"],
          /**
           * The width of the funnel compared to the width of the plot area,
           * or the pixel width if it is a number.
           *
           * @type  {number|string}
           * @since 3.0
           */
          width: "90%",
          /**
           * The width of the neck, the lower part of the funnel. A number defines
           * pixel width, a percentage string defines a percentage of the plot
           * area width.
           *
           * @sample {highcharts} highcharts/demo/funnel/
           *         Funnel demo
           *
           * @type  {number|string}
           * @since 3.0
           */
          neckWidth: "30%",
          /**
           * The height of the funnel or pyramid. If it is a number it defines
           * the pixel height, if it is a percentage string it is the percentage
           * of the plot area height.
           *
           * @sample {highcharts} highcharts/demo/funnel/
           *         Funnel demo
           *
           * @type  {number|string}
           * @since 3.0
           */
          height: "100%",
          /**
           * The height of the neck, the lower part of the funnel. A number
           * defines pixel width, a percentage string defines a percentage of the
           * plot area height.
           *
           * @type {number|string}
           */
          neckHeight: "25%",
          /**
           * A reversed funnel has the widest area down. A reversed funnel with
           * no neck width and neck height is a pyramid.
           *
           * @since 3.0.10
           */
          reversed: false,
          /**
           * To avoid adapting the data label size in Pie.drawDataLabels.
           * @ignore-option
           */
          size: true,
          dataLabels: {
            connectorWidth: 1,
            verticalAlign: "middle"
          },
          /**
           * Options for the series states.
           */
          states: {
            /**
             * @excluding halo, marker, lineWidth, lineWidthPlus
             * @apioption plotOptions.funnel.states.hover
             */
            /**
             * Options for a selected funnel item.
             *
             * @excluding halo, marker, lineWidth, lineWidthPlus
             */
            select: {
              /**
               * A specific color for the selected point.
               *
               * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               */
              color: palette.neutralColor20,
              /**
               * A specific border color for the selected point.
               *
               * @type {Highcharts.ColorString}
               */
              borderColor: palette.neutralColor100
            }
          }
        });
        return FunnelSeries2;
      }(PieSeries)
    );
    extend$j(FunnelSeries.prototype, {
      animate: noop$3
    });
    addEvent$7(Chart$1, "afterHideAllOverlappingLabels", function() {
      this.series.forEach(function(series) {
        var dataLabelsOptions = series.options && series.options.dataLabels;
        if (isArray$2(dataLabelsOptions)) {
          dataLabelsOptions = dataLabelsOptions[0];
        }
        if (series.is("pie") && series.placeDataLabels && dataLabelsOptions && !dataLabelsOptions.inside) {
          series.placeDataLabels();
        }
      });
    });
    SeriesRegistry$1.registerSeriesType("funnel", FunnelSeries);
    var __extends$g = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var merge$d = Utilities.merge;
    var PyramidSeries = (
      /** @class */
      function(_super) {
        __extends$g(PyramidSeries2, _super);
        function PyramidSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        PyramidSeries2.defaultOptions = merge$d(FunnelSeries.defaultOptions, {
          /**
           * The pyramid neck width is zero by default, as opposed to the funnel,
           * which shares the same layout logic.
           *
           * @since 3.0.10
           */
          neckWidth: "0%",
          /**
           * The pyramid neck width is zero by default, as opposed to the funnel,
           * which shares the same layout logic.
           *
           * @since 3.0.10
           */
          neckHeight: "0%",
          /**
           * The pyramid is reversed by default, as opposed to the funnel, which
           * shares the layout engine, and is not reversed.
           *
           * @since 3.0.10
           */
          reversed: true
        });
        return PyramidSeries2;
      }(FunnelSeries)
    );
    SeriesRegistry$1.registerSeriesType("pyramid", PyramidSeries);
    var colorPointMixin$1 = {
      /* eslint-disable valid-jsdoc */
      /**
       * Set the visibility of a single point
       * @private
       * @function Highcharts.colorPointMixin.setVisible
       * @param {boolean} visible
       * @return {void}
       */
      setVisible: function(vis) {
        var point = this, method = vis ? "show" : "hide";
        point.visible = point.options.visible = Boolean(vis);
        ["graphic", "dataLabel"].forEach(function(key) {
          if (point[key]) {
            point[key][method]();
          }
        });
        this.series.buildKDTree();
      }
      /* eslint-enable valid-jsdoc */
    };
    var colorSeriesMixin$1 = {
      optionalAxis: "colorAxis",
      /* eslint-disable valid-jsdoc */
      /**
       * In choropleth maps, the color is a result of the value, so this needs
       * translation too
       * @private
       * @function Highcharts.colorSeriesMixin.translateColors
       * @return {void}
       */
      translateColors: function() {
        var series = this, points = this.data.length ? this.data : this.points, nullColor = this.options.nullColor, colorAxis = this.colorAxis, colorKey = this.colorKey;
        points.forEach(function(point) {
          var value = point.getNestedProperty(colorKey), color2;
          color2 = point.options.color || (point.isNull || point.value === null ? nullColor : colorAxis && typeof value !== "undefined" ? colorAxis.toColor(value, point) : point.color || series.color);
          if (color2 && point.color !== color2) {
            point.color = color2;
            if (series.options.legendType === "point" && point.legendItem) {
              series.chart.legend.colorizeItem(point, point.visible);
            }
          }
        });
      }
      /* eslint-enable valid-jsdoc */
    };
    var exports$1 = {
      colorPointMixin: colorPointMixin$1,
      colorSeriesMixin: colorSeriesMixin$1
    };
    var color$4 = Color.parse;
    var colorPointMixin = exports$1.colorPointMixin, colorSeriesMixin = exports$1.colorSeriesMixin;
    var addEvent$6 = Utilities.addEvent, extend$i = Utilities.extend, merge$c = Utilities.merge, pick$f = Utilities.pick, splat = Utilities.splat;
    var ColorAxisComposition;
    (function(ColorAxisComposition2) {
      var composedClasses2 = [];
      var ColorAxisClass;
      function compose(ColorAxisType, ChartClass, FxClass, LegendClass, SeriesClass) {
        if (!ColorAxisClass) {
          ColorAxisClass = ColorAxisType;
        }
        if (composedClasses2.indexOf(ChartClass) === -1) {
          composedClasses2.push(ChartClass);
          var chartProto2 = ChartClass.prototype;
          chartProto2.collectionsWithUpdate.push("colorAxis");
          chartProto2.collectionsWithInit.colorAxis = [chartProto2.addColorAxis];
          addEvent$6(ChartClass, "afterGetAxes", onChartAfterGetAxes);
          wrapChartCreateAxis(ChartClass);
        }
        if (composedClasses2.indexOf(FxClass) === -1) {
          composedClasses2.push(FxClass);
          var fxProto = FxClass.prototype;
          fxProto.fillSetter = wrapFxFillSetter;
          fxProto.strokeSetter = wrapFxStrokeSetter;
        }
        if (composedClasses2.indexOf(LegendClass) === -1) {
          composedClasses2.push(LegendClass);
          addEvent$6(LegendClass, "afterGetAllItems", onLegendAfterGetAllItems);
          addEvent$6(LegendClass, "afterColorizeItem", onLegendAfterColorizeItem);
          addEvent$6(LegendClass, "afterUpdate", onLegendAfterUpdate);
        }
        if (composedClasses2.indexOf(SeriesClass) === -1) {
          composedClasses2.push(SeriesClass);
          extend$i(SeriesClass.prototype, colorSeriesMixin);
          extend$i(SeriesClass.prototype.pointClass.prototype, colorPointMixin);
          addEvent$6(SeriesClass, "afterTranslate", onSeriesAfterTranslate);
          addEvent$6(SeriesClass, "bindAxes", onSeriesBindAxes);
        }
      }
      ColorAxisComposition2.compose = compose;
      function onChartAfterGetAxes() {
        var _this = this;
        var options = this.options;
        this.colorAxis = [];
        if (options.colorAxis) {
          options.colorAxis = splat(options.colorAxis);
          options.colorAxis.forEach(function(axisOptions, i) {
            axisOptions.index = i;
            new ColorAxisClass(_this, axisOptions);
          });
        }
      }
      function onLegendAfterGetAllItems(e2) {
        var _this = this;
        var colorAxes = this.chart.colorAxis || [], destroyItem = function(item2) {
          var i2 = e2.allItems.indexOf(item2);
          if (i2 !== -1) {
            _this.destroyItem(e2.allItems[i2]);
            e2.allItems.splice(i2, 1);
          }
        };
        var colorAxisItems = [], options, i;
        colorAxes.forEach(function(colorAxis) {
          options = colorAxis.options;
          if (options && options.showInLegend) {
            if (options.dataClasses && options.visible) {
              colorAxisItems = colorAxisItems.concat(colorAxis.getDataClassLegendSymbols());
            } else if (options.visible) {
              colorAxisItems.push(colorAxis);
            }
            colorAxis.series.forEach(function(series) {
              if (!series.options.showInLegend || options.dataClasses) {
                if (series.options.legendType === "point") {
                  series.points.forEach(function(point) {
                    destroyItem(point);
                  });
                } else {
                  destroyItem(series);
                }
              }
            });
          }
        });
        i = colorAxisItems.length;
        while (i--) {
          e2.allItems.unshift(colorAxisItems[i]);
        }
      }
      function onLegendAfterColorizeItem(e2) {
        if (e2.visible && e2.item.legendColor) {
          e2.item.legendSymbol.attr({
            fill: e2.item.legendColor
          });
        }
      }
      function onLegendAfterUpdate() {
        var colorAxes = this.chart.colorAxis;
        if (colorAxes) {
          colorAxes.forEach(function(colorAxis) {
            colorAxis.update({}, arguments[2]);
          });
        }
      }
      function onSeriesAfterTranslate() {
        if (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) {
          this.translateColors();
        }
      }
      function onSeriesBindAxes() {
        var axisTypes = this.axisTypes;
        if (!axisTypes) {
          this.axisTypes = ["colorAxis"];
        } else if (axisTypes.indexOf("colorAxis") === -1) {
          axisTypes.push("colorAxis");
        }
      }
      function wrapChartCreateAxis(ChartClass) {
        var superCreateAxis = ChartClass.prototype.createAxis;
        ChartClass.prototype.createAxis = function(type, options) {
          if (type !== "colorAxis") {
            return superCreateAxis.apply(this, arguments);
          }
          var axis = new ColorAxisClass(this, merge$c(options.axis, {
            index: this[type].length,
            isX: false
          }));
          this.isDirtyLegend = true;
          this.axes.forEach(function(axis2) {
            axis2.series = [];
          });
          this.series.forEach(function(series) {
            series.bindAxes();
            series.isDirtyData = true;
          });
          if (pick$f(options.redraw, true)) {
            this.redraw(options.animation);
          }
          return axis;
        };
      }
      function wrapFxFillSetter() {
        this.elem.attr("fill", color$4(this.start).tweenTo(color$4(this.end), this.pos), void 0, true);
      }
      function wrapFxStrokeSetter() {
        this.elem.attr("stroke", color$4(this.start).tweenTo(color$4(this.end), this.pos), void 0, true);
      }
    })(ColorAxisComposition || (ColorAxisComposition = {}));
    const ColorAxisComposition$1 = ColorAxisComposition;
    var colorAxisDefaults = {
      /**
       * Whether to allow decimals on the color axis.
       * @type      {boolean}
       * @default   true
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.allowDecimals
       */
      /**
       * Determines how to set each data class' color if no individual
       * color is set. The default value, `tween`, computes intermediate
       * colors between `minColor` and `maxColor`. The other possible
       * value, `category`, pulls colors from the global or chart specific
       * [colors](#colors) array.
       *
       * @sample {highmaps} maps/coloraxis/dataclasscolor/
       *         Category colors
       *
       * @type       {string}
       * @default    tween
       * @product    highcharts highstock highmaps
       * @validvalue ["tween", "category"]
       * @apioption  colorAxis.dataClassColor
       */
      /**
       * An array of data classes or ranges for the choropleth map. If
       * none given, the color axis is scalar and values are distributed
       * as a gradient between the minimum and maximum colors.
       *
       * @sample {highmaps} maps/demo/data-class-ranges/
       *         Multiple ranges
       *
       * @sample {highmaps} maps/demo/data-class-two-ranges/
       *         Two ranges
       *
       * @type      {Array<*>}
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.dataClasses
       */
      /**
       * The layout of the color axis. Can be `'horizontal'` or `'vertical'`.
       * If none given, the color axis has the same layout as the legend.
       *
       * @sample highcharts/coloraxis/horizontal-layout/
       *         Horizontal color axis layout with vertical legend
       *
       * @type      {string|undefined}
       * @since     7.2.0
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.layout
       */
      /**
       * The color of each data class. If not set, the color is pulled
       * from the global or chart-specific [colors](#colors) array. In
       * styled mode, this option is ignored. Instead, use colors defined
       * in CSS.
       *
       * @sample {highmaps} maps/demo/data-class-two-ranges/
       *         Explicit colors
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.dataClasses.color
       */
      /**
       * The start of the value range that the data class represents,
       * relating to the point value.
       *
       * The range of each `dataClass` is closed in both ends, but can be
       * overridden by the next `dataClass`.
       *
       * @type      {number}
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.dataClasses.from
       */
      /**
       * The name of the data class as it appears in the legend.
       * If no name is given, it is automatically created based on the
       * `from` and `to` values. For full programmatic control,
       * [legend.labelFormatter](#legend.labelFormatter) can be used.
       * In the formatter, `this.from` and `this.to` can be accessed.
       *
       * @sample {highmaps} maps/coloraxis/dataclasses-name/
       *         Named data classes
       *
       * @sample {highmaps} maps/coloraxis/dataclasses-labelformatter/
       *         Formatted data classes
       *
       * @type      {string}
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.dataClasses.name
       */
      /**
       * The end of the value range that the data class represents,
       * relating to the point value.
       *
       * The range of each `dataClass` is closed in both ends, but can be
       * overridden by the next `dataClass`.
       *
       * @type      {number}
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.dataClasses.to
       */
      /** @ignore-option */
      lineWidth: 0,
      /**
       * Padding of the min value relative to the length of the axis. A
       * padding of 0.05 will make a 100px axis 5px longer.
       *
       * @product highcharts highstock highmaps
       */
      minPadding: 0,
      /**
       * The maximum value of the axis in terms of map point values. If
       * `null`, the max value is automatically calculated. If the
       * `endOnTick` option is true, the max value might be rounded up.
       *
       * @sample {highmaps} maps/coloraxis/gridlines/
       *         Explicit min and max to reduce the effect of outliers
       *
       * @type      {number}
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.max
       */
      /**
       * The minimum value of the axis in terms of map point values. If
       * `null`, the min value is automatically calculated. If the
       * `startOnTick` option is true, the min value might be rounded
       * down.
       *
       * @sample {highmaps} maps/coloraxis/gridlines/
       *         Explicit min and max to reduce the effect of outliers
       *
       * @type      {number}
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.min
       */
      /**
       * Padding of the max value relative to the length of the axis. A
       * padding of 0.05 will make a 100px axis 5px longer.
       *
       * @product highcharts highstock highmaps
       */
      maxPadding: 0,
      /**
       * Color of the grid lines extending from the axis across the
       * gradient.
       *
       * @sample {highmaps} maps/coloraxis/gridlines/
       *         Grid lines demonstrated
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default   #e6e6e6
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.gridLineColor
       */
      /**
       * The width of the grid lines extending from the axis across the
       * gradient of a scalar color axis.
       *
       * @sample {highmaps} maps/coloraxis/gridlines/
       *         Grid lines demonstrated
       *
       * @product highcharts highstock highmaps
       */
      gridLineWidth: 1,
      /**
       * The interval of the tick marks in axis units. When `null`, the
       * tick interval is computed to approximately follow the
       * `tickPixelInterval`.
       *
       * @type      {number}
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.tickInterval
       */
      /**
       * If [tickInterval](#colorAxis.tickInterval) is `null` this option
       * sets the approximate pixel interval of the tick marks.
       *
       * @product highcharts highstock highmaps
       */
      tickPixelInterval: 72,
      /**
       * Whether to force the axis to start on a tick. Use this option
       * with the `maxPadding` option to control the axis start.
       *
       * @product highcharts highstock highmaps
       */
      startOnTick: true,
      /**
       * Whether to force the axis to end on a tick. Use this option with
       * the [maxPadding](#colorAxis.maxPadding) option to control the
       * axis end.
       *
       * @product highcharts highstock highmaps
       */
      endOnTick: true,
      /** @ignore */
      offset: 0,
      /**
       * The triangular marker on a scalar color axis that points to the
       * value of the hovered area. To disable the marker, set
       * `marker: null`.
       *
       * @sample {highmaps} maps/coloraxis/marker/
       *         Black marker
       *
       * @declare Highcharts.PointMarkerOptionsObject
       * @product highcharts highstock highmaps
       */
      marker: {
        /**
         * Animation for the marker as it moves between values. Set to
         * `false` to disable animation. Defaults to `{ duration: 50 }`.
         *
         * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}
         * @product highcharts highstock highmaps
         */
        animation: {
          /** @internal */
          duration: 50
        },
        /** @internal */
        width: 0.01,
        /**
         * The color of the marker.
         *
         * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @product highcharts highstock highmaps
         */
        color: palette.neutralColor40
      },
      /**
       * The axis labels show the number for each tick.
       *
       * For more live examples on label options, see [xAxis.labels in the
       * Highcharts API.](/highcharts#xAxis.labels)
       *
       * @extends xAxis.labels
       * @product highcharts highstock highmaps
       */
      labels: {
        /**
         * How to handle overflowing labels on horizontal color axis. If set
         * to `"allow"`, it will not be aligned at all. By default it
         * `"justify"` labels inside the chart area. If there is room to
         * move it, it will be aligned to the edge, else it will be removed.
         *
         * @validvalue ["allow", "justify"]
         * @product    highcharts highstock highmaps
         */
        overflow: "justify",
        rotation: 0
      },
      /**
       * The color to represent the minimum of the color axis. Unless
       * [dataClasses](#colorAxis.dataClasses) or
       * [stops](#colorAxis.stops) are set, the gradient starts at this
       * value.
       *
       * If dataClasses are set, the color is based on minColor and
       * maxColor unless a color is set for each data class, or the
       * [dataClassColor](#colorAxis.dataClassColor) is set.
       *
       * @sample {highmaps} maps/coloraxis/mincolor-maxcolor/
       *         Min and max colors on scalar (gradient) axis
       * @sample {highmaps} maps/coloraxis/mincolor-maxcolor-dataclasses/
       *         On data classes
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product highcharts highstock highmaps
       */
      minColor: palette.highlightColor10,
      /**
       * The color to represent the maximum of the color axis. Unless
       * [dataClasses](#colorAxis.dataClasses) or
       * [stops](#colorAxis.stops) are set, the gradient ends at this
       * value.
       *
       * If dataClasses are set, the color is based on minColor and
       * maxColor unless a color is set for each data class, or the
       * [dataClassColor](#colorAxis.dataClassColor) is set.
       *
       * @sample {highmaps} maps/coloraxis/mincolor-maxcolor/
       *         Min and max colors on scalar (gradient) axis
       * @sample {highmaps} maps/coloraxis/mincolor-maxcolor-dataclasses/
       *         On data classes
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product highcharts highstock highmaps
       */
      maxColor: palette.highlightColor100,
      /**
       * Color stops for the gradient of a scalar color axis. Use this in
       * cases where a linear gradient between a `minColor` and `maxColor`
       * is not sufficient. The stops is an array of tuples, where the
       * first item is a float between 0 and 1 assigning the relative
       * position in the gradient, and the second item is the color.
       *
       * @sample {highmaps} maps/demo/heatmap/
       *         Heatmap with three color stops
       *
       * @type      {Array<Array<number,Highcharts.ColorString>>}
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.stops
       */
      /**
       * The pixel length of the main tick marks on the color axis.
       */
      tickLength: 5,
      /**
       * The type of interpolation to use for the color axis. Can be
       * `linear` or `logarithmic`.
       *
       * @sample highcharts/coloraxis/logarithmic-with-emulate-negative-values/
       *         Logarithmic color axis with extension to emulate negative
       *         values
       *
       * @type      {Highcharts.ColorAxisTypeValue}
       * @default   linear
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.type
       */
      /**
       * Whether to reverse the axis so that the highest number is closest
       * to the origin. Defaults to `false` in a horizontal legend and
       * `true` in a vertical legend, where the smallest value starts on
       * top.
       *
       * @type      {boolean}
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.reversed
       */
      /**
       * @product   highcharts highstock highmaps
       * @excluding afterBreaks, pointBreak, pointInBreak
       * @apioption colorAxis.events
       */
      /**
       * Fires when the legend item belonging to the colorAxis is clicked.
       * One parameter, `event`, is passed to the function.
       *
       * @type      {Function}
       * @product   highcharts highstock highmaps
       * @apioption colorAxis.events.legendItemClick
       */
      /**
       * Whether to display the colorAxis in the legend.
       *
       * @sample highcharts/coloraxis/hidden-coloraxis-with-3d-chart/
       *         Hidden color axis with 3d chart
       *
       * @see [heatmap.showInLegend](#series.heatmap.showInLegend)
       *
       * @since   4.2.7
       * @product highcharts highstock highmaps
       */
      showInLegend: true
    };
    var __extends$f = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var color$3 = Color.parse;
    var noop$2 = H.noop;
    var Series$6 = SeriesRegistry$1.series;
    var extend$h = Utilities.extend, isNumber$7 = Utilities.isNumber, merge$b = Utilities.merge, pick$e = Utilities.pick;
    var ColorAxis = (
      /** @class */
      function(_super) {
        __extends$f(ColorAxis2, _super);
        function ColorAxis2(chart, userOptions) {
          var _this = _super.call(this, chart, userOptions) || this;
          _this.beforePadding = false;
          _this.chart = void 0;
          _this.coll = "colorAxis";
          _this.dataClasses = void 0;
          _this.legendItem = void 0;
          _this.legendItems = void 0;
          _this.name = "";
          _this.options = void 0;
          _this.stops = void 0;
          _this.visible = true;
          _this.init(chart, userOptions);
          return _this;
        }
        ColorAxis2.compose = function(ChartClass, FxClass, LegendClass, SeriesClass) {
          ColorAxisComposition$1.compose(ColorAxis2, ChartClass, FxClass, LegendClass, SeriesClass);
        };
        ColorAxis2.prototype.init = function(chart, userOptions) {
          var axis = this;
          var legend = chart.options.legend || {}, horiz = userOptions.layout ? userOptions.layout !== "vertical" : legend.layout !== "vertical", visible = userOptions.visible;
          var options = merge$b(ColorAxis2.defaultColorAxisOptions, userOptions, {
            showEmpty: false,
            title: null,
            visible: legend.enabled && visible !== false
          });
          axis.coll = "colorAxis";
          axis.side = userOptions.side || horiz ? 2 : 1;
          axis.reversed = userOptions.reversed || !horiz;
          axis.opposite = !horiz;
          _super.prototype.init.call(this, chart, options);
          axis.userOptions.visible = visible;
          if (userOptions.dataClasses) {
            axis.initDataClasses(userOptions);
          }
          axis.initStops();
          axis.horiz = horiz;
          axis.zoomEnabled = false;
        };
        ColorAxis2.prototype.initDataClasses = function(userOptions) {
          var axis = this, chart = axis.chart, options = axis.options, len = userOptions.dataClasses.length;
          var dataClasses, colorCounter = 0, colorCount = chart.options.chart.colorCount;
          axis.dataClasses = dataClasses = [];
          axis.legendItems = [];
          (userOptions.dataClasses || []).forEach(function(dataClass, i) {
            var colors;
            dataClass = merge$b(dataClass);
            dataClasses.push(dataClass);
            if (!chart.styledMode && dataClass.color) {
              return;
            }
            if (options.dataClassColor === "category") {
              if (!chart.styledMode) {
                colors = chart.options.colors;
                colorCount = colors.length;
                dataClass.color = colors[colorCounter];
              }
              dataClass.colorIndex = colorCounter;
              colorCounter++;
              if (colorCounter === colorCount) {
                colorCounter = 0;
              }
            } else {
              dataClass.color = color$3(options.minColor).tweenTo(
                color$3(options.maxColor),
                len < 2 ? 0.5 : i / (len - 1)
                // #3219
              );
            }
          });
        };
        ColorAxis2.prototype.hasData = function() {
          return !!(this.tickPositions || []).length;
        };
        ColorAxis2.prototype.setTickPositions = function() {
          if (!this.dataClasses) {
            return _super.prototype.setTickPositions.call(this);
          }
        };
        ColorAxis2.prototype.initStops = function() {
          var axis = this;
          axis.stops = axis.options.stops || [
            [0, axis.options.minColor],
            [1, axis.options.maxColor]
          ];
          axis.stops.forEach(function(stop2) {
            stop2.color = color$3(stop2[1]);
          });
        };
        ColorAxis2.prototype.setOptions = function(userOptions) {
          var axis = this;
          _super.prototype.setOptions.call(this, userOptions);
          axis.options.crosshair = axis.options.marker;
        };
        ColorAxis2.prototype.setAxisSize = function() {
          var axis = this;
          var symbol = axis.legendSymbol;
          var chart = axis.chart;
          var legendOptions = chart.options.legend || {};
          var x, y, width, height;
          if (symbol) {
            this.left = x = symbol.attr("x");
            this.top = y = symbol.attr("y");
            this.width = width = symbol.attr("width");
            this.height = height = symbol.attr("height");
            this.right = chart.chartWidth - x - width;
            this.bottom = chart.chartHeight - y - height;
            this.len = this.horiz ? width : height;
            this.pos = this.horiz ? x : y;
          } else {
            this.len = (this.horiz ? legendOptions.symbolWidth : legendOptions.symbolHeight) || ColorAxis2.defaultLegendLength;
          }
        };
        ColorAxis2.prototype.normalizedValue = function(value) {
          var axis = this;
          if (axis.logarithmic) {
            value = axis.logarithmic.log2lin(value);
          }
          return 1 - (axis.max - value) / (axis.max - axis.min || 1);
        };
        ColorAxis2.prototype.toColor = function(value, point) {
          var axis = this;
          var dataClasses = axis.dataClasses;
          var stops = axis.stops;
          var pos, from, to, color2, dataClass, i;
          if (dataClasses) {
            i = dataClasses.length;
            while (i--) {
              dataClass = dataClasses[i];
              from = dataClass.from;
              to = dataClass.to;
              if ((typeof from === "undefined" || value >= from) && (typeof to === "undefined" || value <= to)) {
                color2 = dataClass.color;
                if (point) {
                  point.dataClass = i;
                  point.colorIndex = dataClass.colorIndex;
                }
                break;
              }
            }
          } else {
            pos = axis.normalizedValue(value);
            i = stops.length;
            while (i--) {
              if (pos > stops[i][0]) {
                break;
              }
            }
            from = stops[i] || stops[i + 1];
            to = stops[i + 1] || from;
            pos = 1 - (to[0] - pos) / (to[0] - from[0] || 1);
            color2 = from.color.tweenTo(to.color, pos);
          }
          return color2;
        };
        ColorAxis2.prototype.getOffset = function() {
          var axis = this;
          var group = axis.legendGroup;
          var sideOffset = axis.chart.axisOffset[axis.side];
          if (group) {
            axis.axisParent = group;
            _super.prototype.getOffset.call(this);
            if (!axis.added) {
              axis.added = true;
              axis.labelLeft = 0;
              axis.labelRight = axis.width;
            }
            axis.chart.axisOffset[axis.side] = sideOffset;
          }
        };
        ColorAxis2.prototype.setLegendColor = function() {
          var axis = this;
          var horiz = axis.horiz;
          var reversed = axis.reversed;
          var one = reversed ? 1 : 0;
          var zero = reversed ? 0 : 1;
          var grad = horiz ? [one, 0, zero, 0] : [0, zero, 0, one];
          axis.legendColor = {
            linearGradient: {
              x1: grad[0],
              y1: grad[1],
              x2: grad[2],
              y2: grad[3]
            },
            stops: axis.stops
          };
        };
        ColorAxis2.prototype.drawLegendSymbol = function(legend, item2) {
          var axis = this;
          var padding = legend.padding;
          var legendOptions = legend.options;
          var horiz = axis.horiz;
          var width = pick$e(legendOptions.symbolWidth, horiz ? ColorAxis2.defaultLegendLength : 12);
          var height = pick$e(legendOptions.symbolHeight, horiz ? 12 : ColorAxis2.defaultLegendLength);
          var labelPadding = pick$e(legendOptions.labelPadding, horiz ? 16 : 30);
          var itemDistance = pick$e(legendOptions.itemDistance, 10);
          this.setLegendColor();
          item2.legendSymbol = this.chart.renderer.rect(0, legend.baseline - 11, width, height).attr({
            zIndex: 1
          }).add(item2.legendGroup);
          axis.legendItemWidth = width + padding + (horiz ? itemDistance : labelPadding);
          axis.legendItemHeight = height + padding + (horiz ? labelPadding : 0);
        };
        ColorAxis2.prototype.setState = function(state) {
          this.series.forEach(function(series) {
            series.setState(state);
          });
        };
        ColorAxis2.prototype.setVisible = function() {
        };
        ColorAxis2.prototype.getSeriesExtremes = function() {
          var axis = this;
          var series = axis.series;
          var colorValArray, colorKey, colorValIndex, pointArrayMap, calculatedExtremes, cSeries, i = series.length, yData, j;
          this.dataMin = Infinity;
          this.dataMax = -Infinity;
          while (i--) {
            cSeries = series[i];
            colorKey = cSeries.colorKey = pick$e(cSeries.options.colorKey, cSeries.colorKey, cSeries.pointValKey, cSeries.zoneAxis, "y");
            pointArrayMap = cSeries.pointArrayMap;
            calculatedExtremes = cSeries[colorKey + "Min"] && cSeries[colorKey + "Max"];
            if (cSeries[colorKey + "Data"]) {
              colorValArray = cSeries[colorKey + "Data"];
            } else {
              if (!pointArrayMap) {
                colorValArray = cSeries.yData;
              } else {
                colorValArray = [];
                colorValIndex = pointArrayMap.indexOf(colorKey);
                yData = cSeries.yData;
                if (colorValIndex >= 0 && yData) {
                  for (j = 0; j < yData.length; j++) {
                    colorValArray.push(pick$e(yData[j][colorValIndex], yData[j]));
                  }
                }
              }
            }
            if (calculatedExtremes) {
              cSeries.minColorValue = cSeries[colorKey + "Min"];
              cSeries.maxColorValue = cSeries[colorKey + "Max"];
            } else {
              var cExtremes = Series$6.prototype.getExtremes.call(cSeries, colorValArray);
              cSeries.minColorValue = cExtremes.dataMin;
              cSeries.maxColorValue = cExtremes.dataMax;
            }
            if (typeof cSeries.minColorValue !== "undefined") {
              this.dataMin = Math.min(this.dataMin, cSeries.minColorValue);
              this.dataMax = Math.max(this.dataMax, cSeries.maxColorValue);
            }
            if (!calculatedExtremes) {
              Series$6.prototype.applyExtremes.call(cSeries);
            }
          }
        };
        ColorAxis2.prototype.drawCrosshair = function(e2, point) {
          var axis = this;
          var plotX = point && point.plotX;
          var plotY = point && point.plotY;
          var axisPos = axis.pos;
          var axisLen = axis.len;
          var crossPos;
          if (point) {
            crossPos = axis.toPixels(point.getNestedProperty(point.series.colorKey));
            if (crossPos < axisPos) {
              crossPos = axisPos - 2;
            } else if (crossPos > axisPos + axisLen) {
              crossPos = axisPos + axisLen + 2;
            }
            point.plotX = crossPos;
            point.plotY = axis.len - crossPos;
            _super.prototype.drawCrosshair.call(this, e2, point);
            point.plotX = plotX;
            point.plotY = plotY;
            if (axis.cross && !axis.cross.addedToColorAxis && axis.legendGroup) {
              axis.cross.addClass("highcharts-coloraxis-marker").add(axis.legendGroup);
              axis.cross.addedToColorAxis = true;
              if (!axis.chart.styledMode && typeof axis.crosshair === "object") {
                axis.cross.attr({
                  fill: axis.crosshair.color
                });
              }
            }
          }
        };
        ColorAxis2.prototype.getPlotLinePath = function(options) {
          var axis = this, left = axis.left, pos = options.translatedValue, top = axis.top;
          return isNumber$7(pos) ? (
            // pos can be 0 (#3969)
            axis.horiz ? [
              ["M", pos - 4, top - 6],
              ["L", pos + 4, top - 6],
              ["L", pos, top],
              ["Z"]
            ] : [
              ["M", left, pos],
              ["L", left - 6, pos + 6],
              ["L", left - 6, pos - 6],
              ["Z"]
            ]
          ) : _super.prototype.getPlotLinePath.call(this, options);
        };
        ColorAxis2.prototype.update = function(newOptions, redraw) {
          var axis = this, chart = axis.chart, legend = chart.legend;
          this.series.forEach(function(series) {
            series.isDirtyData = true;
          });
          if (newOptions.dataClasses && legend.allItems || axis.dataClasses) {
            axis.destroyItems();
          }
          _super.prototype.update.call(this, newOptions, redraw);
          if (axis.legendItem) {
            axis.setLegendColor();
            legend.colorizeItem(this, true);
          }
        };
        ColorAxis2.prototype.destroyItems = function() {
          var axis = this;
          var chart = axis.chart;
          if (axis.legendItem) {
            chart.legend.destroyItem(axis);
          } else if (axis.legendItems) {
            axis.legendItems.forEach(function(item2) {
              chart.legend.destroyItem(item2);
            });
          }
          chart.isDirtyLegend = true;
        };
        ColorAxis2.prototype.destroy = function() {
          this.chart.isDirtyLegend = true;
          this.destroyItems();
          _super.prototype.destroy.apply(this, [].slice.call(arguments));
        };
        ColorAxis2.prototype.remove = function(redraw) {
          this.destroyItems();
          _super.prototype.remove.call(this, redraw);
        };
        ColorAxis2.prototype.getDataClassLegendSymbols = function() {
          var axis = this;
          var chart = axis.chart;
          var legendItems = axis.legendItems;
          var legendOptions = chart.options.legend;
          var valueDecimals = legendOptions.valueDecimals;
          var valueSuffix = legendOptions.valueSuffix || "";
          var name;
          if (!legendItems.length) {
            axis.dataClasses.forEach(function(dataClass, i) {
              var from = dataClass.from, to = dataClass.to, numberFormatter = chart.numberFormatter;
              var vis = true;
              name = "";
              if (typeof from === "undefined") {
                name = "< ";
              } else if (typeof to === "undefined") {
                name = "> ";
              }
              if (typeof from !== "undefined") {
                name += numberFormatter(from, valueDecimals) + valueSuffix;
              }
              if (typeof from !== "undefined" && typeof to !== "undefined") {
                name += " - ";
              }
              if (typeof to !== "undefined") {
                name += numberFormatter(to, valueDecimals) + valueSuffix;
              }
              legendItems.push(extend$h({
                chart,
                name,
                options: {},
                drawLegendSymbol: LegendSymbol$1.drawRectangle,
                visible: true,
                setState: noop$2,
                isDataClass: true,
                setVisible: function() {
                  vis = axis.visible = !vis;
                  axis.series.forEach(function(series) {
                    series.points.forEach(function(point) {
                      if (point.dataClass === i) {
                        point.setVisible(vis);
                      }
                    });
                  });
                  chart.legend.colorizeItem(this, vis);
                }
              }, dataClass));
            });
          }
          return legendItems;
        };
        ColorAxis2.defaultColorAxisOptions = colorAxisDefaults;
        ColorAxis2.defaultLegendLength = 200;
        ColorAxis2.keepProps = [
          "legendGroup",
          "legendItemHeight",
          "legendItemWidth",
          "legendItem",
          "legendSymbol"
        ];
        return ColorAxis2;
      }(Axis)
    );
    Array.prototype.push.apply(Axis.keepProps, ColorAxis.keepProps);
    var defined$7 = Utilities.defined, addEvent$5 = Utilities.addEvent;
    var noop$1 = H.noop, seriesTypes = H.seriesTypes;
    addEvent$5(Point$2, "afterSetState", function(e2) {
      var point = this;
      if (point.moveToTopOnHover && point.graphic) {
        point.graphic.attr({
          zIndex: e2 && e2.state === "hover" ? 1 : 0
        });
      }
    });
    var colorMapPointMixin$1 = {
      dataLabelOnNull: true,
      moveToTopOnHover: true,
      /* eslint-disable valid-jsdoc */
      /**
       * Color points have a value option that determines whether or not it is
       * a null point
       * @private
       */
      isValid: function() {
        return this.value !== null && this.value !== Infinity && this.value !== -Infinity;
      }
      /* eslint-enable valid-jsdoc */
    };
    var colorMapSeriesMixin$2 = {
      pointArrayMap: ["value"],
      axisTypes: ["xAxis", "yAxis", "colorAxis"],
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      getSymbol: noop$1,
      parallelArrays: ["x", "y", "value"],
      colorKey: "value",
      pointAttribs: seriesTypes.column.prototype.pointAttribs,
      /* eslint-disable valid-jsdoc */
      /**
       * Get the color attibutes to apply on the graphic
       * @private
       * @function Highcharts.colorMapSeriesMixin.colorAttribs
       * @param {Highcharts.Point} point
       * @return {Highcharts.SVGAttributes}
       */
      colorAttribs: function(point) {
        var ret = {};
        if (defined$7(point.color) && (!point.state || point.state === "normal")) {
          ret[this.colorProp || "fill"] = point.color;
        }
        return ret;
      }
    };
    var exports = {
      colorMapPointMixin: colorMapPointMixin$1,
      colorMapSeriesMixin: colorMapSeriesMixin$2
    };
    var __extends$e = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var colorMapPointMixin = exports.colorMapPointMixin;
    var ScatterPoint$1 = SeriesRegistry$1.seriesTypes.scatter.prototype.pointClass;
    var clamp$2 = Utilities.clamp, extend$g = Utilities.extend, pick$d = Utilities.pick;
    var HeatmapPoint = (
      /** @class */
      function(_super) {
        __extends$e(HeatmapPoint2, _super);
        function HeatmapPoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.options = void 0;
          _this.series = void 0;
          _this.value = void 0;
          _this.x = void 0;
          _this.y = void 0;
          return _this;
        }
        HeatmapPoint2.prototype.applyOptions = function(options, x) {
          var point = _super.prototype.applyOptions.call(this, options, x);
          point.formatPrefix = point.isNull || point.value === null ? "null" : "point";
          return point;
        };
        HeatmapPoint2.prototype.getCellAttributes = function() {
          var point = this, series = point.series, seriesOptions = series.options, xPad = (seriesOptions.colsize || 1) / 2, yPad = (seriesOptions.rowsize || 1) / 2, xAxis = series.xAxis, yAxis = series.yAxis, markerOptions = point.options.marker || series.options.marker, pointPlacement = series.pointPlacementToXValue(), pointPadding = pick$d(point.pointPadding, seriesOptions.pointPadding, 0), cellAttr = {
            x1: clamp$2(Math.round(xAxis.len - (xAxis.translate(point.x - xPad, false, true, false, true, -pointPlacement) || 0)), -xAxis.len, 2 * xAxis.len),
            x2: clamp$2(Math.round(xAxis.len - (xAxis.translate(point.x + xPad, false, true, false, true, -pointPlacement) || 0)), -xAxis.len, 2 * xAxis.len),
            y1: clamp$2(Math.round(yAxis.translate(point.y - yPad, false, true, false, true) || 0), -yAxis.len, 2 * yAxis.len),
            y2: clamp$2(Math.round(yAxis.translate(point.y + yPad, false, true, false, true) || 0), -yAxis.len, 2 * yAxis.len)
          };
          [["width", "x"], ["height", "y"]].forEach(function(dimension) {
            var prop = dimension[0], direction = dimension[1];
            var start = direction + "1", end = direction + "2";
            var side = Math.abs(cellAttr[start] - cellAttr[end]), borderWidth = markerOptions && markerOptions.lineWidth || 0, plotPos = Math.abs(cellAttr[start] + cellAttr[end]) / 2;
            if (markerOptions[prop] && markerOptions[prop] < side) {
              cellAttr[start] = plotPos - markerOptions[prop] / 2 - borderWidth / 2;
              cellAttr[end] = plotPos + markerOptions[prop] / 2 + borderWidth / 2;
            }
            if (pointPadding) {
              if (direction === "y") {
                start = end;
                end = direction + "1";
              }
              cellAttr[start] += pointPadding;
              cellAttr[end] -= pointPadding;
            }
          });
          return cellAttr;
        };
        HeatmapPoint2.prototype.haloPath = function(size) {
          if (!size) {
            return [];
          }
          var rect2 = this.shapeArgs;
          return [
            "M",
            rect2.x - size,
            rect2.y - size,
            "L",
            rect2.x - size,
            rect2.y + rect2.height + size,
            rect2.x + rect2.width + size,
            rect2.y + rect2.height + size,
            rect2.x + rect2.width + size,
            rect2.y - size,
            "Z"
          ];
        };
        HeatmapPoint2.prototype.isValid = function() {
          return this.value !== Infinity && this.value !== -Infinity;
        };
        return HeatmapPoint2;
      }(ScatterPoint$1)
    );
    extend$g(HeatmapPoint.prototype, {
      dataLabelOnNull: colorMapPointMixin.dataLabelOnNull,
      moveToTopOnHover: colorMapPointMixin.moveToTopOnHover
    });
    var __extends$d = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var colorMapSeriesMixin$1 = exports.colorMapSeriesMixin;
    var Series$5 = SeriesRegistry$1.series, _a$5 = SeriesRegistry$1.seriesTypes, ColumnSeries$7 = _a$5.column, ScatterSeries$1 = _a$5.scatter;
    var symbols$1 = SVGRenderer.prototype.symbols;
    var extend$f = Utilities.extend, fireEvent$1 = Utilities.fireEvent, isNumber$6 = Utilities.isNumber, merge$a = Utilities.merge, pick$c = Utilities.pick;
    var HeatmapSeries$1 = (
      /** @class */
      function(_super) {
        __extends$d(HeatmapSeries2, _super);
        function HeatmapSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.colorAxis = void 0;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          _this.valueMax = NaN;
          _this.valueMin = NaN;
          return _this;
        }
        HeatmapSeries2.prototype.drawPoints = function() {
          var _this = this;
          var seriesMarkerOptions = this.options.marker || {};
          if (seriesMarkerOptions.enabled || this._hasPointMarkers) {
            Series$5.prototype.drawPoints.call(this);
            this.points.forEach(function(point) {
              if (point.graphic) {
                point.graphic[_this.chart.styledMode ? "css" : "animate"](_this.colorAttribs(point));
                if (_this.options.borderRadius) {
                  point.graphic.attr({
                    r: _this.options.borderRadius
                  });
                }
                if (point.value === null) {
                  point.graphic.addClass("highcharts-null-point");
                }
              }
            });
          }
        };
        HeatmapSeries2.prototype.getExtremes = function() {
          var _a2 = Series$5.prototype.getExtremes.call(this, this.valueData), dataMin = _a2.dataMin, dataMax = _a2.dataMax;
          if (isNumber$6(dataMin)) {
            this.valueMin = dataMin;
          }
          if (isNumber$6(dataMax)) {
            this.valueMax = dataMax;
          }
          return Series$5.prototype.getExtremes.call(this);
        };
        HeatmapSeries2.prototype.getValidPoints = function(points, insideOnly) {
          return Series$5.prototype.getValidPoints.call(this, points, insideOnly, true);
        };
        HeatmapSeries2.prototype.hasData = function() {
          return !!this.processedXData.length;
        };
        HeatmapSeries2.prototype.init = function() {
          var options;
          Series$5.prototype.init.apply(this, arguments);
          options = this.options;
          options.pointRange = pick$c(options.pointRange, options.colsize || 1);
          this.yAxis.axisPointRange = options.rowsize || 1;
          symbols$1.ellipse = symbols$1.circle;
        };
        HeatmapSeries2.prototype.markerAttribs = function(point, state) {
          var pointMarkerOptions = point.marker || {}, seriesMarkerOptions = this.options.marker || {}, seriesStateOptions, pointStateOptions, shapeArgs = point.shapeArgs || {}, hasImage = point.hasImage, attribs = {};
          if (hasImage) {
            return {
              x: point.plotX,
              y: point.plotY
            };
          }
          if (state) {
            seriesStateOptions = seriesMarkerOptions.states[state] || {};
            pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
            [["width", "x"], ["height", "y"]].forEach(function(dimension) {
              attribs[dimension[0]] = (pointStateOptions[dimension[0]] || seriesStateOptions[dimension[0]] || shapeArgs[dimension[0]]) + (pointStateOptions[dimension[0] + "Plus"] || seriesStateOptions[dimension[0] + "Plus"] || 0);
              attribs[dimension[1]] = shapeArgs[dimension[1]] + (shapeArgs[dimension[0]] - attribs[dimension[0]]) / 2;
            });
          }
          return state ? attribs : shapeArgs;
        };
        HeatmapSeries2.prototype.pointAttribs = function(point, state) {
          var series = this, attr2 = Series$5.prototype.pointAttribs.call(series, point, state), seriesOptions = series.options || {}, plotOptions = series.chart.options.plotOptions || {}, seriesPlotOptions = plotOptions.series || {}, heatmapPlotOptions = plotOptions.heatmap || {}, stateOptions, brightness, borderColor = point && point.options.borderColor || seriesOptions.borderColor || heatmapPlotOptions.borderColor || seriesPlotOptions.borderColor, borderWidth = point && point.options.borderWidth || seriesOptions.borderWidth || heatmapPlotOptions.borderWidth || seriesPlotOptions.borderWidth || attr2["stroke-width"];
          attr2.stroke = point && point.marker && point.marker.lineColor || seriesOptions.marker && seriesOptions.marker.lineColor || borderColor || this.color;
          attr2["stroke-width"] = borderWidth;
          if (state) {
            stateOptions = merge$a(seriesOptions.states[state], seriesOptions.marker && seriesOptions.marker.states[state], point && point.options.states && point.options.states[state] || {});
            brightness = stateOptions.brightness;
            attr2.fill = stateOptions.color || Color.parse(attr2.fill).brighten(brightness || 0).get();
            attr2.stroke = stateOptions.lineColor;
          }
          return attr2;
        };
        HeatmapSeries2.prototype.setClip = function(animation) {
          var series = this, chart = series.chart;
          Series$5.prototype.setClip.apply(series, arguments);
          if (series.options.clip !== false || animation) {
            series.markerGroup.clip((animation || series.clipBox) && series.sharedClipKey ? chart.sharedClips[series.sharedClipKey] : chart.clipRect);
          }
        };
        HeatmapSeries2.prototype.translate = function() {
          var series = this, options = series.options, symbol = options.marker && options.marker.symbol || "rect", shape = symbols$1[symbol] ? symbol : "rect", hasRegularShape = ["circle", "square"].indexOf(shape) !== -1;
          series.generatePoints();
          series.points.forEach(function(point) {
            var pointAttr, sizeDiff, hasImage, cellAttr = point.getCellAttributes(), shapeArgs = {};
            shapeArgs.x = Math.min(cellAttr.x1, cellAttr.x2);
            shapeArgs.y = Math.min(cellAttr.y1, cellAttr.y2);
            shapeArgs.width = Math.max(Math.abs(cellAttr.x2 - cellAttr.x1), 0);
            shapeArgs.height = Math.max(Math.abs(cellAttr.y2 - cellAttr.y1), 0);
            hasImage = point.hasImage = (point.marker && point.marker.symbol || symbol || "").indexOf("url") === 0;
            if (hasRegularShape) {
              sizeDiff = Math.abs(shapeArgs.width - shapeArgs.height);
              shapeArgs.x = Math.min(cellAttr.x1, cellAttr.x2) + (shapeArgs.width < shapeArgs.height ? 0 : sizeDiff / 2);
              shapeArgs.y = Math.min(cellAttr.y1, cellAttr.y2) + (shapeArgs.width < shapeArgs.height ? sizeDiff / 2 : 0);
              shapeArgs.width = shapeArgs.height = Math.min(shapeArgs.width, shapeArgs.height);
            }
            pointAttr = {
              plotX: (cellAttr.x1 + cellAttr.x2) / 2,
              plotY: (cellAttr.y1 + cellAttr.y2) / 2,
              clientX: (cellAttr.x1 + cellAttr.x2) / 2,
              shapeType: "path",
              shapeArgs: merge$a(true, shapeArgs, {
                d: symbols$1[shape](shapeArgs.x, shapeArgs.y, shapeArgs.width, shapeArgs.height)
              })
            };
            if (hasImage) {
              point.marker = {
                width: shapeArgs.width,
                height: shapeArgs.height
              };
            }
            extend$f(point, pointAttr);
          });
          fireEvent$1(series, "afterTranslate");
        };
        HeatmapSeries2.defaultOptions = merge$a(ScatterSeries$1.defaultOptions, {
          /**
           * Animation is disabled by default on the heatmap series.
           */
          animation: false,
          /**
           * The border radius for each heatmap item.
           */
          borderRadius: 0,
          /**
           * The border width for each heatmap item.
           */
          borderWidth: 0,
          /**
           * Padding between the points in the heatmap.
           *
           * @type      {number}
           * @default   0
           * @since     6.0
           * @apioption plotOptions.heatmap.pointPadding
           */
          /**
           * @default   value
           * @apioption plotOptions.heatmap.colorKey
           */
          /**
           * The main color of the series. In heat maps this color is rarely used,
           * as we mostly use the color to denote the value of each point. Unless
           * options are set in the [colorAxis](#colorAxis), the default value
           * is pulled from the [options.colors](#colors) array.
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @since     4.0
           * @product   highcharts
           * @apioption plotOptions.heatmap.color
           */
          /**
           * The column size - how many X axis units each column in the heatmap
           * should span.
           *
           * @sample {highcharts} maps/demo/heatmap/
           *         One day
           * @sample {highmaps} maps/demo/heatmap/
           *         One day
           *
           * @type      {number}
           * @default   1
           * @since     4.0
           * @product   highcharts highmaps
           * @apioption plotOptions.heatmap.colsize
           */
          /**
           * The row size - how many Y axis units each heatmap row should span.
           *
           * @sample {highcharts} maps/demo/heatmap/
           *         1 by default
           * @sample {highmaps} maps/demo/heatmap/
           *         1 by default
           *
           * @type      {number}
           * @default   1
           * @since     4.0
           * @product   highcharts highmaps
           * @apioption plotOptions.heatmap.rowsize
           */
          /**
           * The color applied to null points. In styled mode, a general CSS class
           * is applied instead.
           *
           * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           */
          nullColor: palette.neutralColor3,
          dataLabels: {
            formatter: function() {
              var numberFormatter = this.series.chart.numberFormatter;
              var value = this.point.value;
              return isNumber$6(value) ? numberFormatter(value, -1) : "";
            },
            inside: true,
            verticalAlign: "middle",
            crop: false,
            overflow: false,
            padding: 0
            // #3837
          },
          /**
           * @excluding radius, enabledThreshold
           * @since     8.1
           */
          marker: {
            /**
             * A predefined shape or symbol for the marker. When undefined, the
             * symbol is pulled from options.symbols. Other possible values are
             * `'circle'`, `'square'`,`'diamond'`, `'triangle'`,
             * `'triangle-down'`, `'rect'`, and `'ellipse'`.
             *
             * Additionally, the URL to a graphic can be given on this form:
             * `'url(graphic.png)'`. Note that for the image to be applied to
             * exported charts, its URL needs to be accessible by the export
             * server.
             *
             * Custom callbacks for symbol path generation can also be added to
             * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
             * used by its method name, as shown in the demo.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
             *         Predefined, graphic and custom markers
             * @sample {highstock} highcharts/plotoptions/series-marker-symbol/
             *         Predefined, graphic and custom markers
             */
            symbol: "rect",
            /** @ignore-option */
            radius: 0,
            lineColor: void 0,
            states: {
              /**
               * @excluding radius, radiusPlus
               */
              hover: {
                /**
                 * Set the marker's fixed width on hover state.
                 *
                 * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-width
                 *         70px fixed marker's width and height on hover
                 *
                 * @type      {number|undefined}
                 * @default   undefined
                 * @product   highcharts highmaps
                 * @apioption plotOptions.heatmap.marker.states.hover.width
                 */
                /**
                 * Set the marker's fixed height on hover state.
                 *
                 * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-width
                 *         70px fixed marker's width and height on hover
                 *
                 * @type      {number|undefined}
                 * @default   undefined
                 * @product   highcharts highmaps
                 * @apioption plotOptions.heatmap.marker.states.hover.height
                 */
                /**
                 * The number of pixels to increase the width of the
                 * selected point.
                 *
                 * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-widthplus
                 *         20px greater width and height on hover
                 *
                 * @type      {number|undefined}
                 * @default   undefined
                 * @product   highcharts highmaps
                 * @apioption plotOptions.heatmap.marker.states.hover.widthPlus
                 */
                /**
                 * The number of pixels to increase the height of the
                 * selected point.
                 *
                 * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-widthplus
                *          20px greater width and height on hover
                 *
                 * @type      {number|undefined}
                 * @default   undefined
                 * @product   highcharts highmaps
                 * @apioption plotOptions.heatmap.marker.states.hover.heightPlus
                 */
                /**
                 * The additional line width for a hovered point.
                 *
                 * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-linewidthplus
                 *         5 pixels wider lineWidth on hover
                 * @sample {highmaps} maps/plotoptions/heatmap-marker-states-hover-linewidthplus
                 *         5 pixels wider lineWidth on hover
                 */
                lineWidthPlus: 0
              },
              /**
               * @excluding radius
               */
              select: {
                /**
                 * Set the marker's fixed width on select state.
                 *
                 * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-width
                 *         70px fixed marker's width and height on hover
                 *
                 * @type      {number|undefined}
                 * @default   undefined
                 * @product   highcharts highmaps
                 * @apioption plotOptions.heatmap.marker.states.select.width
                 */
                /**
                 * Set the marker's fixed height on select state.
                 *
                 * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-width
                 *         70px fixed marker's width and height on hover
                 *
                 * @type      {number|undefined}
                 * @default   undefined
                 * @product   highcharts highmaps
                 * @apioption plotOptions.heatmap.marker.states.select.height
                 */
                /**
                 * The number of pixels to increase the width of the
                 * selected point.
                 *
                 * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-widthplus
                 *         20px greater width and height on hover
                 *
                 * @type      {number|undefined}
                 * @default   undefined
                 * @product   highcharts highmaps
                 * @apioption plotOptions.heatmap.marker.states.select.widthPlus
                 */
                /**
                 * The number of pixels to increase the height of the
                 * selected point.
                 *
                 * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-widthplus
                 *         20px greater width and height on hover
                 *
                 * @type      {number|undefined}
                 * @default   undefined
                 * @product   highcharts highmaps
                 * @apioption plotOptions.heatmap.marker.states.select.heightPlus
                 */
              }
            }
          },
          clip: true,
          /** @ignore-option */
          pointRange: null,
          tooltip: {
            pointFormat: "{point.x}, {point.y}: {point.value}<br/>"
          },
          states: {
            hover: {
              /** @ignore-option */
              halo: false,
              /**
               * How much to brighten the point on interaction. Requires the
               * main color to be defined in hex or rgb(a) format.
               *
               * In styled mode, the hover brightening is by default replaced
               * with a fill-opacity set in the `.highcharts-point:hover`
               * rule.
               */
              brightness: 0.2
            }
          }
        });
        return HeatmapSeries2;
      }(ScatterSeries$1)
    );
    extend$f(HeatmapSeries$1.prototype, {
      /**
       * @private
       */
      alignDataLabel: ColumnSeries$7.prototype.alignDataLabel,
      axisTypes: colorMapSeriesMixin$1.axisTypes,
      colorAttribs: colorMapSeriesMixin$1.colorAttribs,
      colorKey: colorMapSeriesMixin$1.colorKey,
      directTouch: true,
      /**
       * @private
       */
      drawLegendSymbol: LegendSymbol$1.drawRectangle,
      getExtremesFromAll: true,
      getSymbol: Series$5.prototype.getSymbol,
      parallelArrays: colorMapSeriesMixin$1.parallelArrays,
      pointArrayMap: ["y", "value"],
      pointClass: HeatmapPoint,
      trackerGroups: colorMapSeriesMixin$1.trackerGroups
    });
    SeriesRegistry$1.registerSeriesType("heatmap", HeatmapSeries$1);
    /**
     * @license Highmaps JS v9.2.2 (2021-08-24)
     * @module highcharts/modules/heatmap
     * @requires highcharts
     *
     * (c) 2009-2021 Torstein Honsi
     *
     * License: www.highcharts.com/license
     */
    var G = H;
    G.ColorAxis = ColorAxis;
    ColorAxis.compose(G.Chart, G.Fx, G.Legend, G.Series);
    var color$2 = Color.parse;
    var extend$e = Utilities.extend, merge$9 = Utilities.merge;
    var SolidGaugeAxis;
    (function(SolidGaugeAxis2) {
      var methods = {
        initDataClasses: function(userOptions) {
          var chart = this.chart, dataClasses, colorCounter = 0, options = this.options;
          this.dataClasses = dataClasses = [];
          userOptions.dataClasses.forEach(function(dataClass, i) {
            var colors;
            dataClass = merge$9(dataClass);
            dataClasses.push(dataClass);
            if (!dataClass.color) {
              if (options.dataClassColor === "category") {
                colors = chart.options.colors;
                dataClass.color = colors[colorCounter++];
                if (colorCounter === colors.length) {
                  colorCounter = 0;
                }
              } else {
                dataClass.color = color$2(options.minColor).tweenTo(color$2(options.maxColor), i / (userOptions.dataClasses.length - 1));
              }
            }
          });
        },
        initStops: function(userOptions) {
          this.stops = userOptions.stops || [
            [0, this.options.minColor],
            [1, this.options.maxColor]
          ];
          this.stops.forEach(function(stop2) {
            stop2.color = color$2(stop2[1]);
          });
        },
        // Translate from a value to a color
        toColor: function(value, point) {
          var pos, stops = this.stops, from, to, color2, dataClasses = this.dataClasses, dataClass, i;
          if (dataClasses) {
            i = dataClasses.length;
            while (i--) {
              dataClass = dataClasses[i];
              from = dataClass.from;
              to = dataClass.to;
              if ((typeof from === "undefined" || value >= from) && (typeof to === "undefined" || value <= to)) {
                color2 = dataClass.color;
                if (point) {
                  point.dataClass = i;
                }
                break;
              }
            }
          } else {
            if (this.logarithmic) {
              value = this.val2lin(value);
            }
            pos = 1 - (this.max - value) / (this.max - this.min);
            i = stops.length;
            while (i--) {
              if (pos > stops[i][0]) {
                break;
              }
            }
            from = stops[i] || stops[i + 1];
            to = stops[i + 1] || from;
            pos = 1 - (to[0] - pos) / (to[0] - from[0] || 1);
            color2 = from.color.tweenTo(to.color, pos);
          }
          return color2;
        }
      };
      function init(axis) {
        extend$e(axis, methods);
      }
      SolidGaugeAxis2.init = init;
    })(SolidGaugeAxis || (SolidGaugeAxis = {}));
    const SolidGaugeAxis$1 = SolidGaugeAxis;
    var _a$4 = SVGRenderer.prototype, symbols = _a$4.symbols, arc = _a$4.symbols.arc;
    symbols.arc = function(x, y, w2, h, options) {
      var path = arc(x, y, w2, h, options);
      if (options && options.rounded) {
        var r = options.r || w2, smallR = (r - (options.innerR || 0)) / 2, outerArcStart = path[0], innerArcStart = path[2];
        if (outerArcStart[0] === "M" && innerArcStart[0] === "L") {
          var x1 = outerArcStart[1], y1 = outerArcStart[2], x2 = innerArcStart[1], y2 = innerArcStart[2], roundStart = ["A", smallR, smallR, 0, 1, 1, x1, y1], roundEnd = ["A", smallR, smallR, 0, 1, 1, x2, y2];
          path[2] = roundEnd;
          path[4] = roundStart;
        }
      }
      return path;
    };
    var __extends$c = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var _a$3 = SeriesRegistry$1.seriesTypes, GaugeSeries = _a$3.gauge, pieProto = _a$3.pie.prototype;
    var clamp$1 = Utilities.clamp, extend$d = Utilities.extend, isNumber$5 = Utilities.isNumber, merge$8 = Utilities.merge, pick$b = Utilities.pick, pInt = Utilities.pInt;
    var solidGaugeOptions = {
      /**
       * The inner radius for points in a solid gauge. Can be given as a number
       * (pixels) or percentage string.
       *
       * @sample {highcharts} highcharts/plotoptions/solidgauge-radius/
       *         Individual radius and innerRadius
       *
       * @type      {number|string}
       * @default   60
       * @since     4.1.6
       * @product   highcharts
       * @apioption plotOptions.solidgauge.innerRadius
       */
      /**
       * Whether the strokes of the solid gauge should be `round` or `square`.
       *
       * @sample {highcharts} highcharts/demo/gauge-activity/
       *         Rounded gauge
       *
       * @type       {string}
       * @default    round
       * @since      4.2.2
       * @product    highcharts
       * @validvalue ["square", "round"]
       * @apioption  plotOptions.solidgauge.linecap
       */
      /**
       * Allow the gauge to overshoot the end of the perimeter axis by this
       * many degrees. Say if the gauge axis goes from 0 to 60, a value of
       * 100, or 1000, will show 5 degrees beyond the end of the axis when this
       * option is set to 5.
       *
       * @type      {number}
       * @default   0
       * @since     3.0.10
       * @product   highcharts
       * @apioption plotOptions.solidgauge.overshoot
       */
      /**
       * The outer radius for points in a solid gauge. Can be given as a number
       * (pixels) or percentage string.
       *
       * @sample {highcharts} highcharts/plotoptions/solidgauge-radius/
       *         Individual radius and innerRadius
       *
       * @type      {number|string}
       * @default   100
       * @since     4.1.6
       * @product   highcharts
       * @apioption plotOptions.solidgauge.radius
       */
      /**
       * Wether to draw rounded edges on the gauge.
       *
       * @sample {highcharts} highcharts/demo/gauge-activity/
       *         Activity Gauge
       *
       * @type      {boolean}
       * @default   false
       * @since     5.0.8
       * @product   highcharts
       * @apioption plotOptions.solidgauge.rounded
       */
      /**
       * The threshold or base level for the gauge.
       *
       * @sample {highcharts} highcharts/plotoptions/solidgauge-threshold/
       *         Zero threshold with negative and positive values
       *
       * @type      {number|null}
       * @since     5.0.3
       * @product   highcharts
       * @apioption plotOptions.solidgauge.threshold
       */
      /**
       * Whether to give each point an individual color.
       */
      colorByPoint: true,
      dataLabels: {
        y: 0
      }
    };
    var SolidGaugeSeries = (
      /** @class */
      function(_super) {
        __extends$c(SolidGaugeSeries2, _super);
        function SolidGaugeSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.points = void 0;
          _this.options = void 0;
          _this.axis = void 0;
          _this.yAxis = void 0;
          _this.startAngleRad = void 0;
          _this.thresholdAngleRad = void 0;
          return _this;
        }
        SolidGaugeSeries2.prototype.translate = function() {
          var axis = this.yAxis;
          SolidGaugeAxis$1.init(axis);
          if (!axis.dataClasses && axis.options.dataClasses) {
            axis.initDataClasses(axis.options);
          }
          axis.initStops(axis.options);
          GaugeSeries.prototype.translate.call(this);
        };
        SolidGaugeSeries2.prototype.drawPoints = function() {
          var series = this, yAxis = series.yAxis, center = yAxis.center, options = series.options, renderer = series.chart.renderer, overshoot = options.overshoot, overshootVal = isNumber$5(overshoot) ? overshoot / 180 * Math.PI : 0, thresholdAngleRad;
          if (isNumber$5(options.threshold)) {
            thresholdAngleRad = yAxis.startAngleRad + yAxis.translate(options.threshold, null, null, null, true);
          }
          this.thresholdAngleRad = pick$b(thresholdAngleRad, yAxis.startAngleRad);
          series.points.forEach(function(point) {
            if (!point.isNull) {
              var graphic = point.graphic, rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true), radius = pInt(pick$b(point.options.radius, options.radius, 100)) * center[2] / 200, innerRadius = pInt(pick$b(point.options.innerRadius, options.innerRadius, 60)) * center[2] / 200, shapeArgs = void 0, d = void 0, toColor = yAxis.toColor(point.y, point), axisMinAngle = Math.min(yAxis.startAngleRad, yAxis.endAngleRad), axisMaxAngle = Math.max(yAxis.startAngleRad, yAxis.endAngleRad), minAngle = void 0, maxAngle = void 0;
              if (toColor === "none") {
                toColor = point.color || series.color || "none";
              }
              if (toColor !== "none") {
                point.color = toColor;
              }
              rotation = clamp$1(rotation, axisMinAngle - overshootVal, axisMaxAngle + overshootVal);
              if (options.wrap === false) {
                rotation = clamp$1(rotation, axisMinAngle, axisMaxAngle);
              }
              minAngle = Math.min(rotation, series.thresholdAngleRad);
              maxAngle = Math.max(rotation, series.thresholdAngleRad);
              if (maxAngle - minAngle > 2 * Math.PI) {
                maxAngle = minAngle + 2 * Math.PI;
              }
              point.shapeArgs = shapeArgs = {
                x: center[0],
                y: center[1],
                r: radius,
                innerR: innerRadius,
                start: minAngle,
                end: maxAngle,
                rounded: options.rounded
              };
              point.startR = radius;
              if (graphic) {
                d = shapeArgs.d;
                graphic.animate(extend$d({ fill: toColor }, shapeArgs));
                if (d) {
                  shapeArgs.d = d;
                }
              } else {
                point.graphic = graphic = renderer.arc(shapeArgs).attr({
                  fill: toColor,
                  "sweep-flag": 0
                }).add(series.group);
              }
              if (!series.chart.styledMode) {
                if (options.linecap !== "square") {
                  graphic.attr({
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round"
                  });
                }
                graphic.attr({
                  stroke: options.borderColor || "none",
                  "stroke-width": options.borderWidth || 0
                });
              }
              if (graphic) {
                graphic.addClass(point.getClassName(), true);
              }
            }
          });
        };
        SolidGaugeSeries2.prototype.animate = function(init) {
          if (!init) {
            this.startAngleRad = this.thresholdAngleRad;
            pieProto.animate.call(this, init);
          }
        };
        SolidGaugeSeries2.defaultOptions = merge$8(GaugeSeries.defaultOptions, solidGaugeOptions);
        return SolidGaugeSeries2;
      }(GaugeSeries)
    );
    extend$d(SolidGaugeSeries.prototype, {
      drawLegendSymbol: LegendSymbol$1.drawRectangle
    });
    SeriesRegistry$1.registerSeriesType("solidgauge", SolidGaugeSeries);
    var TreemapAlgorithmGroup = (
      /** @class */
      function() {
        function TreemapAlgorithmGroup2(h, w2, d, p) {
          this.height = h;
          this.width = w2;
          this.plot = p;
          this.direction = d;
          this.startDirection = d;
          this.total = 0;
          this.nW = 0;
          this.lW = 0;
          this.nH = 0;
          this.lH = 0;
          this.elArr = [];
          this.lP = {
            total: 0,
            lH: 0,
            nH: 0,
            lW: 0,
            nW: 0,
            nR: 0,
            lR: 0,
            aspectRatio: function(w3, h2) {
              return Math.max(w3 / h2, h2 / w3);
            }
          };
        }
        TreemapAlgorithmGroup2.prototype.addElement = function(el) {
          this.lP.total = this.elArr[this.elArr.length - 1];
          this.total = this.total + el;
          if (this.direction === 0) {
            this.lW = this.nW;
            this.lP.lH = this.lP.total / this.lW;
            this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH);
            this.nW = this.total / this.height;
            this.lP.nH = this.lP.total / this.nW;
            this.lP.nR = this.lP.aspectRatio(this.nW, this.lP.nH);
          } else {
            this.lH = this.nH;
            this.lP.lW = this.lP.total / this.lH;
            this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH);
            this.nH = this.total / this.width;
            this.lP.nW = this.lP.total / this.nH;
            this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH);
          }
          this.elArr.push(el);
        };
        TreemapAlgorithmGroup2.prototype.reset = function() {
          this.nW = 0;
          this.lW = 0;
          this.elArr = [];
          this.total = 0;
        };
        return TreemapAlgorithmGroup2;
      }()
    );
    var isFn$1 = function(x) {
      return typeof x === "function";
    };
    var draw = function draw2(params) {
      var _this = this;
      var animatableAttribs = params.animatableAttribs, onComplete = params.onComplete, css2 = params.css, renderer = params.renderer;
      var animation = this.series && this.series.chart.hasRendered ? (
        // Chart-level animation on updates
        void 0
      ) : (
        // Series-level animation on new points
        this.series && this.series.options.animation
      );
      var graphic = this.graphic;
      if (this.shouldDraw()) {
        if (!graphic) {
          this.graphic = graphic = renderer[params.shapeType](params.shapeArgs).add(params.group);
        }
        graphic.css(css2).attr(params.attribs).animate(animatableAttribs, params.isNew ? false : animation, onComplete);
      } else if (graphic) {
        var destroy_1 = function() {
          _this.graphic = graphic = graphic && graphic.destroy();
          if (isFn$1(onComplete)) {
            onComplete();
          }
        };
        if (Object.keys(animatableAttribs).length) {
          graphic.animate(animatableAttribs, void 0, function() {
            destroy_1();
          });
        } else {
          destroy_1();
        }
      }
    };
    var drawPoint = function drawPoint2(params) {
      var point = this, attribs = params.attribs = params.attribs || {};
      attribs["class"] = point.getClassName();
      draw.call(point, params);
    };
    var drawPointModule = {
      draw,
      drawPoint,
      isFn: isFn$1
    };
    var __extends$b = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Point = SeriesRegistry$1.series.prototype.pointClass, _a$2 = SeriesRegistry$1.seriesTypes, PiePoint$1 = _a$2.pie.prototype.pointClass, ScatterPoint = _a$2.scatter.prototype.pointClass;
    var extend$c = Utilities.extend, isNumber$4 = Utilities.isNumber, pick$a = Utilities.pick;
    var TreemapPoint = (
      /** @class */
      function(_super) {
        __extends$b(TreemapPoint2, _super);
        function TreemapPoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.name = void 0;
          _this.node = void 0;
          _this.options = void 0;
          _this.series = void 0;
          _this.value = void 0;
          return _this;
        }
        TreemapPoint2.prototype.getClassName = function() {
          var className = Point.prototype.getClassName.call(this), series = this.series, options = series.options;
          if (this.node.level <= series.nodeMap[series.rootNode].level) {
            className += " highcharts-above-level";
          } else if (!this.node.isLeaf && !pick$a(options.interactByLeaf, !options.allowTraversingTree)) {
            className += " highcharts-internal-node-interactive";
          } else if (!this.node.isLeaf) {
            className += " highcharts-internal-node";
          }
          return className;
        };
        TreemapPoint2.prototype.isValid = function() {
          return Boolean(this.id || isNumber$4(this.value));
        };
        TreemapPoint2.prototype.setState = function(state) {
          Point.prototype.setState.call(this, state);
          if (this.graphic) {
            this.graphic.attr({
              zIndex: state === "hover" ? 1 : 0
            });
          }
        };
        TreemapPoint2.prototype.shouldDraw = function() {
          return isNumber$4(this.plotY) && this.y !== null;
        };
        return TreemapPoint2;
      }(ScatterPoint)
    );
    extend$c(TreemapPoint.prototype, {
      draw: drawPointModule.drawPoint,
      setVisible: PiePoint$1.prototype.setVisible
    });
    var objectEach$1 = Utilities.objectEach;
    var TreemapUtilities;
    (function(TreemapUtilities2) {
      TreemapUtilities2.AXIS_MAX = 100;
      function isBoolean2(x) {
        return typeof x === "boolean";
      }
      TreemapUtilities2.isBoolean = isBoolean2;
      function eachObject(list, func, context) {
        context = context || this;
        objectEach$1(list, function(val, key) {
          func.call(context, val, key, list);
        });
      }
      TreemapUtilities2.eachObject = eachObject;
      function recursive(item2, func, context) {
        if (context === void 0) {
          context = this;
        }
        var next;
        next = func.call(context, item2);
        if (next !== false) {
          recursive(next, func, context);
        }
      }
      TreemapUtilities2.recursive = recursive;
    })(TreemapUtilities || (TreemapUtilities = {}));
    const TreemapUtilities$1 = TreemapUtilities;
    var extend$b = Utilities.extend, isArray$1 = Utilities.isArray, isNumber$3 = Utilities.isNumber, isObject$3 = Utilities.isObject, merge$7 = Utilities.merge, pick$9 = Utilities.pick;
    var isBoolean = function(x) {
      return typeof x === "boolean";
    }, isFn = function(x) {
      return typeof x === "function";
    };
    var setTreeValues = function setTreeValues2(tree, options) {
      var before = options.before, idRoot = options.idRoot, mapIdToNode = options.mapIdToNode, nodeRoot = mapIdToNode[idRoot], levelIsConstant = isBoolean(options.levelIsConstant) ? options.levelIsConstant : true, points = options.points, point = points[tree.i], optionsPoint = point && point.options || {}, childrenTotal = 0, children = [], value;
      tree.levelDynamic = tree.level - (levelIsConstant ? 0 : nodeRoot.level);
      tree.name = pick$9(point && point.name, "");
      tree.visible = idRoot === tree.id || (isBoolean(options.visible) ? options.visible : false);
      if (isFn(before)) {
        tree = before(tree, options);
      }
      tree.children.forEach(function(child, i) {
        var newOptions = extend$b({}, options);
        extend$b(newOptions, {
          index: i,
          siblings: tree.children.length,
          visible: tree.visible
        });
        child = setTreeValues2(child, newOptions);
        children.push(child);
        if (child.visible) {
          childrenTotal += child.val;
        }
      });
      value = pick$9(optionsPoint.value, childrenTotal);
      tree.visible = value >= 0 && (childrenTotal > 0 || tree.visible);
      tree.children = children;
      tree.childrenTotal = childrenTotal;
      tree.isLeaf = tree.visible && !childrenTotal;
      tree.val = value;
      return tree;
    };
    var getColor$1 = function getColor2(node, options) {
      var index = options.index, mapOptionsToLevel = options.mapOptionsToLevel, parentColor = options.parentColor, parentColorIndex = options.parentColorIndex, series = options.series, colors = options.colors, siblings = options.siblings, points = series.points, getColorByPoint, chartOptionsChart = series.chart.options.chart, point, level, colorByPoint, colorIndexByPoint, color2, colorIndex;
      function variation(color3) {
        var colorVariation = level && level.colorVariation;
        if (colorVariation) {
          if (colorVariation.key === "brightness") {
            return Color.parse(color3).brighten(colorVariation.to * (index / siblings)).get();
          }
        }
        return color3;
      }
      if (node) {
        point = points[node.i];
        level = mapOptionsToLevel[node.level] || {};
        getColorByPoint = point && level.colorByPoint;
        if (getColorByPoint) {
          colorIndexByPoint = point.index % (colors ? colors.length : chartOptionsChart.colorCount);
          colorByPoint = colors && colors[colorIndexByPoint];
        }
        if (!series.chart.styledMode) {
          color2 = pick$9(point && point.options.color, level && level.color, colorByPoint, parentColor && variation(parentColor), series.color);
        }
        colorIndex = pick$9(point && point.options.colorIndex, level && level.colorIndex, colorIndexByPoint, parentColorIndex, options.colorIndex);
      }
      return {
        color: color2,
        colorIndex
      };
    };
    var getLevelOptions$2 = function getLevelOptions2(params) {
      var result2 = null, defaults, converted, i, from, to, levels;
      if (isObject$3(params)) {
        result2 = {};
        from = isNumber$3(params.from) ? params.from : 1;
        levels = params.levels;
        converted = {};
        defaults = isObject$3(params.defaults) ? params.defaults : {};
        if (isArray$1(levels)) {
          converted = levels.reduce(function(obj, item2) {
            var level, levelIsConstant, options;
            if (isObject$3(item2) && isNumber$3(item2.level)) {
              options = merge$7({}, item2);
              levelIsConstant = isBoolean(options.levelIsConstant) ? options.levelIsConstant : defaults.levelIsConstant;
              delete options.levelIsConstant;
              delete options.level;
              level = item2.level + (levelIsConstant ? 0 : from - 1);
              if (isObject$3(obj[level])) {
                extend$b(obj[level], options);
              } else {
                obj[level] = options;
              }
            }
            return obj;
          }, {});
        }
        to = isNumber$3(params.to) ? params.to : 1;
        for (i = 0; i <= to; i++) {
          result2[i] = merge$7({}, defaults, isObject$3(converted[i]) ? converted[i] : {});
        }
      }
      return result2;
    };
    var updateRootId$1 = function(series) {
      var rootId, options;
      if (isObject$3(series)) {
        options = isObject$3(series.options) ? series.options : {};
        rootId = pick$9(series.rootNode, options.rootId, "");
        if (isObject$3(series.userOptions)) {
          series.userOptions.rootId = rootId;
        }
        series.rootNode = rootId;
      }
      return rootId;
    };
    var result = {
      getColor: getColor$1,
      getLevelOptions: getLevelOptions$2,
      setTreeValues,
      updateRootId: updateRootId$1
    };
    var Series$4 = SeriesRegistry$1.series;
    var addEvent$4 = Utilities.addEvent, extend$a = Utilities.extend;
    var treemapAxisDefaultValues = false;
    addEvent$4(Series$4, "afterBindAxes", function() {
      var series = this, xAxis = series.xAxis, yAxis = series.yAxis, treeAxis;
      if (xAxis && yAxis) {
        if (series.is("treemap")) {
          treeAxis = {
            endOnTick: false,
            gridLineWidth: 0,
            lineWidth: 0,
            min: 0,
            // dataMin: 0,
            minPadding: 0,
            max: TreemapUtilities$1.AXIS_MAX,
            // dataMax: TreemapUtilities.AXIS_MAX,
            maxPadding: 0,
            startOnTick: false,
            title: void 0,
            tickPositions: []
          };
          extend$a(yAxis.options, treeAxis);
          extend$a(xAxis.options, treeAxis);
          treemapAxisDefaultValues = true;
        } else if (treemapAxisDefaultValues) {
          yAxis.setOptions(yAxis.userOptions);
          xAxis.setOptions(xAxis.userOptions);
          treemapAxisDefaultValues = false;
        }
      }
    });
    var __extends$a = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var color$1 = Color.parse;
    var colorMapSeriesMixin = exports.colorMapSeriesMixin;
    var noop = H.noop;
    var Series$3 = SeriesRegistry$1.series, _a$1 = SeriesRegistry$1.seriesTypes, ColumnSeries$6 = _a$1.column, HeatmapSeries = _a$1.heatmap, ScatterSeries = _a$1.scatter;
    var getColor = result.getColor, getLevelOptions$1 = result.getLevelOptions, updateRootId = result.updateRootId;
    var addEvent$3 = Utilities.addEvent, correctFloat$1 = Utilities.correctFloat, defined$6 = Utilities.defined, error = Utilities.error, extend$9 = Utilities.extend, fireEvent = Utilities.fireEvent, isArray = Utilities.isArray, isObject$2 = Utilities.isObject, isString = Utilities.isString, merge$6 = Utilities.merge, pick$8 = Utilities.pick, stableSort$1 = Utilities.stableSort;
    var TreemapSeries = (
      /** @class */
      function(_super) {
        __extends$a(TreemapSeries2, _super);
        function TreemapSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.axisRatio = void 0;
          _this.data = void 0;
          _this.mapOptionsToLevel = void 0;
          _this.nodeMap = void 0;
          _this.options = void 0;
          _this.points = void 0;
          _this.rootNode = void 0;
          _this.tree = void 0;
          return _this;
        }
        TreemapSeries2.prototype.algorithmCalcPoints = function(directionChange, last, group, childrenArea) {
          var pX, pY, pW, pH, gW = group.lW, gH = group.lH, plot = group.plot, keep, i = 0, end = group.elArr.length - 1;
          if (last) {
            gW = group.nW;
            gH = group.nH;
          } else {
            keep = group.elArr[group.elArr.length - 1];
          }
          group.elArr.forEach(function(p) {
            if (last || i < end) {
              if (group.direction === 0) {
                pX = plot.x;
                pY = plot.y;
                pW = gW;
                pH = p / pW;
              } else {
                pX = plot.x;
                pY = plot.y;
                pH = gH;
                pW = p / pH;
              }
              childrenArea.push({
                x: pX,
                y: pY,
                width: pW,
                height: correctFloat$1(pH)
              });
              if (group.direction === 0) {
                plot.y = plot.y + pH;
              } else {
                plot.x = plot.x + pW;
              }
            }
            i = i + 1;
          });
          group.reset();
          if (group.direction === 0) {
            group.width = group.width - gW;
          } else {
            group.height = group.height - gH;
          }
          plot.y = plot.parent.y + (plot.parent.height - group.height);
          plot.x = plot.parent.x + (plot.parent.width - group.width);
          if (directionChange) {
            group.direction = 1 - group.direction;
          }
          if (!last) {
            group.addElement(keep);
          }
        };
        TreemapSeries2.prototype.algorithmFill = function(directionChange, parent, children) {
          var childrenArea = [], pTot, direction = parent.direction, x = parent.x, y = parent.y, width = parent.width, height = parent.height, pX, pY, pW, pH;
          children.forEach(function(child) {
            pTot = parent.width * parent.height * (child.val / parent.val);
            pX = x;
            pY = y;
            if (direction === 0) {
              pH = height;
              pW = pTot / pH;
              width = width - pW;
              x = x + pW;
            } else {
              pW = width;
              pH = pTot / pW;
              height = height - pH;
              y = y + pH;
            }
            childrenArea.push({
              x: pX,
              y: pY,
              width: pW,
              height: pH
            });
            if (directionChange) {
              direction = 1 - direction;
            }
          });
          return childrenArea;
        };
        TreemapSeries2.prototype.algorithmLowAspectRatio = function(directionChange, parent, children) {
          var childrenArea = [], series = this, pTot, plot = {
            x: parent.x,
            y: parent.y,
            parent
          }, direction = parent.direction, i = 0, end = children.length - 1, group = new TreemapAlgorithmGroup(parent.height, parent.width, direction, plot);
          children.forEach(function(child) {
            pTot = parent.width * parent.height * (child.val / parent.val);
            group.addElement(pTot);
            if (group.lP.nR > group.lP.lR) {
              series.algorithmCalcPoints(
                directionChange,
                false,
                group,
                childrenArea,
                plot
                // @todo no supported
              );
            }
            if (i === end) {
              series.algorithmCalcPoints(
                directionChange,
                true,
                group,
                childrenArea,
                plot
                // @todo not supported
              );
            }
            i = i + 1;
          });
          return childrenArea;
        };
        TreemapSeries2.prototype.alignDataLabel = function(point, dataLabel, labelOptions) {
          var style = labelOptions.style;
          if (style && !defined$6(style.textOverflow) && dataLabel.text && dataLabel.getBBox().width > dataLabel.text.textWidth) {
            dataLabel.css({
              textOverflow: "ellipsis",
              // unit (px) is required when useHTML is true
              width: style.width += "px"
            });
          }
          ColumnSeries$6.prototype.alignDataLabel.apply(this, arguments);
          if (point.dataLabel) {
            point.dataLabel.attr({ zIndex: (point.node.zIndex || 0) + 1 });
          }
        };
        TreemapSeries2.prototype.buildNode = function(id, i, level, list, parent) {
          var series = this, children = [], point = series.points[i], height = 0, node, child;
          (list[id] || []).forEach(function(i2) {
            child = series.buildNode(series.points[i2].id, i2, level + 1, list, id);
            height = Math.max(child.height + 1, height);
            children.push(child);
          });
          node = {
            id,
            i,
            children,
            height,
            level,
            parent,
            visible: false
            // @todo move this to better location
          };
          series.nodeMap[node.id] = node;
          if (point) {
            point.node = node;
          }
          return node;
        };
        TreemapSeries2.prototype.calculateChildrenAreas = function(parent, area) {
          var series = this, options = series.options, mapOptionsToLevel = series.mapOptionsToLevel, level = mapOptionsToLevel[parent.level + 1], algorithm = pick$8(series[level && level.layoutAlgorithm] && level.layoutAlgorithm, options.layoutAlgorithm), alternate = options.alternateStartingDirection, childrenValues = [], children;
          children = parent.children.filter(function(n) {
            return !n.ignore;
          });
          if (level && level.layoutStartingDirection) {
            area.direction = level.layoutStartingDirection === "vertical" ? 0 : 1;
          }
          childrenValues = series[algorithm](area, children);
          children.forEach(function(child, index) {
            var values = childrenValues[index];
            child.values = merge$6(values, {
              val: child.childrenTotal,
              direction: alternate ? 1 - area.direction : area.direction
            });
            child.pointValues = merge$6(values, {
              x: values.x / series.axisRatio,
              // Flip y-values to avoid visual regression with csvCoord in
              // Axis.translate at setPointValues. #12488
              y: TreemapUtilities$1.AXIS_MAX - values.y - values.height,
              width: values.width / series.axisRatio
            });
            if (child.children.length) {
              series.calculateChildrenAreas(child, child.values);
            }
          });
        };
        TreemapSeries2.prototype.drawDataLabels = function() {
          var series = this, mapOptionsToLevel = series.mapOptionsToLevel, points = series.points.filter(function(n) {
            return n.node.visible;
          }), options, level;
          points.forEach(function(point) {
            level = mapOptionsToLevel[point.node.level];
            options = { style: {} };
            if (!point.node.isLeaf) {
              options.enabled = false;
            }
            if (level && level.dataLabels) {
              options = merge$6(options, level.dataLabels);
              series._hasPointLabels = true;
            }
            if (point.shapeArgs) {
              options.style.width = point.shapeArgs.width;
              if (point.dataLabel) {
                point.dataLabel.css({
                  width: point.shapeArgs.width + "px"
                });
              }
            }
            point.dlOptions = merge$6(options, point.options.dataLabels);
          });
          Series$3.prototype.drawDataLabels.call(this);
        };
        TreemapSeries2.prototype.drawPoints = function() {
          var series = this, chart = series.chart, renderer = chart.renderer, points = series.points, styledMode = chart.styledMode, options = series.options, shadow = styledMode ? {} : options.shadow, borderRadius = options.borderRadius, withinAnimationLimit = chart.pointCount < options.animationLimit, allowTraversingTree = options.allowTraversingTree;
          points.forEach(function(point) {
            var levelDynamic = point.node.levelDynamic, animatableAttribs = {}, attribs = {}, css2 = {}, groupKey = "level-group-" + point.node.level, hasGraphic = !!point.graphic, shouldAnimate = withinAnimationLimit && hasGraphic, shapeArgs = point.shapeArgs;
            if (point.shouldDraw()) {
              point.isInside = true;
              if (borderRadius) {
                attribs.r = borderRadius;
              }
              merge$6(
                true,
                // Extend object
                // Which object to extend
                shouldAnimate ? animatableAttribs : attribs,
                // Add shapeArgs to animate/attr if graphic exists
                hasGraphic ? shapeArgs : {},
                // Add style attribs if !styleMode
                styledMode ? {} : series.pointAttribs(point, point.selected ? "select" : void 0)
              );
              if (series.colorAttribs && styledMode) {
                extend$9(css2, series.colorAttribs(point));
              }
              if (!series[groupKey]) {
                series[groupKey] = renderer.g(groupKey).attr({
                  // @todo Set the zIndex based upon the number of
                  // levels, instead of using 1000
                  zIndex: 1e3 - (levelDynamic || 0)
                }).add(series.group);
                series[groupKey].survive = true;
              }
            }
            point.draw({
              animatableAttribs,
              attribs,
              css: css2,
              group: series[groupKey],
              renderer,
              shadow,
              shapeArgs,
              shapeType: "rect"
            });
            if (allowTraversingTree && point.graphic) {
              point.drillId = options.interactByLeaf ? series.drillToByLeaf(point) : series.drillToByGroup(point);
            }
          });
        };
        TreemapSeries2.prototype.drillToByGroup = function(point) {
          var series = this, drillId = false;
          if (point.node.level - series.nodeMap[series.rootNode].level === 1 && !point.node.isLeaf) {
            drillId = point.id;
          }
          return drillId;
        };
        TreemapSeries2.prototype.drillToByLeaf = function(point) {
          var series = this, drillId = false, nodeParent;
          if (point.node.parent !== series.rootNode && point.node.isLeaf) {
            nodeParent = point.node;
            while (!drillId) {
              nodeParent = series.nodeMap[nodeParent.parent];
              if (nodeParent.parent === series.rootNode) {
                drillId = nodeParent.id;
              }
            }
          }
          return drillId;
        };
        TreemapSeries2.prototype.drillToNode = function(id, redraw) {
          error(32, false, void 0, { "treemap.drillToNode": "use treemap.setRootNode" });
          this.setRootNode(id, redraw);
        };
        TreemapSeries2.prototype.drillUp = function() {
          var series = this, node = series.nodeMap[series.rootNode];
          if (node && isString(node.parent)) {
            series.setRootNode(node.parent, true, { trigger: "traverseUpButton" });
          }
        };
        TreemapSeries2.prototype.getExtremes = function() {
          var _a2 = Series$3.prototype.getExtremes.call(this, this.colorValueData), dataMin = _a2.dataMin, dataMax = _a2.dataMax;
          this.valueMin = dataMin;
          this.valueMax = dataMax;
          return Series$3.prototype.getExtremes.call(this);
        };
        TreemapSeries2.prototype.getListOfParents = function(data, existingIds) {
          var arr = isArray(data) ? data : [], ids = isArray(existingIds) ? existingIds : [], listOfParents = arr.reduce(function(prev, curr, i) {
            var parent = pick$8(curr.parent, "");
            if (typeof prev[parent] === "undefined") {
              prev[parent] = [];
            }
            prev[parent].push(i);
            return prev;
          }, {
            "": []
            // Root of tree
          });
          TreemapUtilities$1.eachObject(listOfParents, function(children, parent, list) {
            if (parent !== "" && ids.indexOf(parent) === -1) {
              children.forEach(function(child) {
                list[""].push(child);
              });
              delete list[parent];
            }
          });
          return listOfParents;
        };
        TreemapSeries2.prototype.getTree = function() {
          var series = this, allIds = this.data.map(function(d) {
            return d.id;
          }), parentList = series.getListOfParents(this.data, allIds);
          series.nodeMap = {};
          return series.buildNode("", -1, 0, parentList);
        };
        TreemapSeries2.prototype.hasData = function() {
          return !!this.processedXData.length;
        };
        TreemapSeries2.prototype.init = function(chart, options) {
          var series = this, setOptionsEvent;
          if (colorMapSeriesMixin) {
            this.colorAttribs = colorMapSeriesMixin.colorAttribs;
          }
          setOptionsEvent = addEvent$3(series, "setOptions", function(event) {
            var options2 = event.userOptions;
            if (defined$6(options2.allowDrillToNode) && !defined$6(options2.allowTraversingTree)) {
              options2.allowTraversingTree = options2.allowDrillToNode;
              delete options2.allowDrillToNode;
            }
            if (defined$6(options2.drillUpButton) && !defined$6(options2.traverseUpButton)) {
              options2.traverseUpButton = options2.drillUpButton;
              delete options2.drillUpButton;
            }
          });
          Series$3.prototype.init.call(series, chart, options);
          delete series.opacity;
          series.eventsToUnbind.push(setOptionsEvent);
          if (series.options.allowTraversingTree) {
            series.eventsToUnbind.push(addEvent$3(series, "click", series.onClickDrillToNode));
          }
        };
        TreemapSeries2.prototype.onClickDrillToNode = function(event) {
          var series = this, point = event.point, drillId = point && point.drillId;
          if (isString(drillId)) {
            point.setState("");
            series.setRootNode(drillId, true, { trigger: "click" });
          }
        };
        TreemapSeries2.prototype.pointAttribs = function(point, state) {
          var series = this, mapOptionsToLevel = isObject$2(series.mapOptionsToLevel) ? series.mapOptionsToLevel : {}, level = point && mapOptionsToLevel[point.node.level] || {}, options = this.options, attr2, stateOptions = state && options.states[state] || {}, className = point && point.getClassName() || "", opacity;
          attr2 = {
            "stroke": point && point.borderColor || level.borderColor || stateOptions.borderColor || options.borderColor,
            "stroke-width": pick$8(point && point.borderWidth, level.borderWidth, stateOptions.borderWidth, options.borderWidth),
            "dashstyle": point && point.borderDashStyle || level.borderDashStyle || stateOptions.borderDashStyle || options.borderDashStyle,
            "fill": point && point.color || this.color
          };
          if (className.indexOf("highcharts-above-level") !== -1) {
            attr2.fill = "none";
            attr2["stroke-width"] = 0;
          } else if (className.indexOf("highcharts-internal-node-interactive") !== -1) {
            opacity = pick$8(stateOptions.opacity, options.opacity);
            attr2.fill = color$1(attr2.fill).setOpacity(opacity).get();
            attr2.cursor = "pointer";
          } else if (className.indexOf("highcharts-internal-node") !== -1) {
            attr2.fill = "none";
          } else if (state) {
            attr2.fill = color$1(attr2.fill).brighten(stateOptions.brightness).get();
          }
          return attr2;
        };
        TreemapSeries2.prototype.renderTraverseUpButton = function(rootId) {
          var series = this, nodeMap = series.nodeMap, node = nodeMap[rootId], name = node.name, buttonOptions = series.options.traverseUpButton, backText = pick$8(buttonOptions.text, name, " Back"), attr2, states;
          if (rootId === "" || series.is("sunburst") && series.tree.children.length === 1 && rootId === series.tree.children[0].id) {
            if (series.drillUpButton) {
              series.drillUpButton = series.drillUpButton.destroy();
            }
          } else if (!this.drillUpButton) {
            attr2 = buttonOptions.theme;
            states = attr2 && attr2.states;
            this.drillUpButton = this.chart.renderer.button(backText, 0, 0, function() {
              series.drillUp();
            }, attr2, states && states.hover, states && states.select).addClass("highcharts-drillup-button").attr({
              align: buttonOptions.position.align,
              zIndex: 7
            }).add().align(buttonOptions.position, false, buttonOptions.relativeTo || "plotBox");
          } else {
            this.drillUpButton.placed = false;
            this.drillUpButton.attr({
              text: backText
            }).align();
          }
        };
        TreemapSeries2.prototype.setColorRecursive = function(node, parentColor, colorIndex, index, siblings) {
          var series = this, chart = series && series.chart, colors = chart && chart.options && chart.options.colors, colorInfo, point;
          if (node) {
            colorInfo = getColor(node, {
              colors,
              index,
              mapOptionsToLevel: series.mapOptionsToLevel,
              parentColor,
              parentColorIndex: colorIndex,
              series,
              siblings
            });
            point = series.points[node.i];
            if (point) {
              point.color = colorInfo.color;
              point.colorIndex = colorInfo.colorIndex;
            }
            (node.children || []).forEach(function(child, i) {
              series.setColorRecursive(child, colorInfo.color, colorInfo.colorIndex, i, node.children.length);
            });
          }
        };
        TreemapSeries2.prototype.setPointValues = function() {
          var series = this;
          var points = series.points, xAxis = series.xAxis, yAxis = series.yAxis;
          var styledMode = series.chart.styledMode;
          var getCrispCorrection = function(point) {
            return styledMode ? 0 : (series.pointAttribs(point)["stroke-width"] || 0) % 2 / 2;
          };
          points.forEach(function(point) {
            var _a2 = point.node, values = _a2.pointValues, visible = _a2.visible;
            if (values && visible) {
              var height = values.height, width = values.width, x = values.x, y = values.y;
              var crispCorr = getCrispCorrection(point);
              var x1 = Math.round(xAxis.toPixels(x, true)) - crispCorr;
              var x2 = Math.round(xAxis.toPixels(x + width, true)) - crispCorr;
              var y1 = Math.round(yAxis.toPixels(y, true)) - crispCorr;
              var y2 = Math.round(yAxis.toPixels(y + height, true)) - crispCorr;
              var shapeArgs = {
                x: Math.min(x1, x2),
                y: Math.min(y1, y2),
                width: Math.abs(x2 - x1),
                height: Math.abs(y2 - y1)
              };
              point.plotX = shapeArgs.x + shapeArgs.width / 2;
              point.plotY = shapeArgs.y + shapeArgs.height / 2;
              point.shapeArgs = shapeArgs;
            } else {
              delete point.plotX;
              delete point.plotY;
            }
          });
        };
        TreemapSeries2.prototype.setRootNode = function(id, redraw, eventArguments) {
          var series = this, eventArgs = extend$9({
            newRootId: id,
            previousRootId: series.rootNode,
            redraw: pick$8(redraw, true),
            series
          }, eventArguments);
          var defaultFn = function(args) {
            var series2 = args.series;
            series2.idPreviousRoot = args.previousRootId;
            series2.rootNode = args.newRootId;
            series2.isDirty = true;
            if (args.redraw) {
              series2.chart.redraw();
            }
          };
          fireEvent(series, "setRootNode", eventArgs, defaultFn);
        };
        TreemapSeries2.prototype.setState = function(state) {
          this.options.inactiveOtherPoints = true;
          Series$3.prototype.setState.call(this, state, false);
          this.options.inactiveOtherPoints = false;
        };
        TreemapSeries2.prototype.setTreeValues = function(tree) {
          var series = this, options = series.options, idRoot = series.rootNode, mapIdToNode = series.nodeMap, nodeRoot = mapIdToNode[idRoot], levelIsConstant = TreemapUtilities$1.isBoolean(options.levelIsConstant) ? options.levelIsConstant : true, childrenTotal = 0, children = [], val, point = series.points[tree.i];
          tree.children.forEach(function(child) {
            child = series.setTreeValues(child);
            children.push(child);
            if (!child.ignore) {
              childrenTotal += child.val;
            }
          });
          stableSort$1(children, function(a, b) {
            return (a.sortIndex || 0) - (b.sortIndex || 0);
          });
          val = pick$8(point && point.options.value, childrenTotal);
          if (point) {
            point.value = val;
          }
          extend$9(tree, {
            children,
            childrenTotal,
            // Ignore this node if point is not visible
            ignore: !(pick$8(point && point.visible, true) && val > 0),
            isLeaf: tree.visible && !childrenTotal,
            levelDynamic: tree.level - (levelIsConstant ? 0 : nodeRoot.level),
            name: pick$8(point && point.name, ""),
            sortIndex: pick$8(point && point.sortIndex, -val),
            val
          });
          return tree;
        };
        TreemapSeries2.prototype.sliceAndDice = function(parent, children) {
          return this.algorithmFill(true, parent, children);
        };
        TreemapSeries2.prototype.squarified = function(parent, children) {
          return this.algorithmLowAspectRatio(true, parent, children);
        };
        TreemapSeries2.prototype.strip = function(parent, children) {
          return this.algorithmLowAspectRatio(false, parent, children);
        };
        TreemapSeries2.prototype.stripes = function(parent, children) {
          return this.algorithmFill(false, parent, children);
        };
        TreemapSeries2.prototype.translate = function() {
          var series = this, options = series.options, rootId = updateRootId(series), rootNode, pointValues, seriesArea, tree, val;
          Series$3.prototype.translate.call(series);
          tree = series.tree = series.getTree();
          rootNode = series.nodeMap[rootId];
          if (rootId !== "" && (!rootNode || !rootNode.children.length)) {
            series.setRootNode("", false);
            rootId = series.rootNode;
            rootNode = series.nodeMap[rootId];
          }
          series.renderTraverseUpButton(rootId);
          series.mapOptionsToLevel = getLevelOptions$1({
            from: rootNode.level + 1,
            levels: options.levels,
            to: tree.height,
            defaults: {
              levelIsConstant: series.options.levelIsConstant,
              colorByPoint: options.colorByPoint
            }
          });
          TreemapUtilities$1.recursive(series.nodeMap[series.rootNode], function(node) {
            var next = false, p = node.parent;
            node.visible = true;
            if (p || p === "") {
              next = series.nodeMap[p];
            }
            return next;
          });
          TreemapUtilities$1.recursive(series.nodeMap[series.rootNode].children, function(children) {
            var next = false;
            children.forEach(function(child) {
              child.visible = true;
              if (child.children.length) {
                next = (next || []).concat(child.children);
              }
            });
            return next;
          });
          series.setTreeValues(tree);
          series.axisRatio = series.xAxis.len / series.yAxis.len;
          series.nodeMap[""].pointValues = pointValues = {
            x: 0,
            y: 0,
            width: TreemapUtilities$1.AXIS_MAX,
            height: TreemapUtilities$1.AXIS_MAX
          };
          series.nodeMap[""].values = seriesArea = merge$6(pointValues, {
            width: pointValues.width * series.axisRatio,
            direction: options.layoutStartingDirection === "vertical" ? 0 : 1,
            val: tree.val
          });
          series.calculateChildrenAreas(tree, seriesArea);
          if (!series.colorAxis && !options.colorByPoint) {
            series.setColorRecursive(series.tree);
          }
          if (options.allowTraversingTree) {
            val = rootNode.pointValues;
            series.xAxis.setExtremes(val.x, val.x + val.width, false);
            series.yAxis.setExtremes(val.y, val.y + val.height, false);
            series.xAxis.setScale();
            series.yAxis.setScale();
          }
          series.setPointValues();
        };
        TreemapSeries2.defaultOptions = merge$6(ScatterSeries.defaultOptions, {
          /**
           * When enabled the user can click on a point which is a parent and
           * zoom in on its children. Deprecated and replaced by
           * [allowTraversingTree](#plotOptions.treemap.allowTraversingTree).
           *
           * @sample {highcharts} highcharts/plotoptions/treemap-allowdrilltonode/
           *         Enabled
           *
           * @deprecated
           * @type      {boolean}
           * @default   false
           * @since     4.1.0
           * @product   highcharts
           * @apioption plotOptions.treemap.allowDrillToNode
           */
          /**
           * When enabled the user can click on a point which is a parent and
           * zoom in on its children.
           *
           * @sample {highcharts} highcharts/plotoptions/treemap-allowtraversingtree/
           *         Enabled
           *
           * @since     7.0.3
           * @product   highcharts
           */
          allowTraversingTree: false,
          animationLimit: 250,
          /**
           * The border radius for each treemap item.
           */
          borderRadius: 0,
          /**
           * When the series contains less points than the crop threshold, all
           * points are drawn, event if the points fall outside the visible plot
           * area at the current zoom. The advantage of drawing all points
           * (including markers and columns), is that animation is performed on
           * updates. On the other hand, when the series contains more points than
           * the crop threshold, the series data is cropped to only contain points
           * that fall within the plot area. The advantage of cropping away
           * invisible points is to increase performance on large series.
           *
           * @type      {number}
           * @default   300
           * @since     4.1.0
           * @product   highcharts
           * @apioption plotOptions.treemap.cropThreshold
           */
          /**
           * Fires on a request for change of root node for the tree, before the
           * update is made. An event object is passed to the function, containing
           * additional properties `newRootId`, `previousRootId`, `redraw` and
           * `trigger`.
           *
           * @type {function}
           * @default undefined
           * @sample {highcharts} highcharts/plotoptions/treemap-events-setrootnode/
           *         Alert update information on setRootNode event.
           * @since 7.0.3
           * @product highcharts
           * @apioption plotOptions.treemap.events.setRootNode
           */
          /**
           * This option decides if the user can interact with the parent nodes
           * or just the leaf nodes. When this option is undefined, it will be
           * true by default. However when allowTraversingTree is true, then it
           * will be false by default.
           *
           * @sample {highcharts} highcharts/plotoptions/treemap-interactbyleaf-false/
           *         False
           * @sample {highcharts} highcharts/plotoptions/treemap-interactbyleaf-true-and-allowtraversingtree/
           *         InteractByLeaf and allowTraversingTree is true
           *
           * @type      {boolean}
           * @since     4.1.2
           * @product   highcharts
           * @apioption plotOptions.treemap.interactByLeaf
           */
          /**
           * The sort index of the point inside the treemap level.
           *
           * @sample {highcharts} highcharts/plotoptions/treemap-sortindex/
           *         Sort by years
           *
           * @type      {number}
           * @since     4.1.10
           * @product   highcharts
           * @apioption plotOptions.treemap.sortIndex
           */
          /**
           * A series specific or series type specific color set to apply instead
           * of the global [colors](#colors) when
           * [colorByPoint](#plotOptions.treemap.colorByPoint) is true.
           *
           * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
           * @since     3.0
           * @product   highcharts
           * @apioption plotOptions.treemap.colors
           */
          /**
           * Whether to display this series type or specific series item in the
           * legend.
           */
          showInLegend: false,
          /**
           * @ignore-option
           */
          marker: void 0,
          /**
           * When using automatic point colors pulled from the `options.colors`
           * collection, this option determines whether the chart should receive
           * one color per series or one color per point.
           *
           * @see [series colors](#plotOptions.treemap.colors)
           *
           * @since     2.0
           * @product   highcharts
           * @apioption plotOptions.treemap.colorByPoint
           */
          colorByPoint: false,
          /**
           * @since 4.1.0
           */
          dataLabels: {
            defer: false,
            enabled: true,
            formatter: function() {
              var point = this && this.point ? this.point : {}, name = isString(point.name) ? point.name : "";
              return name;
            },
            inside: true,
            verticalAlign: "middle"
          },
          tooltip: {
            headerFormat: "",
            pointFormat: "<b>{point.name}</b>: {point.value}<br/>"
          },
          /**
           * Whether to ignore hidden points when the layout algorithm runs.
           * If `false`, hidden points will leave open spaces.
           *
           * @since 5.0.8
           */
          ignoreHiddenPoint: true,
          /**
           * This option decides which algorithm is used for setting position
           * and dimensions of the points.
           *
           * @see [How to write your own algorithm](https://www.highcharts.com/docs/chart-and-series-types/treemap)
           *
           * @sample {highcharts} highcharts/plotoptions/treemap-layoutalgorithm-sliceanddice/
           *         SliceAndDice by default
           * @sample {highcharts} highcharts/plotoptions/treemap-layoutalgorithm-stripes/
           *         Stripes
           * @sample {highcharts} highcharts/plotoptions/treemap-layoutalgorithm-squarified/
           *         Squarified
           * @sample {highcharts} highcharts/plotoptions/treemap-layoutalgorithm-strip/
           *         Strip
           *
           * @since      4.1.0
           * @validvalue ["sliceAndDice", "stripes", "squarified", "strip"]
           */
          layoutAlgorithm: "sliceAndDice",
          /**
           * Defines which direction the layout algorithm will start drawing.
           *
           * @since       4.1.0
           * @validvalue ["vertical", "horizontal"]
           */
          layoutStartingDirection: "vertical",
          /**
           * Enabling this option will make the treemap alternate the drawing
           * direction between vertical and horizontal. The next levels starting
           * direction will always be the opposite of the previous.
           *
           * @sample {highcharts} highcharts/plotoptions/treemap-alternatestartingdirection-true/
           *         Enabled
           *
           * @since 4.1.0
           */
          alternateStartingDirection: false,
          /**
           * Used together with the levels and allowTraversingTree options. When
           * set to false the first level visible to be level one, which is
           * dynamic when traversing the tree. Otherwise the level will be the
           * same as the tree structure.
           *
           * @since 4.1.0
           */
          levelIsConstant: true,
          /**
           * Options for the button appearing when drilling down in a treemap.
           * Deprecated and replaced by
           * [traverseUpButton](#plotOptions.treemap.traverseUpButton).
           *
           * @deprecated
           */
          drillUpButton: {
            /**
             * The position of the button.
             *
             * @deprecated
             */
            position: {
              /**
               * Vertical alignment of the button.
               *
               * @deprecated
               * @type      {Highcharts.VerticalAlignValue}
               * @default   top
               * @product   highcharts
               * @apioption plotOptions.treemap.drillUpButton.position.verticalAlign
               */
              /**
               * Horizontal alignment of the button.
               *
               * @deprecated
               * @type {Highcharts.AlignValue}
               */
              align: "right",
              /**
               * Horizontal offset of the button.
               *
               * @deprecated
               */
              x: -10,
              /**
               * Vertical offset of the button.
               *
               * @deprecated
               */
              y: 10
            }
          },
          /**
           * Options for the button appearing when traversing down in a treemap.
           */
          traverseUpButton: {
            /**
             * The position of the button.
             */
            position: {
              /**
               * Vertical alignment of the button.
               *
               * @type      {Highcharts.VerticalAlignValue}
               * @default   top
               * @product   highcharts
               * @apioption plotOptions.treemap.traverseUpButton.position.verticalAlign
               */
              /**
               * Horizontal alignment of the button.
               *
               * @type {Highcharts.AlignValue}
               */
              align: "right",
              /**
               * Horizontal offset of the button.
               */
              x: -10,
              /**
               * Vertical offset of the button.
               */
              y: 10
            }
          },
          /**
           * Set options on specific levels. Takes precedence over series options,
           * but not point options.
           *
           * @sample {highcharts} highcharts/plotoptions/treemap-levels/
           *         Styling dataLabels and borders
           * @sample {highcharts} highcharts/demo/treemap-with-levels/
           *         Different layoutAlgorithm
           *
           * @type      {Array<*>}
           * @since     4.1.0
           * @product   highcharts
           * @apioption plotOptions.treemap.levels
           */
          /**
           * Can set a `borderColor` on all points which lies on the same level.
           *
           * @type      {Highcharts.ColorString}
           * @since     4.1.0
           * @product   highcharts
           * @apioption plotOptions.treemap.levels.borderColor
           */
          /**
           * Set the dash style of the border of all the point which lies on the
           * level. See
           * [plotOptions.scatter.dashStyle](#plotoptions.scatter.dashstyle)
           * for possible options.
           *
           * @type      {Highcharts.DashStyleValue}
           * @since     4.1.0
           * @product   highcharts
           * @apioption plotOptions.treemap.levels.borderDashStyle
           */
          /**
           * Can set the borderWidth on all points which lies on the same level.
           *
           * @type      {number}
           * @since     4.1.0
           * @product   highcharts
           * @apioption plotOptions.treemap.levels.borderWidth
           */
          /**
           * Can set a color on all points which lies on the same level.
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @since     4.1.0
           * @product   highcharts
           * @apioption plotOptions.treemap.levels.color
           */
          /**
           * A configuration object to define how the color of a child varies from
           * the parent's color. The variation is distributed among the children
           * of node. For example when setting brightness, the brightness change
           * will range from the parent's original brightness on the first child,
           * to the amount set in the `to` setting on the last node. This allows a
           * gradient-like color scheme that sets children out from each other
           * while highlighting the grouping on treemaps and sectors on sunburst
           * charts.
           *
           * @sample highcharts/demo/sunburst/
           *         Sunburst with color variation
           *
           * @since     6.0.0
           * @product   highcharts
           * @apioption plotOptions.treemap.levels.colorVariation
           */
          /**
           * The key of a color variation. Currently supports `brightness` only.
           *
           * @type       {string}
           * @since      6.0.0
           * @product    highcharts
           * @validvalue ["brightness"]
           * @apioption  plotOptions.treemap.levels.colorVariation.key
           */
          /**
           * The ending value of a color variation. The last sibling will receive
           * this value.
           *
           * @type      {number}
           * @since     6.0.0
           * @product   highcharts
           * @apioption plotOptions.treemap.levels.colorVariation.to
           */
          /**
           * Can set the options of dataLabels on each point which lies on the
           * level.
           * [plotOptions.treemap.dataLabels](#plotOptions.treemap.dataLabels) for
           * possible values.
           *
           * @extends   plotOptions.treemap.dataLabels
           * @since     4.1.0
           * @product   highcharts
           * @apioption plotOptions.treemap.levels.dataLabels
           */
          /**
           * Can set the layoutAlgorithm option on a specific level.
           *
           * @type       {string}
           * @since      4.1.0
           * @product    highcharts
           * @validvalue ["sliceAndDice", "stripes", "squarified", "strip"]
           * @apioption  plotOptions.treemap.levels.layoutAlgorithm
           */
          /**
           * Can set the layoutStartingDirection option on a specific level.
           *
           * @type       {string}
           * @since      4.1.0
           * @product    highcharts
           * @validvalue ["vertical", "horizontal"]
           * @apioption  plotOptions.treemap.levels.layoutStartingDirection
           */
          /**
           * Decides which level takes effect from the options set in the levels
           * object.
           *
           * @sample {highcharts} highcharts/plotoptions/treemap-levels/
           *         Styling of both levels
           *
           * @type      {number}
           * @since     4.1.0
           * @product   highcharts
           * @apioption plotOptions.treemap.levels.level
           */
          // Presentational options
          /**
           * The color of the border surrounding each tree map item.
           *
           * @type {Highcharts.ColorString}
           */
          borderColor: palette.neutralColor10,
          /**
           * The width of the border surrounding each tree map item.
           */
          borderWidth: 1,
          colorKey: "colorValue",
          /**
           * The opacity of a point in treemap. When a point has children, the
           * visibility of the children is determined by the opacity.
           *
           * @since 4.2.4
           */
          opacity: 0.15,
          /**
           * A wrapper object for all the series options in specific states.
           *
           * @extends plotOptions.heatmap.states
           */
          states: {
            /**
             * Options for the hovered series
             *
             * @extends   plotOptions.heatmap.states.hover
             * @excluding halo
             */
            hover: {
              /**
               * The border color for the hovered state.
               */
              borderColor: palette.neutralColor40,
              /**
               * Brightness for the hovered point. Defaults to 0 if the
               * heatmap series is loaded first, otherwise 0.1.
               *
               * @type    {number}
               * @default undefined
               */
              brightness: HeatmapSeries ? 0 : 0.1,
              /**
               * @extends plotOptions.heatmap.states.hover.halo
               */
              halo: false,
              /**
               * The opacity of a point in treemap. When a point has children,
               * the visibility of the children is determined by the opacity.
               *
               * @since 4.2.4
               */
              opacity: 0.75,
              /**
               * The shadow option for hovered state.
               */
              shadow: false
            }
          }
        });
        return TreemapSeries2;
      }(ScatterSeries)
    );
    extend$9(TreemapSeries.prototype, {
      buildKDTree: noop,
      colorKey: "colorValue",
      directTouch: true,
      drawLegendSymbol: LegendSymbol$1.drawRectangle,
      getExtremesFromAll: true,
      getSymbol: noop,
      optionalAxis: "colorAxis",
      parallelArrays: ["x", "y", "value", "colorValue"],
      pointArrayMap: ["value"],
      pointClass: TreemapPoint,
      trackerGroups: ["group", "dataLabelsGroup"],
      utils: {
        recursive: TreemapUtilities$1.recursive
      }
    });
    SeriesRegistry$1.registerSeriesType("treemap", TreemapSeries);
    var getOptions = DefaultOptions.getOptions;
    var addEvent$2 = Utilities.addEvent, extend$8 = Utilities.extend;
    var chartPrototype = Chart$1.prototype, defaultOptions$1 = getOptions();
    extend$8(
      defaultOptions$1.lang,
      /**
       * @optionparent lang
       */
      {
        /**
         * The text to display when the chart contains no data.
         *
         * @see [noData](#noData)
         *
         * @sample highcharts/no-data-to-display/no-data-line
         *         No-data text
         *
         * @since    3.0.8
         * @product  highcharts highstock
         * @requires modules/no-data-to-display
         */
        noData: "No data to display"
      }
    );
    defaultOptions$1.noData = {
      /**
       * An object of additional SVG attributes for the no-data label.
       *
       * @type      {Highcharts.SVGAttributes}
       * @since     3.0.8
       * @product   highcharts highstock gantt
       * @apioption noData.attr
       */
      attr: {
        zIndex: 1
      },
      /**
       * Whether to insert the label as HTML, or as pseudo-HTML rendered with
       * SVG.
       *
       * @type      {boolean}
       * @default   false
       * @since     4.1.10
       * @product   highcharts highstock gantt
       * @apioption noData.useHTML
       */
      /**
       * The position of the no-data label, relative to the plot area.
       *
       * @type  {Highcharts.AlignObject}
       * @since 3.0.8
       */
      position: {
        /**
         * Horizontal offset of the label, in pixels.
         */
        x: 0,
        /**
         * Vertical offset of the label, in pixels.
         */
        y: 0,
        /**
         * Horizontal alignment of the label.
         *
         * @type {Highcharts.AlignValue}
         */
        align: "center",
        /**
         * Vertical alignment of the label.
         *
         * @type {Highcharts.VerticalAlignValue}
         */
        verticalAlign: "middle"
      },
      /**
       * CSS styles for the no-data label.
       *
       * @sample highcharts/no-data-to-display/no-data-line
       *         Styled no-data text
       *
       * @type {Highcharts.CSSObject}
       */
      style: {
        /** @ignore */
        fontWeight: "bold",
        /** @ignore */
        fontSize: "12px",
        /** @ignore */
        color: palette.neutralColor60
      }
    };
    chartPrototype.showNoData = function(str) {
      var chart = this, options = chart.options, text = str || options && options.lang.noData || "", noDataOptions = options && (options.noData || {});
      if (chart.renderer) {
        if (!chart.noDataLabel) {
          chart.noDataLabel = chart.renderer.label(text, 0, 0, void 0, void 0, void 0, noDataOptions.useHTML, void 0, "no-data").add();
        }
        if (!chart.styledMode) {
          chart.noDataLabel.attr(AST.filterUserAttributes(noDataOptions.attr || {})).css(noDataOptions.style || {});
        }
        chart.noDataLabel.align(extend$8(chart.noDataLabel.getBBox(), noDataOptions.position || {}), false, "plotBox");
      }
    };
    chartPrototype.hideNoData = function() {
      var chart = this;
      if (chart.noDataLabel) {
        chart.noDataLabel = chart.noDataLabel.destroy();
      }
    };
    chartPrototype.hasData = function() {
      var chart = this, series = chart.series || [], i = series.length;
      while (i--) {
        if (series[i].hasData() && !series[i].options.isInternal) {
          return true;
        }
      }
      return chart.loadingShown;
    };
    addEvent$2(Chart$1, "render", function handleNoData() {
      if (this.hasData()) {
        this.hideNoData();
      } else {
        this.showNoData();
      }
    });
    var defined$5 = Utilities.defined, extend$7 = Utilities.extend, find$2 = Utilities.find, pick$7 = Utilities.pick;
    var NodesMixin = H.NodesMixin = {
      /* eslint-disable valid-jsdoc */
      /**
       * Create a single node that holds information on incoming and outgoing
       * links.
       * @private
       */
      createNode: function(id) {
        function findById(nodes, id2) {
          return find$2(nodes, function(node2) {
            return node2.id === id2;
          });
        }
        var node = findById(this.nodes, id), PointClass = this.pointClass, options;
        if (!node) {
          options = this.options.nodes && findById(this.options.nodes, id);
          node = new PointClass().init(this, extend$7({
            className: "highcharts-node",
            isNode: true,
            id,
            y: 1
            // Pass isNull test
          }, options));
          node.linksTo = [];
          node.linksFrom = [];
          node.formatPrefix = "node";
          node.name = node.name || node.options.id || "";
          node.mass = pick$7(
            // Node:
            node.options.mass,
            node.options.marker && node.options.marker.radius,
            // Series:
            this.options.marker && this.options.marker.radius,
            // Default:
            4
          );
          node.getSum = function() {
            var sumTo = 0, sumFrom = 0;
            node.linksTo.forEach(function(link) {
              sumTo += link.weight;
            });
            node.linksFrom.forEach(function(link) {
              sumFrom += link.weight;
            });
            return Math.max(sumTo, sumFrom);
          };
          node.offset = function(point, coll) {
            var offset2 = 0;
            for (var i = 0; i < node[coll].length; i++) {
              if (node[coll][i] === point) {
                return offset2;
              }
              offset2 += node[coll][i].weight;
            }
          };
          node.hasShape = function() {
            var outgoing = 0;
            node.linksTo.forEach(function(link) {
              if (link.outgoing) {
                outgoing++;
              }
            });
            return !node.linksTo.length || outgoing !== node.linksTo.length;
          };
          this.nodes.push(node);
        }
        return node;
      },
      /**
       * Extend generatePoints by adding the nodes, which are Point objects
       * but pushed to the this.nodes array.
       */
      generatePoints: function() {
        var chart = this.chart, nodeLookup = {};
        Series$e.prototype.generatePoints.call(this);
        if (!this.nodes) {
          this.nodes = [];
        }
        this.colorCounter = 0;
        this.nodes.forEach(function(node) {
          node.linksFrom.length = 0;
          node.linksTo.length = 0;
          node.level = node.options.level;
        });
        this.points.forEach(function(point) {
          if (defined$5(point.from)) {
            if (!nodeLookup[point.from]) {
              nodeLookup[point.from] = this.createNode(point.from);
            }
            nodeLookup[point.from].linksFrom.push(point);
            point.fromNode = nodeLookup[point.from];
            if (chart.styledMode) {
              point.colorIndex = pick$7(point.options.colorIndex, nodeLookup[point.from].colorIndex);
            } else {
              point.color = point.options.color || nodeLookup[point.from].color;
            }
          }
          if (defined$5(point.to)) {
            if (!nodeLookup[point.to]) {
              nodeLookup[point.to] = this.createNode(point.to);
            }
            nodeLookup[point.to].linksTo.push(point);
            point.toNode = nodeLookup[point.to];
          }
          point.name = point.name || point.id;
        }, this);
        this.nodeLookup = nodeLookup;
      },
      // Destroy all nodes on setting new data
      setData: function() {
        if (this.nodes) {
          this.nodes.forEach(function(node) {
            node.destroy();
          });
          this.nodes.length = 0;
        }
        Series$e.prototype.setData.apply(this, arguments);
      },
      // Destroy alll nodes and links
      destroy: function() {
        this.data = [].concat(this.points || [], this.nodes);
        return Series$e.prototype.destroy.apply(this, arguments);
      },
      /**
       * When hovering node, highlight all connected links. When hovering a link,
       * highlight all connected nodes.
       */
      setNodeState: function(state) {
        var args = arguments, others = this.isNode ? this.linksTo.concat(this.linksFrom) : [this.fromNode, this.toNode];
        if (state !== "select") {
          others.forEach(function(linkOrNode) {
            if (linkOrNode && linkOrNode.series) {
              Point$2.prototype.setState.apply(linkOrNode, args);
              if (!linkOrNode.isNode) {
                if (linkOrNode.fromNode.graphic) {
                  Point$2.prototype.setState.apply(linkOrNode.fromNode, args);
                }
                if (linkOrNode.toNode && linkOrNode.toNode.graphic) {
                  Point$2.prototype.setState.apply(linkOrNode.toNode, args);
                }
              }
            }
          });
        }
        Point$2.prototype.setState.apply(this, args);
      }
      /* eslint-enable valid-jsdoc */
    };
    var __extends$9 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var ColumnSeries$5 = SeriesRegistry$1.seriesTypes.column;
    var defined$4 = Utilities.defined, extend$6 = Utilities.extend;
    var SankeyPoint$1 = (
      /** @class */
      function(_super) {
        __extends$9(SankeyPoint2, _super);
        function SankeyPoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.className = void 0;
          _this.fromNode = void 0;
          _this.level = void 0;
          _this.linkBase = void 0;
          _this.linksFrom = void 0;
          _this.linksTo = void 0;
          _this.mass = void 0;
          _this.nodeX = void 0;
          _this.nodeY = void 0;
          _this.options = void 0;
          _this.series = void 0;
          _this.toNode = void 0;
          return _this;
        }
        SankeyPoint2.prototype.applyOptions = function(options, x) {
          Point$2.prototype.applyOptions.call(this, options, x);
          if (defined$4(this.options.level)) {
            this.options.column = this.column = this.options.level;
          }
          return this;
        };
        SankeyPoint2.prototype.getClassName = function() {
          return (this.isNode ? "highcharts-node " : "highcharts-link ") + Point$2.prototype.getClassName.call(this);
        };
        SankeyPoint2.prototype.isValid = function() {
          return this.isNode || typeof this.weight === "number";
        };
        return SankeyPoint2;
      }(ColumnSeries$5.prototype.pointClass)
    );
    extend$6(SankeyPoint$1.prototype, {
      setState: NodesMixin.setNodeState
    });
    var __extends$8 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Series$2 = SeriesRegistry$1.series, ColumnSeries$4 = SeriesRegistry$1.seriesTypes.column;
    var getLevelOptions = result.getLevelOptions;
    var defined$3 = Utilities.defined, extend$5 = Utilities.extend, find$1 = Utilities.find, isObject$1 = Utilities.isObject, merge$5 = Utilities.merge, pick$6 = Utilities.pick, relativeLength$1 = Utilities.relativeLength, stableSort = Utilities.stableSort;
    var SankeySeries$1 = (
      /** @class */
      function(_super) {
        __extends$8(SankeySeries2, _super);
        function SankeySeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.colDistance = void 0;
          _this.data = void 0;
          _this.group = void 0;
          _this.nodeLookup = void 0;
          _this.nodePadding = void 0;
          _this.nodes = void 0;
          _this.nodeWidth = void 0;
          _this.options = void 0;
          _this.points = void 0;
          _this.translationFactor = void 0;
          return _this;
        }
        SankeySeries2.getDLOptions = function(params) {
          var optionsPoint = isObject$1(params.optionsPoint) ? params.optionsPoint.dataLabels : {}, optionsLevel = isObject$1(params.level) ? params.level.dataLabels : {}, options = merge$5({
            style: {}
          }, optionsLevel, optionsPoint);
          return options;
        };
        SankeySeries2.prototype.createNodeColumn = function() {
          var series = this, chart = this.chart, column = [];
          column.sum = function() {
            return this.reduce(function(sum, node) {
              return sum + node.getSum();
            }, 0);
          };
          column.offset = function(node, factor) {
            var offset2 = 0, totalNodeOffset, nodePadding = series.nodePadding;
            for (var i = 0; i < column.length; i++) {
              var sum = column[i].getSum();
              var height = Math.max(sum * factor, series.options.minLinkWidth);
              if (sum) {
                totalNodeOffset = height + nodePadding;
              } else {
                totalNodeOffset = 0;
              }
              if (column[i] === node) {
                return {
                  relativeTop: offset2 + relativeLength$1(node.options.offset || 0, totalNodeOffset)
                };
              }
              offset2 += totalNodeOffset;
            }
          };
          column.top = function(factor) {
            var nodePadding = series.nodePadding;
            var height = this.reduce(function(height2, node) {
              if (height2 > 0) {
                height2 += nodePadding;
              }
              var nodeHeight = Math.max(node.getSum() * factor, series.options.minLinkWidth);
              height2 += nodeHeight;
              return height2;
            }, 0);
            return (chart.plotSizeY - height) / 2;
          };
          return column;
        };
        SankeySeries2.prototype.createNodeColumns = function() {
          var columns = [];
          this.nodes.forEach(function(node) {
            var fromColumn = -1, fromNode;
            if (!defined$3(node.options.column)) {
              if (node.linksTo.length === 0) {
                node.column = 0;
              } else {
                for (var i2 = 0; i2 < node.linksTo.length; i2++) {
                  var point = node.linksTo[i2];
                  if (point.fromNode.column > fromColumn && point.fromNode !== node) {
                    fromNode = point.fromNode;
                    fromColumn = fromNode.column;
                  }
                }
                node.column = fromColumn + 1;
                if (fromNode && fromNode.options.layout === "hanging") {
                  node.hangsFrom = fromNode;
                  var i_1 = -1;
                  find$1(fromNode.linksFrom, function(link, index) {
                    var found = link.toNode === node;
                    if (found) {
                      i_1 = index;
                    }
                    return found;
                  });
                  node.column += i_1;
                }
              }
            }
            if (!columns[node.column]) {
              columns[node.column] = this.createNodeColumn();
            }
            columns[node.column].push(node);
          }, this);
          for (var i = 0; i < columns.length; i++) {
            if (typeof columns[i] === "undefined") {
              columns[i] = this.createNodeColumn();
            }
          }
          return columns;
        };
        SankeySeries2.prototype.generatePoints = function() {
          NodesMixin.generatePoints.apply(this, arguments);
          function order(node, level) {
            if (typeof node.level === "undefined") {
              node.level = level;
              node.linksFrom.forEach(function(link) {
                if (link.toNode) {
                  order(link.toNode, level + 1);
                }
              });
            }
          }
          if (this.orderNodes) {
            this.nodes.filter(function(node) {
              return node.linksTo.length === 0;
            }).forEach(function(node) {
              order(node, 0);
            });
            stableSort(this.nodes, function(a, b) {
              return a.level - b.level;
            });
          }
        };
        SankeySeries2.prototype.getNodePadding = function() {
          var nodePadding = this.options.nodePadding || 0;
          if (this.nodeColumns) {
            var maxLength = this.nodeColumns.reduce(function(acc, col) {
              return Math.max(acc, col.length);
            }, 0);
            if (maxLength * nodePadding > this.chart.plotSizeY) {
              nodePadding = this.chart.plotSizeY / maxLength;
            }
          }
          return nodePadding;
        };
        SankeySeries2.prototype.hasData = function() {
          return !!this.processedXData.length;
        };
        SankeySeries2.prototype.pointAttribs = function(point, state) {
          if (!point) {
            return {};
          }
          var series = this, level = point.isNode ? point.level : point.fromNode.level, levelOptions = series.mapOptionsToLevel[level || 0] || {}, options = point.options, stateOptions = levelOptions.states && levelOptions.states[state || ""] || {}, values = [
            "colorByPoint",
            "borderColor",
            "borderWidth",
            "linkOpacity"
          ].reduce(function(obj, key) {
            obj[key] = pick$6(stateOptions[key], options[key], levelOptions[key], series.options[key]);
            return obj;
          }, {}), color2 = pick$6(stateOptions.color, options.color, values.colorByPoint ? point.color : levelOptions.color);
          if (point.isNode) {
            return {
              fill: color2,
              stroke: values.borderColor,
              "stroke-width": values.borderWidth
            };
          }
          return {
            fill: Color.parse(color2).setOpacity(values.linkOpacity).get()
          };
        };
        SankeySeries2.prototype.render = function() {
          var points = this.points;
          this.points = this.points.concat(this.nodes || []);
          ColumnSeries$4.prototype.render.call(this);
          this.points = points;
        };
        SankeySeries2.prototype.translate = function() {
          var _this = this;
          var getColumnTranslationFactor = function(column) {
            var nodes = column.slice();
            var minLinkWidth = _this.options.minLinkWidth || 0;
            var exceedsMinLinkWidth;
            var factor = 0;
            var i;
            var remainingHeight = chart.plotSizeY - options.borderWidth - (column.length - 1) * series.nodePadding;
            while (column.length) {
              factor = remainingHeight / column.sum();
              exceedsMinLinkWidth = false;
              i = column.length;
              while (i--) {
                if (column[i].getSum() * factor < minLinkWidth) {
                  column.splice(i, 1);
                  remainingHeight -= minLinkWidth;
                  exceedsMinLinkWidth = true;
                }
              }
              if (!exceedsMinLinkWidth) {
                break;
              }
            }
            column.length = 0;
            nodes.forEach(function(node) {
              return column.push(node);
            });
            return factor;
          };
          if (!this.processedXData) {
            this.processData();
          }
          this.generatePoints();
          this.nodeColumns = this.createNodeColumns();
          this.nodeWidth = relativeLength$1(this.options.nodeWidth, this.chart.plotSizeX);
          var series = this, chart = this.chart, options = this.options, nodeWidth = this.nodeWidth, nodeColumns = this.nodeColumns;
          this.nodePadding = this.getNodePadding();
          this.translationFactor = nodeColumns.reduce(function(translationFactor, column) {
            return Math.min(translationFactor, getColumnTranslationFactor(column));
          }, Infinity);
          this.colDistance = (chart.plotSizeX - nodeWidth - options.borderWidth) / Math.max(1, nodeColumns.length - 1);
          series.mapOptionsToLevel = getLevelOptions({
            // NOTE: if support for allowTraversingTree is added, then from
            // should be the level of the root node.
            from: 1,
            levels: options.levels,
            to: nodeColumns.length - 1,
            defaults: {
              borderColor: options.borderColor,
              borderRadius: options.borderRadius,
              borderWidth: options.borderWidth,
              color: series.color,
              colorByPoint: options.colorByPoint,
              // NOTE: if support for allowTraversingTree is added, then
              // levelIsConstant should be optional.
              levelIsConstant: true,
              linkColor: options.linkColor,
              linkLineWidth: options.linkLineWidth,
              linkOpacity: options.linkOpacity,
              states: options.states
            }
          });
          nodeColumns.forEach(function(column) {
            column.forEach(function(node) {
              series.translateNode(node, column);
            });
          }, this);
          this.nodes.forEach(function(node) {
            node.linksFrom.forEach(function(linkPoint) {
              if ((linkPoint.weight || linkPoint.isNull) && linkPoint.to) {
                series.translateLink(linkPoint);
                linkPoint.allowShadow = false;
              }
            });
          });
        };
        SankeySeries2.prototype.translateLink = function(point) {
          var getY = function(node, fromOrTo) {
            var linkTop = node.offset(point, fromOrTo) * translationFactor;
            var y = Math.min(
              node.nodeY + linkTop,
              // Prevent links from spilling below the node (#12014)
              node.nodeY + (node.shapeArgs && node.shapeArgs.height || 0) - linkHeight
            );
            return y;
          };
          var fromNode = point.fromNode, toNode = point.toNode, chart = this.chart, translationFactor = this.translationFactor, linkHeight = Math.max(point.weight * translationFactor, this.options.minLinkWidth), options = this.options, curvy = (chart.inverted ? -this.colDistance : this.colDistance) * options.curveFactor, fromY = getY(fromNode, "linksFrom"), toY = getY(toNode, "linksTo"), nodeLeft = fromNode.nodeX, nodeW = this.nodeWidth, right = toNode.column * this.colDistance, outgoing = point.outgoing, straight = right > nodeLeft + nodeW;
          if (chart.inverted) {
            fromY = chart.plotSizeY - fromY;
            toY = (chart.plotSizeY || 0) - toY;
            right = chart.plotSizeX - right;
            nodeW = -nodeW;
            linkHeight = -linkHeight;
            straight = nodeLeft > right;
          }
          point.shapeType = "path";
          point.linkBase = [
            fromY,
            fromY + linkHeight,
            toY,
            toY + linkHeight
          ];
          if (straight && typeof toY === "number") {
            point.shapeArgs = {
              d: [
                ["M", nodeLeft + nodeW, fromY],
                [
                  "C",
                  nodeLeft + nodeW + curvy,
                  fromY,
                  right - curvy,
                  toY,
                  right,
                  toY
                ],
                ["L", right + (outgoing ? nodeW : 0), toY + linkHeight / 2],
                ["L", right, toY + linkHeight],
                [
                  "C",
                  right - curvy,
                  toY + linkHeight,
                  nodeLeft + nodeW + curvy,
                  fromY + linkHeight,
                  nodeLeft + nodeW,
                  fromY + linkHeight
                ],
                ["Z"]
              ]
            };
          } else if (typeof toY === "number") {
            var bend = 20, vDist = chart.plotHeight - fromY - linkHeight, x1 = right - bend - linkHeight, x2 = right - bend, x3 = right, x4 = nodeLeft + nodeW, x5 = x4 + bend, x6 = x5 + linkHeight, fy1 = fromY, fy2 = fromY + linkHeight, fy3 = fy2 + bend, y4 = fy3 + vDist, y5 = y4 + bend, y6 = y5 + linkHeight, ty1 = toY, ty2 = ty1 + linkHeight, ty3 = ty2 + bend, cfy1 = fy2 - linkHeight * 0.7, cy2 = y5 + linkHeight * 0.7, cty1 = ty2 - linkHeight * 0.7, cx1 = x3 - linkHeight * 0.7, cx2 = x4 + linkHeight * 0.7;
            point.shapeArgs = {
              d: [
                ["M", x4, fy1],
                ["C", cx2, fy1, x6, cfy1, x6, fy3],
                ["L", x6, y4],
                ["C", x6, cy2, cx2, y6, x4, y6],
                ["L", x3, y6],
                ["C", cx1, y6, x1, cy2, x1, y4],
                ["L", x1, ty3],
                ["C", x1, cty1, cx1, ty1, x3, ty1],
                ["L", x3, ty2],
                ["C", x2, ty2, x2, ty2, x2, ty3],
                ["L", x2, y4],
                ["C", x2, y5, x2, y5, x3, y5],
                ["L", x4, y5],
                ["C", x5, y5, x5, y5, x5, y4],
                ["L", x5, fy3],
                ["C", x5, fy2, x5, fy2, x4, fy2],
                ["Z"]
              ]
            };
          }
          point.dlBox = {
            x: nodeLeft + (right - nodeLeft + nodeW) / 2,
            y: fromY + (toY - fromY) / 2,
            height: linkHeight,
            width: 0
          };
          point.tooltipPos = chart.inverted ? [
            chart.plotSizeY - point.dlBox.y - linkHeight / 2,
            chart.plotSizeX - point.dlBox.x
          ] : [
            point.dlBox.x,
            point.dlBox.y + linkHeight / 2
          ];
          point.y = point.plotY = 1;
          if (!point.color) {
            point.color = fromNode.color;
          }
        };
        SankeySeries2.prototype.translateNode = function(node, column) {
          var translationFactor = this.translationFactor, chart = this.chart, options = this.options, sum = node.getSum(), nodeHeight = Math.max(Math.round(sum * translationFactor), this.options.minLinkWidth), crisp = Math.round(options.borderWidth) % 2 / 2, nodeOffset = column.offset(node, translationFactor), fromNodeTop = Math.floor(pick$6(nodeOffset.absoluteTop, column.top(translationFactor) + nodeOffset.relativeTop)) + crisp, left = Math.floor(this.colDistance * node.column + options.borderWidth / 2) + crisp, nodeLeft = chart.inverted ? chart.plotSizeX - left : left, nodeWidth = Math.round(this.nodeWidth);
          node.sum = sum;
          if (sum) {
            node.shapeType = "rect";
            node.nodeX = nodeLeft;
            node.nodeY = fromNodeTop;
            var x = nodeLeft, y = fromNodeTop, width = node.options.width || options.width || nodeWidth, height = node.options.height || options.height || nodeHeight;
            if (chart.inverted) {
              x = nodeLeft - nodeWidth;
              y = chart.plotSizeY - fromNodeTop - nodeHeight;
              width = node.options.height || options.height || nodeWidth;
              height = node.options.width || options.width || nodeHeight;
            }
            node.dlOptions = SankeySeries2.getDLOptions({
              level: this.mapOptionsToLevel[node.level],
              optionsPoint: node.options
            });
            node.plotX = 1;
            node.plotY = 1;
            node.tooltipPos = chart.inverted ? [
              chart.plotSizeY - y - height / 2,
              chart.plotSizeX - x - width / 2
            ] : [
              x + width / 2,
              y + height / 2
            ];
            node.shapeArgs = {
              x,
              y,
              width,
              height,
              display: node.hasShape() ? "" : "none"
            };
          } else {
            node.dlOptions = {
              enabled: false
            };
          }
        };
        SankeySeries2.defaultOptions = merge$5(ColumnSeries$4.defaultOptions, {
          borderWidth: 0,
          colorByPoint: true,
          /**
           * Higher numbers makes the links in a sankey diagram or dependency
           * wheelrender more curved. A `curveFactor` of 0 makes the lines
           * straight.
           *
           * @private
           */
          curveFactor: 0.33,
          /**
           * Options for the data labels appearing on top of the nodes and links.
           * For sankey charts, data labels are visible for the nodes by default,
           * but hidden for links. This is controlled by modifying the
           * `nodeFormat`, and the `format` that applies to links and is an empty
           * string by default.
           *
           * @declare Highcharts.SeriesSankeyDataLabelsOptionsObject
           *
           * @private
           */
          dataLabels: {
            enabled: true,
            backgroundColor: "none",
            crop: false,
            /**
             * The
             * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
             * specifying what to show for _nodes_ in the sankey diagram. By
             * default the `nodeFormatter` returns `{point.name}`.
             *
             * @sample highcharts/plotoptions/sankey-link-datalabels/
             *         Node and link data labels
             *
             * @type {string}
             */
            nodeFormat: void 0,
            // eslint-disable-next-line valid-jsdoc
            /**
             * Callback to format data labels for _nodes_ in the sankey diagram.
             * The `nodeFormat` option takes precedence over the
             * `nodeFormatter`.
             *
             * @type  {Highcharts.SeriesSankeyDataLabelsFormatterCallbackFunction}
             * @since 6.0.2
             */
            nodeFormatter: function() {
              return this.point.name;
            },
            format: void 0,
            // eslint-disable-next-line valid-jsdoc
            /**
             * @type {Highcharts.SeriesSankeyDataLabelsFormatterCallbackFunction}
             */
            formatter: function() {
              return;
            },
            inside: true
          },
          /**
           * @ignore-option
           *
           * @private
           */
          inactiveOtherPoints: true,
          /**
           * Set options on specific levels. Takes precedence over series options,
           * but not node and link options.
           *
           * @sample highcharts/demo/sunburst
           *         Sunburst chart
           *
           * @type      {Array<*>}
           * @since     7.1.0
           * @apioption plotOptions.sankey.levels
           */
          /**
           * Can set `borderColor` on all nodes which lay on the same level.
           *
           * @type      {Highcharts.ColorString}
           * @apioption plotOptions.sankey.levels.borderColor
           */
          /**
           * Can set `borderWidth` on all nodes which lay on the same level.
           *
           * @type      {number}
           * @apioption plotOptions.sankey.levels.borderWidth
           */
          /**
           * Can set `color` on all nodes which lay on the same level.
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @apioption plotOptions.sankey.levels.color
           */
          /**
           * Can set `colorByPoint` on all nodes which lay on the same level.
           *
           * @type      {boolean}
           * @default   true
           * @apioption plotOptions.sankey.levels.colorByPoint
           */
          /**
           * Can set `dataLabels` on all points which lay on the same level.
           *
           * @extends   plotOptions.sankey.dataLabels
           * @apioption plotOptions.sankey.levels.dataLabels
           */
          /**
           * Decides which level takes effect from the options set in the levels
           * object.
           *
           * @type      {number}
           * @apioption plotOptions.sankey.levels.level
           */
          /**
           * Can set `linkOpacity` on all points which lay on the same level.
           *
           * @type      {number}
           * @default   0.5
           * @apioption plotOptions.sankey.levels.linkOpacity
           */
          /**
           * Can set `states` on all nodes and points which lay on the same level.
           *
           * @extends   plotOptions.sankey.states
           * @apioption plotOptions.sankey.levels.states
           */
          /**
           * Opacity for the links between nodes in the sankey diagram.
           *
           * @private
           */
          linkOpacity: 0.5,
          /**
           * The minimal width for a line of a sankey. By default,
           * 0 values are not shown.
           *
           * @sample highcharts/plotoptions/sankey-minlinkwidth
           *         Sankey diagram with minimal link height
           *
           * @type      {number}
           * @since     7.1.3
           * @default   0
           * @apioption plotOptions.sankey.minLinkWidth
           *
           * @private
           */
          minLinkWidth: 0,
          /**
           * The pixel width of each node in a sankey diagram or dependency wheel,
           * or the height in case the chart is inverted.
           *
           * @private
           */
          nodeWidth: 20,
          /**
           * The padding between nodes in a sankey diagram or dependency wheel, in
           * pixels.
           *
           * If the number of nodes is so great that it is possible to lay them
           * out within the plot area with the given `nodePadding`, they will be
           * rendered with a smaller padding as a strategy to avoid overflow.
           *
           * @private
           */
          nodePadding: 10,
          showInLegend: false,
          states: {
            hover: {
              /**
               * Opacity for the links between nodes in the sankey diagram in
               * hover mode.
               */
              linkOpacity: 1
            },
            /**
             * The opposite state of a hover for a single point node/link.
             *
             * @declare Highcharts.SeriesStatesInactiveOptionsObject
             */
            inactive: {
              /**
               * Opacity for the links between nodes in the sankey diagram in
               * inactive mode.
               */
              linkOpacity: 0.1,
              /**
               * Opacity of inactive markers.
               *
               * @type      {number}
               * @apioption plotOptions.series.states.inactive.opacity
               */
              opacity: 0.1,
              /**
               * Animation when not hovering over the marker.
               *
               * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
               * @apioption plotOptions.series.states.inactive.animation
               */
              animation: {
                /** @internal */
                duration: 50
              }
            }
          },
          tooltip: {
            /**
             * A callback for defining the format for _nodes_ in the chart's
             * tooltip, as opposed to links.
             *
             * @type      {Highcharts.FormatterCallbackFunction<Highcharts.SankeyNodeObject>}
             * @since     6.0.2
             * @apioption plotOptions.sankey.tooltip.nodeFormatter
             */
            /**
             * Whether the tooltip should follow the pointer or stay fixed on
             * the item.
             */
            followPointer: true,
            headerFormat: '<span style="font-size: 10px">{series.name}</span><br/>',
            pointFormat: "{point.fromNode.name}  {point.toNode.name}: <b>{point.weight}</b><br/>",
            /**
             * The
             * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
             * specifying what to show for _nodes_ in tooltip of a diagram
             * series, as opposed to links.
             */
            nodeFormat: "{point.name}: <b>{point.sum}</b><br/>"
          }
        });
        return SankeySeries2;
      }(ColumnSeries$4)
    );
    extend$5(SankeySeries$1.prototype, {
      animate: Series$2.prototype.animate,
      // Create a single node that holds information on incoming and outgoing
      // links.
      createNode: NodesMixin.createNode,
      destroy: NodesMixin.destroy,
      forceDL: true,
      invertible: true,
      isCartesian: false,
      orderNodes: true,
      pointArrayMap: ["from", "to"],
      pointClass: SankeyPoint$1,
      searchPoint: H.noop,
      setData: NodesMixin.setData
    });
    SeriesRegistry$1.registerSeriesType("sankey", SankeySeries$1);
    var __extends$7 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Series$1 = SeriesRegistry$1.series, PiePoint = SeriesRegistry$1.seriesTypes.pie.prototype.pointClass;
    var defined$2 = Utilities.defined, isNumber$2 = Utilities.isNumber, merge$4 = Utilities.merge, objectEach = Utilities.objectEach, pick$5 = Utilities.pick;
    var TimelinePoint = (
      /** @class */
      function(_super) {
        __extends$7(TimelinePoint2, _super);
        function TimelinePoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.options = void 0;
          _this.series = void 0;
          return _this;
        }
        TimelinePoint2.prototype.alignConnector = function() {
          var point = this, series = point.series, connector = point.connector, dl = point.dataLabel, dlOptions = point.dataLabel.options = merge$4(series.options.dataLabels, point.options.dataLabels), chart = point.series.chart, bBox = connector.getBBox(), plotPos = {
            x: bBox.x + dl.translateX,
            y: bBox.y + dl.translateY
          }, isVisible;
          if (chart.inverted) {
            plotPos.y -= dl.options.connectorWidth / 2;
          } else {
            plotPos.x += dl.options.connectorWidth / 2;
          }
          isVisible = chart.isInsidePlot(plotPos.x, plotPos.y);
          connector[isVisible ? "animate" : "attr"]({
            d: point.getConnectorPath()
          });
          if (!series.chart.styledMode) {
            connector.attr({
              stroke: dlOptions.connectorColor || point.color,
              "stroke-width": dlOptions.connectorWidth,
              opacity: dl[defined$2(dl.newOpacity) ? "newOpacity" : "opacity"]
            });
          }
        };
        TimelinePoint2.prototype.drawConnector = function() {
          var point = this, series = point.series;
          if (!point.connector) {
            point.connector = series.chart.renderer.path(point.getConnectorPath()).attr({
              zIndex: -1
            }).add(point.dataLabel);
          }
          if (point.series.chart.isInsidePlot(
            // #10507
            point.dataLabel.x,
            point.dataLabel.y
          )) {
            point.alignConnector();
          }
        };
        TimelinePoint2.prototype.getConnectorPath = function() {
          var point = this, chart = point.series.chart, xAxisLen = point.series.xAxis.len, inverted = chart.inverted, direction = inverted ? "x2" : "y2", dl = point.dataLabel, targetDLPos = dl.targetPosition, coords = {
            x1: point.plotX,
            y1: point.plotY,
            x2: point.plotX,
            y2: isNumber$2(targetDLPos.y) ? targetDLPos.y : dl.y
          }, negativeDistance = (dl.alignAttr || dl)[direction[0]] < point.series.yAxis.len / 2, path;
          if (inverted) {
            coords = {
              x1: point.plotY,
              y1: xAxisLen - point.plotX,
              x2: targetDLPos.x || dl.x,
              y2: xAxisLen - point.plotX
            };
          }
          if (negativeDistance) {
            coords[direction] += dl[inverted ? "width" : "height"];
          }
          objectEach(coords, function(_coord, i) {
            coords[i] -= (dl.alignAttr || dl)[i[0]];
          });
          path = chart.renderer.crispLine([
            ["M", coords.x1, coords.y1],
            ["L", coords.x2, coords.y2]
          ], dl.options.connectorWidth);
          return path;
        };
        TimelinePoint2.prototype.init = function() {
          var point = _super.prototype.init.apply(this, arguments);
          point.name = pick$5(point.name, "Event");
          point.y = 1;
          return point;
        };
        TimelinePoint2.prototype.isValid = function() {
          return this.options.y !== null;
        };
        TimelinePoint2.prototype.setState = function() {
          var proceed = _super.prototype.setState;
          if (!this.isNull) {
            proceed.apply(this, arguments);
          }
        };
        TimelinePoint2.prototype.setVisible = function(visible, redraw) {
          var point = this, series = point.series;
          redraw = pick$5(redraw, series.options.ignoreHiddenPoint);
          PiePoint.prototype.setVisible.call(point, visible, false);
          series.processData();
          if (redraw) {
            series.chart.redraw();
          }
        };
        TimelinePoint2.prototype.applyOptions = function(options, x) {
          options = Point$2.prototype.optionsToObject.call(this, options);
          this.userDLOptions = merge$4(this.userDLOptions, options.dataLabels);
          return _super.prototype.applyOptions.call(this, options, x);
        };
        return TimelinePoint2;
      }(Series$1.prototype.pointClass)
    );
    var __extends$6 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var _a = SeriesRegistry$1.seriesTypes, ColumnSeries$3 = _a.column, LineSeries = _a.line;
    var addEvent$1 = Utilities.addEvent, arrayMax = Utilities.arrayMax, arrayMin = Utilities.arrayMin, defined$1 = Utilities.defined, extend$4 = Utilities.extend, merge$3 = Utilities.merge, pick$4 = Utilities.pick;
    var TimelineSeries = (
      /** @class */
      function(_super) {
        __extends$6(TimelineSeries2, _super);
        function TimelineSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          _this.userOptions = void 0;
          _this.visibilityMap = void 0;
          return _this;
        }
        TimelineSeries2.prototype.alignDataLabel = function(point, dataLabel, _options, _alignTo) {
          var series = this, isInverted = series.chart.inverted, visiblePoints = series.visibilityMap.filter(function(point2) {
            return point2;
          }), visiblePointsCount = series.visiblePointsCount, pointIndex = visiblePoints.indexOf(point), isFirstOrLast = !pointIndex || pointIndex === visiblePointsCount - 1, dataLabelsOptions = series.options.dataLabels, userDLOptions = point.userDLOptions || {}, multiplier = dataLabelsOptions.alternate ? isFirstOrLast ? 1.5 : 2 : 1, distance, availableSpace = Math.floor(series.xAxis.len / visiblePointsCount), pad2 = dataLabel.padding, targetDLWidth, styles;
          if (point.visible) {
            distance = Math.abs(userDLOptions.x || point.options.dataLabels.x);
            if (isInverted) {
              targetDLWidth = (distance - pad2) * 2 - point.itemHeight / 2;
              styles = {
                width: targetDLWidth + "px",
                // Apply ellipsis when data label height is exceeded.
                textOverflow: dataLabel.width / targetDLWidth * dataLabel.height / 2 > availableSpace * multiplier ? "ellipsis" : "none"
              };
            } else {
              styles = {
                width: (userDLOptions.width || dataLabelsOptions.width || availableSpace * multiplier - pad2 * 2) + "px"
              };
            }
            dataLabel.css(styles);
            if (!series.chart.styledMode) {
              dataLabel.shadow(dataLabelsOptions.shadow);
            }
          }
          _super.prototype.alignDataLabel.apply(series, arguments);
        };
        TimelineSeries2.prototype.bindAxes = function() {
          var series = this;
          _super.prototype.bindAxes.call(series);
          ["xAxis", "yAxis"].forEach(function(axis) {
            if (axis === "xAxis" && !series[axis].userOptions.type) {
              series[axis].categories = series[axis].hasNames = true;
            }
          });
        };
        TimelineSeries2.prototype.distributeDL = function() {
          var series = this, dataLabelsOptions = series.options.dataLabels;
          var visibilityIndex = 1;
          if (dataLabelsOptions) {
            var distance_1 = dataLabelsOptions.distance || 0;
            series.points.forEach(function(point) {
              var _a2;
              point.options.dataLabels = merge$3((_a2 = {}, _a2[series.chart.inverted ? "x" : "y"] = dataLabelsOptions.alternate && visibilityIndex % 2 ? -distance_1 : distance_1, _a2), point.userDLOptions);
              visibilityIndex++;
            });
          }
        };
        TimelineSeries2.prototype.generatePoints = function() {
          var series = this;
          _super.prototype.generatePoints.apply(series);
          series.points.forEach(function(point, i) {
            point.applyOptions({
              x: series.xData[i]
            }, series.xData[i]);
          });
        };
        TimelineSeries2.prototype.getVisibilityMap = function() {
          var series = this, map = (series.data.length ? series.data : series.userOptions.data).map(function(point) {
            return point && point.visible !== false && !point.isNull ? point : false;
          });
          return map;
        };
        TimelineSeries2.prototype.getXExtremes = function(xData) {
          var series = this, filteredData = xData.filter(function(x, i) {
            return series.points[i].isValid() && series.points[i].visible;
          });
          return {
            min: arrayMin(filteredData),
            max: arrayMax(filteredData)
          };
        };
        TimelineSeries2.prototype.init = function() {
          var series = this;
          _super.prototype.init.apply(series, arguments);
          series.eventsToUnbind.push(addEvent$1(series, "afterTranslate", function() {
            var lastPlotX, closestPointRangePx = Number.MAX_VALUE;
            series.points.forEach(function(point) {
              point.isInside = point.isInside && point.visible;
              if (point.visible && !point.isNull) {
                if (defined$1(lastPlotX)) {
                  closestPointRangePx = Math.min(closestPointRangePx, Math.abs(point.plotX - lastPlotX));
                }
                lastPlotX = point.plotX;
              }
            });
            series.closestPointRangePx = closestPointRangePx;
          }));
          series.eventsToUnbind.push(addEvent$1(series, "drawDataLabels", function() {
            series.distributeDL();
          }));
          series.eventsToUnbind.push(addEvent$1(series, "afterDrawDataLabels", function() {
            var dataLabel;
            series.points.forEach(function(point) {
              dataLabel = point.dataLabel;
              if (dataLabel) {
                dataLabel.animate = function(params) {
                  if (this.targetPosition) {
                    this.targetPosition = params;
                  }
                  return SVGElement.prototype.animate.apply(this, arguments);
                };
                if (!dataLabel.targetPosition) {
                  dataLabel.targetPosition = {};
                }
                return point.drawConnector();
              }
            });
          }));
          series.eventsToUnbind.push(addEvent$1(series.chart, "afterHideOverlappingLabel", function() {
            series.points.forEach(function(p) {
              if (p.connector && p.dataLabel && p.dataLabel.oldOpacity !== p.dataLabel.newOpacity) {
                p.alignConnector();
              }
            });
          }));
        };
        TimelineSeries2.prototype.markerAttribs = function(point, state) {
          var series = this, seriesMarkerOptions = series.options.marker, seriesStateOptions, pointMarkerOptions = point.marker || {}, symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol, pointStateOptions, width = pick$4(pointMarkerOptions.width, seriesMarkerOptions.width, series.closestPointRangePx), height = pick$4(pointMarkerOptions.height, seriesMarkerOptions.height), radius = 0, attribs;
          if (series.xAxis.dateTime) {
            return _super.prototype.markerAttribs.call(this, point, state);
          }
          if (state) {
            seriesStateOptions = seriesMarkerOptions.states[state] || {};
            pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
            radius = pick$4(pointStateOptions.radius, seriesStateOptions.radius, radius + (seriesStateOptions.radiusPlus || 0));
          }
          point.hasImage = symbol && symbol.indexOf("url") === 0;
          attribs = {
            x: Math.floor(point.plotX) - width / 2 - radius / 2,
            y: point.plotY - height / 2 - radius / 2,
            width: width + radius,
            height: height + radius
          };
          return attribs;
        };
        TimelineSeries2.prototype.processData = function() {
          var series = this, visiblePoints = 0, i;
          series.visibilityMap = series.getVisibilityMap();
          series.visibilityMap.forEach(function(point) {
            if (point) {
              visiblePoints++;
            }
          });
          series.visiblePointsCount = visiblePoints;
          for (i = 0; i < series.xData.length; i++) {
            series.yData[i] = 1;
          }
          _super.prototype.processData.call(this, arguments);
          return;
        };
        TimelineSeries2.defaultOptions = merge$3(LineSeries.defaultOptions, {
          colorByPoint: true,
          stickyTracking: false,
          ignoreHiddenPoint: true,
          /**
           * @ignore
           * @private
           */
          legendType: "point",
          lineWidth: 4,
          tooltip: {
            headerFormat: '<span style="color:{point.color}"></span> <span style="font-size: 10px"> {point.key}</span><br/>',
            pointFormat: "{point.description}"
          },
          states: {
            hover: {
              lineWidthPlus: 0
            }
          },
          /**
           * @declare Highcharts.TimelineDataLabelsOptionsObject
           *
           * @private
           */
          dataLabels: {
            enabled: true,
            allowOverlap: true,
            /**
             * Whether to position data labels alternately. For example, if
             * [distance](#plotOptions.timeline.dataLabels.distance)
             * is set equal to `100`, then data labels will be positioned
             * alternately (on both sides of the point) at a distance of 100px.
             *
             * @sample {highcharts} highcharts/series-timeline/alternate-disabled
             *         Alternate disabled
             */
            alternate: true,
            backgroundColor: palette.backgroundColor,
            borderWidth: 1,
            borderColor: palette.neutralColor40,
            borderRadius: 3,
            color: palette.neutralColor80,
            /**
             * The color of the line connecting the data label to the point.
             * The default color is the same as the point's color.
             *
             * In styled mode, the connector stroke is given in the
             * `.highcharts-data-label-connector` class.
             *
             * @sample {highcharts} highcharts/series-timeline/connector-styles
             *         Custom connector width and color
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @apioption plotOptions.timeline.dataLabels.connectorColor
             */
            /**
             * The width of the line connecting the data label to the point.
             *
             * In styled mode, the connector stroke width is given in the
             * `.highcharts-data-label-connector` class.
             *
             * @sample {highcharts} highcharts/series-timeline/connector-styles
             *         Custom connector width and color
             */
            connectorWidth: 1,
            /**
             * A pixel value defining the distance between the data label and
             * the point. Negative numbers puts the label on top of the point.
             */
            distance: 100,
            // eslint-disable-next-line valid-jsdoc
            /**
             * @type    {Highcharts.TimelineDataLabelsFormatterCallbackFunction}
             * @default function () {
             *   let format;
             *
             *   if (!this.series.chart.styledMode) {
             *       format = '<span style="color:' + this.point.color +
             *           '"> </span>';
             *   } else {
             *       format = '<span> </span>';
             *   }
             *   format += '<span>' + (this.key || '') + '</span><br/>' +
             *       (this.point.label || '');
             *   return format;
             * }
             */
            formatter: function() {
              var format2;
              if (!this.series.chart.styledMode) {
                format2 = '<span style="color:' + this.point.color + '"> </span>';
              } else {
                format2 = "<span> </span>";
              }
              format2 += '<span class="highcharts-strong">' + (this.key || "") + "</span><br/>" + (this.point.label || "");
              return format2;
            },
            style: {
              /** @internal */
              textOutline: "none",
              /** @internal */
              fontWeight: "normal",
              /** @internal */
              fontSize: "12px"
            },
            /**
             * Shadow options for the data label.
             *
             * @type {boolean|Highcharts.CSSObject}
             */
            shadow: false,
            /**
             * @type      {number}
             * @apioption plotOptions.timeline.dataLabels.width
             */
            verticalAlign: "middle"
          },
          marker: {
            enabledThreshold: 0,
            symbol: "square",
            radius: 6,
            lineWidth: 2,
            height: 15
          },
          showInLegend: false,
          colorKey: "x"
        });
        return TimelineSeries2;
      }(LineSeries)
    );
    extend$4(TimelineSeries.prototype, {
      // Use a simple symbol from LegendSymbolMixin
      drawLegendSymbol: LegendSymbol$1.drawRectangle,
      // Use a group of trackers from TrackerMixin
      drawTracker: ColumnSeries$3.prototype.drawTracker,
      pointClass: TimelinePoint,
      trackerGroups: ["markerGroup", "dataLabelsGroup"]
    });
    SeriesRegistry$1.registerSeriesType("timeline", TimelineSeries);
    var __extends$5 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var SankeyPoint = SeriesRegistry$1.seriesTypes.sankey.prototype.pointClass;
    var OrganizationPoint = (
      /** @class */
      function(_super) {
        __extends$5(OrganizationPoint2, _super);
        function OrganizationPoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.fromNode = void 0;
          _this.linksFrom = void 0;
          _this.linksTo = void 0;
          _this.options = void 0;
          _this.series = void 0;
          _this.toNode = void 0;
          return _this;
        }
        OrganizationPoint2.prototype.getSum = function() {
          return 1;
        };
        return OrganizationPoint2;
      }(SankeyPoint)
    );
    var __extends$4 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var SankeySeries = SeriesRegistry$1.seriesTypes.sankey;
    var css = Utilities.css, extend$3 = Utilities.extend, merge$2 = Utilities.merge, pick$3 = Utilities.pick, wrap = Utilities.wrap;
    var OrganizationSeries = (
      /** @class */
      function(_super) {
        __extends$4(OrganizationSeries2, _super);
        function OrganizationSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        OrganizationSeries2.curvedPath = function(path, r) {
          var d = [];
          for (var i = 0; i < path.length; i++) {
            var x = path[i][1];
            var y = path[i][2];
            if (typeof x === "number" && typeof y === "number") {
              if (i === 0) {
                d.push(["M", x, y]);
              } else if (i === path.length - 1) {
                d.push(["L", x, y]);
              } else if (r) {
                var prevSeg = path[i - 1];
                var nextSeg = path[i + 1];
                if (prevSeg && nextSeg) {
                  var x1 = prevSeg[1], y1 = prevSeg[2], x2 = nextSeg[1], y2 = nextSeg[2];
                  if (typeof x1 === "number" && typeof x2 === "number" && typeof y1 === "number" && typeof y2 === "number" && x1 !== x2 && y1 !== y2) {
                    var directionX = x1 < x2 ? 1 : -1, directionY = y1 < y2 ? 1 : -1;
                    d.push([
                      "L",
                      x - directionX * Math.min(Math.abs(x - x1), r),
                      y - directionY * Math.min(Math.abs(y - y1), r)
                    ], [
                      "C",
                      x,
                      y,
                      x,
                      y,
                      x + directionX * Math.min(Math.abs(x - x2), r),
                      y + directionY * Math.min(Math.abs(y - y2), r)
                    ]);
                  }
                }
              } else {
                d.push(["L", x, y]);
              }
            }
          }
          return d;
        };
        OrganizationSeries2.prototype.alignDataLabel = function(point, dataLabel, options) {
          if (options.useHTML) {
            var width_1 = point.shapeArgs.width, height_1 = point.shapeArgs.height, padjust = this.options.borderWidth + 2 * this.options.dataLabels.padding;
            if (this.chart.inverted) {
              width_1 = height_1;
              height_1 = point.shapeArgs.width;
            }
            height_1 -= padjust;
            width_1 -= padjust;
            var text = dataLabel.text;
            if (text) {
              css(text.element.parentNode, {
                width: width_1 + "px",
                height: height_1 + "px"
              });
              css(text.element, {
                left: 0,
                top: 0,
                width: "100%",
                height: "100%",
                overflow: "hidden"
              });
            }
            dataLabel.getBBox = function() {
              return {
                width: width_1,
                height: height_1
              };
            };
            dataLabel.width = width_1;
            dataLabel.height = height_1;
          }
          _super.prototype.alignDataLabel.apply(this, arguments);
        };
        OrganizationSeries2.prototype.createNode = function(id) {
          var node = _super.prototype.createNode.call(this, id);
          node.getSum = function() {
            return 1;
          };
          return node;
        };
        OrganizationSeries2.prototype.createNodeColumn = function() {
          var column = _super.prototype.createNodeColumn.call(this);
          wrap(column, "offset", function(proceed, node, factor) {
            var offset2 = proceed.call(this, node, factor);
            if (node.hangsFrom) {
              return {
                absoluteTop: node.hangsFrom.nodeY
              };
            }
            return offset2;
          });
          return column;
        };
        OrganizationSeries2.prototype.pointAttribs = function(point, state) {
          var series = this, attribs = SankeySeries.prototype.pointAttribs.call(series, point, state), level = point.isNode ? point.level : point.fromNode.level, levelOptions = series.mapOptionsToLevel[level || 0] || {}, options = point.options, stateOptions = levelOptions.states && levelOptions.states[state] || {}, values = ["borderRadius", "linkColor", "linkLineWidth"].reduce(function(obj, key) {
            obj[key] = pick$3(stateOptions[key], options[key], levelOptions[key], series.options[key]);
            return obj;
          }, {});
          if (!point.isNode) {
            attribs.stroke = values.linkColor;
            attribs["stroke-width"] = values.linkLineWidth;
            delete attribs.fill;
          } else {
            if (values.borderRadius) {
              attribs.r = values.borderRadius;
            }
          }
          return attribs;
        };
        OrganizationSeries2.prototype.translateLink = function(point) {
          var fromNode = point.fromNode, toNode = point.toNode, crisp = Math.round(this.options.linkLineWidth) % 2 / 2, x1 = Math.floor(fromNode.shapeArgs.x + fromNode.shapeArgs.width) + crisp, y1 = Math.floor(fromNode.shapeArgs.y + fromNode.shapeArgs.height / 2) + crisp, x2 = Math.floor(toNode.shapeArgs.x) + crisp, y2 = Math.floor(toNode.shapeArgs.y + toNode.shapeArgs.height / 2) + crisp, xMiddle, hangingIndent = this.options.hangingIndent, toOffset = toNode.options.offset, percentOffset = /%$/.test(toOffset) && parseInt(toOffset, 10), inverted = this.chart.inverted;
          if (inverted) {
            x1 -= fromNode.shapeArgs.width;
            x2 += toNode.shapeArgs.width;
          }
          xMiddle = Math.floor(x2 + (inverted ? 1 : -1) * (this.colDistance - this.nodeWidth) / 2) + crisp;
          if (percentOffset && (percentOffset >= 50 || percentOffset <= -50)) {
            xMiddle = x2 = Math.floor(x2 + (inverted ? -0.5 : 0.5) * toNode.shapeArgs.width) + crisp;
            y2 = toNode.shapeArgs.y;
            if (percentOffset > 0) {
              y2 += toNode.shapeArgs.height;
            }
          }
          if (toNode.hangsFrom === fromNode) {
            if (this.chart.inverted) {
              y1 = Math.floor(fromNode.shapeArgs.y + fromNode.shapeArgs.height - hangingIndent / 2) + crisp;
              y2 = toNode.shapeArgs.y + toNode.shapeArgs.height;
            } else {
              y1 = Math.floor(fromNode.shapeArgs.y + hangingIndent / 2) + crisp;
            }
            xMiddle = x2 = Math.floor(toNode.shapeArgs.x + toNode.shapeArgs.width / 2) + crisp;
          }
          point.plotY = 1;
          point.shapeType = "path";
          point.shapeArgs = {
            d: OrganizationSeries2.curvedPath([
              ["M", x1, y1],
              ["L", xMiddle, y1],
              ["L", xMiddle, y2],
              ["L", x2, y2]
            ], this.options.linkRadius)
          };
        };
        OrganizationSeries2.prototype.translateNode = function(node, column) {
          SankeySeries.prototype.translateNode.call(this, node, column);
          if (node.hangsFrom) {
            node.shapeArgs.height -= this.options.hangingIndent;
            if (!this.chart.inverted) {
              node.shapeArgs.y += this.options.hangingIndent;
            }
          }
          node.nodeHeight = this.chart.inverted ? node.shapeArgs.width : node.shapeArgs.height;
        };
        OrganizationSeries2.defaultOptions = merge$2(SankeySeries.defaultOptions, {
          /**
           * The border color of the node cards.
           *
           * @type {Highcharts.ColorString}
           * @private
           */
          borderColor: palette.neutralColor60,
          /**
           * The border radius of the node cards.
           *
           * @private
           */
          borderRadius: 3,
          /**
           * Radius for the rounded corners of the links between nodes.
           *
           * @sample   highcharts/series-organization/link-options
           *           Square links
           *
           * @private
           */
          linkRadius: 10,
          borderWidth: 1,
          /**
           * @declare Highcharts.SeriesOrganizationDataLabelsOptionsObject
           *
           * @private
           */
          dataLabels: {
            /* eslint-disable valid-jsdoc */
            /**
             * A callback for defining the format for _nodes_ in the
             * organization chart. The `nodeFormat` option takes precedence
             * over `nodeFormatter`.
             *
             * In an organization chart, the `nodeFormatter` is a quite complex
             * function of the available options, striving for a good default
             * layout of cards with or without images. In organization chart,
             * the data labels come with `useHTML` set to true, meaning they
             * will be rendered as true HTML above the SVG.
             *
             * @sample highcharts/series-organization/datalabels-nodeformatter
             *         Modify the default label format output
             *
             * @type  {Highcharts.SeriesSankeyDataLabelsFormatterCallbackFunction}
             * @since 6.0.2
             */
            nodeFormatter: function() {
              var outerStyle = {
                width: "100%",
                height: "100%",
                display: "flex",
                "flex-direction": "row",
                "align-items": "center",
                "justify-content": "center"
              }, imageStyle = {
                "max-height": "100%",
                "border-radius": "50%"
              }, innerStyle = {
                width: "100%",
                padding: 0,
                "text-align": "center",
                "white-space": "normal"
              }, nameStyle = {
                margin: 0
              }, titleStyle = {
                margin: 0
              }, descriptionStyle = {
                opacity: 0.75,
                margin: "5px"
              };
              function styleAttr(style) {
                return Object.keys(style).reduce(function(str, key) {
                  return str + key + ":" + style[key] + ";";
                }, 'style="') + '"';
              }
              if (this.point.image) {
                imageStyle["max-width"] = "30%";
                innerStyle.width = "70%";
              }
              if (this.series.chart.renderer.forExport) {
                outerStyle.display = "block";
                innerStyle.position = "absolute";
                innerStyle.left = this.point.image ? "30%" : 0;
                innerStyle.top = 0;
              }
              var html2 = "<div " + styleAttr(outerStyle) + ">";
              if (this.point.image) {
                html2 += '<img src="' + this.point.image + '" ' + styleAttr(imageStyle) + ">";
              }
              html2 += "<div " + styleAttr(innerStyle) + ">";
              if (this.point.name) {
                html2 += "<h4 " + styleAttr(nameStyle) + ">" + this.point.name + "</h4>";
              }
              if (this.point.title) {
                html2 += "<p " + styleAttr(titleStyle) + ">" + (this.point.title || "") + "</p>";
              }
              if (this.point.description) {
                html2 += "<p " + styleAttr(descriptionStyle) + ">" + this.point.description + "</p>";
              }
              html2 += "</div></div>";
              return html2;
            },
            /* eslint-enable valid-jsdoc */
            style: {
              /** @internal */
              fontWeight: "normal",
              /** @internal */
              fontSize: "13px"
            },
            useHTML: true
          },
          /**
           * The indentation in pixels of hanging nodes, nodes which parent has
           * [layout](#series.organization.nodes.layout) set to `hanging`.
           *
           * @private
           */
          hangingIndent: 20,
          /**
           * The color of the links between nodes.
           *
           * @type {Highcharts.ColorString}
           * @private
           */
          linkColor: palette.neutralColor60,
          /**
           * The line width of the links connecting nodes, in pixels.
           *
           * @sample   highcharts/series-organization/link-options
           *           Square links
           *
           * @private
           */
          linkLineWidth: 1,
          /**
           * In a horizontal chart, the width of the nodes in pixels. Node that
           * most organization charts are vertical, so the name of this option
           * is counterintuitive.
           *
           * @private
           */
          nodeWidth: 50,
          tooltip: {
            nodeFormat: "{point.name}<br>{point.title}<br>{point.description}"
          }
        });
        return OrganizationSeries2;
      }(SankeySeries)
    );
    extend$3(OrganizationSeries.prototype, {
      pointClass: OrganizationPoint
    });
    SeriesRegistry$1.registerSeriesType("organization", OrganizationSeries);
    var __extends$3 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var ColumnSeries$2 = SeriesRegistry$1.seriesTypes.column;
    var extend$2 = Utilities.extend;
    var XRangePoint = (
      /** @class */
      function(_super) {
        __extends$3(XRangePoint2, _super);
        function XRangePoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.options = void 0;
          _this.series = void 0;
          return _this;
        }
        XRangePoint2.getColorByCategory = function(series, point) {
          var colors = series.options.colors || series.chart.options.colors, colorCount = colors ? colors.length : series.chart.options.chart.colorCount, colorIndex = point.y % colorCount, color2 = colors && colors[colorIndex];
          return {
            colorIndex,
            color: color2
          };
        };
        XRangePoint2.prototype.resolveColor = function() {
          var series = this.series, colorByPoint;
          if (series.options.colorByPoint && !this.options.color) {
            colorByPoint = XRangePoint2.getColorByCategory(series, this);
            if (!series.chart.styledMode) {
              this.color = colorByPoint.color;
            }
            if (!this.options.colorIndex) {
              this.colorIndex = colorByPoint.colorIndex;
            }
          } else if (!this.color) {
            this.color = series.color;
          }
        };
        XRangePoint2.prototype.init = function() {
          Point$2.prototype.init.apply(this, arguments);
          if (!this.y) {
            this.y = 0;
          }
          return this;
        };
        XRangePoint2.prototype.setState = function() {
          Point$2.prototype.setState.apply(this, arguments);
          this.series.drawPoint(this, this.series.getAnimationVerb());
        };
        XRangePoint2.prototype.getLabelConfig = function() {
          var point = this, cfg = Point$2.prototype.getLabelConfig.call(point), yCats = point.series.yAxis.categories;
          cfg.x2 = point.x2;
          cfg.yCategory = point.yCategory = yCats && yCats[point.y];
          return cfg;
        };
        XRangePoint2.prototype.isValid = function() {
          return typeof this.x === "number" && typeof this.x2 === "number";
        };
        return XRangePoint2;
      }(ColumnSeries$2.prototype.pointClass)
    );
    extend$2(XRangePoint.prototype, {
      tooltipDateKeys: ["x", "x2"]
    });
    var addEvent = Utilities.addEvent, pick$2 = Utilities.pick;
    addEvent(Axis, "afterGetSeriesExtremes", function() {
      var axis = this, axisSeries = axis.series, dataMax, modMax;
      if (axis.isXAxis) {
        dataMax = pick$2(axis.dataMax, -Number.MAX_VALUE);
        axisSeries.forEach(function(series) {
          if (series.x2Data) {
            series.x2Data.forEach(function(val) {
              if (val > dataMax) {
                dataMax = val;
                modMax = true;
              }
            });
          }
        });
        if (modMax) {
          axis.dataMax = dataMax;
        }
      }
    });
    var __extends$2 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var color = Color.parse;
    var Series = SeriesRegistry$1.series, ColumnSeries$1 = SeriesRegistry$1.seriesTypes.column;
    var columnProto = ColumnSeries$1.prototype;
    var clamp = Utilities.clamp, correctFloat = Utilities.correctFloat, defined = Utilities.defined, extend$1 = Utilities.extend, find = Utilities.find, isNumber$1 = Utilities.isNumber, isObject = Utilities.isObject, merge$1 = Utilities.merge, pick$1 = Utilities.pick;
    var XRangeSeries = (
      /** @class */
      function(_super) {
        __extends$2(XRangeSeries2, _super);
        function XRangeSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          return _this;
        }
        XRangeSeries2.prototype.init = function() {
          ColumnSeries$1.prototype.init.apply(this, arguments);
          this.options.stacking = void 0;
        };
        XRangeSeries2.prototype.getColumnMetrics = function() {
          var metrics, chart = this.chart;
          function swapAxes() {
            chart.series.forEach(function(s) {
              var xAxis = s.xAxis;
              s.xAxis = s.yAxis;
              s.yAxis = xAxis;
            });
          }
          swapAxes();
          metrics = columnProto.getColumnMetrics.call(this);
          swapAxes();
          return metrics;
        };
        XRangeSeries2.prototype.cropData = function(xData, yData, min, max) {
          var cropData = Series.prototype.cropData, crop = cropData.call(this, this.x2Data, yData, min, max);
          crop.xData = xData.slice(crop.start, crop.end);
          return crop;
        };
        XRangeSeries2.prototype.findPointIndex = function(options) {
          var _a2 = this, cropped = _a2.cropped, cropStart = _a2.cropStart, points = _a2.points;
          var id = options.id;
          var pointIndex;
          if (id) {
            var point = find(points, function(point2) {
              return point2.id === id;
            });
            pointIndex = point ? point.index : void 0;
          }
          if (typeof pointIndex === "undefined") {
            var point = find(points, function(point2) {
              return point2.x === options.x && point2.x2 === options.x2 && !point2.touched;
            });
            pointIndex = point ? point.index : void 0;
          }
          if (cropped && isNumber$1(pointIndex) && isNumber$1(cropStart) && pointIndex >= cropStart) {
            pointIndex -= cropStart;
          }
          return pointIndex;
        };
        XRangeSeries2.prototype.translatePoint = function(point) {
          var series = this, xAxis = series.xAxis, yAxis = series.yAxis, metrics = series.columnMetrics, options = series.options, minPointLength = options.minPointLength || 0, oldColWidth = (point.shapeArgs && point.shapeArgs.width || 0) / 2, seriesXOffset = series.pointXOffset = metrics.offset, plotX = point.plotX, posX = pick$1(point.x2, point.x + (point.len || 0)), plotX2 = xAxis.translate(posX, 0, 0, 0, 1), length = Math.abs(plotX2 - plotX), widthDifference, partialFill, inverted = this.chart.inverted, borderWidth = pick$1(options.borderWidth, 1), crisper = borderWidth % 2 / 2, yOffset = metrics.offset, pointHeight = Math.round(metrics.width), dlLeft, dlRight, dlWidth, clipRectWidth, tooltipYOffset;
          if (minPointLength) {
            widthDifference = minPointLength - length;
            if (widthDifference < 0) {
              widthDifference = 0;
            }
            plotX -= widthDifference / 2;
            plotX2 += widthDifference / 2;
          }
          plotX = Math.max(plotX, -10);
          plotX2 = clamp(plotX2, -10, xAxis.len + 10);
          if (defined(point.options.pointWidth)) {
            yOffset -= (Math.ceil(point.options.pointWidth) - pointHeight) / 2;
            pointHeight = Math.ceil(point.options.pointWidth);
          }
          if (options.pointPlacement && isNumber$1(point.plotY) && yAxis.categories) {
            point.plotY = yAxis.translate(point.y, 0, 1, 0, 1, options.pointPlacement);
          }
          var x = Math.floor(Math.min(plotX, plotX2)) + crisper;
          var x2 = Math.floor(Math.max(plotX, plotX2)) + crisper;
          var shapeArgs = {
            x,
            y: Math.floor(point.plotY + yOffset) + crisper,
            width: x2 - x,
            height: pointHeight,
            r: series.options.borderRadius
          };
          point.shapeArgs = shapeArgs;
          if (!inverted) {
            point.tooltipPos[0] -= oldColWidth + seriesXOffset - shapeArgs.width / 2;
          } else {
            point.tooltipPos[1] += seriesXOffset + oldColWidth;
          }
          dlLeft = shapeArgs.x;
          dlRight = dlLeft + shapeArgs.width;
          if (dlLeft < 0 || dlRight > xAxis.len) {
            dlLeft = clamp(dlLeft, 0, xAxis.len);
            dlRight = clamp(dlRight, 0, xAxis.len);
            dlWidth = dlRight - dlLeft;
            point.dlBox = merge$1(shapeArgs, {
              x: dlLeft,
              width: dlRight - dlLeft,
              centerX: dlWidth ? dlWidth / 2 : null
            });
          } else {
            point.dlBox = null;
          }
          var tooltipPos = point.tooltipPos;
          var xIndex = !inverted ? 0 : 1;
          var yIndex = !inverted ? 1 : 0;
          tooltipYOffset = series.columnMetrics ? series.columnMetrics.offset : -metrics.width / 2;
          if (!inverted) {
            tooltipPos[xIndex] += (xAxis.reversed ? -1 : 0) * shapeArgs.width;
          } else {
            tooltipPos[xIndex] += shapeArgs.width / 2;
          }
          tooltipPos[yIndex] = clamp(tooltipPos[yIndex] + (inverted ? -1 : 1) * tooltipYOffset, 0, yAxis.len - 1);
          partialFill = point.partialFill;
          if (partialFill) {
            if (isObject(partialFill)) {
              partialFill = partialFill.amount;
            }
            if (!isNumber$1(partialFill)) {
              partialFill = 0;
            }
            point.partShapeArgs = merge$1(shapeArgs, {
              r: series.options.borderRadius
            });
            clipRectWidth = Math.max(Math.round(length * partialFill + point.plotX - plotX), 0);
            point.clipRectArgs = {
              x: xAxis.reversed ? (
                // #10717
                shapeArgs.x + length - clipRectWidth
              ) : shapeArgs.x,
              y: shapeArgs.y,
              width: clipRectWidth,
              height: shapeArgs.height
            };
          }
        };
        XRangeSeries2.prototype.translate = function() {
          columnProto.translate.apply(this, arguments);
          this.points.forEach(function(point) {
            this.translatePoint(point);
          }, this);
        };
        XRangeSeries2.prototype.drawPoint = function(point, verb) {
          var series = this, seriesOpts = series.options, renderer = series.chart.renderer, graphic = point.graphic, type = point.shapeType, shapeArgs = point.shapeArgs, partShapeArgs = point.partShapeArgs, clipRectArgs = point.clipRectArgs, pfOptions = point.partialFill, cutOff = seriesOpts.stacking && !seriesOpts.borderRadius, pointState = point.state, stateOpts = seriesOpts.states[pointState || "normal"] || {}, pointStateVerb = typeof pointState === "undefined" ? "attr" : verb, pointAttr = series.pointAttribs(point, pointState), animation = pick$1(series.chart.options.chart.animation, stateOpts.animation), fill;
          if (!point.isNull && point.visible !== false) {
            if (graphic) {
              graphic.rect[verb](shapeArgs);
            } else {
              point.graphic = graphic = renderer.g("point").addClass(point.getClassName()).add(point.group || series.group);
              graphic.rect = renderer[type](merge$1(shapeArgs)).addClass(point.getClassName()).addClass("highcharts-partfill-original").add(graphic);
            }
            if (partShapeArgs) {
              if (graphic.partRect) {
                graphic.partRect[verb](merge$1(partShapeArgs));
                graphic.partialClipRect[verb](merge$1(clipRectArgs));
              } else {
                graphic.partialClipRect = renderer.clipRect(clipRectArgs.x, clipRectArgs.y, clipRectArgs.width, clipRectArgs.height);
                graphic.partRect = renderer[type](partShapeArgs).addClass("highcharts-partfill-overlay").add(graphic).clip(graphic.partialClipRect);
              }
            }
            if (!series.chart.styledMode) {
              graphic.rect[verb](pointAttr, animation).shadow(seriesOpts.shadow, null, cutOff);
              if (partShapeArgs) {
                if (!isObject(pfOptions)) {
                  pfOptions = {};
                }
                if (isObject(seriesOpts.partialFill)) {
                  pfOptions = merge$1(seriesOpts.partialFill, pfOptions);
                }
                fill = pfOptions.fill || color(pointAttr.fill).brighten(-0.3).get() || color(point.color || series.color).brighten(-0.3).get();
                pointAttr.fill = fill;
                graphic.partRect[pointStateVerb](pointAttr, animation).shadow(seriesOpts.shadow, null, cutOff);
              }
            }
          } else if (graphic) {
            point.graphic = graphic.destroy();
          }
        };
        XRangeSeries2.prototype.drawPoints = function() {
          var series = this, verb = series.getAnimationVerb();
          series.points.forEach(function(point) {
            series.drawPoint(point, verb);
          });
        };
        XRangeSeries2.prototype.getAnimationVerb = function() {
          return this.chart.pointCount < (this.options.animationLimit || 250) ? "animate" : "attr";
        };
        XRangeSeries2.prototype.isPointInside = function(point) {
          var shapeArgs = point.shapeArgs, plotX = point.plotX, plotY = point.plotY;
          if (!shapeArgs) {
            return _super.prototype.isPointInside.apply(this, arguments);
          }
          var isInside = typeof plotX !== "undefined" && typeof plotY !== "undefined" && plotY >= 0 && plotY <= this.yAxis.len && (shapeArgs.x || 0) + (shapeArgs.width || 0) >= 0 && plotX <= this.xAxis.len;
          return isInside;
        };
        XRangeSeries2.defaultOptions = merge$1(ColumnSeries$1.defaultOptions, {
          /**
           * A partial fill for each point, typically used to visualize how much
           * of a task is performed. The partial fill object can be set either on
           * series or point level.
           *
           * @sample {highcharts} highcharts/demo/x-range
           *         X-range with partial fill
           *
           * @product   highcharts highstock gantt
           * @apioption plotOptions.xrange.partialFill
           */
          /**
           * The fill color to be used for partial fills. Defaults to a darker
           * shade of the point color.
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @product   highcharts highstock gantt
           * @apioption plotOptions.xrange.partialFill.fill
           */
          /**
           * A partial fill for each point, typically used to visualize how much
           * of a task is performed. See [completed](series.gantt.data.completed).
           *
           * @sample gantt/demo/progress-indicator
           *         Gantt with progress indicator
           *
           * @product   gantt
           * @apioption plotOptions.gantt.partialFill
           */
          /**
           * In an X-range series, this option makes all points of the same Y-axis
           * category the same color.
           */
          colorByPoint: true,
          dataLabels: {
            formatter: function() {
              var point = this.point, amount = point.partialFill;
              if (isObject(amount)) {
                amount = amount.amount;
              }
              if (isNumber$1(amount) && amount > 0) {
                return correctFloat(amount * 100) + "%";
              }
            },
            inside: true,
            verticalAlign: "middle"
          },
          tooltip: {
            headerFormat: '<span style="font-size: 10px">{point.x} - {point.x2}</span><br/>',
            pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.yCategory}</b><br/>'
          },
          borderRadius: 3,
          pointRange: 0
        });
        return XRangeSeries2;
      }(ColumnSeries$1)
    );
    extend$1(XRangeSeries.prototype, {
      type: "xrange",
      parallelArrays: ["x", "x2", "y"],
      requireSorting: false,
      animate: Series.prototype.animate,
      cropShoulder: 1,
      getExtremesFromAll: true,
      autoIncrement: H.noop,
      buildKDTree: H.noop,
      pointClass: XRangePoint
    });
    SeriesRegistry$1.registerSeriesType("xrange", XRangeSeries);
    var __extends$1 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var BulletPoint = (
      /** @class */
      function(_super) {
        __extends$1(BulletPoint2, _super);
        function BulletPoint2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.options = void 0;
          _this.series = void 0;
          return _this;
        }
        BulletPoint2.prototype.destroy = function() {
          if (this.targetGraphic) {
            this.targetGraphic = this.targetGraphic.destroy();
          }
          _super.prototype.destroy.apply(this, arguments);
          return;
        };
        return BulletPoint2;
      }(ColumnSeries$h.prototype.pointClass)
    );
    var __extends = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var ColumnSeries = SeriesRegistry$1.seriesTypes.column;
    var extend = Utilities.extend, isNumber = Utilities.isNumber, merge = Utilities.merge, pick = Utilities.pick, relativeLength = Utilities.relativeLength;
    var BulletSeries = (
      /** @class */
      function(_super) {
        __extends(BulletSeries2, _super);
        function BulletSeries2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.data = void 0;
          _this.options = void 0;
          _this.points = void 0;
          _this.targetData = void 0;
          return _this;
        }
        BulletSeries2.prototype.drawPoints = function() {
          var series = this, chart = series.chart, options = series.options, animationLimit = options.animationLimit || 250;
          _super.prototype.drawPoints.apply(this, arguments);
          series.points.forEach(function(point) {
            var pointOptions = point.options, targetVal = point.target, pointVal = point.y;
            var targetShapeArgs, targetGraphic = point.targetGraphic, width, height, targetOptions, y;
            if (isNumber(targetVal) && targetVal !== null) {
              targetOptions = merge(options.targetOptions, pointOptions.targetOptions);
              height = targetOptions.height;
              var shapeArgs = point.shapeArgs;
              if (point.dlBox && shapeArgs && !isNumber(shapeArgs.width)) {
                shapeArgs = point.dlBox;
              }
              width = relativeLength(targetOptions.width, shapeArgs.width);
              y = series.yAxis.translate(targetVal, false, true, false, true) - targetOptions.height / 2 - 0.5;
              targetShapeArgs = series.crispCol.apply({
                // Use fake series object to set borderWidth of target
                chart,
                borderWidth: targetOptions.borderWidth,
                options: {
                  crisp: options.crisp
                }
              }, [
                shapeArgs.x + shapeArgs.width / 2 - width / 2,
                y,
                width,
                height
              ]);
              if (targetGraphic) {
                targetGraphic[chart.pointCount < animationLimit ? "animate" : "attr"](targetShapeArgs);
                if (isNumber(pointVal) && pointVal !== null) {
                  targetGraphic.element.point = point;
                } else {
                  targetGraphic.element.point = void 0;
                }
              } else {
                point.targetGraphic = targetGraphic = chart.renderer.rect().attr(targetShapeArgs).add(series.group);
              }
              if (!chart.styledMode) {
                targetGraphic.attr({
                  fill: pick(targetOptions.color, pointOptions.color, series.zones.length && (point.getZone.call({
                    series,
                    x: point.x,
                    y: targetVal,
                    options: {}
                  }).color || series.color) || void 0, point.color, series.color),
                  stroke: pick(targetOptions.borderColor, point.borderColor, series.options.borderColor),
                  "stroke-width": targetOptions.borderWidth,
                  r: targetOptions.borderRadius
                });
              }
              if (isNumber(pointVal) && pointVal !== null) {
                targetGraphic.element.point = point;
              }
              targetGraphic.addClass(point.getClassName() + " highcharts-bullet-target", true);
            } else if (targetGraphic) {
              point.targetGraphic = targetGraphic.destroy();
            }
          });
        };
        BulletSeries2.prototype.getExtremes = function(yData) {
          var dataExtremes = _super.prototype.getExtremes.call(this, yData), series = this, targetData = series.targetData;
          if (targetData && targetData.length) {
            var targetExtremes = _super.prototype.getExtremes.call(this, targetData);
            if (isNumber(targetExtremes.dataMin)) {
              dataExtremes.dataMin = Math.min(pick(dataExtremes.dataMin, Infinity), targetExtremes.dataMin);
            }
            if (isNumber(targetExtremes.dataMax)) {
              dataExtremes.dataMax = Math.max(pick(dataExtremes.dataMax, -Infinity), targetExtremes.dataMax);
            }
          }
          return dataExtremes;
        };
        BulletSeries2.defaultOptions = merge(ColumnSeries.defaultOptions, {
          /**
           * All options related with look and positiong of targets.
           *
           * @since 6.0.0
           */
          targetOptions: {
            /**
             * The width of the rectangle representing the target. Could be set
             * as a pixel value or as a percentage of a column width.
             *
             * @type  {number|string}
             * @since 6.0.0
             */
            width: "140%",
            /**
             * The height of the rectangle representing the target.
             *
             * @since 6.0.0
             */
            height: 3,
            /**
             * The border color of the rectangle representing the target. When
             * not set, the  point's border color is used.
             *
             * In styled mode, use class `highcharts-bullet-target` instead.
             *
             * @type      {Highcharts.ColorString}
             * @since     6.0.0
             * @product   highcharts
             * @apioption plotOptions.bullet.targetOptions.borderColor
             */
            /**
             * The color of the rectangle representing the target. When not set,
             * point's color (if set in point's options -
             * [`color`](#series.bullet.data.color)) or zone of the target value
             * (if [`zones`](#plotOptions.bullet.zones) or
             * [`negativeColor`](#plotOptions.bullet.negativeColor) are set)
             * or the same color as the point has is used.
             *
             * In styled mode, use class `highcharts-bullet-target` instead.
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @since     6.0.0
             * @product   highcharts
             * @apioption plotOptions.bullet.targetOptions.color
             */
            /**
             * The border width of the rectangle representing the target.
             *
             * In styled mode, use class `highcharts-bullet-target` instead.
             *
             * @since   6.0.0
             */
            borderWidth: 0,
            /**
             * The border radius of the rectangle representing the target.
             */
            borderRadius: 0
          },
          tooltip: {
            pointFormat: '<span style="color:{series.color}"></span> {series.name}: <b>{point.y}</b>. Target: <b>{point.target}</b><br/>'
          }
        });
        return BulletSeries2;
      }(ColumnSeries)
    );
    extend(BulletSeries.prototype, {
      parallelArrays: ["x", "y", "target"],
      pointArrayMap: ["y", "target"]
    });
    BulletSeries.prototype.pointClass = BulletPoint;
    SeriesRegistry$1.registerSeriesType("bullet", BulletSeries);
    /**
    @license
    Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    function isSlot(node) {
      return node.localName === "slot";
    }
    let FlattenedNodesObserver = class {
      /**
       * Returns the list of flattened nodes for the given `node`.
       * This list consists of a node's children and, for any children
       * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
       * For example, if the observed node has children `<a></a><slot></slot><b></b>`
       * and the `<slot>` has one `<div>` assigned to it, then the flattened
       * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
       * `<slot>` elements assigned to it, these are flattened as well.
       *
       * @param {!HTMLElement|!HTMLSlotElement} node The node for which to
       *      return the list of flattened nodes.
       * @return {!Array<!Node>} The list of flattened nodes for the given `node`.
       * @nocollapse See https://github.com/google/closure-compiler/issues/2763
       */
      // eslint-disable-next-line
      static getFlattenedNodes(node) {
        const wrapped = wrap$e(node);
        if (isSlot(node)) {
          node = /** @type {!HTMLSlotElement} */
          node;
          return wrapped.assignedNodes({ flatten: true });
        } else {
          return Array.from(wrapped.childNodes).map((node2) => {
            if (isSlot(node2)) {
              node2 = /** @type {!HTMLSlotElement} */
              node2;
              return wrap$e(node2).assignedNodes({ flatten: true });
            } else {
              return [node2];
            }
          }).reduce((a, b) => a.concat(b), []);
        }
      }
      /**
       * @param {!HTMLElement} target Node on which to listen for changes.
       * @param {?function(this: Element, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Function called when there are additions
       * or removals from the target's list of flattened nodes.
       */
      // eslint-disable-next-line
      constructor(target, callback) {
        this._shadyChildrenObserver = null;
        this._nativeChildrenObserver = null;
        this._connected = false;
        this._target = target;
        this.callback = callback;
        this._effectiveNodes = [];
        this._observer = null;
        this._scheduled = false;
        this._boundSchedule = () => {
          this._schedule();
        };
        this.connect();
        this._schedule();
      }
      /**
       * Activates an observer. This method is automatically called when
       * a `FlattenedNodesObserver` is created. It should only be called to
       * re-activate an observer that has been deactivated via the `disconnect` method.
       *
       * @return {void}
       */
      connect() {
        if (isSlot(this._target)) {
          this._listenSlots([this._target]);
        } else if (wrap$e(this._target).children) {
          this._listenSlots(
            /** @type {!NodeList<!Node>} */
            wrap$e(this._target).children
          );
          if (window.ShadyDOM) {
            this._shadyChildrenObserver = window.ShadyDOM.observeChildren(this._target, (mutations) => {
              this._processMutations(mutations);
            });
          } else {
            this._nativeChildrenObserver = new MutationObserver((mutations) => {
              this._processMutations(mutations);
            });
            this._nativeChildrenObserver.observe(this._target, { childList: true });
          }
        }
        this._connected = true;
      }
      /**
       * Deactivates the flattened nodes observer. After calling this method
       * the observer callback will not be called when changes to flattened nodes
       * occur. The `connect` method may be subsequently called to reactivate
       * the observer.
       *
       * @return {void}
       * @override
       */
      disconnect() {
        if (isSlot(this._target)) {
          this._unlistenSlots([this._target]);
        } else if (wrap$e(this._target).children) {
          this._unlistenSlots(
            /** @type {!NodeList<!Node>} */
            wrap$e(this._target).children
          );
          if (window.ShadyDOM && this._shadyChildrenObserver) {
            window.ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
            this._shadyChildrenObserver = null;
          } else if (this._nativeChildrenObserver) {
            this._nativeChildrenObserver.disconnect();
            this._nativeChildrenObserver = null;
          }
        }
        this._connected = false;
      }
      /**
       * @return {void}
       * @private
       */
      _schedule() {
        if (!this._scheduled) {
          this._scheduled = true;
          microTask$1.run(() => this.flush());
        }
      }
      /**
       * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
       * @return {void}
       * @private
       */
      _processMutations(mutations) {
        this._processSlotMutations(mutations);
        this.flush();
      }
      /**
       * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
       * @return {void}
       * @private
       */
      _processSlotMutations(mutations) {
        if (mutations) {
          for (let i = 0; i < mutations.length; i++) {
            let mutation = mutations[i];
            if (mutation.addedNodes) {
              this._listenSlots(mutation.addedNodes);
            }
            if (mutation.removedNodes) {
              this._unlistenSlots(mutation.removedNodes);
            }
          }
        }
      }
      /**
       * Flushes the observer causing any pending changes to be immediately
       * delivered the observer callback. By default these changes are delivered
       * asynchronously at the next microtask checkpoint.
       *
       * @return {boolean} Returns true if any pending changes caused the observer
       * callback to run.
       */
      flush() {
        if (!this._connected) {
          return false;
        }
        if (window.ShadyDOM) {
          ShadyDOM.flush();
        }
        if (this._nativeChildrenObserver) {
          this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
        } else if (this._shadyChildrenObserver) {
          this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
        }
        this._scheduled = false;
        let info = {
          target: this._target,
          addedNodes: [],
          removedNodes: []
        };
        let newNodes = this.constructor.getFlattenedNodes(this._target);
        let splices = calculateSplices(
          newNodes,
          this._effectiveNodes
        );
        for (let i = 0, s; i < splices.length && (s = splices[i]); i++) {
          for (let j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
            info.removedNodes.push(n);
          }
        }
        for (let i = 0, s; i < splices.length && (s = splices[i]); i++) {
          for (let j = s.index; j < s.index + s.addedCount; j++) {
            info.addedNodes.push(newNodes[j]);
          }
        }
        this._effectiveNodes = newNodes;
        let didFlush = false;
        if (info.addedNodes.length || info.removedNodes.length) {
          didFlush = true;
          this.callback.call(this._target, info);
        }
        return didFlush;
      }
      /**
       * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
       * @return {void}
       * @private
       */
      _listenSlots(nodeList) {
        for (let i = 0; i < nodeList.length; i++) {
          let n = nodeList[i];
          if (isSlot(n)) {
            n.addEventListener("slotchange", this._boundSchedule);
          }
        }
      }
      /**
       * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
       * @return {void}
       * @private
       */
      _unlistenSlots(nodeList) {
        for (let i = 0; i < nodeList.length; i++) {
          let n = nodeList[i];
          if (isSlot(n)) {
            n.removeEventListener("slotchange", this._boundSchedule);
          }
        }
      }
    };
    function inflateFunctions(config) {
      if (Array.isArray(config)) {
        config.forEach(inflateFunctions);
        return;
      }
      if (
        // Check if param is a primitive/null/undefined value
        !(config instanceof Object) || // Check if param is a plain object (not a HC object)
        config.constructor !== Object
      ) {
        return;
      }
      Object.entries(config).forEach(([attr, targetProperty]) => {
        if (attr.startsWith("_fn_") && (typeof targetProperty === "string" || targetProperty instanceof String)) {
          try {
            config[attr.substr(4)] = eval(`(${targetProperty})`);
          } catch (e) {
            config[attr.substr(4)] = eval(`(function(){${targetProperty}})`);
          }
          delete config[attr];
        } else if (targetProperty instanceof Object) {
          inflateFunctions(targetProperty);
        }
      });
    }
    /**
     * @license
     * Copyright (c) 2000 - 2024 Vaadin Ltd.
     *
     * This program is available under Vaadin Commercial License and Service Terms.
     *
     *
     * See https://vaadin.com/commercial-license-and-service-terms for the full
     * license.
     */
    class ChartSeries extends PolymerElement {
      static get is() {
        return "vaadin-chart-series";
      }
      static get properties() {
        return {
          /**
           * An array of data used by the series.
           * Format depends on the chart type and can be:
           *   - An array of numerical values `[y0, y1, y2, y3,...]`
           *   - An array of arrays with 2 values (`x`, `y`) `[ [x0, y0], [x1, y1], [x2, y2], ... ]`
           *   - An array of objects, each one describing one point `[ {x: x0, y: y0, name: 'Point0', color: '#FF0000'}, {...}, ...]`
           *
           *  See more in [API Site](https://api.highcharts.com/highcharts/series)
           *
           * Note that you should always use [Polymer API](https://www.polymer-project.org/2.0/docs/devguide/model-data#array-mutation)
           * to mutate the values array in order to make the component aware of the
           * change and be able to synchronize it.
           * @type {ChartSeriesValues}
           */
          values: {
            type: Array,
            value: () => []
          },
          /**
           * Value-axis minimum-value.
           * Sets the value to a series bound by 'unit' property.
           * Otherwise sets the value to the first series.
           * Undefined by default (determined from data).
           * @attr {number} value-min
           */
          valueMin: {
            type: Number,
            reflectToAttribute: true
          },
          /**
           * Value-axis maximum-value.
           * See the 'valueMin'
           * @attr {number} value-max
           */
          valueMax: {
            type: Number,
            reflectToAttribute: true
          },
          /**
           * A string with the type of the series.
           * Defaults to `'line'` in case no type is set for the chart.
           * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type on `<vaadin-chart>`.
           */
          type: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * The name of the series as shown in the legend, tooltip etc.
           * @type {string}
           */
          title: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Shows/hides data-point markers for line-like series.
           * Acceptable input are:
           *  - `shown`: markers are always visible
           *  - `hidden`: markers are always hidden
           *  - `auto`: markers are visible for widespread data and hidden, when data is dense *(default)*
           * @type {ChartSeriesMarkers | undefined}
           */
          markers: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Used to connect the series to an axis; if multiple series have the same `unit`, they will share axis.
           * Displayed as a title for the axis.
           * If no unit is defined, then series will be connected to the first axis.
           */
          unit: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Used to group series in a different stacks.
           * "stacking" property should be specified either for each series or in plotOptions.
           * It is recommended to place series in a single stack, when they belong to the same yAxis.
           * @type {number | string}
           */
          stack: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * The height of the neck, the lower part of the funnel.
           * A number defines pixel width, a percentage string defines a percentage of the plot area height. Defaults to 30%.
           * Note that this property only applies for "funnel" charts.
           * @attr {number | string} neck-position
           * @type {number | string}
           */
          neckPosition: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * The width of the neck, the lower part of the funnel.
           * A number defines pixel width, a percentage string defines a percentage of the plot area width. Defaults to 30%.
           * Note that this property only applies for "funnel" charts.
           * @attr {number | string} neck-width
           * @type {number | string}
           */
          neckWidth: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Object with the configured options defined and used to create a series.
           * @type {!ChartSeriesOptions}
           * @readonly
           */
          options: {
            type: Object
          },
          /**
           * Represents additional JSON configuration.
           * @type {SeriesOptionsType | undefined}
           */
          additionalOptions: {
            type: Object,
            reflectToAttribute: true
          },
          /**
           * @type {!Series | undefined}
           * @protected
           */
          _series: {
            type: Object
          }
        };
      }
      static get observers() {
        return [
          "__additionalOptionsObserver(additionalOptions.*, _series)",
          "__markersObserver(markers, _series)",
          "__neckPositionObserver(neckPosition, _series)",
          "__neckWidthObserver(neckWidth, _series)",
          "__stackObserver(stack, _series)",
          "__titleObserver(title, _series)",
          "__typeObserver(type, _series)",
          "__unitObserver(unit, valueMin, valueMax, _series)",
          "__valueMinObserver(valueMin, _series)",
          "__valueMaxObserver(valueMax, _series)",
          "__valuesObserver(values.splices, _series)"
        ];
      }
      get options() {
        const options = deepMerge({}, this.additionalOptions);
        if (this.type) {
          options.type = this.type;
        }
        if (this.title) {
          options.name = this.title;
        }
        if (this.values) {
          options.data = this.values;
        }
        if (this.markers) {
          if (!this.__isMarkersValid()) {
            this.markers = "auto";
          }
          options.marker = this.__markersConfiguration;
        }
        if (this.unit) {
          options.yAxis = this.unit;
        }
        if (this.stack) {
          options.stack = this.stack;
        }
        if (isFinite(this.valueMin)) {
          options.yAxisValueMin = this.valueMin;
        }
        if (isFinite(this.valueMax)) {
          options.yAxisValueMax = this.valueMax;
        }
        if (this.neckWidth) {
          options.neckWidth = this.neckWidth;
        }
        if (this.neckPosition) {
          options.neckHeight = this.neckPosition;
        }
        return options;
      }
      /** @private */
      get __markersConfiguration() {
        const config2 = {};
        switch (this.markers) {
          case "shown":
            config2.enabled = true;
            break;
          case "hidden":
            config2.enabled = false;
            break;
          case "auto":
          default:
            config2.enabled = null;
            break;
        }
        return config2;
      }
      /**
       * Method to attach a series object of type `Highcharts.Series`.
       * @param {!Series} series Object of type `Highcharts.Series`
       */
      setSeries(series) {
        this._series = series;
      }
      /** @private */
      __valuesObserver(splices, series) {
        if (series) {
          series.setData(this.values);
        }
      }
      /** @private */
      __additionalOptionsObserver(additionalOptions, series) {
        if (series && additionalOptions.base) {
          series.update(additionalOptions.base);
        }
      }
      /** @private */
      __updateAxis(series, value, key) {
        if (!isFinite(value)) {
          this.__showWarn(`value-${key}`, "Numbers or null");
          return;
        }
        if (series && series.yAxis) {
          series.yAxis.update({ [key]: value });
        }
      }
      /** @private */
      __valueMinObserver(valueMin, series) {
        if (valueMin === void 0 || series === void 0) {
          return;
        }
        this.__updateAxis(series, valueMin, "min");
      }
      /** @private */
      __valueMaxObserver(valueMax, series) {
        if (valueMax === void 0 || series === void 0) {
          return;
        }
        this.__updateAxis(series, valueMax, "max");
      }
      /** @private */
      __typeObserver(type, series) {
        if (type && series) {
          series.update({ type });
        }
      }
      /** @private */
      __titleObserver(title, series) {
        if (title === void 0 || series === void 0) {
          return;
        }
        series.update({ name: title });
      }
      /** @private */
      __stackObserver(stack, series) {
        if (stack === void 0 || series === void 0) {
          return;
        }
        series.update({ stack });
      }
      /** @private */
      __neckPositionObserver(neckPosition, series) {
        if (neckPosition === void 0 || series === void 0) {
          return;
        }
        series.update({ neckHeight: neckPosition });
      }
      /** @private */
      __neckWidthObserver(neckWidth, series) {
        if (neckWidth === void 0 || series === void 0) {
          return;
        }
        series.update({ neckWidth });
      }
      /** @private */
      __unitObserver(unit, valueMin, valueMax, series) {
        if (series && unit !== this.__oldUnit) {
          this.__oldUnit = unit;
          const parent = this.parentNode instanceof Chart && this.parentNode;
          if (parent && parent instanceof Chart) {
            if (unit && !parent.__getAxis(unit)) {
              const title = { title: { text: unit } };
              parent.__addAxis({ id: unit, axisGenerated: true, ...title });
            }
            series.update({ yAxis: unit || 0 });
            if (valueMin !== void 0) {
              this.__updateAxis(series, valueMin, "min");
            }
            if (valueMax !== void 0) {
              this.__updateAxis(series, valueMax, "max");
            }
            parent.__removeAxisIfEmpty();
          }
        }
      }
      /** @private */
      __isMarkersValid() {
        if (["shown", "hidden", "auto"].indexOf(this.markers) === -1) {
          this.__showWarn("markers", '"shown", "hidden" or "auto"');
          return false;
        }
        return true;
      }
      /** @private */
      __markersObserver(markers, series) {
        if (markers === void 0 || series === void 0) {
          return;
        }
        if (!this.__isMarkersValid()) {
          this.markers = "auto";
          return;
        }
        series.update({
          marker: this.__markersConfiguration
        });
      }
      /** @private */
      __showWarn(propertyName, acceptedValues) {
        console.warn(`<vaadin-chart-series> Acceptable values for "${propertyName}" are ${acceptedValues}`);
      }
    }
    defineCustomElement(ChartSeries);
    /**
     * @license
     * Copyright (c) 2000 - 2024 Vaadin Ltd.
     *
     * This program is available under Vaadin Commercial License and Service Terms.
     *
     *
     * See https://vaadin.com/commercial-license-and-service-terms for the full
     * license.
     */
    function deepMerge(target, source) {
      const isObject2 = (item2) => item2 && typeof item2 === "object" && !Array.isArray(item2);
      if (isObject2(source) && isObject2(target)) {
        Object.keys(source).forEach((key) => {
          if (isObject2(source[key])) {
            if (!target[key]) {
              Object.assign(target, { [key]: {} });
            }
            deepMerge(target[key], source[key]);
          } else {
            Object.assign(target, { [key]: source[key] });
          }
        });
      }
      return target;
    }
    ["exportChart", "exportChartLocal", "getSVG"].forEach((methodName) => {
      G$7.wrap(G$7.Chart.prototype, methodName, function(proceed, ...args) {
        G$7.fireEvent(this, "beforeExport");
        const result2 = proceed.apply(this, args);
        G$7.fireEvent(this, "afterExport");
        return result2;
      });
    });
    Pointer.prototype.onDocumentMouseMove = function(e2) {
      const chart = this.chart;
      const chartPosition = this.chartPosition;
      const pEvt = this.normalize(e2, chartPosition);
      const tooltip = chart.tooltip;
      if (chartPosition && (!tooltip || !tooltip.isStickyOnContact()) && !chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
        visiblePlotOnly: true
      }) && // Use the first element from the composed path instead of the actual target
      !this.inClass(pEvt.composedPath()[0], "highcharts-tracker")) {
        this.reset();
      }
    };
    G$7.setOptions({ lang: { noData: "" } });
    class Chart extends ResizeMixin(ElementMixin(ThemableMixin(PolymerElement))) {
      static get template() {
        return html`
      <style>
        :host {
          display: block;
          width: 100%;
          overflow: hidden;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <div id="chart"></div>
      <slot id="slot"></slot>
    `;
      }
      static get is() {
        return "vaadin-chart";
      }
      static get cvdlName() {
        return "vaadin-chart";
      }
      static get properties() {
        return {
          /**
           * Configuration object that exposes the JS Api to configure the chart.
           *
           * Most important methods are:
           * - `addSeries (Object options, [Boolean redraw], [Mixed animation])`
           * - `addAxis (Object options, [Boolean isX], [Boolean redraw], [Mixed animation])`
           * - `setTitle (Object title, object subtitle, Boolean redraw)`
           *
           * Most important properties are:
           * - `configuration.series`: An array of the chart's series. Detailed API for Series object is
           *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Series)
           * - `configuration.xAxis`: An array of the chart's x axes. Detailed API for Axis object is
           *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)
           * - `configuration.yAxis`: An array of the chart's y axes. Detailed API for Axis object is
           *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)
           * - `configuration.title`: The chart title.
           *
           * For detailed documentation of available API check the [API site](http://api.highcharts.com/class-reference/classes.list)
           * @type {!Highcharts.Chart | undefined}
           */
          configuration: Object,
          /**
           * If categories are present names are used instead of numbers for the category axis.
           * The format of categories can be an `Array` with a list of categories, such as `['2010', '2011', '2012']`
           * or a mapping `Object`, like `{0:'1',9:'Target (10)', 15: 'Max'}`.
           * @type {ChartCategories | undefined}
           */
          categories: {
            type: Object,
            reflectToAttribute: true
          },
          /**
           * Category-axis maximum value. Defaults to `undefined`.
           * @attr {number} category-max
           */
          categoryMax: {
            type: Number,
            reflectToAttribute: true
          },
          /**
           * Category-axis minimum value. Defaults to `undefined`.
           * @attr {number} category-min
           */
          categoryMin: {
            type: Number,
            reflectToAttribute: true
          },
          /**
           * The position of the category axis. Acceptable values are `left`, `right`, `top` and `bottom`
           * except for bar charts which only accept `left` and `right`.
           * With the default value, charts appear as though they have `category-position="bottom"`
           * except for bar charts that appear as though they have `category-position="left"`.
           *
           * Defaults to `undefined`
           *
           * @attr {left|right|top|bottom} category-position
           * @type {ChartCategoryPosition | undefined}
           */
          categoryPosition: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Specifies whether to hide legend or show.
           * Legend configuration can be set up via additionalOptions property
           * @attr {boolean} no-legend
           */
          noLegend: {
            type: Boolean,
            reflectToAttribute: true
          },
          /**
           * Specifies how series are stacked on top of each other.
           * Possible values are null, "normal" or "percent".
           * If "stack" property is not defined on the vaadin-chart-series elements, then series will be put into
           * the default stack.
           * @attr {normal|percent} stacking
           * @type {ChartStacking | undefined}
           */
          stacking: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Specifies whether the chart is a normal chart or a timeline chart.
           */
          timeline: {
            type: Boolean,
            reflectToAttribute: true
          },
          /**
           * Represents the title of the chart.
           * @type {string}
           */
          title: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Whether or not to show tooltip when hovering data points.
           */
          tooltip: {
            type: Boolean,
            reflectToAttribute: true
          },
          /**
           * Sets the default series type of the chart.
           * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type.
           */
          type: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Represents the subtitle of the chart.
           * @type {string | undefined}
           */
          subtitle: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Specifies whether to show chart in 3 or in 2 dimensions.
           * Some display angles are added by default to the "chart.options3d" (`{alpha: 15, beta: 15, depth: 50}`).
           * 3D display options can be modified via `additionalOptions`.
           * The thickness of a Pie chart can be set on `additionalOptions` through `plotOptions.pie.depth`.
           * 3D is supported by Bar, Column, Pie and Scatter3D charts.
           * More info available at [Highcharts](https://www.highcharts.com/docs/chart-concepts/3d-charts).
           */
          chart3d: {
            type: Boolean,
            reflectToAttribute: true
          },
          /**
           * Specifies the message displayed on a chart without displayable data.
           * @attr {string} empty-text
           * @type {string}
           */
          emptyText: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Represents additional JSON configuration.
           * @type {Options | undefined}
           */
          additionalOptions: {
            type: Object,
            reflectToAttribute: true
          },
          /**
           * When present, cartesian charts like line, spline, area and column are transformed
           * into the polar coordinate system.
           */
          polar: {
            type: Boolean,
            reflectToAttribute: true
          }
        };
      }
      static get observers() {
        return [
          "__chart3dObserver(chart3d, configuration)",
          "__emptyTextObserver(emptyText, configuration)",
          "__hideLegend(noLegend, configuration)",
          "__polarObserver(polar, configuration)",
          "__stackingObserver(stacking, configuration)",
          "__tooltipObserver(tooltip, configuration)",
          "__updateCategories(categories, configuration)",
          "__updateCategoryMax(categoryMax, configuration)",
          "__updateCategoryMin(categoryMin, configuration)",
          "__updateCategoryPosition(categoryPosition, configuration)",
          "__updateSubtitle(subtitle, configuration)",
          "__updateTitle(title, configuration)",
          "__updateType(type, configuration)",
          "__updateAdditionalOptions(additionalOptions.*)"
        ];
      }
      /** @private */
      static __callHighchartsFunction(functionName, redrawCharts, ...args) {
        const functionToCall = G$7[functionName];
        if (functionToCall && typeof functionToCall === "function") {
          args.forEach((arg) => inflateFunctions(arg));
          functionToCall.apply(this.configuration, args);
          if (redrawCharts) {
            G$7.charts.forEach((c) => c.redraw());
          }
        }
      }
      constructor() {
        super();
        this._baseConfig = {
          annotations: [],
          chart: {
            styledMode: true
          },
          credits: {
            enabled: false
          },
          exporting: {
            enabled: false
          },
          title: {
            text: null
          },
          series: [],
          xAxis: {},
          yAxis: {
            axisGenerated: true
          }
        };
        this._baseChart3d = {
          enabled: true,
          alpha: 15,
          beta: 15,
          depth: 50
        };
      }
      /**
       * @return {!Options}
       */
      get options() {
        const options = { ...this._baseConfig };
        deepMerge(options, this.additionalOptions);
        if (this.type) {
          options.chart.type = this.type;
        }
        if (this.polar) {
          options.chart.polar = true;
        }
        if (this.title) {
          options.title = {
            text: this.title
          };
        }
        if (!options.tooltip) {
          options.tooltip = {};
          if (!this.tooltip) {
            options.tooltip.enabled = false;
          }
        }
        if (this.subtitle) {
          options.subtitle = {
            text: this.subtitle
          };
        }
        if (this.categories) {
          if (Array.isArray(options.xAxis)) {
            options.xAxis[0].categories = this.categories;
          } else {
            options.xAxis.categories = this.categories;
          }
        }
        if (isFinite(this.categoryMin)) {
          if (Array.isArray(options.xAxis)) {
            options.xAxis[0].min = this.categoryMin;
          } else {
            options.xAxis.min = this.categoryMin;
          }
        }
        if (isFinite(this.categoryMax)) {
          if (Array.isArray(options.xAxis)) {
            options.xAxis[0].max = this.categoryMax;
          } else {
            options.xAxis.max = this.categoryMax;
          }
        }
        if (this.noLegend) {
          options.legend = {
            enabled: false
          };
        }
        if (this.emptyText) {
          if (!options.lang) {
            options.lang = {};
          }
          options.lang.noData = this.emptyText;
        }
        if (this.categoryPosition) {
          options.chart.inverted = this.__shouldInvert();
          if (Array.isArray(options.xAxis)) {
            options.xAxis.forEach((e2) => {
              e2.opposite = this.__shouldFlipOpposite();
            });
          } else if (options.xAxis) {
            options.xAxis.opposite = this.__shouldFlipOpposite();
          }
        }
        if (this.stacking) {
          if (!options.plotOptions) {
            options.plotOptions = {};
          }
          if (!options.plotOptions.series) {
            options.plotOptions.series = {};
          }
          options.plotOptions.series.stacking = this.stacking;
        }
        if (this.chart3d) {
          options.chart.options3d = { ...this._baseChart3d, ...options.chart.options3d };
        }
        return options;
      }
      /**
       * Name of the chart events to add to the configuration and its corresponding event for the chart element
       * @private
       */
      get __chartEventNames() {
        return {
          /**
           * Fired when a new series is added.
           * @event chart-add-series
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} chart Chart object where the event was sent from
           */
          addSeries: "chart-add-series",
          /**
           * Fired after a chart is exported.
           * @event chart-after-export
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} chart Chart object where the event was sent from
           */
          afterExport: "chart-after-export",
          /**
           * Fired after a chart is printed.
           * @event chart-after-print
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} chart Chart object where the event was sent from
           */
          afterPrint: "chart-after-print",
          /**
           * Fired before a chart is exported.
           * @event chart-before-export
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} chart Chart object where the event was sent from
           */
          beforeExport: "chart-before-export",
          /**
           * Fired before a chart is printed.
           * @event chart-before-print
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} chart Chart object where the event was sent from
           */
          beforePrint: "chart-before-print",
          /**
           * Fired when clicking on the plot background.
           * @event chart-click
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} chart Chart object where the event was sent from
           */
          click: "chart-click",
          /**
           * Fired when drilldown point is clicked.
           * @event chart-drilldown
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} chart Chart object where the event was sent from
           */
          drilldown: "chart-drilldown",
          /**
           * Fired when drilling up from a drilldown series.
           * @event chart-drillup
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} chart Chart object where the event was sent from
           */
          drillup: "chart-drillup",
          /**
           * Fired after all the series has been drilled up if chart has multiple drilldown series.
           * @event chart-drillupall
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} chart Chart object where the event was sent from
           */
          drillupall: "chart-drillupall",
          /**
           * Fired when the chart is finished loading.
           * @event chart-load
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} chart Chart object where the event was sent from
           */
          load: "chart-load",
          /**
           * Fired when the chart is redraw. Can be called after a `Chart.configuration.redraw()`
           * or after an axis, series or point is modified with the `redraw` option set to `true`.
           * @event chart-redraw
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} chart Chart object where the event was sent from
           */
          redraw: "chart-redraw",
          /**
           * Fired when an area of the chart has been selected.
           * @event chart-selection
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} chart Chart object where the event was sent from
           */
          selection: "chart-selection"
        };
      }
      /**
       * Name of the series events to add to the configuration and its corresponding event for the chart element
       * @private
       */
      get __seriesEventNames() {
        return {
          /**
           * Fired when the series has finished its initial animation.
           * @event series-after-animate
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} series Series object where the event was sent from
           */
          afterAnimate: "series-after-animate",
          /**
           * Fired when the checkbox next to the series' name in the legend is clicked.
           * @event series-checkbox-click
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} series Series object where the event was sent from
           */
          checkboxClick: "series-checkbox-click",
          /**
           * Fired when the series is clicked.
           * @event series-click
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} series Series object where the event was sent from
           */
          click: "series-click",
          /**
           * Fired when the series is hidden after chart generation time.
           * @event series-hide
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} series Series object where the event was sent from
           */
          hide: "series-hide",
          /**
           * Fired when the legend item belonging to the series is clicked.
           * @event series-legend-item-click
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} series Series object where the event was sent from
           */
          legendItemClick: "series-legend-item-click",
          /**
           * Fired when the mouses leave the graph.
           * @event series-mouse-out
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} series Series object where the event was sent from
           */
          mouseOut: "series-mouse-out",
          /**
           * Fired when the mouse enters the graph.
           * @event series-mouse-over
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} series Series object where the event was sent from
           */
          mouseOver: "series-mouse-over",
          /**
           * Fired when the series is show after chart generation time.
           * @event series-show
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} series Series object where the event was sent from
           */
          show: "series-show"
        };
      }
      /**
       * Name of the point events to add to the configuration and its corresponding event for the chart element
       * @private
       */
      get __pointEventNames() {
        return {
          /**
           * Fired when the point is clicked.
           * @event point-click
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} point Point object where the event was sent from
           */
          click: "point-click",
          /**
           * Fired when the legend item belonging to the point is clicked.
           * @event point-legend-item-click
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} point Point object where the event was sent from
           */
          legendItemClick: "point-legend-item-click",
          /**
           * Fired when the mouse leaves the area close to the point.
           * @event point-mouse-out
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} point Point object where the event was sent from
           */
          mouseOut: "point-mouse-out",
          /**
           * Fired when the mouse enters the area close to the point.
           * @event point-mouse-over
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} point Point object where the event was sent from
           */
          mouseOver: "point-mouse-over",
          /**
           * Fired when the point is removed from the series.
           * @event point-remove
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} point Point object where the event was sent from
           */
          remove: "point-remove",
          /**
           * Fired when the point is selected either programmatically or by clicking on the point.
           * @event point-select
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} point Point object where the event was sent from
           */
          select: "point-select",
          /**
           * Fired when the point is unselected either programmatically or by clicking on the point
           * @event point-unselect
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} point Point object where the event was sent from
           */
          unselect: "point-unselect",
          /**
           * Fired when the point is updated programmatically through `.updateConfiguration()` method.
           * @event point-update
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} point Point object where the event was sent from
           */
          update: "point-update"
        };
      }
      /** @private */
      get __xAxesEventNames() {
        return {
          /**
           * Fired when when the minimum and maximum is set for the x axis.
           * @event xaxes-extremes-set
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} axis Point object where the event was sent from
           */
          afterSetExtremes: "xaxes-extremes-set"
        };
      }
      /** @private */
      get __yAxesEventNames() {
        return {
          /**
           * Fired when when the minimum and maximum is set for the y axis.
           * @event yaxes-extremes-set
           * @param {Object} detail.originalEvent object with details about the event sent
           * @param {Object} axis Point object where the event was sent from
           */
          afterSetExtremes: "yaxes-extremes-set"
        };
      }
      /** @protected */
      connectedCallback() {
        super.connectedCallback();
        this.__updateStyles();
        beforeNextRender(this, () => {
          if (this.configuration) {
            this.__reflow();
            return;
          }
          const options = { ...this.options, ...this._jsonConfigurationBuffer };
          this._jsonConfigurationBuffer = null;
          this.__initChart(options);
          this.__addChildObserver();
          this.__checkTurboMode();
        });
      }
      /** @protected */
      ready() {
        super.ready();
        this.addEventListener("chart-redraw", this.__onRedraw.bind(this));
      }
      /**
       * Implements resize callback from `ResizeMixin`
       * to reflow when the chart element is resized.
       * @protected
       * @override
       */
      _onResize(contentRect) {
        if (!this.configuration) {
          return;
        }
        const { height, width } = contentRect;
        const { chartHeight, chartWidth } = this.configuration;
        if (height !== chartHeight || width !== chartWidth) {
          this.__reflow();
        }
      }
      /** @private */
      __reflow() {
        if (!this.configuration) {
          return;
        }
        this.configuration.reflow();
      }
      /** @private */
      __addChildObserver() {
        this._childObserver = new FlattenedNodesObserver(this.$.slot, (info) => {
          this.__addSeries(info.addedNodes.filter(this.__filterSeriesNodes));
          this.__removeSeries(info.removedNodes.filter(this.__filterSeriesNodes));
          this.__cleanupAfterSeriesRemoved(info.removedNodes.filter(this.__filterSeriesNodes));
        });
      }
      /** @private */
      __filterSeriesNodes(node) {
        return node.nodeType === Node.ELEMENT_NODE && node instanceof ChartSeries;
      }
      /** @private */
      __addSeries(series) {
        if (this.__isSeriesEmpty(series)) {
          return;
        }
        const seriesNodes = Array.from(this.childNodes).filter(this.__filterSeriesNodes);
        const yAxes = this.configuration.yAxis.reduce((acc, axis, index) => {
          acc[axis.options.id || index] = axis;
          return acc;
        }, {});
        for (let i = 0, len = series.length; i < len; i++) {
          const seriesElement = series[i];
          const { yAxis: unit, yAxisValueMin: valueMin, yAxisValueMax: valueMax } = seriesElement.options;
          const idxOnChildList = seriesNodes.indexOf(seriesElement);
          if (!unit && !this.configuration.yAxis.some((e2) => e2.userOptions.id === void 0)) {
            yAxes[unit] = this.__addAxis({ axisGenerated: true });
          } else if (unit && !yAxes[unit]) {
            yAxes[unit] = this.__addAxis({ id: unit, title: { text: unit }, axisGenerated: true });
          }
          if (isFinite(valueMin)) {
            this.__setYAxisProps(yAxes, unit, { min: valueMin });
          }
          if (isFinite(valueMax)) {
            this.__setYAxisProps(yAxes, unit, { max: valueMax });
          }
          const seriesConfiguration = this.__updateOrAddSeriesInstance(seriesElement.options, idxOnChildList, false);
          seriesElement.setSeries(seriesConfiguration);
        }
        this.__removeAxisIfEmpty();
        this.configuration.redraw();
      }
      /** @private */
      __removeSeries(seriesNodes) {
        if (this.__isSeriesEmpty(seriesNodes)) {
          return;
        }
        seriesNodes.forEach((series) => {
          if (series instanceof ChartSeries) {
            series._series.remove();
          }
        });
      }
      /** @private */
      __setYAxisProps(yAxes, yAxisId, props) {
        if (yAxisId) {
          yAxes[yAxisId].update(props);
        } else {
          this.configuration.yAxis[0].update(props);
        }
      }
      /** @private */
      __isSeriesEmpty(series) {
        return series === null || series.length === 0;
      }
      /** @private */
      __cleanupAfterSeriesRemoved(series) {
        if (this.__isSeriesEmpty(series)) {
          return;
        }
        this.__removeAxisIfEmpty();
        this.__updateNoDataElement(this.configuration);
      }
      /** @private */
      __initChart(options) {
        this.__initEventsListeners(options);
        this.__updateStyledMode(options);
        if (this.timeline) {
          this.configuration = G$7.stockChart(this.$.chart, options);
        } else {
          this.configuration = G$7.chart(this.$.chart, options);
        }
      }
      /** @private */
      __updateStyledMode(options) {
        const styledMode = options.chart.styledMode;
        this.$.chart.toggleAttribute("styled-mode", !!styledMode);
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback();
        if (this._childObserver) {
          this._childObserver.disconnect();
        }
      }
      /**
       * Search for axis with given `id`.
       *
       * @param {string} id contains the id that will be searched
       * @param {boolean} isXAxis indicates if it will remove x or y axes. Defaults to `false`.
       * @return {Axis}
       * @protected
       */
      __getAxis(id, isXAxis) {
        id = Number.parseInt(id) || id;
        if (this.configuration) {
          return (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).find((axis) => axis.options.id === id);
        }
      }
      /**
       * Add an axis with given options
       *
       * @param {Object} options axis options
       * @param {boolean} isXAxis indicates if axis is X (`true`) or Y (`false`). Defaults to `false`.
       * @return {!Axis}
       * @protected
       */
      __addAxis(options, isXAxis) {
        if (this.configuration) {
          this.__createEventListeners(isXAxis ? this.__xAxesEventNames : this.__yAxesEventNames, options, "events", "axis");
          return this.configuration.addAxis(options, isXAxis);
        }
      }
      /**
       * Iterates over axes (y or x) and removes whenever it doesn't contain any series and was created for unit
       *
       * @param {boolean} isXAxis indicates if it will remove x or y axes. Defaults to `false`.
       * @protected
       */
      __removeAxisIfEmpty(isXAxis) {
        if (this.configuration) {
          (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).forEach((axis) => {
            if (axis.userOptions.axisGenerated && axis.series.length === 0) {
              axis.remove();
            }
          });
        }
      }
      /**
       * Update the chart configuration.
       * This JSON API provides a simple single-argument alternative to the configuration property.
       *
       * Styling properties specified in this configuration will be ignored. To learn about chart styling
       * please see the CSS Styling section above.
       *
       * @param {!Options} jsonConfiguration Object chart configuration. Most important properties are:
       *
       * - annotations `Object[]` custom labels or shapes that can be tied to points, axis coordinates or chart pixel coordinates.
       *    Detailed API for annotations object is available in [API Site](http://api.highcharts.com/highcharts/annotations)
       * - chart `Object` with options regarding the chart area and plot area as well as general chart options.
       *    Detailed API for chart object is available in [API Site](http://api.highcharts.com/highcharts/chart)
       * - credits `Object` with options regarding the chart area and plot area as well as general chart options.
       *    Detailed API for credits object is available in [API Site](http://api.highcharts.com/highcharts/credits)
       * - plotOptions `Object` wrapper for config objects for each series type.
       *    Detailed API for plotOptions object is available in [API Site](http://api.highcharts.com/highcharts/plotOptions)
       * - series `Object[]` the actual series to append to the chart.
       *    Detailed API for series object is available in [API Site](http://api.highcharts.com/highcharts/series)
       * - subtitle `Object` the chart's subtitle.
       *    Detailed API for subtitle object is available in [API Site](http://api.highcharts.com/highcharts/subtitle)
       * - title `Object` the chart's main title.
       *    Detailed API for title object is available in [API Site](http://api.highcharts.com/highcharts/title)
       * - tooltip `Object` Options for the tooltip that appears when the user hovers over a series or point.
       *    Detailed API for tooltip object is available in [API Site](http://api.highcharts.com/highcharts/tooltip)
       * - xAxis `Object[]` The X axis or category axis. Normally this is the horizontal axis.
       *    Detailed API for xAxis object is available in [API Site](http://api.highcharts.com/highcharts/xAxis)
       * - yAxis `Object[]` The Y axis or value axis. Normally this is the vertical axis.
       *    Detailed API for yAxis object is available in [API Site](http://api.highcharts.com/highcharts/yAxis)
       * - zAxis `Object[]` The Z axis or depth axis for 3D plots.
       *    Detailed API for zAxis object is available in [API Site](http://api.highcharts.com/highcharts/zAxis)
       *
       * @param {boolean=} resetConfiguration Optional boolean that should be set to true if no other chart configuration was set before or
       *    if existing configuration should be discarded.
       */
      updateConfiguration(jsonConfiguration, resetConfiguration) {
        if (resetConfiguration || !this._jsonConfigurationBuffer) {
          this._jsonConfigurationBuffer = {};
        }
        const configCopy = deepMerge({}, jsonConfiguration);
        inflateFunctions(configCopy);
        this._jsonConfigurationBuffer = this.__makeConfigurationBuffer(this._jsonConfigurationBuffer, configCopy);
        beforeNextRender(this, () => {
          if (!this.configuration || !this._jsonConfigurationBuffer) {
            return;
          }
          if (resetConfiguration) {
            const initialOptions = { ...this.options, ...this._jsonConfigurationBuffer };
            this.__initChart(initialOptions);
            this._jsonConfigurationBuffer = null;
            return;
          }
          this.configuration.update(this._jsonConfigurationBuffer, false);
          if (this._jsonConfigurationBuffer.credits) {
            this.__updateOrAddCredits(this._jsonConfigurationBuffer.credits);
          }
          if (this._jsonConfigurationBuffer.xAxis) {
            this.__updateOrAddAxes(this._jsonConfigurationBuffer.xAxis, true, false);
          }
          if (this._jsonConfigurationBuffer.yAxis) {
            this.__updateOrAddAxes(this._jsonConfigurationBuffer.yAxis, false, false);
          }
          if (this._jsonConfigurationBuffer.series) {
            this.__updateOrAddSeries(this._jsonConfigurationBuffer.series, false);
          }
          this._jsonConfigurationBuffer = null;
          this.configuration.redraw();
        });
      }
      /** @private */
      __makeConfigurationBuffer(target, source) {
        const _source = G$7.merge(source);
        const _target = G$7.merge(target);
        this.__mergeConfigurationArray(_target, _source, "series");
        this.__mergeConfigurationArray(_target, _source, "xAxis");
        this.__mergeConfigurationArray(_target, _source, "yAxis");
        return G$7.merge(_target, _source);
      }
      /** @private */
      __mergeConfigurationArray(target, configuration, entry) {
        if (!configuration || !configuration[entry] || !Array.isArray(configuration[entry])) {
          return;
        }
        if (!target[entry]) {
          target[entry] = Array.from(configuration[entry]);
          return;
        }
        const maxLength = Math.max(target[entry].length, configuration[entry].length);
        for (let i = 0; i < maxLength; i++) {
          target[entry][i] = G$7.merge(target[entry][i], configuration[entry][i]);
        }
        delete configuration[entry];
      }
      /** @private */
      __initEventsListeners(configuration) {
        this.__initChartEventsListeners(configuration);
        this.__initSeriesEventsListeners(configuration);
        this.__initPointsEventsListeners(configuration);
        this.__initAxisEventsListeners(configuration, true);
        this.__initAxisEventsListeners(configuration, false);
      }
      /** @private */
      __initChartEventsListeners(configuration) {
        this.__createEventListeners(this.__chartEventNames, configuration, "chart.events", "chart");
      }
      /** @private */
      __initSeriesEventsListeners(configuration) {
        this.__createEventListeners(this.__seriesEventNames, configuration, "plotOptions.series.events", "series");
      }
      /** @private */
      __initPointsEventsListeners(configuration) {
        this.__createEventListeners(this.__pointEventNames, configuration, "plotOptions.series.point.events", "point");
      }
      /** @private */
      __initAxisEventsListeners(configuration, isXAxis) {
        let eventNames, axes;
        if (isXAxis) {
          eventNames = this.__xAxesEventNames;
          axes = configuration.xAxis;
        } else {
          eventNames = this.__yAxesEventNames;
          axes = configuration.yAxis;
        }
        if (Array.isArray(axes)) {
          axes.forEach((axis) => this.__createEventListeners(eventNames, axis, "events", "axis"));
        } else {
          this.__createEventListeners(eventNames, axes, "events", "axis");
        }
      }
      /** @private */
      __createEventListeners(eventList, configuration, pathToAdd, eventType) {
        const eventObject = this.__ensureObjectPath(configuration, pathToAdd);
        for (let keys2 = Object.keys(eventList), i = 0; i < keys2.length; i++) {
          const key = keys2[i];
          if (!eventObject[key]) {
            eventObject[key] = (event) => {
              const customEvent = {
                bubbles: false,
                composed: true,
                detail: {
                  originalEvent: event,
                  [eventType]: event.target
                }
              };
              if (event.type === "afterSetExtremes") {
                if (event.min == null || event.max == null) {
                  return;
                }
              }
              if (event.type === "selection") {
                if (event.xAxis && event.xAxis[0]) {
                  customEvent.detail.xAxisMin = event.xAxis[0].min;
                  customEvent.detail.xAxisMax = event.xAxis[0].max;
                }
                if (event.yAxis && event.yAxis[0]) {
                  customEvent.detail.yAxisMin = event.yAxis[0].min;
                  customEvent.detail.yAxisMax = event.yAxis[0].max;
                }
              }
              if (event.type === "click") {
                if (event.xAxis && event.xAxis[0]) {
                  customEvent.detail.xValue = event.xAxis[0].value;
                }
                if (event.yAxis && event.yAxis[0]) {
                  customEvent.detail.yValue = event.yAxis[0].value;
                }
              }
              if (["beforePrint", "beforeExport"].indexOf(event.type) >= 0) {
                if (!this.tempBodyStyle) {
                  let effectiveCss = "";
                  [...this.shadowRoot.querySelectorAll("style")].forEach((style) => {
                    effectiveCss += style.textContent;
                  });
                  effectiveCss = effectiveCss.replace(/:host\(.+?\)/gu, (match2) => {
                    const selector = match2.substr(6, match2.length - 7);
                    return this.matches(selector) ? "" : match2;
                  });
                  effectiveCss = `${effectiveCss}body {    -moz-transform: scale(0.9, 0.9);    zoom: 0.9;    zoom: 90%;}`;
                  this.tempBodyStyle = document.createElement("style");
                  this.tempBodyStyle.textContent = effectiveCss;
                  document.body.appendChild(this.tempBodyStyle);
                  if (this.options.chart.styledMode) {
                    document.body.setAttribute("styled-mode", "");
                  }
                }
              }
              if (["afterPrint", "afterExport"].indexOf(event.type) >= 0) {
                if (this.tempBodyStyle) {
                  document.body.removeChild(this.tempBodyStyle);
                  delete this.tempBodyStyle;
                  if (this.options.chart.styledMode) {
                    document.body.removeAttribute("styled-mode");
                  }
                }
              }
              this.dispatchEvent(new CustomEvent(eventList[key], customEvent));
              if (event.type === "legendItemClick" && this._visibilityTogglingDisabled) {
                return false;
              }
            };
          }
        }
      }
      /** @private */
      __ensureObjectPath(object, path) {
        if (typeof path !== "string") {
          return;
        }
        path = path.split(".");
        return path.reduce((obj, key) => {
          if (!obj[key]) {
            obj[key] = {};
          }
          return obj[key];
        }, object);
      }
      /** @private */
      __updateOrAddCredits(credits) {
        if (this.configuration.credits) {
          this.configuration.credits.update(credits);
        } else {
          this.configuration.addCredits(credits);
        }
      }
      /** @private */
      __updateOrAddAxes(axes, isX, redraw) {
        if (!Array.isArray(axes)) {
          axes = [axes];
        }
        const confAxes = isX ? this.configuration.xAxis : this.configuration.yAxis;
        for (let i = 0; i < axes.length; i++) {
          const axis = axes[i];
          if (confAxes[i]) {
            confAxes[i].update(axis, redraw);
          } else {
            this.configuration.addAxis(axis, isX, redraw);
          }
        }
      }
      /** @private */
      __updateOrAddSeries(series, redraw) {
        if (!Array.isArray(series)) {
          throw new Error("The type of jsonConfiguration.series should be Object[]");
        }
        for (let i = 0; i < series.length; i++) {
          const currentSeries = series[i];
          this.__updateOrAddSeriesInstance(currentSeries, i, redraw);
        }
      }
      /** @private */
      __updateOrAddSeriesInstance(seriesOptions, position, redraw) {
        if (this.configuration.series[position]) {
          this.configuration.series[position].update(seriesOptions, redraw);
        } else {
          this.configuration.addSeries(seriesOptions, redraw);
        }
        return this.configuration.series[position];
      }
      /** @private */
      __updateCategories(categories, config2) {
        if (categories === void 0 || !config2) {
          return;
        }
        this.__updateOrAddAxes([{ categories }], true);
      }
      /** @private */
      __updateCategoryMax(max, config2) {
        if (max === void 0 || !config2) {
          return;
        }
        if (!isFinite(max)) {
          console.warn('<vaadin-chart> Acceptable value for "category-max" are Numbers or null');
          return;
        }
        this.__updateOrAddAxes([{ max }], true);
      }
      /** @private */
      __updateCategoryMin(min, config2) {
        if (min === void 0 || !config2) {
          return;
        }
        if (!isFinite(min)) {
          console.warn('<vaadin-chart> Acceptable value for "category-min" are Numbers or null');
          return;
        }
        this.__updateOrAddAxes([{ min }], true);
      }
      /** @private */
      __shouldInvert() {
        if (this.type === "bar" && ["top", "bottom"].indexOf(this.categoryPosition) >= 0) {
          console.warn(`<vaadin-chart> Acceptable "category-position" values for bar charts are
          "left" and "right". For "top" and "bottom" positions please consider using a column chart.`);
          return;
        }
        const inverted = ["left", "right"];
        return inverted.indexOf(this.categoryPosition) >= 0;
      }
      /** @private */
      __shouldFlipOpposite() {
        const opposite = ["top", "right"];
        const oppositeBar = ["right"];
        return (this.type === "bar" ? oppositeBar : opposite).indexOf(this.categoryPosition) >= 0;
      }
      /** @private */
      __updateCategoryPosition(categoryPosition, config2) {
        if (categoryPosition === void 0 || !config2) {
          return;
        }
        const validPositions = ["left", "right", "top", "bottom"];
        if (validPositions.indexOf(categoryPosition) < 0) {
          console.warn(`<vaadin-chart> Acceptable "category-position" values are ${validPositions}`);
          return;
        }
        config2.update({
          chart: {
            inverted: this.__shouldInvert()
          }
        });
        config2.xAxis.forEach(
          (e2) => e2.update({
            opposite: this.__shouldFlipOpposite()
          })
        );
      }
      /** @private */
      __hideLegend(noLegend, config2) {
        if (noLegend === void 0 || !config2) {
          return;
        }
        if (config2.legend) {
          config2.legend.update({ enabled: !noLegend });
        } else {
          config2.legend = { enabled: !noLegend };
        }
      }
      /** @private */
      __updateTitle(title, config2) {
        if (title === void 0 || !config2) {
          return;
        }
        if (title && title.length > 0) {
          config2.title.update({ text: title });
        }
      }
      /** @private */
      __tooltipObserver(tooltip, config2) {
        if (tooltip === void 0 || !config2) {
          return;
        }
        config2.tooltip.update({ enabled: tooltip });
      }
      /** @private */
      __updateType(type, config2) {
        if (type === void 0 || !config2) {
          return;
        }
        if (type && type.length > 0) {
          config2.update({
            chart: { type }
          });
        }
      }
      /** @private */
      __updateSubtitle(subtitle, config2) {
        if (subtitle === void 0 || !config2) {
          return;
        }
        if (subtitle && subtitle.length > 0) {
          if (!config2.subtitle) {
            config2.setSubtitle({ text: subtitle });
          } else {
            config2.subtitle.update({ text: subtitle });
          }
        }
      }
      /** @private */
      __updateAdditionalOptions(options) {
        if (this.configuration && options.base) {
          this.updateConfiguration(options.base);
        }
      }
      /** @private */
      __isStackingValid() {
        if (["normal", "percent", null].indexOf(this.stacking) === -1) {
          this.__showWarn("stacking", '"normal", "percent" or null');
          return false;
        }
        return true;
      }
      /** @private */
      __stackingObserver(stacking, config2) {
        if (stacking === void 0 || !config2) {
          return;
        }
        if (!this.__isStackingValid()) {
          this.stacking = null;
          return;
        }
        config2.update({
          plotOptions: {
            series: { stacking }
          }
        });
      }
      /** @private */
      __chart3dObserver(chart3d, config2) {
        if (chart3d === void 0 || !config2) {
          return;
        }
        if (chart3d) {
          config2.update({
            chart: {
              options3d: {
                ...this._baseChart3d,
                ...this.additionalOptions && this.additionalOptions.chart && this.additionalOptions.chart.options3d,
                enabled: true
              }
            }
          });
        } else {
          config2.update({
            chart: {
              options3d: {
                enabled: false
              }
            }
          });
        }
      }
      /** @private */
      __polarObserver(polar, config2) {
        if (polar === void 0 || !config2) {
          return;
        }
        config2.update({
          chart: { polar }
        });
      }
      /** @private */
      __emptyTextObserver(emptyText, config2) {
        if (emptyText === void 0 || !config2) {
          return;
        }
        config2.update({
          lang: {
            noData: emptyText
          }
        });
        this.__updateNoDataElement(config2);
      }
      /**
       * Force the no data text element to become visible if the chart has no data.
       * This is necessary in cases where Highcharts does not update the element
       * automatically, for example when setting the language config
       * @private
       */
      __updateNoDataElement(config2) {
        const isEmpty = config2.series.every((e2) => e2.data.length === 0);
        if (isEmpty) {
          config2.hideNoData();
          config2.showNoData(this.emptyText);
        }
      }
      /** @private */
      __callChartFunction(functionName, ...args) {
        if (this.configuration) {
          const functionToCall = this.configuration[functionName];
          if (functionToCall && typeof functionToCall === "function") {
            args.forEach((arg) => inflateFunctions(arg));
            functionToCall.apply(this.configuration, args);
          }
        }
      }
      /** @private */
      __callSeriesFunction(functionName, seriesIndex, ...args) {
        if (this.configuration && this.configuration.series[seriesIndex]) {
          const series = this.configuration.series[seriesIndex];
          const functionToCall = series[functionName];
          if (functionToCall && typeof functionToCall === "function") {
            args.forEach((arg) => inflateFunctions(arg));
            functionToCall.apply(series, args);
          }
        }
      }
      /** @private */
      __callAxisFunction(functionName, axisCategory, axisIndex, ...args) {
        if (this.configuration) {
          let axes;
          switch (axisCategory) {
            case 0:
              axes = this.configuration.xAxis;
              break;
            case 1:
              axes = this.configuration.yAxis;
              break;
            case 2:
              axes = this.configuration.zAxis;
              break;
            case 3:
              axes = this.configuration.colorAxis;
              break;
          }
          if (axes && axes[axisIndex]) {
            const axis = axes[axisIndex];
            const functionToCall = axis[functionName];
            if (functionToCall && typeof functionToCall === "function") {
              args.forEach((arg) => inflateFunctions(arg));
              functionToCall.apply(axis, args);
            }
          }
        }
      }
      /** @private */
      __callPointFunction(functionName, seriesIndex, pointIndex, ...args) {
        if (this.configuration && this.configuration.series[seriesIndex] && this.configuration.series[seriesIndex].data[pointIndex]) {
          const point = this.configuration.series[seriesIndex].data[pointIndex];
          const functionToCall = point[functionName];
          if (functionToCall && typeof functionToCall === "function") {
            functionToCall.apply(point, args);
          }
        }
      }
      /**
       * Updates chart container and current chart style property depending on flex status
       * @private
       */
      __updateStyles() {
        const isFlex = getComputedStyle(this).flex !== "0 1 auto";
        if (isFlex) {
          this.$.chart.setAttribute("style", "flex: 1; ");
          let style = "";
          if (this.hasAttribute("style")) {
            style = this.getAttribute("style");
            if (!style.endsWith(";")) {
              style += ";";
            }
          }
          style += "display: flex;";
          this.setAttribute("style", style);
        } else {
          this.$.chart.setAttribute("style", "height:100%; width:100%;");
        }
      }
      /** @private */
      __showWarn(propertyName, acceptedValues) {
        console.warn(`<vaadin-chart> Acceptable values for "${propertyName}" are ${acceptedValues}`);
      }
      /** @private */
      __onRedraw() {
        this.__checkTurboMode();
      }
      /** @private */
      __checkTurboMode() {
        const isDevelopmentMode = !!window.Vaadin.developmentMode;
        if (!this.configuration || !isDevelopmentMode || this.__turboModeWarningAlreadyLogged) {
          return;
        }
        const exceedsTurboThreshold = this.configuration.series.some((series) => {
          const threshold = series.options && series.options.turboThreshold || 0;
          const dataLength = series.data.length;
          return threshold > 0 && dataLength > threshold;
        });
        if (exceedsTurboThreshold) {
          this.__turboModeWarningAlreadyLogged = true;
          console.warn(
            "<vaadin-chart> Turbo mode has been enabled for one or more series, because the number of data items exceeds the configured threshold. Turbo mode improves the performance of charts with lots of data, but is not compatible with every type of series. Please consult the documentation on compatibility, or how to disable turbo mode."
          );
        }
      }
    }
    defineCustomElement(Chart);
    registerStyles$1(
      "vaadin-checkbox",
      css$e`
    :host {
      color: var(--vaadin-checkbox-label-color, var(--lumo-body-text-color));
      font-size: var(--vaadin-checkbox-label-font-size, var(--lumo-font-size-m));
      font-family: var(--lumo-font-family);
      line-height: var(--lumo-line-height-s);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      cursor: default;
      outline: none;
      --_checkbox-size: var(--vaadin-checkbox-size, calc(var(--lumo-size-m) / 2));
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
      --_invalid-background: var(--vaadin-input-field-invalid-background, var(--lumo-error-color-10pct));
    }

    [part='label'] {
      display: flex;
      position: relative;
      max-width: max-content;
    }

    :host([has-label]) ::slotted(label) {
      padding: var(
        --vaadin-checkbox-label-padding,
        var(--lumo-space-xs) var(--lumo-space-s) var(--lumo-space-xs) var(--lumo-space-xs)
      );
    }

    :host([dir='rtl'][has-label]) ::slotted(label) {
      padding: var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-s);
    }

    :host([has-label][required]) ::slotted(label) {
      padding-inline-end: var(--lumo-space-m);
    }

    [part='checkbox'] {
      width: var(--_checkbox-size);
      height: var(--_checkbox-size);
      margin: var(--lumo-space-xs);
      position: relative;
      border-radius: var(--vaadin-checkbox-border-radius, var(--lumo-border-radius-s));
      background: var(--vaadin-checkbox-background, var(--lumo-contrast-20pct));
      transition: transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2), background-color 0.15s;
      cursor: var(--lumo-clickable-cursor);
      /* Default field border color */
      --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
    }

    :host([indeterminate]),
    :host([checked]) {
      --vaadin-input-field-border-color: transparent;
    }

    :host([indeterminate]) [part='checkbox'],
    :host([checked]) [part='checkbox'] {
      background-color: var(--_selection-color);
    }

    /* Checkmark */
    [part='checkbox']::after {
      pointer-events: none;
      font-family: 'lumo-icons';
      content: var(--vaadin-checkbox-checkmark-char, var(--lumo-icons-checkmark));
      color: var(--vaadin-checkbox-checkmark-color, var(--lumo-primary-contrast-color));
      font-size: var(--vaadin-checkbox-checkmark-size, calc(var(--_checkbox-size) + 2px));
      line-height: 1;
      position: absolute;
      top: -1px;
      left: -1px;
      contain: content;
      opacity: 0;
    }

    :host([checked]) [part='checkbox']::after {
      opacity: 1;
    }

    :host([readonly]:not([checked]):not([indeterminate])) {
      color: var(--lumo-secondary-text-color);
    }

    :host([readonly]:not([checked]):not([indeterminate])) [part='checkbox'] {
      background: transparent;
      box-shadow: none;
    }

    :host([readonly]:not([checked]):not([indeterminate])) [part='checkbox']::after {
      content: '';
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      border-radius: inherit;
      top: 0;
      left: 0;
      opacity: 1;
      border: var(--vaadin-input-field-readonly-border, 1px dashed var(--lumo-contrast-50pct));
    }

    /* Indeterminate checkmark */
    :host([indeterminate]) [part='checkbox']::after {
      content: var(--vaadin-checkbox-checkmark-char-indeterminate, '');
      opacity: 1;
      top: 45%;
      height: 10%;
      left: 22%;
      right: 22%;
      width: auto;
      border: 0;
      background-color: var(--lumo-primary-contrast-color);
    }

    /* Focus ring */
    :host([focus-ring]) [part='checkbox'] {
      box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color),
        inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
    }

    :host([focus-ring][readonly]:not([checked]):not([indeterminate])) [part='checkbox'] {
      box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color);
    }

    /* Disabled */
    :host([disabled]) {
      pointer-events: none;
      --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
    }

    :host([disabled]) ::slotted(label) {
      color: inherit;
    }

    :host([disabled]) [part='checkbox'] {
      background-color: var(--lumo-contrast-10pct);
    }

    :host([disabled]) [part='checkbox']::after {
      color: var(--lumo-contrast-30pct);
    }

    :host([disabled]) [part='label'],
    :host([disabled]) [part='helper-text'] {
      color: var(--lumo-disabled-text-color);
      -webkit-text-fill-color: var(--lumo-disabled-text-color);
    }

    :host([indeterminate][disabled]) [part='checkbox']::after {
      background-color: var(--lumo-contrast-30pct);
    }

    :host([readonly][checked]) [part='checkbox'],
    :host([readonly][indeterminate]) [part='checkbox'] {
      background-color: var(--vaadin-checkbox-readonly-checked-background, var(--lumo-contrast-70pct));
    }

    /* Used for activation "halo" */
    [part='checkbox']::before {
      pointer-events: none;
      color: transparent;
      width: 100%;
      height: 100%;
      line-height: var(--_checkbox-size);
      border-radius: inherit;
      background-color: inherit;
      transform: scale(1.4);
      opacity: 0;
      transition: transform 0.1s, opacity 0.8s;
    }

    /* Hover */
    :host(:not([checked]):not([indeterminate]):not([disabled]):not([readonly]):not([invalid]):hover) [part='checkbox'] {
      background: var(--vaadin-checkbox-background-hover, var(--lumo-contrast-30pct));
    }

    /* Disable hover for touch devices */
    @media (pointer: coarse) {
      /* prettier-ignore */
      :host(:not([checked]):not([indeterminate]):not([disabled]):not([readonly]):not([invalid]):hover) [part='checkbox'] {
        background: var(--vaadin-checkbox-background, var(--lumo-contrast-20pct));
      }
    }

    /* Active */
    :host([active]) [part='checkbox'] {
      transform: scale(0.9);
      transition-duration: 0.05s;
    }

    :host([active][checked]) [part='checkbox'] {
      transform: scale(1.1);
    }

    :host([active]:not([checked])) [part='checkbox']::before {
      transition-duration: 0.01s, 0.01s;
      transform: scale(0);
      opacity: 0.4;
    }

    /* Required */
    :host([required]) [part='required-indicator'] {
      position: absolute;
      top: var(--lumo-space-xs);
      right: var(--lumo-space-xs);
    }

    :host([required][dir='rtl']) [part='required-indicator'] {
      right: auto;
      left: var(--lumo-space-xs);
    }

    :host([required]) [part='required-indicator']::after {
      content: var(--lumo-required-field-indicator, '\\2022');
      transition: opacity 0.2s;
      color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
      width: 1em;
      text-align: center;
    }

    /* Invalid */
    :host([invalid]) {
      --vaadin-input-field-border-color: var(--lumo-error-color);
    }

    :host([invalid]) [part='checkbox'] {
      background: var(--_invalid-background);
      background-image: linear-gradient(var(--_invalid-background) 0%, var(--_invalid-background) 100%);
    }

    :host([invalid]:hover) [part='checkbox'] {
      background-image: linear-gradient(var(--_invalid-background) 0%, var(--_invalid-background) 100%),
        linear-gradient(var(--_invalid-background) 0%, var(--_invalid-background) 100%);
    }

    :host([invalid][focus-ring]) {
      --_focus-ring-color: var(--lumo-error-color-50pct);
    }

    :host([invalid]) [part='required-indicator']::after {
      color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
    }

    /* Error message */
    [part='error-message'] {
      font-size: var(--vaadin-input-field-error-font-size, var(--lumo-font-size-xs));
      line-height: var(--lumo-line-height-xs);
      font-weight: var(--vaadin-input-field-error-font-weight, 400);
      color: var(--vaadin-input-field-error-color, var(--lumo-error-text-color));
      will-change: max-height;
      transition: 0.4s max-height;
      max-height: 5em;
      padding-inline-start: var(--lumo-space-xs);
    }

    :host([has-error-message]) [part='error-message']::after,
    :host([has-helper]) [part='helper-text']::after {
      content: '';
      display: block;
      height: 0.4em;
    }

    :host(:not([invalid])) [part='error-message'] {
      max-height: 0;
      overflow: hidden;
    }

    /* Helper */
    [part='helper-text'] {
      display: block;
      color: var(--vaadin-input-field-helper-color, var(--lumo-secondary-text-color));
      font-size: var(--vaadin-input-field-helper-font-size, var(--lumo-font-size-xs));
      line-height: var(--lumo-line-height-xs);
      font-weight: var(--vaadin-input-field-helper-font-weight, 400);
      margin-left: calc(var(--lumo-border-radius-m) / 4);
      transition: color 0.2s;
      padding-inline-start: var(--lumo-space-xs);
    }

    :host(:hover:not([readonly])) [part='helper-text'] {
      color: var(--lumo-body-text-color);
    }

    :host([has-error-message]) ::slotted(label),
    :host([has-helper]) ::slotted(label) {
      padding-bottom: 0;
    }
  `,
      { moduleId: "lumo-checkbox" }
    );
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const CheckedMixin = dedupingMixin(
      (superclass) => class CheckedMixinClass extends DelegateStateMixin(DisabledMixin(InputMixin(superclass))) {
        static get properties() {
          return {
            /**
             * True if the element is checked.
             * @type {boolean}
             */
            checked: {
              type: Boolean,
              value: false,
              notify: true,
              reflectToAttribute: true
            }
          };
        }
        static get delegateProps() {
          return [...super.delegateProps, "checked"];
        }
        /**
         * @param {Event} event
         * @protected
         * @override
         */
        _onChange(event) {
          const input = event.target;
          this._toggleChecked(input.checked);
        }
        /** @protected */
        _toggleChecked(checked) {
          this.checked = checked;
        }
      }
    );
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const CheckboxMixin = (superclass) => class CheckboxMixinClass extends FieldMixin(CheckedMixin(DelegateFocusMixin(ActiveMixin(superclass)))) {
      static get properties() {
        return {
          /**
           * True if the checkbox is in the indeterminate state which means
           * it is not possible to say whether it is checked or unchecked.
           * The state is reset once the user switches the checkbox by hand.
           *
           * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Indeterminate_state_checkboxes
           *
           * @type {boolean}
           */
          indeterminate: {
            type: Boolean,
            notify: true,
            value: false,
            reflectToAttribute: true
          },
          /**
           * The name of the checkbox.
           *
           * @type {string}
           */
          name: {
            type: String,
            value: ""
          },
          /**
           * When true, the user cannot modify the value of the checkbox.
           * The difference between `disabled` and `readonly` is that the
           * read-only checkbox remains focusable, is announced by screen
           * readers and its value can be submitted as part of the form.
           */
          readonly: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          /**
           * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
           *
           * @override
           * @protected
           */
          tabindex: {
            type: Number,
            value: 0,
            reflectToAttribute: true
          }
        };
      }
      static get observers() {
        return ["__readonlyChanged(readonly, inputElement)"];
      }
      /** @override */
      static get delegateProps() {
        return [...super.delegateProps, "indeterminate"];
      }
      /** @override */
      static get delegateAttrs() {
        return [...super.delegateAttrs, "name", "invalid"];
      }
      constructor() {
        super();
        this._setType("checkbox");
        this._boundOnInputClick = this._onInputClick.bind(this);
        this.value = "on";
      }
      /** @protected */
      ready() {
        super.ready();
        this.addController(
          new InputController(this, (input) => {
            this._setInputElement(input);
            this._setFocusElement(input);
            this.stateTarget = input;
            this.ariaTarget = input;
          })
        );
        this.addController(new LabelledInputController(this.inputElement, this._labelController));
        this._createMethodObserver("_checkedChanged(checked)");
      }
      /**
       * Override method inherited from `ActiveMixin` to prevent setting `active`
       * attribute when readonly, or when clicking a link placed inside the label,
       * or when clicking slotted helper or error message element.
       *
       * @param {Event} event
       * @return {boolean}
       * @protected
       * @override
       */
      _shouldSetActive(event) {
        if (this.readonly || event.target.localName === "a" || event.target === this._helperNode || event.target === this._errorNode) {
          return false;
        }
        return super._shouldSetActive(event);
      }
      /**
       * Override method inherited from `InputMixin`.
       * @param {!HTMLElement} input
       * @protected
       * @override
       */
      _addInputListeners(input) {
        super._addInputListeners(input);
        input.addEventListener("click", this._boundOnInputClick);
      }
      /**
       * Override method inherited from `InputMixin`.
       * @param {!HTMLElement} input
       * @protected
       * @override
       */
      _removeInputListeners(input) {
        super._removeInputListeners(input);
        input.removeEventListener("click", this._boundOnInputClick);
      }
      /** @private */
      _onInputClick(event) {
        if (this.readonly) {
          event.preventDefault();
        }
      }
      /** @private */
      __readonlyChanged(readonly, inputElement) {
        if (!inputElement) {
          return;
        }
        if (readonly) {
          inputElement.setAttribute("aria-readonly", "true");
        } else {
          inputElement.removeAttribute("aria-readonly");
        }
      }
      /**
       * Override method inherited from `CheckedMixin` to reset
       * `indeterminate` state checkbox is toggled by the user.
       *
       * @param {boolean} checked
       * @protected
       * @override
       */
      _toggleChecked(checked) {
        if (this.indeterminate) {
          this.indeterminate = false;
        }
        super._toggleChecked(checked);
      }
      /**
       * @override
       * @return {boolean}
       */
      checkValidity() {
        return !this.required || !!this.checked;
      }
      /**
       * Override method inherited from `FocusMixin` to validate on blur.
       * @param {boolean} focused
       * @protected
       */
      _setFocused(focused) {
        super._setFocused(focused);
        if (!focused && document.hasFocus()) {
          this.validate();
        }
      }
      /** @private */
      _checkedChanged(checked) {
        if (checked || this.__oldChecked) {
          this.validate();
        }
        this.__oldChecked = checked;
      }
      /**
       * Override an observer from `FieldMixin`
       * to validate when required is removed.
       *
       * @protected
       * @override
       */
      _requiredChanged(required) {
        super._requiredChanged(required);
        if (required === false) {
          this.validate();
        }
      }
      /** @private */
      _onRequiredIndicatorClick() {
        this._labelNode.click();
      }
      /**
       * Fired when the checkbox is checked or unchecked by the user.
       *
       * @event change
       */
    };
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const checkboxStyles = css$e`
  :host {
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([disabled]) {
    -webkit-tap-highlight-color: transparent;
  }

  .vaadin-checkbox-container {
    display: grid;
    grid-template-columns: auto 1fr;
    align-items: baseline;
  }

  [part='checkbox'],
  ::slotted(input),
  [part='label'] {
    grid-row: 1;
  }

  [part='checkbox'],
  ::slotted(input) {
    grid-column: 1;
  }

  [part='helper-text'],
  [part='error-message'] {
    grid-column: 2;
  }

  :host(:not([has-helper])) [part='helper-text'],
  :host(:not([has-error-message])) [part='error-message'] {
    display: none;
  }

  [part='checkbox'] {
    width: var(--vaadin-checkbox-size, 1em);
    height: var(--vaadin-checkbox-size, 1em);
    --_input-border-width: var(--vaadin-input-field-border-width, 0);
    --_input-border-color: var(--vaadin-input-field-border-color, transparent);
    box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
  }

  [part='checkbox']::before {
    display: block;
    content: '\\202F';
    line-height: var(--vaadin-checkbox-size, 1em);
    contain: paint;
  }

  /* visually hidden */
  ::slotted(input) {
    opacity: 0;
    cursor: inherit;
    margin: 0;
    align-self: stretch;
    -webkit-appearance: none;
    width: initial;
    height: initial;
  }

  @media (forced-colors: active) {
    [part='checkbox'] {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([disabled]) [part='checkbox'],
    :host([disabled]) [part='checkbox']::after {
      outline-color: GrayText;
    }

    :host(:is([checked], [indeterminate])) [part='checkbox']::after {
      outline: 1px solid;
      outline-offset: -1px;
      border-radius: inherit;
    }

    :host([focused]) [part='checkbox'],
    :host([focused]) [part='checkbox']::after {
      outline-width: 2px;
    }
  }
`;
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-checkbox", checkboxStyles, { moduleId: "vaadin-checkbox-styles" });
    class Checkbox extends CheckboxMixin(ElementMixin(ThemableMixin(PolymerElement))) {
      static get is() {
        return "vaadin-checkbox";
      }
      static get template() {
        return html`
      <div class="vaadin-checkbox-container">
        <div part="checkbox" aria-hidden="true"></div>
        <slot name="input"></slot>
        <div part="label">
          <slot name="label"></slot>
          <div part="required-indicator" on-click="_onRequiredIndicatorClick"></div>
        </div>
        <div part="helper-text">
          <slot name="helper"></slot>
        </div>
        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
      <slot name="tooltip"></slot>
    `;
      }
      /** @protected */
      ready() {
        super.ready();
        this._tooltipController = new TooltipController(this);
        this._tooltipController.setAriaTarget(this.inputElement);
        this.addController(this._tooltipController);
      }
    }
    defineCustomElement(Checkbox);
    const checkboxGroup = css$e`
  :host {
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-m);
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: var(--lumo-space-xs) 0;
  }

  :host::before {
    /* Effective height of vaadin-checkbox */
    height: var(--lumo-size-s);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  :host([theme~='vertical']) [part='group-field'] {
    flex-direction: column;
  }

  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([focused]:not([disabled])) [part='label'] {
    color: var(--lumo-primary-text-color);
  }

  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'],
  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'] {
      color: var(--lumo-secondary-text-color);
    }
  }
`;
    registerStyles$1("vaadin-checkbox-group", [requiredField, helper, checkboxGroup], {
      moduleId: "lumo-checkbox-group"
    });
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const CheckboxGroupMixin = (superclass) => class CheckboxGroupMixinClass extends FieldMixin(FocusMixin(DisabledMixin(superclass))) {
      static get properties() {
        return {
          /**
           * An array containing values of the currently checked checkboxes.
           *
           * The array is immutable so toggling checkboxes always results in
           * creating a new array.
           *
           * @type {!Array<!string>}
           */
          value: {
            type: Array,
            value: () => [],
            notify: true,
            sync: true,
            observer: "__valueChanged"
          },
          /**
           * When true, the user cannot modify the value of the checkbox group.
           * The difference between `disabled` and `readonly` is that in the
           * read-only checkbox group, all the checkboxes are also read-only,
           * and therefore remain focusable and announced by screen readers.
           */
          readonly: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            observer: "__readonlyChanged"
          }
        };
      }
      constructor() {
        super();
        this.__registerCheckbox = this.__registerCheckbox.bind(this);
        this.__unregisterCheckbox = this.__unregisterCheckbox.bind(this);
        this.__onCheckboxCheckedChanged = this.__onCheckboxCheckedChanged.bind(this);
        this._tooltipController = new TooltipController(this);
        this._tooltipController.addEventListener("tooltip-changed", (event) => {
          const tooltip = event.detail.node;
          if (tooltip && tooltip.isConnected) {
            const inputs = this.__checkboxes.map((checkbox) => checkbox.inputElement);
            this._tooltipController.setAriaTarget(inputs);
          } else {
            this._tooltipController.setAriaTarget([]);
          }
        });
      }
      /**
       * A collection of the checkboxes.
       *
       * @return {!Array<!Checkbox>}
       * @private
       */
      get __checkboxes() {
        return this.__filterCheckboxes([...this.children]);
      }
      /** @protected */
      ready() {
        super.ready();
        this.ariaTarget = this;
        this.setAttribute("role", "group");
        const slot = this.shadowRoot.querySelector("slot:not([name])");
        this._observer = new SlotObserver(slot, ({ addedNodes, removedNodes }) => {
          const addedCheckboxes = this.__filterCheckboxes(addedNodes);
          const removedCheckboxes = this.__filterCheckboxes(removedNodes);
          addedCheckboxes.forEach(this.__registerCheckbox);
          removedCheckboxes.forEach(this.__unregisterCheckbox);
          const inputs = this.__checkboxes.map((checkbox) => checkbox.inputElement);
          this._tooltipController.setAriaTarget(inputs);
          this.__warnOfCheckboxesWithoutValue(addedCheckboxes);
        });
        this.addController(this._tooltipController);
      }
      /**
       * Override method inherited from `ValidateMixin`
       * to validate the value array.
       *
       * @override
       * @return {boolean}
       */
      checkValidity() {
        return !this.required || this.value.length > 0;
      }
      /**
       * @param {!Array<!Node>} nodes
       * @return {!Array<!Checkbox>}
       * @private
       */
      __filterCheckboxes(nodes) {
        return nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && node.localName === "vaadin-checkbox");
      }
      /**
       * @param {!Array<!Checkbox>} checkboxes
       * @private
       */
      __warnOfCheckboxesWithoutValue(checkboxes) {
        const hasCheckboxesWithoutValue = checkboxes.some((checkbox) => {
          const { value } = checkbox;
          return !checkbox.hasAttribute("value") && (!value || value === "on");
        });
        if (hasCheckboxesWithoutValue) {
          console.warn("Please provide the value attribute to all the checkboxes inside the checkbox group.");
        }
      }
      /**
       * Registers the checkbox after adding it to the group.
       *
       * @param {!Checkbox} checkbox
       * @private
       */
      __registerCheckbox(checkbox) {
        checkbox.addEventListener("checked-changed", this.__onCheckboxCheckedChanged);
        if (this.disabled) {
          checkbox.disabled = true;
        }
        if (this.readonly) {
          checkbox.readonly = true;
        }
        if (checkbox.checked) {
          this.__addCheckboxToValue(checkbox.value);
        } else if (this.value.includes(checkbox.value)) {
          checkbox.checked = true;
        }
      }
      /**
       * Unregisters the checkbox before removing it from the group.
       *
       * @param {!Checkbox} checkbox
       * @private
       */
      __unregisterCheckbox(checkbox) {
        checkbox.removeEventListener("checked-changed", this.__onCheckboxCheckedChanged);
        if (checkbox.checked) {
          this.__removeCheckboxFromValue(checkbox.value);
        }
      }
      /**
       * Override method inherited from `DisabledMixin`
       * to propagate the `disabled` property to the checkboxes.
       *
       * @param {boolean} newValue
       * @param {boolean} oldValue
       * @override
       * @protected
       */
      _disabledChanged(newValue, oldValue) {
        super._disabledChanged(newValue, oldValue);
        if (!newValue && oldValue === void 0) {
          return;
        }
        if (oldValue !== newValue) {
          this.__checkboxes.forEach((checkbox) => {
            checkbox.disabled = newValue;
          });
        }
      }
      /**
       * @param {string} value
       * @private
       */
      __addCheckboxToValue(value) {
        if (!this.value.includes(value)) {
          this.value = [...this.value, value];
        }
      }
      /**
       * @param {string} value
       * @private
       */
      __removeCheckboxFromValue(value) {
        if (this.value.includes(value)) {
          this.value = this.value.filter((v) => v !== value);
        }
      }
      /**
       * @param {!CustomEvent} event
       * @private
       */
      __onCheckboxCheckedChanged(event) {
        const checkbox = event.target;
        if (checkbox.checked) {
          this.__addCheckboxToValue(checkbox.value);
        } else {
          this.__removeCheckboxFromValue(checkbox.value);
        }
      }
      /**
       * @param {string | null | undefined} value
       * @param {string | null | undefined} oldValue
       * @private
       */
      __valueChanged(value, oldValue) {
        if (value.length === 0 && oldValue === void 0) {
          return;
        }
        this.toggleAttribute("has-value", value.length > 0);
        this.__checkboxes.forEach((checkbox) => {
          checkbox.checked = value.includes(checkbox.value);
        });
        if (oldValue !== void 0) {
          this.validate();
        }
      }
      /** @private */
      __readonlyChanged(readonly, oldReadonly) {
        if (readonly || oldReadonly) {
          this.__checkboxes.forEach((checkbox) => {
            checkbox.readonly = readonly;
          });
        }
      }
      /**
       * Override method inherited from `FocusMixin`
       * to prevent removing the `focused` attribute
       * when focus moves between checkboxes inside the group.
       *
       * @param {!FocusEvent} event
       * @return {boolean}
       * @protected
       */
      _shouldRemoveFocus(event) {
        return !this.contains(event.relatedTarget);
      }
      /**
       * Override method inherited from `FocusMixin`
       * to run validation when the group loses focus.
       *
       * @param {boolean} focused
       * @override
       * @protected
       */
      _setFocused(focused) {
        super._setFocused(focused);
        if (!focused && document.hasFocus()) {
          this.validate();
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const checkboxGroupStyles = css$e`
  :host {
    display: inline-flex;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  .vaadin-group-field-container {
    display: flex;
    flex-direction: column;
    width: 100%;
  }

  [part='group-field'] {
    display: flex;
    flex-wrap: wrap;
  }

  :host(:not([has-label])) [part='label'] {
    display: none;
  }
`;
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-checkbox-group", checkboxGroupStyles, { moduleId: "vaadin-checkbox-group-styles" });
    class CheckboxGroup extends CheckboxGroupMixin(ElementMixin(ThemableMixin(PolymerElement))) {
      static get is() {
        return "vaadin-checkbox-group";
      }
      static get template() {
        return html`
      <div class="vaadin-group-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div part="group-field">
          <slot></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
      }
    }
    defineCustomElement(CheckboxGroup);
    /**
    @license
    Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    class Debouncer {
      constructor() {
        this._asyncModule = null;
        this._callback = null;
        this._timer = null;
      }
      /**
       * Sets the scheduler; that is, a module with the Async interface,
       * a callback and optional arguments to be passed to the run function
       * from the async module.
       *
       * @param {!AsyncInterface} asyncModule Object with Async interface.
       * @param {function()} callback Callback to run.
       * @return {void}
       */
      setConfig(asyncModule, callback) {
        this._asyncModule = asyncModule;
        this._callback = callback;
        this._timer = this._asyncModule.run(() => {
          this._timer = null;
          debouncerQueue.delete(this);
          this._callback();
        });
      }
      /**
       * Cancels an active debouncer and returns a reference to itself.
       *
       * @return {void}
       */
      cancel() {
        if (this.isActive()) {
          this._cancelAsync();
          debouncerQueue.delete(this);
        }
      }
      /**
       * Cancels a debouncer's async callback.
       *
       * @return {void}
       */
      _cancelAsync() {
        if (this.isActive()) {
          this._asyncModule.cancel(
            /** @type {number} */
            this._timer
          );
          this._timer = null;
        }
      }
      /**
       * Flushes an active debouncer and returns a reference to itself.
       *
       * @return {void}
       */
      flush() {
        if (this.isActive()) {
          this.cancel();
          this._callback();
        }
      }
      /**
       * Returns true if the debouncer is active.
       *
       * @return {boolean} True if active.
       */
      isActive() {
        return this._timer != null;
      }
      /**
       * Creates a debouncer if no debouncer is passed as a parameter
       * or it cancels an active debouncer otherwise. The following
       * example shows how a debouncer can be called multiple times within a
       * microtask and "debounced" such that the provided callback function is
       * called once. Add this method to a custom element:
       *
       * ```js
       * import {microTask} from '@polymer/polymer/lib/utils/async.js';
       * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';
       * // ...
       *
       * _debounceWork() {
       *   this._debounceJob = Debouncer.debounce(this._debounceJob,
       *       microTask, () => this._doWork());
       * }
       * ```
       *
       * If the `_debounceWork` method is called multiple times within the same
       * microtask, the `_doWork` function will be called only once at the next
       * microtask checkpoint.
       *
       * Note: In testing it is often convenient to avoid asynchrony. To accomplish
       * this with a debouncer, you can use `enqueueDebouncer` and
       * `flush`. For example, extend the above example by adding
       * `enqueueDebouncer(this._debounceJob)` at the end of the
       * `_debounceWork` method. Then in a test, call `flush` to ensure
       * the debouncer has completed.
       *
       * @param {Debouncer?} debouncer Debouncer object.
       * @param {!AsyncInterface} asyncModule Object with Async interface
       * @param {function()} callback Callback to run.
       * @return {!Debouncer} Returns a debouncer object.
       */
      static debounce(debouncer, asyncModule, callback) {
        if (debouncer instanceof Debouncer) {
          debouncer._cancelAsync();
        } else {
          debouncer = new Debouncer();
        }
        debouncer.setConfig(asyncModule, callback);
        return debouncer;
      }
    }
    let debouncerQueue = /* @__PURE__ */ new Set();
    const enqueueDebouncer = function(debouncer) {
      debouncerQueue.add(debouncer);
    };
    const flushDebouncers = function() {
      const didFlush = Boolean(debouncerQueue.size);
      debouncerQueue.forEach((debouncer) => {
        try {
          debouncer.flush();
        } catch (e2) {
          setTimeout(() => {
            throw e2;
          });
        }
      });
      return didFlush;
    };
    /**
    @license
    Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    const flush = function() {
      let shadyDOM, debouncers;
      do {
        shadyDOM = window.ShadyDOM && ShadyDOM.flush();
        if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
          window.ShadyCSS.ScopingShim.flush();
        }
        debouncers = flushDebouncers();
      } while (shadyDOM || debouncers);
    };
    /**
    @license
    Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    let elementsHidden = false;
    function hideElementsGlobally() {
      if (legacyOptimizations && !useShadow) {
        if (!elementsHidden) {
          elementsHidden = true;
          const style = document.createElement("style");
          style.textContent = "dom-bind,dom-if,dom-repeat{display:none;}";
          document.head.appendChild(style);
        }
        return true;
      }
      return false;
    }
    /**
    @license
    Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    function mutablePropertyChange(inst, property, value, old, mutableData) {
      let isObject2;
      if (mutableData) {
        isObject2 = typeof value === "object" && value !== null;
        if (isObject2) {
          old = inst.__dataTemp[property];
        }
      }
      let shouldChange = old !== value && (old === old || value === value);
      if (isObject2 && shouldChange) {
        inst.__dataTemp[property] = value;
      }
      return shouldChange;
    }
    const MutableData = dedupingMixin((superClass) => {
      class MutableData2 extends superClass {
        /**
         * Overrides `PropertyEffects` to provide option for skipping
         * strict equality checking for Objects and Arrays.
         *
         * This method pulls the value to dirty check against from the `__dataTemp`
         * cache (rather than the normal `__data` cache) for Objects.  Since the temp
         * cache is cleared at the end of a turn, this implementation allows
         * side-effects of deep object changes to be processed by re-setting the
         * same object (using the temp cache as an in-turn backstop to prevent
         * cycles due to 2-way notification).
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         * @protected
         */
        _shouldPropertyChange(property, value, old) {
          return mutablePropertyChange(this, property, value, old, true);
        }
      }
      return MutableData2;
    });
    const OptionalMutableData = dedupingMixin((superClass) => {
      class OptionalMutableData2 extends superClass {
        /** @nocollapse */
        static get properties() {
          return {
            /**
             * Instance-level flag for configuring the dirty-checking strategy
             * for this element.  When true, Objects and Arrays will skip dirty
             * checking, otherwise strict equality checking will be used.
             */
            mutableData: Boolean
          };
        }
        /**
         * Overrides `PropertyEffects` to provide option for skipping
         * strict equality checking for Objects and Arrays.
         *
         * When `this.mutableData` is true on this instance, this method
         * pulls the value to dirty check against from the `__dataTemp` cache
         * (rather than the normal `__data` cache) for Objects.  Since the temp
         * cache is cleared at the end of a turn, this implementation allows
         * side-effects of deep object changes to be processed by re-setting the
         * same object (using the temp cache as an in-turn backstop to prevent
         * cycles due to 2-way notification).
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         * @protected
         */
        _shouldPropertyChange(property, value, old) {
          return mutablePropertyChange(this, property, value, old, this.mutableData);
        }
      }
      return OptionalMutableData2;
    });
    MutableData._mutablePropertyChange = mutablePropertyChange;
    /**
    @license
    Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    let newInstance = null;
    function HTMLTemplateElementExtension() {
      return newInstance;
    }
    HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
      constructor: {
        value: HTMLTemplateElementExtension,
        writable: true
      }
    });
    const DataTemplate = PropertyEffects(HTMLTemplateElementExtension);
    const MutableDataTemplate = MutableData(DataTemplate);
    function upgradeTemplate(template2, constructor) {
      newInstance = template2;
      Object.setPrototypeOf(template2, constructor.prototype);
      new constructor();
      newInstance = null;
    }
    const templateInstanceBase = PropertyEffects(class {
    });
    function showHideChildren(hide, children) {
      for (let i = 0; i < children.length; i++) {
        let n = children[i];
        if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
          if (n.nodeType === Node.TEXT_NODE) {
            if (hide) {
              n.__polymerTextContent__ = n.textContent;
              n.textContent = "";
            } else {
              n.textContent = n.__polymerTextContent__;
            }
          } else if (n.localName === "slot") {
            if (hide) {
              n.__polymerReplaced__ = document.createComment("hidden-slot");
              wrap$e(wrap$e(n).parentNode).replaceChild(n.__polymerReplaced__, n);
            } else {
              const replace = n.__polymerReplaced__;
              if (replace) {
                wrap$e(wrap$e(replace).parentNode).replaceChild(n, replace);
              }
            }
          } else if (n.style) {
            if (hide) {
              n.__polymerDisplay__ = n.style.display;
              n.style.display = "none";
            } else {
              n.style.display = n.__polymerDisplay__;
            }
          }
        }
        n.__hideTemplateChildren__ = hide;
        if (n._showHideChildren) {
          n._showHideChildren(hide);
        }
      }
    }
    class TemplateInstanceBase extends templateInstanceBase {
      constructor(props) {
        super();
        this._configureProperties(props);
        this.root = this._stampTemplate(this.__dataHost);
        let children = [];
        this.children = /** @type {!NodeList} */
        children;
        for (let n = this.root.firstChild; n; n = n.nextSibling) {
          children.push(n);
          n.__templatizeInstance = this;
        }
        if (this.__templatizeOwner && this.__templatizeOwner.__hideTemplateChildren__) {
          this._showHideChildren(true);
        }
        let options = this.__templatizeOptions;
        if (props && options.instanceProps || !options.instanceProps) {
          this._enableProperties();
        }
      }
      /**
       * Configure the given `props` by calling `_setPendingProperty`. Also
       * sets any properties stored in `__hostProps`.
       * @private
       * @param {Object} props Object of property name-value pairs to set.
       * @return {void}
       */
      _configureProperties(props) {
        let options = this.__templatizeOptions;
        if (options.forwardHostProp) {
          for (let hprop in this.__hostProps) {
            this._setPendingProperty(hprop, this.__dataHost["_host_" + hprop]);
          }
        }
        for (let iprop in props) {
          this._setPendingProperty(iprop, props[iprop]);
        }
      }
      /**
       * Forwards a host property to this instance.  This method should be
       * called on instances from the `options.forwardHostProp` callback
       * to propagate changes of host properties to each instance.
       *
       * Note this method enqueues the change, which are flushed as a batch.
       *
       * @param {string} prop Property or path name
       * @param {*} value Value of the property to forward
       * @return {void}
       */
      forwardHostProp(prop, value) {
        if (this._setPendingPropertyOrPath(prop, value, false, true)) {
          this.__dataHost._enqueueClient(this);
        }
      }
      /**
       * Override point for adding custom or simulated event handling.
       *
       * @override
       * @param {!Node} node Node to add event listener to
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to add
       * @return {void}
       */
      _addEventListenerToNode(node, eventName, handler) {
        if (this._methodHost && this.__templatizeOptions.parentModel) {
          this._methodHost._addEventListenerToNode(node, eventName, (e2) => {
            e2.model = this;
            handler(e2);
          });
        } else {
          let templateHost = this.__dataHost.__dataHost;
          if (templateHost) {
            templateHost._addEventListenerToNode(node, eventName, handler);
          }
        }
      }
      /**
       * Shows or hides the template instance top level child elements. For
       * text nodes, `textContent` is removed while "hidden" and replaced when
       * "shown."
       * @param {boolean} hide Set to true to hide the children;
       * set to false to show them.
       * @return {void}
       * @protected
       */
      _showHideChildren(hide) {
        showHideChildren(hide, this.children);
      }
      /**
       * Overrides default property-effects implementation to intercept
       * textContent bindings while children are "hidden" and cache in
       * private storage for later retrieval.
       *
       * @override
       * @param {!Node} node The node to set a property on
       * @param {string} prop The property to set
       * @param {*} value The value to set
       * @return {void}
       * @protected
       */
      _setUnmanagedPropertyToNode(node, prop, value) {
        if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == "textContent") {
          node.__polymerTextContent__ = value;
        } else {
          super._setUnmanagedPropertyToNode(node, prop, value);
        }
      }
      /**
       * Find the parent model of this template instance.  The parent model
       * is either another templatize instance that had option `parentModel: true`,
       * or else the host element.
       *
       * @return {!Polymer_PropertyEffects} The parent model of this instance
       */
      get parentModel() {
        let model = this.__parentModel;
        if (!model) {
          let options;
          model = this;
          do {
            model = model.__dataHost.__dataHost;
          } while ((options = model.__templatizeOptions) && !options.parentModel);
          this.__parentModel = model;
        }
        return model;
      }
      /**
       * Stub of HTMLElement's `dispatchEvent`, so that effects that may
       * dispatch events safely no-op.
       *
       * @param {Event} event Event to dispatch
       * @return {boolean} Always true.
       * @override
       */
      dispatchEvent(event) {
        return true;
      }
    }
    TemplateInstanceBase.prototype.__dataHost;
    TemplateInstanceBase.prototype.__templatizeOptions;
    TemplateInstanceBase.prototype._methodHost;
    TemplateInstanceBase.prototype.__templatizeOwner;
    TemplateInstanceBase.prototype.__hostProps;
    const MutableTemplateInstanceBase = MutableData(
      // This cast shouldn't be neccessary, but Closure doesn't understand that
      // TemplateInstanceBase is a constructor function.
      /** @type {function(new:TemplateInstanceBase)} */
      TemplateInstanceBase
    );
    function findMethodHost(template2) {
      let templateHost = template2.__dataHost;
      return templateHost && templateHost._methodHost || templateHost;
    }
    function createTemplatizerClass(template2, templateInfo, options) {
      let templatizerBase = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
      if (templatize.mixin) {
        templatizerBase = templatize.mixin(templatizerBase);
      }
      let klass = class extends templatizerBase {
      };
      klass.prototype.__templatizeOptions = options;
      klass.prototype._bindTemplate(template2);
      addNotifyEffects(klass, template2, templateInfo, options);
      return klass;
    }
    function addPropagateEffects(target, templateInfo, options, methodHost) {
      let userForwardHostProp = options.forwardHostProp;
      if (userForwardHostProp && templateInfo.hasHostProps) {
        const isTemplate = target.localName == "template";
        let klass = templateInfo.templatizeTemplateClass;
        if (!klass) {
          if (isTemplate) {
            let templatizedBase = options.mutableData ? MutableDataTemplate : DataTemplate;
            class TemplatizedTemplate extends templatizedBase {
            }
            klass = templateInfo.templatizeTemplateClass = TemplatizedTemplate;
          } else {
            const templatizedBase = target.constructor;
            class TemplatizedTemplateExtension extends templatizedBase {
            }
            klass = templateInfo.templatizeTemplateClass = TemplatizedTemplateExtension;
          }
          let hostProps = templateInfo.hostProps;
          for (let prop in hostProps) {
            klass.prototype._addPropertyEffect(
              "_host_" + prop,
              klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE,
              { fn: createForwardHostPropEffect(prop, userForwardHostProp) }
            );
            klass.prototype._createNotifyingProperty("_host_" + prop);
          }
          if (legacyWarnings && methodHost) {
            warnOnUndeclaredProperties(templateInfo, options, methodHost);
          }
        }
        if (target.__dataProto) {
          Object.assign(target.__data, target.__dataProto);
        }
        if (isTemplate) {
          upgradeTemplate(target, klass);
          target.__dataTemp = {};
          target.__dataPending = null;
          target.__dataOld = null;
          target._enableProperties();
        } else {
          Object.setPrototypeOf(target, klass.prototype);
          const hostProps = templateInfo.hostProps;
          for (let prop in hostProps) {
            prop = "_host_" + prop;
            if (prop in target) {
              const val = target[prop];
              delete target[prop];
              target.__data[prop] = val;
            }
          }
        }
      }
    }
    function createForwardHostPropEffect(hostProp, userForwardHostProp) {
      return function forwardHostProp(template2, prop, props) {
        userForwardHostProp.call(
          template2.__templatizeOwner,
          prop.substring("_host_".length),
          props[prop]
        );
      };
    }
    function addNotifyEffects(klass, template2, templateInfo, options) {
      let hostProps = templateInfo.hostProps || {};
      for (let iprop in options.instanceProps) {
        delete hostProps[iprop];
        let userNotifyInstanceProp = options.notifyInstanceProp;
        if (userNotifyInstanceProp) {
          klass.prototype._addPropertyEffect(
            iprop,
            klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
            { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) }
          );
        }
      }
      if (options.forwardHostProp && template2.__dataHost) {
        for (let hprop in hostProps) {
          if (!templateInfo.hasHostProps) {
            templateInfo.hasHostProps = true;
          }
          klass.prototype._addPropertyEffect(
            hprop,
            klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
            { fn: createNotifyHostPropEffect() }
          );
        }
      }
    }
    function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
      return function notifyInstanceProp(inst, prop, props) {
        userNotifyInstanceProp.call(
          inst.__templatizeOwner,
          inst,
          prop,
          props[prop]
        );
      };
    }
    function createNotifyHostPropEffect() {
      return function notifyHostProp(inst, prop, props) {
        inst.__dataHost._setPendingPropertyOrPath("_host_" + prop, props[prop], true, true);
      };
    }
    function templatize(template2, owner, options) {
      if (strictTemplatePolicy && !findMethodHost(template2)) {
        throw new Error("strictTemplatePolicy: template owner not trusted");
      }
      options = /** @type {!TemplatizeOptions} */
      options || {};
      if (template2.__templatizeOwner) {
        throw new Error("A <template> can only be templatized once");
      }
      template2.__templatizeOwner = owner;
      const ctor = owner ? owner.constructor : TemplateInstanceBase;
      let templateInfo = ctor._parseTemplate(template2);
      let baseClass = templateInfo.templatizeInstanceClass;
      if (!baseClass) {
        baseClass = createTemplatizerClass(template2, templateInfo, options);
        templateInfo.templatizeInstanceClass = baseClass;
      }
      const methodHost = findMethodHost(template2);
      addPropagateEffects(template2, templateInfo, options, methodHost);
      let klass = class TemplateInstance extends baseClass {
      };
      klass.prototype._methodHost = methodHost;
      klass.prototype.__dataHost = /** @type {!DataTemplate} */
      template2;
      klass.prototype.__templatizeOwner = /** @type {!Object} */
      owner;
      klass.prototype.__hostProps = templateInfo.hostProps;
      klass = /** @type {function(new:TemplateInstanceBase)} */
      klass;
      return klass;
    }
    function warnOnUndeclaredProperties(templateInfo, options, methodHost) {
      const declaredProps = methodHost.constructor._properties;
      const { propertyEffects } = templateInfo;
      const { instanceProps } = options;
      for (let prop in propertyEffects) {
        if (!declaredProps[prop] && !(instanceProps && instanceProps[prop])) {
          const effects = propertyEffects[prop];
          for (let i = 0; i < effects.length; i++) {
            const { part } = effects[i].info;
            if (!(part.signature && part.signature.static)) {
              console.warn(`Property '${prop}' used in template but not declared in 'properties'; attribute will not be observed.`);
              break;
            }
          }
        }
      }
    }
    function modelForElement(template2, node) {
      let model;
      while (node) {
        if (model = node.__dataHost ? node : node.__templatizeInstance) {
          if (model.__dataHost != template2) {
            node = model.__dataHost;
          } else {
            return model;
          }
        } else {
          node = wrap$e(node).parentNode;
        }
      }
      return null;
    }
    /**
    @license
    Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    class DomIfBase extends PolymerElement {
      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      static get is() {
        return "dom-if";
      }
      static get template() {
        return null;
      }
      static get properties() {
        return {
          /**
           * Fired whenever DOM is added or removed/hidden by this template (by
           * default, rendering occurs lazily).  To force immediate rendering, call
           * `render`.
           *
           * @event dom-change
           */
          /**
           * A boolean indicating whether this template should stamp.
           */
          if: {
            type: Boolean,
            observer: "__debounceRender"
          },
          /**
           * When true, elements will be removed from DOM and discarded when `if`
           * becomes false and re-created and added back to the DOM when `if`
           * becomes true.  By default, stamped elements will be hidden but left
           * in the DOM when `if` becomes false, which is generally results
           * in better performance.
           */
          restamp: {
            type: Boolean,
            observer: "__debounceRender"
          },
          /**
           * When the global `suppressTemplateNotifications` setting is used, setting
           * `notifyDomChange: true` will enable firing `dom-change` events on this
           * element.
           */
          notifyDomChange: {
            type: Boolean
          }
        };
      }
      constructor() {
        super();
        this.__renderDebouncer = null;
        this._lastIf = false;
        this.__hideTemplateChildren__ = false;
        this.__template;
        this._templateInfo;
      }
      __debounceRender() {
        this.__renderDebouncer = Debouncer.debounce(
          this.__renderDebouncer,
          microTask$1,
          () => this.__render()
        );
        enqueueDebouncer(this.__renderDebouncer);
      }
      /**
       * @override
       * @return {void}
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        const parent = wrap$e(this).parentNode;
        if (!parent || parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !wrap$e(parent).host) {
          this.__teardownInstance();
        }
      }
      /**
       * @override
       * @return {void}
       */
      connectedCallback() {
        super.connectedCallback();
        if (!hideElementsGlobally()) {
          this.style.display = "none";
        }
        if (this.if) {
          this.__debounceRender();
        }
      }
      /**
       * Ensures a template has been assigned to `this.__template`.  If it has not
       * yet been, it querySelectors for it in its children and if it does not yet
       * exist (e.g. in parser-generated case), opens a mutation observer and
       * waits for it to appear (returns false if it has not yet been found,
       * otherwise true).  In the `removeNestedTemplates` case, the "template" will
       * be the `dom-if` element itself.
       *
       * @return {boolean} True when a template has been found, false otherwise
       */
      __ensureTemplate() {
        if (!this.__template) {
          const thisAsTemplate = (
            /** @type {!HTMLTemplateElement} */
            /** @type {!HTMLElement} */
            this
          );
          let template2 = thisAsTemplate._templateInfo ? thisAsTemplate : (
            /** @type {!HTMLTemplateElement} */
            wrap$e(thisAsTemplate).querySelector("template")
          );
          if (!template2) {
            let observer = new MutationObserver(() => {
              if (wrap$e(this).querySelector("template")) {
                observer.disconnect();
                this.__render();
              } else {
                throw new Error("dom-if requires a <template> child");
              }
            });
            observer.observe(this, { childList: true });
            return false;
          }
          this.__template = template2;
        }
        return true;
      }
      /**
       * Ensures a an instance of the template has been created and inserted. This
       * method may return false if the template has not yet been found or if
       * there is no `parentNode` to insert the template into (in either case,
       * connection or the template-finding mutation observer firing will queue
       * another render, causing this method to be called again at a more
       * appropriate time).
       *
       * Subclasses should implement the following methods called here:
       * - `__hasInstance`
       * - `__createAndInsertInstance`
       * - `__getInstanceNodes`
       *
       * @return {boolean} True if the instance was created, false otherwise.
       */
      __ensureInstance() {
        let parentNode = wrap$e(this).parentNode;
        if (!this.__hasInstance()) {
          if (!parentNode) {
            return false;
          }
          if (!this.__ensureTemplate()) {
            return false;
          }
          this.__createAndInsertInstance(parentNode);
        } else {
          let children = this.__getInstanceNodes();
          if (children && children.length) {
            let lastChild = wrap$e(this).previousSibling;
            if (lastChild !== children[children.length - 1]) {
              for (let i = 0, n; i < children.length && (n = children[i]); i++) {
                wrap$e(parentNode).insertBefore(n, this);
              }
            }
          }
        }
        return true;
      }
      /**
       * Forces the element to render its content. Normally rendering is
       * asynchronous to a provoking change. This is done for efficiency so
       * that multiple changes trigger only a single render. The render method
       * should be called if, for example, template rendering is required to
       * validate application state.
       *
       * @return {void}
       */
      render() {
        flush();
      }
      /**
       * Performs the key rendering steps:
       * 1. Ensure a template instance has been stamped (when true)
       * 2. Remove the template instance (when false and restamp:true)
       * 3. Sync the hidden state of the instance nodes with the if/restamp state
       * 4. Fires the `dom-change` event when necessary
       *
       * @return {void}
       */
      __render() {
        if (this.if) {
          if (!this.__ensureInstance()) {
            return;
          }
        } else if (this.restamp) {
          this.__teardownInstance();
        }
        this._showHideChildren();
        if ((!suppressTemplateNotifications || this.notifyDomChange) && this.if != this._lastIf) {
          this.dispatchEvent(new CustomEvent("dom-change", {
            bubbles: true,
            composed: true
          }));
          this._lastIf = this.if;
        }
      }
      // Ideally these would be annotated as abstract methods in an abstract class,
      // but closure compiler is finnicky
      /* eslint-disable valid-jsdoc */
      /**
       * Abstract API to be implemented by subclass: Returns true if a template
       * instance has been created and inserted.
       *
       * @protected
       * @return {boolean} True when an instance has been created.
       */
      __hasInstance() {
      }
      /**
       * Abstract API to be implemented by subclass: Returns the child nodes stamped
       * from a template instance.
       *
       * @protected
       * @return {Array<Node>} Array of child nodes stamped from the template
       * instance.
       */
      __getInstanceNodes() {
      }
      /**
       * Abstract API to be implemented by subclass: Creates an instance of the
       * template and inserts it into the given parent node.
       *
       * @protected
       * @param {Node} parentNode The parent node to insert the instance into
       * @return {void}
       */
      __createAndInsertInstance(parentNode) {
      }
      // eslint-disable-line no-unused-vars
      /**
       * Abstract API to be implemented by subclass: Removes nodes created by an
       * instance of a template and any associated cleanup.
       *
       * @protected
       * @return {void}
       */
      __teardownInstance() {
      }
      /**
       * Abstract API to be implemented by subclass: Shows or hides any template
       * instance childNodes based on the `if` state of the element and its
       * `__hideTemplateChildren__` property.
       *
       * @protected
       * @return {void}
       */
      _showHideChildren() {
      }
      /* eslint-enable valid-jsdoc */
    }
    class DomIfFast extends DomIfBase {
      constructor() {
        super();
        this.__instance = null;
        this.__syncInfo = null;
      }
      /**
       * Implementation of abstract API needed by DomIfBase.
       *
       * @override
       * @return {boolean} True when an instance has been created.
       */
      __hasInstance() {
        return Boolean(this.__instance);
      }
      /**
       * Implementation of abstract API needed by DomIfBase.
       *
       * @override
       * @return {Array<Node>} Array of child nodes stamped from the template
       * instance.
       */
      __getInstanceNodes() {
        return this.__instance.templateInfo.childNodes;
      }
      /**
       * Implementation of abstract API needed by DomIfBase.
       *
       * Stamps the template by calling `_stampTemplate` on the `__dataHost` of this
       * element and then inserts the resulting nodes into the given `parentNode`.
       *
       * @override
       * @param {Node} parentNode The parent node to insert the instance into
       * @return {void}
       */
      __createAndInsertInstance(parentNode) {
        const host = this.__dataHost || this;
        if (strictTemplatePolicy) {
          if (!this.__dataHost) {
            throw new Error("strictTemplatePolicy: template owner not trusted");
          }
        }
        const templateInfo = host._bindTemplate(
          /** @type {!HTMLTemplateElement} */
          this.__template,
          true
        );
        templateInfo.runEffects = (runEffects, changedProps, hasPaths) => {
          let syncInfo = this.__syncInfo;
          if (this.if) {
            if (syncInfo) {
              this.__syncInfo = null;
              this._showHideChildren();
              changedProps = Object.assign(syncInfo.changedProps, changedProps);
            }
            runEffects(changedProps, hasPaths);
          } else {
            if (this.__instance) {
              if (!syncInfo) {
                syncInfo = this.__syncInfo = { runEffects, changedProps: {} };
              }
              if (hasPaths) {
                for (const p in changedProps) {
                  const rootProp = root(p);
                  syncInfo.changedProps[rootProp] = this.__dataHost[rootProp];
                }
              } else {
                Object.assign(syncInfo.changedProps, changedProps);
              }
            }
          }
        };
        this.__instance = host._stampTemplate(
          /** @type {!HTMLTemplateElement} */
          this.__template,
          templateInfo
        );
        wrap$e(parentNode).insertBefore(this.__instance, this);
      }
      /**
       * Run effects for any properties that changed while the `if` was false.
       *
       * @return {void}
       */
      __syncHostProperties() {
        const syncInfo = this.__syncInfo;
        if (syncInfo) {
          this.__syncInfo = null;
          syncInfo.runEffects(syncInfo.changedProps, false);
        }
      }
      /**
       * Implementation of abstract API needed by DomIfBase.
       *
       * Remove the instance and any nodes it created.  Uses the `__dataHost`'s
       * runtime `_removeBoundDom` method.
       *
       * @override
       * @return {void}
       */
      __teardownInstance() {
        const host = this.__dataHost || this;
        if (this.__instance) {
          host._removeBoundDom(this.__instance);
          this.__instance = null;
          this.__syncInfo = null;
        }
      }
      /**
       * Implementation of abstract API needed by DomIfBase.
       *
       * Shows or hides the template instance top level child nodes. For
       * text nodes, `textContent` is removed while "hidden" and replaced when
       * "shown."
       *
       * @override
       * @return {void}
       * @protected
       * @suppress {visibility}
       */
      _showHideChildren() {
        const hidden = this.__hideTemplateChildren__ || !this.if;
        if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
          this.__instance.__hidden = hidden;
          showHideChildren(hidden, this.__instance.templateInfo.childNodes);
        }
        if (!hidden) {
          this.__syncHostProperties();
        }
      }
    }
    class DomIfLegacy extends DomIfBase {
      constructor() {
        super();
        this.__ctor = null;
        this.__instance = null;
        this.__invalidProps = null;
      }
      /**
       * Implementation of abstract API needed by DomIfBase.
       *
       * @override
       * @return {boolean} True when an instance has been created.
       */
      __hasInstance() {
        return Boolean(this.__instance);
      }
      /**
       * Implementation of abstract API needed by DomIfBase.
       *
       * @override
       * @return {Array<Node>} Array of child nodes stamped from the template
       * instance.
       */
      __getInstanceNodes() {
        return this.__instance.children;
      }
      /**
       * Implementation of abstract API needed by DomIfBase.
       *
       * Stamps the template by creating a new instance of the templatized
       * constructor (which is created lazily if it does not yet exist), and then
       * inserts its resulting `root` doc fragment into the given `parentNode`.
       *
       * @override
       * @param {Node} parentNode The parent node to insert the instance into
       * @return {void}
       */
      __createAndInsertInstance(parentNode) {
        if (!this.__ctor) {
          this.__ctor = templatize(
            /** @type {!HTMLTemplateElement} */
            this.__template,
            this,
            {
              // dom-if templatizer instances require `mutable: true`, as
              // `__syncHostProperties` relies on that behavior to sync objects
              mutableData: true,
              /**
               * @param {string} prop Property to forward
               * @param {*} value Value of property
               * @this {DomIfLegacy}
               */
              forwardHostProp: function(prop, value) {
                if (this.__instance) {
                  if (this.if) {
                    this.__instance.forwardHostProp(prop, value);
                  } else {
                    this.__invalidProps = this.__invalidProps || /* @__PURE__ */ Object.create(null);
                    this.__invalidProps[root(prop)] = true;
                  }
                }
              }
            }
          );
        }
        this.__instance = new this.__ctor();
        wrap$e(parentNode).insertBefore(this.__instance.root, this);
      }
      /**
       * Implementation of abstract API needed by DomIfBase.
       *
       * Removes the instance and any nodes it created.
       *
       * @override
       * @return {void}
       */
      __teardownInstance() {
        if (this.__instance) {
          let c$ = this.__instance.children;
          if (c$ && c$.length) {
            let parent = wrap$e(c$[0]).parentNode;
            if (parent) {
              parent = wrap$e(parent);
              for (let i = 0, n; i < c$.length && (n = c$[i]); i++) {
                parent.removeChild(n);
              }
            }
          }
          this.__invalidProps = null;
          this.__instance = null;
        }
      }
      /**
       * Forwards any properties that changed while the `if` was false into the
       * template instance and flushes it.
       *
       * @return {void}
       */
      __syncHostProperties() {
        let props = this.__invalidProps;
        if (props) {
          this.__invalidProps = null;
          for (let prop in props) {
            this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
          }
          this.__instance._flushProperties();
        }
      }
      /**
       * Implementation of abstract API needed by DomIfBase.
       *
       * Shows or hides the template instance top level child elements. For
       * text nodes, `textContent` is removed while "hidden" and replaced when
       * "shown."
       *
       * @override
       * @protected
       * @return {void}
       * @suppress {visibility}
       */
      _showHideChildren() {
        const hidden = this.__hideTemplateChildren__ || !this.if;
        if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
          this.__instance.__hidden = hidden;
          this.__instance._showHideChildren(hidden);
        }
        if (!hidden) {
          this.__syncHostProperties();
        }
      }
    }
    const DomIf = fastDomIf ? DomIfFast : DomIfLegacy;
    customElements.define(DomIf.is, DomIf);
    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const notifyChildrenConnectedChanged = (parent, isConnected) => {
      const children = parent._$disconnectableChildren;
      if (children === void 0) {
        return false;
      }
      for (const obj of children) {
        obj["_$notifyDirectiveConnectionChanged"]?.(isConnected, false);
        notifyChildrenConnectedChanged(obj, isConnected);
      }
      return true;
    };
    const removeDisconnectableFromParent = (obj) => {
      let parent, children;
      do {
        if ((parent = obj._$parent) === void 0) {
          break;
        }
        children = parent._$disconnectableChildren;
        children.delete(obj);
        obj = parent;
      } while (children?.size === 0);
    };
    const addDisconnectableToParent = (obj) => {
      for (let parent; parent = obj._$parent; obj = parent) {
        let children = parent._$disconnectableChildren;
        if (children === void 0) {
          parent._$disconnectableChildren = children = /* @__PURE__ */ new Set();
        } else if (children.has(obj)) {
          break;
        }
        children.add(obj);
        installDisconnectAPI(parent);
      }
    };
    function reparentDisconnectables(newParent) {
      if (this._$disconnectableChildren !== void 0) {
        removeDisconnectableFromParent(this);
        this._$parent = newParent;
        addDisconnectableToParent(this);
      } else {
        this._$parent = newParent;
      }
    }
    function notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {
      const value = this._$committedValue;
      const children = this._$disconnectableChildren;
      if (children === void 0 || children.size === 0) {
        return;
      }
      if (isClearingValue) {
        if (Array.isArray(value)) {
          for (let i = fromPartIndex; i < value.length; i++) {
            notifyChildrenConnectedChanged(value[i], false);
            removeDisconnectableFromParent(value[i]);
          }
        } else if (value != null) {
          notifyChildrenConnectedChanged(value, false);
          removeDisconnectableFromParent(value);
        }
      } else {
        notifyChildrenConnectedChanged(this, isConnected);
      }
    }
    const installDisconnectAPI = (obj) => {
      if (obj.type == PartType.CHILD) {
        obj._$notifyConnectionChanged ??= notifyChildPartConnectedChanged;
        obj._$reparentDisconnectables ??= reparentDisconnectables;
      }
    };
    class AsyncDirective extends Directive {
      constructor() {
        super(...arguments);
        this._$disconnectableChildren = void 0;
      }
      /**
       * Initialize the part with internal fields
       * @param part
       * @param parent
       * @param attributeIndex
       */
      _$initialize(part, parent, attributeIndex) {
        super._$initialize(part, parent, attributeIndex);
        addDisconnectableToParent(this);
        this.isConnected = part._$isConnected;
      }
      // This property needs to remain unminified.
      /**
       * Called from the core code when a directive is going away from a part (in
       * which case `shouldRemoveFromParent` should be true), and from the
       * `setChildrenConnected` helper function when recursively changing the
       * connection state of a tree (in which case `shouldRemoveFromParent` should
       * be false).
       *
       * @param isConnected
       * @param isClearingDirective - True when the directive itself is being
       *     removed; false when the tree is being disconnected
       * @internal
       */
      ["_$notifyDirectiveConnectionChanged"](isConnected, isClearingDirective = true) {
        if (isConnected !== this.isConnected) {
          this.isConnected = isConnected;
          if (isConnected) {
            this.reconnected?.();
          } else {
            this.disconnected?.();
          }
        }
        if (isClearingDirective) {
          notifyChildrenConnectedChanged(this, isConnected);
          removeDisconnectableFromParent(this);
        }
      }
      /**
       * Sets the value of the directive's Part outside the normal `update`/`render`
       * lifecycle of a directive.
       *
       * This method should not be called synchronously from a directive's `update`
       * or `render`.
       *
       * @param directive The directive to update
       * @param value The value to set
       */
      setValue(value) {
        if (isSingleExpression(this.__part)) {
          this.__part._$setValue(value, this);
        } else {
          if (this.__attributeIndex === void 0) {
            throw new Error(`Expected this.__attributeIndex to be a number`);
          }
          const newValues = [...this.__part._$committedValue];
          newValues[this.__attributeIndex] = value;
          this.__part._$setValue(newValues, this, 0);
        }
      }
      /**
       * User callbacks for implementing logic to release any resources/subscriptions
       * that may have been retained by this directive. Since directives may also be
       * re-connected, `reconnected` should also be implemented to restore the
       * working state of the directive prior to the next render.
       */
      disconnected() {
      }
      reconnected() {
      }
    }
    class FlowComponentDirective extends AsyncDirective {
      constructor(partInfo) {
        super(partInfo);
        if (partInfo.type !== PartType.CHILD) {
          throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
        }
      }
      update(part, [appid, nodeid]) {
        this.updateContent(part, appid, nodeid);
        return noChange;
      }
      updateContent(part, appid, nodeid) {
        const { parentNode, startNode } = part;
        this.__parentNode = parentNode;
        const hasNewNodeId = nodeid !== void 0 && nodeid !== null;
        const newNode = hasNewNodeId ? this.getNewNode(appid, nodeid) : null;
        const oldNode = this.getOldNode(part);
        clearTimeout(this.__parentNode.__nodeRetryTimeout);
        if (hasNewNodeId && !newNode) {
          this.__parentNode.__nodeRetryTimeout = setTimeout(() => this.updateContent(part, appid, nodeid));
        } else if (oldNode === newNode) {
          return;
        } else if (oldNode && newNode) {
          parentNode.replaceChild(newNode, oldNode);
        } else if (oldNode) {
          parentNode.removeChild(oldNode);
        } else if (newNode) {
          startNode.after(newNode);
        }
      }
      getNewNode(appid, nodeid) {
        return window.Vaadin.Flow.clients[appid].getByNodeId(nodeid);
      }
      getOldNode(part) {
        const { startNode, endNode } = part;
        if (startNode.nextSibling === endNode) {
          return;
        }
        return startNode.nextSibling;
      }
      disconnected() {
        clearTimeout(this.__parentNode.__nodeRetryTimeout);
      }
    }
    const flowComponentDirective = directive(FlowComponentDirective);
    function getNode(appid, nodeid) {
      return flowComponentDirective(appid, nodeid);
    }
    function setChildNodes(appid, nodeIds, root2) {
      render(html$1`${nodeIds.map((id) => flowComponentDirective(appid, id))}`, root2);
    }
    function patchVirtualContainer(container) {
      const originalInsertBefore = container.insertBefore;
      container.insertBefore = function(newNode, referenceNode) {
        if (referenceNode && referenceNode.parentNode === this) {
          return originalInsertBefore.call(this, newNode, referenceNode);
        } else {
          return originalInsertBefore.call(this, newNode, null);
        }
      };
    }
    window.Vaadin ||= {};
    window.Vaadin.FlowComponentHost ||= { patchVirtualContainer, getNode, setChildNodes };
    class FlowComponentRenderer extends PolymerElement {
      static get template() {
        return html`
      <style>
        :host {
          animation: 1ms flow-component-renderer-appear;
        }

        @keyframes flow-component-renderer-appear {
          to {
            opacity: 1;
          }
        }
      </style>
      <slot></slot>
    `;
      }
      static get is() {
        return "flow-component-renderer";
      }
      static get properties() {
        return {
          nodeid: Number,
          appid: String
        };
      }
      static get observers() {
        return ["_attachRenderedComponentIfAble(appid, nodeid)"];
      }
      ready() {
        super.ready();
        this.addEventListener("click", function(event) {
          if (this.firstChild && typeof this.firstChild.click === "function" && event.target === this) {
            event.stopPropagation();
            this.firstChild.click();
          }
        });
        this.addEventListener("animationend", this._onAnimationEnd);
      }
      _asyncAttachRenderedComponentIfAble() {
        this._debouncer = Debouncer.debounce(
          this._debouncer,
          idlePeriod,
          () => this._attachRenderedComponentIfAble()
        );
      }
      _attachRenderedComponentIfAble() {
        if (this.appid == null) {
          return;
        }
        if (this.nodeid == null) {
          if (this.firstChild) {
            this.removeChild(this.firstChild);
          }
          return;
        }
        const renderedComponent = this._getRenderedComponent();
        if (this.firstChild) {
          if (!renderedComponent) {
            this._asyncAttachRenderedComponentIfAble();
          } else if (this.firstChild !== renderedComponent) {
            this.replaceChild(renderedComponent, this.firstChild);
            this._defineFocusTarget();
            this.onComponentRendered();
          } else {
            this._defineFocusTarget();
            this.onComponentRendered();
          }
        } else {
          if (renderedComponent) {
            this.appendChild(renderedComponent);
            this._defineFocusTarget();
            this.onComponentRendered();
          } else {
            this._asyncAttachRenderedComponentIfAble();
          }
        }
      }
      _getRenderedComponent() {
        try {
          return window.Vaadin.Flow.clients[this.appid].getByNodeId(this.nodeid);
        } catch (error2) {
          console.error(
            "Could not get node %s from app %s",
            this.nodeid,
            this.appid
          );
          console.error(error2);
        }
        return null;
      }
      onComponentRendered() {
      }
      /* Setting the `focus-target` attribute to the first focusable descendant
      starting from the firstChild necessary for the focus to be delegated
      within the flow-component-renderer when used inside a vaadin-grid cell  */
      _defineFocusTarget() {
        var focusable = this._getFirstFocusableDescendant(this.firstChild);
        if (focusable !== null) {
          focusable.setAttribute("focus-target", "true");
        }
      }
      _getFirstFocusableDescendant(node) {
        if (this._isFocusable(node)) {
          return node;
        }
        if (node.hasAttribute && (node.hasAttribute("disabled") || node.hasAttribute("hidden"))) {
          return null;
        }
        if (!node.children) {
          return null;
        }
        for (var i = 0; i < node.children.length; i++) {
          var focusable = this._getFirstFocusableDescendant(node.children[i]);
          if (focusable !== null) {
            return focusable;
          }
        }
        return null;
      }
      _isFocusable(node) {
        if (node.hasAttribute && typeof node.hasAttribute === "function" && (node.hasAttribute("disabled") || node.hasAttribute("hidden"))) {
          return false;
        }
        return node.tabIndex === 0;
      }
      _onAnimationEnd(e2) {
        if (e2.animationName.indexOf("flow-component-renderer-appear") === 0) {
          this._attachRenderedComponentIfAble();
        }
      }
    }
    window.customElements.define(FlowComponentRenderer.is, FlowComponentRenderer);
    (function() {
      const tryCatchWrapper = function(callback) {
        return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Combo Box");
      };
      window.Vaadin.Flow.comboBoxConnector = {
        initLazy: (comboBox) => tryCatchWrapper(function(comboBox2) {
          if (comboBox2.$connector) {
            return;
          }
          comboBox2.$connector = {};
          const pageCallbacks = {};
          let cache = {};
          let lastFilter = "";
          const placeHolder = new window.Vaadin.ComboBoxPlaceholder();
          const serverFacade = /* @__PURE__ */ (() => {
            let lastFilterSentToServer = "";
            let dataCommunicatorResetNeeded = false;
            const needsDataCommunicatorReset = () => dataCommunicatorResetNeeded = true;
            const getLastFilterSentToServer = () => lastFilterSentToServer;
            const requestData = (startIndex, endIndex, params) => {
              const count = endIndex - startIndex;
              const filter = params.filter;
              comboBox2.$server.setRequestedRange(startIndex, count, filter);
              lastFilterSentToServer = filter;
              if (dataCommunicatorResetNeeded) {
                comboBox2.$server.resetDataCommunicator();
                dataCommunicatorResetNeeded = false;
              }
            };
            return {
              needsDataCommunicatorReset,
              getLastFilterSentToServer,
              requestData
            };
          })();
          const clearPageCallbacks = (pages = Object.keys(pageCallbacks)) => {
            pages.forEach((page) => {
              pageCallbacks[page]([], comboBox2.size);
              delete pageCallbacks[page];
              const pageStart = parseInt(page) * comboBox2.pageSize;
              const pageEnd = pageStart + comboBox2.pageSize;
              const end = Math.min(pageEnd, comboBox2.filteredItems.length);
              for (let i = pageStart; i < end; i++) {
                comboBox2.filteredItems[i] = placeHolder;
              }
            });
          };
          comboBox2.dataProvider = function(params, callback) {
            if (params.pageSize != comboBox2.pageSize) {
              throw "Invalid pageSize";
            }
            if (comboBox2._clientSideFilter) {
              if (cache[0]) {
                performClientSideFilter(cache[0], params.filter, callback);
                return;
              } else {
                params.filter = "";
              }
            }
            const filterChanged = params.filter !== lastFilter;
            if (filterChanged) {
              cache = {};
              lastFilter = params.filter;
              this._filterDebouncer = Debouncer.debounce(this._filterDebouncer, timeOut.after(500), () => {
                if (serverFacade.getLastFilterSentToServer() === params.filter) {
                  serverFacade.needsDataCommunicatorReset();
                }
                if (params.filter !== lastFilter) {
                  throw new Error("Expected params.filter to be '" + lastFilter + "' but was '" + params.filter + "'");
                }
                this._filterDebouncer = void 0;
                clearPageCallbacks();
                comboBox2.dataProvider(params, callback);
              });
              return;
            }
            if (this._filterDebouncer) {
              pageCallbacks[params.page] = callback;
              return;
            }
            if (cache[params.page]) {
              commitPage(params.page, callback);
            } else {
              pageCallbacks[params.page] = callback;
              const maxRangeCount = Math.max(params.pageSize * 2, 500);
              const activePages = Object.keys(pageCallbacks).map((page) => parseInt(page));
              const rangeMin = Math.min(...activePages);
              const rangeMax = Math.max(...activePages);
              if (activePages.length * params.pageSize > maxRangeCount) {
                if (params.page === rangeMin) {
                  clearPageCallbacks([String(rangeMax)]);
                } else {
                  clearPageCallbacks([String(rangeMin)]);
                }
                comboBox2.dataProvider(params, callback);
              } else if (rangeMax - rangeMin + 1 !== activePages.length) {
                clearPageCallbacks();
              } else {
                const startIndex = params.pageSize * rangeMin;
                const endIndex = params.pageSize * (rangeMax + 1);
                serverFacade.requestData(startIndex, endIndex, params);
              }
            }
          };
          comboBox2.$connector.clear = tryCatchWrapper((start, length) => {
            const firstPageToClear = Math.floor(start / comboBox2.pageSize);
            const numberOfPagesToClear = Math.ceil(length / comboBox2.pageSize);
            for (let i = firstPageToClear; i < firstPageToClear + numberOfPagesToClear; i++) {
              delete cache[i];
            }
          });
          comboBox2.$connector.filter = tryCatchWrapper(function(item2, filter) {
            filter = filter ? filter.toString().toLowerCase() : "";
            return comboBox2._getItemLabel(item2, comboBox2.itemLabelPath).toString().toLowerCase().indexOf(filter) > -1;
          });
          comboBox2.$connector.set = tryCatchWrapper(function(index, items, filter) {
            if (filter != serverFacade.getLastFilterSentToServer()) {
              return;
            }
            if (index % comboBox2.pageSize != 0) {
              throw "Got new data to index " + index + " which is not aligned with the page size of " + comboBox2.pageSize;
            }
            if (index === 0 && items.length === 0 && pageCallbacks[0]) {
              cache[0] = [];
              return;
            }
            const firstPageToSet = index / comboBox2.pageSize;
            const updatedPageCount = Math.ceil(items.length / comboBox2.pageSize);
            for (let i = 0; i < updatedPageCount; i++) {
              let page = firstPageToSet + i;
              let slice = items.slice(i * comboBox2.pageSize, (i + 1) * comboBox2.pageSize);
              cache[page] = slice;
            }
          });
          comboBox2.$connector.updateData = tryCatchWrapper(function(items) {
            const itemsMap = new Map(items.map((item2) => [item2.key, item2]));
            comboBox2.filteredItems = comboBox2.filteredItems.map((item2) => {
              return itemsMap.get(item2.key) || item2;
            });
          });
          comboBox2.$connector.updateSize = tryCatchWrapper(function(newSize) {
            if (!comboBox2._clientSideFilter) {
              comboBox2.size = newSize;
            }
          });
          comboBox2.$connector.reset = tryCatchWrapper(function() {
            clearPageCallbacks();
            cache = {};
            comboBox2.clearCache();
          });
          comboBox2.$connector.confirm = tryCatchWrapper(function(id, filter) {
            if (filter != serverFacade.getLastFilterSentToServer()) {
              return;
            }
            let activePages = Object.getOwnPropertyNames(pageCallbacks);
            for (let i = 0; i < activePages.length; i++) {
              let page = activePages[i];
              if (cache[page]) {
                commitPage(page, pageCallbacks[page]);
              }
            }
            comboBox2.$server.confirmUpdate(id);
          });
          const commitPage = tryCatchWrapper(function(page, callback) {
            let data = cache[page];
            if (comboBox2._clientSideFilter) {
              performClientSideFilter(data, comboBox2.filter, callback);
            } else {
              delete cache[page];
              callback(data, comboBox2.size);
            }
          });
          const performClientSideFilter = tryCatchWrapper(function(page, filter, callback) {
            let filteredItems = page;
            if (filter) {
              filteredItems = page.filter((item2) => comboBox2.$connector.filter(item2, filter));
            }
            callback(filteredItems, filteredItems.length);
          });
          comboBox2.addEventListener(
            "custom-value-set",
            tryCatchWrapper((e2) => e2.preventDefault())
          );
        })(comboBox)
      };
    })();
    window.Vaadin.ComboBoxPlaceholder = ComboBoxPlaceholder;
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const chip = css$e`
  :host {
    font-size: var(--lumo-font-size-xxs);
    line-height: 1;
    color: var(--lumo-body-text-color);
    border-radius: var(--lumo-border-radius-s);
    background-color: var(--lumo-contrast-20pct);
    cursor: var(--lumo-clickable-cursor);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  :host([focused]) [part='remove-button'] {
    color: inherit;
  }

  :host([slot='overflow']) {
    position: relative;
    min-width: var(--lumo-size-xxs);
    margin-inline-start: var(--lumo-space-s);
  }

  :host([slot='overflow'])::before,
  :host([slot='overflow'])::after {
    position: absolute;
    content: '';
    width: 100%;
    height: 100%;
    border-left: calc(var(--lumo-space-s) / 4) solid;
    border-radius: var(--lumo-border-radius-s);
    border-color: var(--lumo-contrast-30pct);
  }

  :host([slot='overflow'])::before {
    left: calc(-1 * var(--lumo-space-s) / 2);
  }

  :host([slot='overflow'])::after {
    left: calc(-1 * var(--lumo-space-s));
  }

  :host([count='2']) {
    margin-inline-start: calc(var(--lumo-space-s) / 2);
  }

  :host([count='2'])::after {
    display: none;
  }

  :host([count='1']) {
    margin-inline-start: 0;
  }

  :host([count='1'])::before,
  :host([count='1'])::after {
    display: none;
  }

  [part='label'] {
    font-weight: 500;
    line-height: 1.25;
  }

  [part='remove-button'] {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: -0.3125em;
    margin-bottom: -0.3125em;
    margin-inline-start: auto;
    width: 1.25em;
    height: 1.25em;
    font-size: 1.5em;
    transition: none;
  }

  [part='remove-button']::before {
    content: var(--lumo-icons-cross);
  }

  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
    pointer-events: none;
  }
`;
    registerStyles$1("vaadin-multi-select-combo-box-chip", [fieldButton, chip], {
      moduleId: "lumo-multi-select-combo-box-chip"
    });
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const multiSelectComboBoxItem = css$e`
  @media (any-hover: hover) {
    :host(:hover[readonly]) {
      background-color: transparent;
      cursor: default;
    }
  }
`;
    registerStyles$1("vaadin-multi-select-combo-box-item", [item, comboBoxItem, multiSelectComboBoxItem], {
      moduleId: "lumo-multi-select-combo-box-item"
    });
    registerStyles$1(
      "vaadin-multi-select-combo-box-overlay",
      [
        overlay,
        menuOverlayCore,
        comboBoxOverlay,
        loader,
        comboBoxLoader,
        css$e`
      :host {
        --_vaadin-multi-select-combo-box-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-multi-select-combo-box-items-container-border-style: solid;
      }
    `
      ],
      { moduleId: "lumo-multi-select-combo-box-overlay" }
    );
    registerStyles$1(
      "vaadin-multi-select-combo-box-container",
      css$e`
    :host([auto-expand-vertically]) {
      padding-block: var(--lumo-space-xs);
    }
  `,
      { moduleId: "lumo-multi-select-combo-box-container" }
    );
    const multiSelectComboBox$1 = css$e`
  :host([has-value]) {
    padding-inline-start: 0;
  }

  :host([has-value]) ::slotted(input:placeholder-shown) {
    caret-color: var(--lumo-body-text-color) !important;
  }

  [part='label'] {
    flex-shrink: 0;
  }

  /* Override input-container styles */
  ::slotted([slot='chip']),
  ::slotted([slot='overflow']) {
    min-height: auto;
    padding: 0.3125em calc(0.5em + var(--lumo-border-radius-s) / 4);
    color: var(--lumo-body-text-color);
    -webkit-mask-image: none;
    mask-image: none;
  }

  :host([auto-expand-vertically]) ::slotted([slot='chip']) {
    margin-block: calc(var(--lumo-space-xs) / 2);
  }

  ::slotted([slot='chip']:not([readonly]):not([disabled])) {
    padding-inline-end: 0;
  }

  :host([auto-expand-vertically]) ::slotted([slot='input']) {
    min-height: calc(var(--lumo-text-field-size, var(--lumo-size-m)) - 2 * var(--lumo-space-xs));
  }

  ::slotted([slot='chip']:not(:last-of-type)),
  ::slotted([slot='overflow']:not(:last-of-type)) {
    margin-inline-end: var(--lumo-space-xs);
  }

  ::slotted([slot='chip'][focused]) {
    background-color: var(--vaadin-selection-color, var(--lumo-primary-color));
    color: var(--lumo-primary-contrast-color);
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }

  :host([readonly][has-value]) [part='toggle-button'] {
    color: var(--lumo-contrast-60pct);
    cursor: var(--lumo-clickable-cursor);
  }
`;
    registerStyles$1("vaadin-multi-select-combo-box", [inputFieldShared, multiSelectComboBox$1], {
      moduleId: "lumo-multi-select-combo-box"
    });
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class MultiSelectComboBoxChip extends ThemableMixin(PolymerElement) {
      static get is() {
        return "vaadin-multi-select-combo-box-chip";
      }
      static get properties() {
        return {
          disabled: {
            type: Boolean,
            reflectToAttribute: true
          },
          readonly: {
            type: Boolean,
            reflectToAttribute: true
          },
          label: {
            type: String
          },
          item: {
            type: Object
          }
        };
      }
      static get template() {
        return html`
      <style>
        :host {
          display: inline-flex;
          align-items: center;
          align-self: center;
          white-space: nowrap;
          box-sizing: border-box;
        }

        [part='label'] {
          overflow: hidden;
          text-overflow: ellipsis;
        }

        :host([hidden]),
        :host(:is([readonly], [disabled], [slot='overflow'])) [part='remove-button'] {
          display: none !important;
        }

        @media (forced-colors: active) {
          :host {
            outline: 1px solid;
            outline-offset: -1px;
          }
        }
      </style>
      <div part="label">[[label]]</div>
      <div part="remove-button" on-click="_onRemoveClick"></div>
    `;
      }
      /** @private */
      _onRemoveClick(event) {
        event.stopPropagation();
        this.dispatchEvent(
          new CustomEvent("item-removed", {
            detail: {
              item: this.item
            },
            bubbles: true,
            composed: true
          })
        );
      }
    }
    defineCustomElement(MultiSelectComboBoxChip);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1(
      "vaadin-multi-select-combo-box-container",
      css$e`
    #wrapper {
      display: flex;
      width: 100%;
      min-width: 0;
    }

    :host([auto-expand-vertically]) #wrapper {
      flex-wrap: wrap;
    }
  `,
      {
        moduleId: "vaadin-multi-select-combo-box-container-styles"
      }
    );
    let memoizedTemplate$1;
    class MultiSelectComboBoxContainer extends InputContainer {
      static get is() {
        return "vaadin-multi-select-combo-box-container";
      }
      static get template() {
        if (!memoizedTemplate$1) {
          memoizedTemplate$1 = super.template.cloneNode(true);
          const content = memoizedTemplate$1.content;
          const slots = content.querySelectorAll("slot");
          const wrapper = document.createElement("div");
          wrapper.setAttribute("id", "wrapper");
          content.insertBefore(wrapper, slots[2]);
          wrapper.appendChild(slots[0]);
          wrapper.appendChild(slots[1]);
        }
        return memoizedTemplate$1;
      }
      static get properties() {
        return {
          /**
           * Set to true to not collapse selected items chips into the overflow
           * chip and instead always expand vertically, causing input field to
           * wrap into multiple lines when width is limited.
           * @attr {boolean} auto-expand-vertically
           */
          autoExpandVertically: {
            type: Boolean,
            reflectToAttribute: true
          }
        };
      }
    }
    defineCustomElement(MultiSelectComboBoxContainer);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class MultiSelectComboBoxItem extends ComboBoxItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
      static get is() {
        return "vaadin-multi-select-combo-box-item";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
      }
    }
    defineCustomElement(MultiSelectComboBoxItem);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const multiSelectComboBoxOverlayStyles = css$e`
  #overlay {
    width: var(
      --vaadin-multi-select-combo-box-overlay-width,
      var(--_vaadin-multi-select-combo-box-overlay-default-width, auto)
    );
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;
    registerStyles$1("vaadin-multi-select-combo-box-overlay", [overlayStyles, multiSelectComboBoxOverlayStyles], {
      moduleId: "vaadin-multi-select-combo-box-overlay-styles"
    });
    class MultiSelectComboBoxOverlay extends ComboBoxOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
      static get is() {
        return "vaadin-multi-select-combo-box-overlay";
      }
      static get template() {
        return html`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="loader"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
      }
    }
    defineCustomElement(MultiSelectComboBoxOverlay);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class MultiSelectComboBoxScroller extends ComboBoxScrollerMixin(PolymerElement) {
      static get is() {
        return "vaadin-multi-select-combo-box-scroller";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-multi-select-combo-box-items-container-border-width);
          border-style: var(--_vaadin-multi-select-combo-box-items-container-border-style);
          border-color: var(--_vaadin-multi-select-combo-box-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
      }
      /** @protected */
      ready() {
        super.ready();
        this.setAttribute("aria-multiselectable", "true");
      }
      /**
       * @protected
       * @override
       */
      _isItemSelected(item2, _selectedItem, itemIdPath) {
        if (item2 instanceof ComboBoxPlaceholder) {
          return false;
        }
        if (this.owner.readonly) {
          return false;
        }
        return this.owner._findIndex(item2, this.owner.selectedItems, itemIdPath) > -1;
      }
      /**
       * @param {HTMLElement} el
       * @param {number} index
       * @protected
       * @override
       */
      _updateElement(el, index) {
        super._updateElement(el, index);
        el.toggleAttribute("readonly", this.owner.readonly);
      }
    }
    defineCustomElement(MultiSelectComboBoxScroller);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class MultiSelectComboBoxInternal extends ComboBoxDataProviderMixin(ComboBoxMixin(ThemableMixin(PolymerElement))) {
      static get is() {
        return "vaadin-multi-select-combo-box-internal";
      }
      static get template() {
        return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <slot></slot>

      <vaadin-multi-select-combo-box-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[_target]]"
        no-vertical-overlap
        restore-focus-node="[[inputElement]]"
      ></vaadin-multi-select-combo-box-overlay>
    `;
      }
      static get properties() {
        return {
          /**
           * A subset of items, filtered based on the user input.
           */
          filteredItems: {
            type: Array,
            notify: true
          },
          /**
           * When true, filter string isn't cleared after selecting an item.
           */
          keepFilter: {
            type: Boolean,
            value: false
          },
          /**
           * When set to `true`, "loading" attribute is set
           * on the host and the overlay element.
           * @type {boolean}
           */
          loading: {
            type: Boolean,
            notify: true
          },
          /**
           * Total number of items.
           * @type {number | undefined}
           */
          size: {
            type: Number,
            notify: true
          },
          /**
           * Selected items to render in the dropdown
           * when the component is read-only.
           */
          selectedItems: {
            type: Array,
            value: () => []
          },
          /**
           * Set to true to group selected items at the top of the overlay.
           * @attr {boolean} selected-items-on-top
           */
          selectedItemsOnTop: {
            type: Boolean,
            value: false
          },
          /**
           * Last input value entered by the user before value is updated.
           * Used to store `filter` property value before clearing it.
           */
          lastFilter: {
            type: String,
            notify: true
          },
          /**
           * A subset of items to be shown at the top of the overlay.
           */
          topGroup: {
            type: Array,
            observer: "_topGroupChanged"
          },
          _target: {
            type: Object
          }
        };
      }
      static get observers() {
        return ["_readonlyChanged(readonly)"];
      }
      /**
       * Reference to the clear button element.
       * @protected
       * @return {!HTMLElement}
       */
      get clearElement() {
        return this.querySelector('[part="clear-button"]');
      }
      /**
       * Tag name prefix used by scroller and items.
       * @protected
       * @return {string}
       */
      get _tagNamePrefix() {
        return "vaadin-multi-select-combo-box";
      }
      /**
       * Override method inherited from the combo-box
       * to allow opening dropdown when readonly.
       * @override
       */
      open() {
        if (!this.disabled && !(this.readonly && this.selectedItems.length === 0)) {
          this.opened = true;
        }
      }
      /** @protected */
      ready() {
        super.ready();
        this._target = this;
        this._toggleElement = this.querySelector(".toggle-button");
      }
      /** @private */
      _readonlyChanged() {
        this._setDropdownItems(this.filteredItems);
      }
      /**
       * Override combo-box method to group selected
       * items at the top of the overlay.
       *
       * @protected
       * @override
       */
      _setDropdownItems(items) {
        if (this.readonly) {
          super._setDropdownItems(this.selectedItems);
          return;
        }
        if (this.filter || !this.selectedItemsOnTop) {
          super._setDropdownItems(items);
          return;
        }
        if (items && items.length && this.topGroup && this.topGroup.length) {
          const filteredItems = items.filter(
            (item2) => this._comboBox._findIndex(item2, this.topGroup, this.itemIdPath) === -1
          );
          super._setDropdownItems(this.topGroup.concat(filteredItems));
          return;
        }
        super._setDropdownItems(items);
      }
      /** @private */
      _topGroupChanged(topGroup) {
        if (topGroup) {
          this._setDropdownItems(this.filteredItems);
        }
      }
      /**
       * Override combo-box method to set correct owner for using by item renderers.
       * This needs to be done before the scroller gets added to the DOM to ensure
       * Lit directive works in case when combo-box is opened using attribute.
       *
       * @protected
       * @override
       */
      _initScroller() {
        const comboBox = this.getRootNode().host;
        this._comboBox = comboBox;
        super._initScroller(comboBox);
      }
      /**
       * Override Enter handler to keep overlay open
       * when item is selected or unselected.
       * @param {!Event} event
       * @protected
       * @override
       */
      _onEnter(event) {
        if (this.opened) {
          event.preventDefault();
          event.stopPropagation();
          if (this.readonly) {
            this.close();
          } else if (this._hasValidInputValue()) {
            const focusedItem = this._dropdownItems[this._focusedIndex];
            this._commitValue();
            this._focusedIndex = this._dropdownItems.indexOf(focusedItem);
          }
          return;
        }
        super._onEnter(event);
      }
      /**
       * Override Escape handler to not clear
       * selected items when readonly.
       * @param {!Event} event
       * @protected
       * @override
       */
      _onEscape(event) {
        if (this.readonly) {
          event.stopPropagation();
          if (this.opened) {
            this.close();
          }
          return;
        }
        super._onEscape(event);
      }
      /**
       * Override from combo-box to ignore requests to clear the filter if the
       * keepFilter option is enabled. Exceptions are when the dropdown is closed,
       * so the filter is still cleared on cancel and focus out.
       * @protected
       * @override
       */
      _clearFilter() {
        if (!this.keepFilter || !this.opened) {
          super._clearFilter();
        }
      }
      /**
       * Override method from combo-box to always clear the filter when reverting
       * the input value, regardless of the keepFilter option.
       * @override
       * @protected
       */
      _revertInputValueToValue() {
        super._revertInputValueToValue();
        this.filter = "";
      }
      /**
       * @protected
       * @override
       */
      _commitValue() {
        this.lastFilter = this.filter;
        super._commitValue();
      }
      /**
       * Override method inherited from the combo-box
       * to not update focused item when readonly.
       * @protected
       * @override
       */
      _onArrowDown() {
        if (!this.readonly) {
          super._onArrowDown();
        } else if (!this.opened) {
          this.open();
        }
      }
      /**
       * Override method inherited from the combo-box
       * to not update focused item when readonly.
       * @protected
       * @override
       */
      _onArrowUp() {
        if (!this.readonly) {
          super._onArrowUp();
        } else if (!this.opened) {
          this.open();
        }
      }
      /**
       * Override method inherited from the combo-box
       * to close dropdown on blur when readonly.
       * @param {boolean} focused
       * @protected
       * @override
       */
      _setFocused(focused) {
        if (!focused) {
          this._ignoreCommitValue = true;
        }
        super._setFocused(focused);
        if (!focused && this.readonly && !this._closeOnBlurIsPrevented) {
          this.close();
        }
      }
      /**
       * Override method inherited from the combo-box
       * to not commit an already selected item again
       * on blur, which would result in un-selecting.
       * @protected
       * @override
       */
      _detectAndDispatchChange() {
        if (this._ignoreCommitValue) {
          this._ignoreCommitValue = false;
          this.selectedItem = null;
          this._inputElementValue = "";
          return;
        }
        super._detectAndDispatchChange();
      }
      /**
       * @param {CustomEvent} event
       * @protected
       * @override
       */
      _overlaySelectedItemChanged(event) {
        event.stopPropagation();
        if (this.readonly) {
          return;
        }
        if (event.detail.item instanceof ComboBoxPlaceholder) {
          return;
        }
        if (this.opened) {
          this.dispatchEvent(
            new CustomEvent("combo-box-item-selected", {
              detail: {
                item: event.detail.item
              }
            })
          );
        }
      }
      /**
       * Override method inherited from the combo-box
       * to not request data provider when read-only.
       *
       * @protected
       * @override
       */
      _shouldFetchData() {
        if (this.readonly) {
          return false;
        }
        return super._shouldFetchData();
      }
      /**
       * Override method inherited from the combo-box
       * to not clear the data provider cache when read-only.
       *
       * @protected
       * @override
       */
      clearCache() {
        if (this.readonly) {
          return;
        }
        super.clearCache();
      }
    }
    defineCustomElement(MultiSelectComboBoxInternal);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const multiSelectComboBox = css$e`
  :host {
    --input-min-width: var(--vaadin-multi-select-combo-box-input-min-width, 4em);
    --_chip-min-width: var(--vaadin-multi-select-combo-box-chip-min-width, 50px);
  }

  #chips {
    display: flex;
    align-items: center;
  }

  ::slotted(input) {
    box-sizing: border-box;
    flex: 1 0 var(--input-min-width);
  }

  ::slotted([slot='chip']),
  ::slotted([slot='overflow']) {
    flex: 0 1 auto;
  }

  ::slotted([slot='chip']) {
    overflow: hidden;
  }

  :host(:is([readonly], [disabled])) ::slotted(input) {
    flex-grow: 0;
    flex-basis: 0;
    padding: 0;
  }

  :host([auto-expand-vertically]) #chips {
    display: contents;
  }

  :host([auto-expand-horizontally]) [class$='container'] {
    width: auto;
  }
`;
    registerStyles$1("vaadin-multi-select-combo-box", [inputFieldShared$1, multiSelectComboBox], {
      moduleId: "vaadin-multi-select-combo-box-styles"
    });
    class MultiSelectComboBox extends ResizeMixin(InputControlMixin(ThemableMixin(ElementMixin(PolymerElement)))) {
      static get is() {
        return "vaadin-multi-select-combo-box";
      }
      static get template() {
        return html`
      <div class="vaadin-multi-select-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-multi-select-combo-box-internal
          id="comboBox"
          items="[[items]]"
          item-id-path="[[itemIdPath]]"
          item-label-path="[[itemLabelPath]]"
          item-value-path="[[itemValuePath]]"
          disabled="[[disabled]]"
          readonly="[[readonly]]"
          auto-open-disabled="[[autoOpenDisabled]]"
          allow-custom-value="[[allowCustomValue]]"
          overlay-class="[[overlayClass]]"
          data-provider="[[dataProvider]]"
          filter="{{filter}}"
          last-filter="{{_lastFilter}}"
          loading="{{loading}}"
          size="{{size}}"
          filtered-items="[[filteredItems]]"
          selected-items="[[selectedItems]]"
          selected-items-on-top="[[selectedItemsOnTop]]"
          top-group="[[_topGroup]]"
          opened="{{opened}}"
          renderer="[[renderer]]"
          keep-filter="[[keepFilter]]"
          theme$="[[_theme]]"
          on-combo-box-item-selected="_onComboBoxItemSelected"
          on-change="_onComboBoxChange"
          on-custom-value-set="_onCustomValueSet"
          on-filtered-items-changed="_onFilteredItemsChanged"
        >
          <vaadin-multi-select-combo-box-container
            part="input-field"
            auto-expand-vertically="[[autoExpandVertically]]"
            readonly="[[readonly]]"
            disabled="[[disabled]]"
            invalid="[[invalid]]"
            theme$="[[_theme]]"
          >
            <slot name="overflow" slot="prefix"></slot>
            <div id="chips" part="chips" slot="prefix">
              <slot name="chip"></slot>
            </div>
            <slot name="input"></slot>
            <div
              id="clearButton"
              part="clear-button"
              slot="suffix"
              on-touchend="_onClearButtonTouchend"
              aria-hidden="true"
            ></div>
            <div id="toggleButton" class="toggle-button" part="toggle-button" slot="suffix" aria-hidden="true"></div>
          </vaadin-multi-select-combo-box-container>
        </vaadin-multi-select-combo-box-internal>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
      }
      static get properties() {
        return {
          /**
           * Set to true to auto expand horizontally, causing input field to
           * grow until max width is reached.
           * @attr {boolean} auto-expand-horizontally
           */
          autoExpandHorizontally: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            observer: "_autoExpandHorizontallyChanged"
          },
          /**
           * Set to true to not collapse selected items chips into the overflow
           * chip and instead always expand vertically, causing input field to
           * wrap into multiple lines when width is limited.
           * @attr {boolean} auto-expand-vertically
           */
          autoExpandVertically: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            observer: "_autoExpandVerticallyChanged"
          },
          /**
           * Set true to prevent the overlay from opening automatically.
           * @attr {boolean} auto-open-disabled
           */
          autoOpenDisabled: Boolean,
          /**
           * Set to true to display the clear icon which clears the input.
           * @attr {boolean} clear-button-visible
           */
          clearButtonVisible: {
            type: Boolean,
            reflectToAttribute: true,
            observer: "_clearButtonVisibleChanged",
            value: false
          },
          /**
           * A full set of items to filter the visible options from.
           * The items can be of either `String` or `Object` type.
           */
          items: {
            type: Array
          },
          /**
           * The item property used for a visual representation of the item.
           * @attr {string} item-label-path
           */
          itemLabelPath: {
            type: String,
            value: "label"
          },
          /**
           * Path for the value of the item. If `items` is an array of objects,
           * this property is used as a string value for the selected item.
           * @attr {string} item-value-path
           */
          itemValuePath: {
            type: String,
            value: "value"
          },
          /**
           * Path for the id of the item, used to detect whether the item is selected.
           * @attr {string} item-id-path
           */
          itemIdPath: {
            type: String
          },
          /**
           * The object used to localize this component.
           * To change the default localization, replace the entire
           * _i18n_ object or just the property you want to modify.
           *
           * The object has the following JSON structure and default values:
           * ```
           * {
           *   // Screen reader announcement on clear button click.
           *   cleared: 'Selection cleared',
           *   // Screen reader announcement when a chip is focused.
           *   focused: ' focused. Press Backspace to remove',
           *   // Screen reader announcement when item is selected.
           *   selected: 'added to selection',
           *   // Screen reader announcement when item is deselected.
           *   deselected: 'removed from selection',
           *   // Screen reader announcement of the selected items count.
           *   // {count} is replaced with the actual count of items.
           *   total: '{count} items selected',
           * }
           * ```
           * @type {!MultiSelectComboBoxI18n}
           * @default {English/US}
           */
          i18n: {
            type: Object,
            value: () => {
              return {
                cleared: "Selection cleared",
                focused: "focused. Press Backspace to remove",
                selected: "added to selection",
                deselected: "removed from selection",
                total: "{count} items selected"
              };
            }
          },
          /**
           * When true, filter string isn't cleared after selecting an item.
           */
          keepFilter: {
            type: Boolean,
            value: false
          },
          /**
           * True when loading items from the data provider, false otherwise.
           */
          loading: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          /**
           * A space-delimited list of CSS class names to set on the overlay element.
           *
           * @attr {string} overlay-class
           */
          overlayClass: {
            type: String
          },
          /**
           * When present, it specifies that the field is read-only.
           */
          readonly: {
            type: Boolean,
            value: false,
            observer: "_readonlyChanged",
            reflectToAttribute: true
          },
          /**
           * The list of selected items.
           * Note: modifying the selected items creates a new array each time.
           */
          selectedItems: {
            type: Array,
            value: () => [],
            notify: true
          },
          /**
           * True if the dropdown is open, false otherwise.
           */
          opened: {
            type: Boolean,
            notify: true,
            value: false,
            reflectToAttribute: true
          },
          /**
           * Total number of items.
           */
          size: {
            type: Number
          },
          /**
           * Number of items fetched at a time from the data provider.
           * @attr {number} page-size
           */
          pageSize: {
            type: Number,
            value: 50,
            observer: "_pageSizeChanged"
          },
          /**
           * Function that provides items lazily. Receives two arguments:
           *
           * - `params` - Object with the following properties:
           *   - `params.page` Requested page index
           *   - `params.pageSize` Current page size
           *   - `params.filter` Currently applied filter
           *
           * - `callback(items, size)` - Callback function with arguments:
           *   - `items` Current page of items
           *   - `size` Total number of items.
           */
          dataProvider: {
            type: Object
          },
          /**
           * When true, the user can input a value that is not present in the items list.
           * @attr {boolean} allow-custom-value
           */
          allowCustomValue: {
            type: Boolean,
            value: false
          },
          /**
           * A hint to the user of what can be entered in the control.
           * The placeholder will be only displayed in the case when
           * there is no item selected.
           */
          placeholder: {
            type: String,
            value: "",
            observer: "_placeholderChanged"
          },
          /**
           * Custom function for rendering the content of every item.
           * Receives three arguments:
           *
           * - `root` The `<vaadin-multi-select-combo-box-item>` internal container DOM element.
           * - `comboBox` The reference to the `<vaadin-multi-select-combo-box>` element.
           * - `model` The object with the properties related with the rendered
           *   item, contains:
           *   - `model.index` The index of the rendered item.
           *   - `model.item` The item.
           */
          renderer: Function,
          /**
           * Filtering string the user has typed into the input field.
           */
          filter: {
            type: String,
            value: "",
            notify: true
          },
          /**
           * A subset of items, filtered based on the user input. Filtered items
           * can be assigned directly to omit the internal filtering functionality.
           * The items can be of either `String` or `Object` type.
           */
          filteredItems: Array,
          /**
           * Set to true to group selected items at the top of the overlay.
           * @attr {boolean} selected-items-on-top
           */
          selectedItemsOnTop: {
            type: Boolean,
            value: false
          },
          /** @private */
          value: {
            type: String
          },
          /** @private */
          _overflowItems: {
            type: Array,
            value: () => []
          },
          /** @private */
          _focusedChipIndex: {
            type: Number,
            value: -1,
            observer: "_focusedChipIndexChanged"
          },
          /** @private */
          _lastFilter: {
            type: String
          },
          /** @private */
          _topGroup: {
            type: Array
          }
        };
      }
      static get observers() {
        return [
          "_selectedItemsChanged(selectedItems, selectedItems.*)",
          "__updateOverflowChip(_overflow, _overflowItems, disabled, readonly)",
          "__updateTopGroup(selectedItemsOnTop, selectedItems, opened)"
        ];
      }
      /** @protected */
      get slotStyles() {
        const tag = this.localName;
        return [
          ...super.slotStyles,
          `
        ${tag}[has-value] input::placeholder {
          color: transparent !important;
          forced-color-adjust: none;
        }
      `
        ];
      }
      /**
       * Used by `InputControlMixin` as a reference to the clear button element.
       * @protected
       * @return {!HTMLElement}
       */
      get clearElement() {
        return this.$.clearButton;
      }
      /** @protected */
      get _chips() {
        return [...this.querySelectorAll('[slot="chip"]')];
      }
      /**
       * Override a getter from `InputMixin` to compute
       * the presence of value based on `selectedItems`.
       *
       * @protected
       * @override
       */
      get _hasValue() {
        return this.selectedItems && this.selectedItems.length > 0;
      }
      /** @protected */
      ready() {
        super.ready();
        this.addController(
          new InputController(this, (input) => {
            this._setInputElement(input);
            this._setFocusElement(input);
            this.stateTarget = input;
            this.ariaTarget = input;
          })
        );
        this.addController(new LabelledInputController(this.inputElement, this._labelController));
        this._tooltipController = new TooltipController(this);
        this.addController(this._tooltipController);
        this._tooltipController.setPosition("top");
        this._tooltipController.setAriaTarget(this.inputElement);
        this._tooltipController.setShouldShow((target) => !target.opened);
        this._inputField = this.shadowRoot.querySelector('[part="input-field"]');
        this._overflowController = new SlotController(this, "overflow", "vaadin-multi-select-combo-box-chip", {
          initializer: (chip2) => {
            chip2.addEventListener("mousedown", (e2) => this._preventBlur(e2));
            this._overflow = chip2;
          }
        });
        this.addController(this._overflowController);
        this.__updateChips();
        processTemplates(this);
      }
      /**
       * Returns true if the current input value satisfies all constraints (if any).
       * @return {boolean}
       */
      checkValidity() {
        return this.required && !this.readonly ? this._hasValue : true;
      }
      /**
       * Clears the selected items.
       */
      clear() {
        this.__updateSelection([]);
        announce(this.i18n.cleared);
      }
      /**
       * Clears the cached pages and reloads data from data provider when needed.
       */
      clearCache() {
        if (this.$ && this.$.comboBox) {
          this.$.comboBox.clearCache();
        }
      }
      /**
       * Requests an update for the content of items.
       * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.
       *
       * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
       */
      requestContentUpdate() {
        if (this.$ && this.$.comboBox) {
          this.$.comboBox.requestContentUpdate();
        }
      }
      /**
       * Override method inherited from `DisabledMixin` to forward disabled to chips.
       * @protected
       * @override
       */
      _disabledChanged(disabled, oldDisabled) {
        super._disabledChanged(disabled, oldDisabled);
        if (disabled || oldDisabled) {
          this.__updateChips();
        }
      }
      /**
       * Override method inherited from `InputMixin` to forward the input to combo-box.
       * @protected
       * @override
       */
      _inputElementChanged(input) {
        super._inputElementChanged(input);
        if (input) {
          this.$.comboBox._setInputElement(input);
        }
      }
      /**
       * Override method inherited from `FocusMixin` to validate on blur.
       * @param {boolean} focused
       * @protected
       */
      _setFocused(focused) {
        super._setFocused(focused);
        if (!focused && document.hasFocus()) {
          this._focusedChipIndex = -1;
          this.validate();
        }
      }
      /**
       * Implement callback from `ResizeMixin` to update chips.
       * @protected
       * @override
       */
      _onResize() {
        this.__updateChips();
      }
      /**
       * Override method from `DelegateStateMixin` to set required state
       * using `aria-required` attribute instead of `required`, in order
       * to prevent screen readers from announcing "invalid entry".
       * @protected
       * @override
       */
      _delegateAttribute(name, value) {
        if (!this.stateTarget) {
          return;
        }
        if (name === "required") {
          this._delegateAttribute("aria-required", value ? "true" : false);
          return;
        }
        super._delegateAttribute(name, value);
      }
      /** @private */
      _autoExpandHorizontallyChanged(autoExpand, oldAutoExpand) {
        if (autoExpand || oldAutoExpand) {
          this.__updateChips();
        }
      }
      /** @private */
      _autoExpandVerticallyChanged(autoExpand, oldAutoExpand) {
        if (autoExpand || oldAutoExpand) {
          this.__updateChips();
        }
      }
      /**
       * Setting clear button visible reduces total space available
       * for rendering chips, and making it hidden increases it.
       * @private
       */
      _clearButtonVisibleChanged(visible, oldVisible) {
        if (visible || oldVisible) {
          this.__updateChips();
        }
      }
      /**
       * Implement two-way binding for the `filteredItems` property
       * that can be set on the internal combo-box element.
       *
       * @param {CustomEvent} event
       * @private
       */
      _onFilteredItemsChanged(event) {
        const { value } = event.detail;
        if (Array.isArray(value) || value == null) {
          this.filteredItems = value;
        }
      }
      /** @private */
      _readonlyChanged(readonly, oldReadonly) {
        if (readonly || oldReadonly) {
          this.__updateChips();
        }
        if (this.dataProvider) {
          this.clearCache();
        }
      }
      /** @private */
      _pageSizeChanged(pageSize, oldPageSize) {
        if (Math.floor(pageSize) !== pageSize || pageSize <= 0) {
          this.pageSize = oldPageSize;
          console.error('"pageSize" value must be an integer > 0');
        }
        this.$.comboBox.pageSize = this.pageSize;
      }
      /** @private */
      _placeholderChanged(placeholder) {
        const tmpPlaceholder = this.__tmpA11yPlaceholder;
        if (tmpPlaceholder !== placeholder) {
          this.__savedPlaceholder = placeholder;
          if (tmpPlaceholder) {
            this.placeholder = tmpPlaceholder;
          }
        }
      }
      /** @private */
      _selectedItemsChanged(selectedItems) {
        this._toggleHasValue(this._hasValue);
        if (this._hasValue) {
          const tmpPlaceholder = this._mergeItemLabels(selectedItems);
          this.__tmpA11yPlaceholder = tmpPlaceholder;
          this.placeholder = tmpPlaceholder;
        } else {
          delete this.__tmpA11yPlaceholder;
          this.placeholder = this.__savedPlaceholder;
        }
        this.__updateChips();
        this.requestContentUpdate();
        if (this.opened) {
          this.$.comboBox.$.overlay._updateOverlayWidth();
        }
      }
      /** @private */
      _getItemLabel(item2) {
        return this.$.comboBox._getItemLabel(item2);
      }
      /** @private */
      _mergeItemLabels(items) {
        return items.map((item2) => this._getItemLabel(item2)).join(", ");
      }
      /** @private */
      _findIndex(item2, selectedItems, itemIdPath) {
        if (itemIdPath && item2) {
          for (let index = 0; index < selectedItems.length; index++) {
            if (selectedItems[index] && selectedItems[index][itemIdPath] === item2[itemIdPath]) {
              return index;
            }
          }
          return -1;
        }
        return selectedItems.indexOf(item2);
      }
      /**
       * Clear the internal combo box value and filter. Filter will not be cleared
       * when the `keepFilter` option is enabled. Using `force` can enforce clearing
       * the filter.
       * @param {boolean} force overrides the keepFilter option
       * @private
       */
      __clearInternalValue(force = false) {
        if (!this.keepFilter || force) {
          this.filter = "";
          this.$.comboBox.clear();
        } else {
          this.$.comboBox.clear();
          this._inputElementValue = this.filter;
        }
      }
      /** @private */
      __announceItem(itemLabel, isSelected, itemCount) {
        const state = isSelected ? "selected" : "deselected";
        const total = this.i18n.total.replace("{count}", itemCount || 0);
        announce(`${itemLabel} ${this.i18n[state]} ${total}`);
      }
      /** @private */
      __removeItem(item2) {
        const itemsCopy = [...this.selectedItems];
        itemsCopy.splice(itemsCopy.indexOf(item2), 1);
        this.__updateSelection(itemsCopy);
        const itemLabel = this._getItemLabel(item2);
        this.__announceItem(itemLabel, false, itemsCopy.length);
      }
      /** @private */
      __selectItem(item2) {
        const itemsCopy = [...this.selectedItems];
        const index = this._findIndex(item2, itemsCopy, this.itemIdPath);
        const itemLabel = this._getItemLabel(item2);
        let isSelected = false;
        if (index !== -1) {
          const lastFilter = this._lastFilter;
          if (lastFilter && lastFilter.toLowerCase() === itemLabel.toLowerCase()) {
            this.__clearInternalValue();
            return;
          }
          itemsCopy.splice(index, 1);
        } else {
          itemsCopy.push(item2);
          isSelected = true;
        }
        this.__updateSelection(itemsCopy);
        this.__clearInternalValue();
        this.__announceItem(itemLabel, isSelected, itemsCopy.length);
      }
      /** @private */
      __updateSelection(selectedItems) {
        this.selectedItems = selectedItems;
        this.validate();
        this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
      }
      /** @private */
      __updateTopGroup(selectedItemsOnTop, selectedItems, opened) {
        if (!selectedItemsOnTop) {
          this._topGroup = [];
        } else if (!opened) {
          this._topGroup = [...selectedItems];
        }
      }
      /** @private */
      __createChip(item2) {
        const chip2 = document.createElement("vaadin-multi-select-combo-box-chip");
        chip2.setAttribute("slot", "chip");
        chip2.item = item2;
        chip2.disabled = this.disabled;
        chip2.readonly = this.readonly;
        const label = this._getItemLabel(item2);
        chip2.label = label;
        chip2.setAttribute("title", label);
        chip2.addEventListener("item-removed", (e2) => this._onItemRemoved(e2));
        chip2.addEventListener("mousedown", (e2) => this._preventBlur(e2));
        return chip2;
      }
      /** @private */
      __getOverflowWidth() {
        const chip2 = this._overflow;
        chip2.style.visibility = "hidden";
        chip2.removeAttribute("hidden");
        const count = chip2.getAttribute("count");
        chip2.setAttribute("count", "99");
        const overflowStyle = getComputedStyle(chip2);
        const overflowWidth = chip2.clientWidth + parseInt(overflowStyle.marginInlineStart);
        chip2.setAttribute("count", count);
        chip2.setAttribute("hidden", "");
        chip2.style.visibility = "";
        return overflowWidth;
      }
      /** @private */
      __updateChips() {
        if (!this._inputField || !this.inputElement) {
          return;
        }
        this._chips.forEach((chip2) => {
          chip2.remove();
        });
        const items = [...this.selectedItems];
        const totalWidth = this._inputField.$.wrapper.clientWidth;
        const inputWidth = parseInt(getComputedStyle(this.inputElement).flexBasis);
        let remainingWidth = totalWidth - inputWidth;
        if (items.length > 1) {
          remainingWidth -= this.__getOverflowWidth();
        }
        const chipMinWidth = parseInt(getComputedStyle(this).getPropertyValue("--_chip-min-width"));
        if (this.autoExpandHorizontally) {
          const chips = [];
          for (let i = items.length - 1, refNode = null; i >= 0; i--) {
            const chip2 = this.__createChip(items[i]);
            this.insertBefore(chip2, refNode);
            refNode = chip2;
            chips.unshift(chip2);
          }
          const overflowItems = [];
          const availableWidth = this._inputField.$.wrapper.clientWidth - this.$.chips.clientWidth;
          if (!this.autoExpandVertically && availableWidth < inputWidth) {
            while (chips.length > 1) {
              const lastChip = chips.pop();
              lastChip.remove();
              overflowItems.unshift(items.pop());
              const neededWidth = overflowItems.length > 0 ? inputWidth + this.__getOverflowWidth() : inputWidth;
              if (this._inputField.$.wrapper.clientWidth - this.$.chips.clientWidth >= neededWidth) {
                break;
              }
            }
            if (chips.length === 1) {
              chips[0].style.maxWidth = `${Math.max(chipMinWidth, remainingWidth)}px`;
            }
          }
          this._overflowItems = overflowItems;
          return;
        }
        for (let i = items.length - 1, refNode = null; i >= 0; i--) {
          const chip2 = this.__createChip(items[i]);
          this.insertBefore(chip2, refNode);
          if (!this.autoExpandVertically && this.$.chips.clientWidth > remainingWidth) {
            if (refNode === null) {
              chip2.style.maxWidth = `${Math.max(chipMinWidth, remainingWidth)}px`;
            } else {
              chip2.remove();
              break;
            }
          }
          items.pop();
          refNode = chip2;
        }
        this._overflowItems = items;
      }
      /** @private */
      __updateOverflowChip(overflow, items, disabled, readonly) {
        if (overflow) {
          const count = items.length;
          overflow.label = `${count}`;
          overflow.setAttribute("count", `${count}`);
          overflow.setAttribute("title", this._mergeItemLabels(items));
          overflow.toggleAttribute("hidden", count === 0);
          overflow.disabled = disabled;
          overflow.readonly = readonly;
        }
      }
      /** @private */
      _onClearButtonTouchend(event) {
        event.preventDefault();
        event.stopPropagation();
        this.clear();
      }
      /**
       * Override method inherited from `InputControlMixin` and clear items.
       * @protected
       * @override
       */
      _onClearButtonClick(event) {
        event.stopPropagation();
        this.clear();
      }
      /**
       * Override an event listener from `InputControlMixin` to
       * stop the change event re-targeted from the input.
       *
       * @param {!Event} event
       * @protected
       * @override
       */
      _onChange(event) {
        event.stopPropagation();
      }
      /**
       * Override an event listener from `KeyboardMixin`.
       * Do not call `super` in order to override clear
       * button logic defined in `InputControlMixin`.
       *
       * @param {!KeyboardEvent} event
       * @protected
       * @override
       */
      _onEscape(event) {
        if (this.clearButtonVisible && this.selectedItems && this.selectedItems.length) {
          event.stopPropagation();
          this.selectedItems = [];
        }
      }
      /**
       * Override an event listener from `KeyboardMixin`.
       * @param {KeyboardEvent} event
       * @protected
       * @override
       */
      _onKeyDown(event) {
        super._onKeyDown(event);
        const chips = this._chips;
        if (!this.readonly && chips.length > 0) {
          switch (event.key) {
            case "Backspace":
              this._onBackSpace(chips);
              break;
            case "ArrowLeft":
              this._onArrowLeft(chips, event);
              break;
            case "ArrowRight":
              this._onArrowRight(chips, event);
              break;
            default:
              this._focusedChipIndex = -1;
              break;
          }
        }
      }
      /** @private */
      _onArrowLeft(chips, event) {
        if (this.inputElement.selectionStart !== 0) {
          return;
        }
        const idx = this._focusedChipIndex;
        if (idx !== -1) {
          event.preventDefault();
        }
        let newIdx;
        if (!this.__isRTL) {
          if (idx === -1) {
            newIdx = chips.length - 1;
          } else if (idx > 0) {
            newIdx = idx - 1;
          }
        } else if (idx === chips.length - 1) {
          newIdx = -1;
        } else if (idx > -1) {
          newIdx = idx + 1;
        }
        if (newIdx !== void 0) {
          this._focusedChipIndex = newIdx;
        }
      }
      /** @private */
      _onArrowRight(chips, event) {
        if (this.inputElement.selectionStart !== 0) {
          return;
        }
        const idx = this._focusedChipIndex;
        if (idx !== -1) {
          event.preventDefault();
        }
        let newIdx;
        if (this.__isRTL) {
          if (idx === -1) {
            newIdx = chips.length - 1;
          } else if (idx > 0) {
            newIdx = idx - 1;
          }
        } else if (idx === chips.length - 1) {
          newIdx = -1;
        } else if (idx > -1) {
          newIdx = idx + 1;
        }
        if (newIdx !== void 0) {
          this._focusedChipIndex = newIdx;
        }
      }
      /** @private */
      _onBackSpace(chips) {
        if (this.inputElement.selectionStart !== 0) {
          return;
        }
        const idx = this._focusedChipIndex;
        if (idx === -1) {
          this._focusedChipIndex = chips.length - 1;
        } else {
          this.__removeItem(chips[idx].item);
          this._focusedChipIndex = -1;
        }
      }
      /** @private */
      _focusedChipIndexChanged(focusedIndex, oldFocusedIndex) {
        if (focusedIndex > -1 || oldFocusedIndex > -1) {
          const chips = this._chips;
          chips.forEach((chip2, index) => {
            chip2.toggleAttribute("focused", index === focusedIndex);
          });
          if (focusedIndex > -1) {
            const item2 = chips[focusedIndex].item;
            const itemLabel = this._getItemLabel(item2);
            announce(`${itemLabel} ${this.i18n.focused}`);
          }
        }
      }
      /** @private */
      _onComboBoxChange() {
        const item2 = this.$.comboBox.selectedItem;
        if (item2) {
          this.__selectItem(item2);
        }
      }
      /** @private */
      _onComboBoxItemSelected(event) {
        this.__selectItem(event.detail.item);
      }
      /** @private */
      _onCustomValueSet(event) {
        event.preventDefault();
        event.stopPropagation();
        this.__clearInternalValue(true);
        this.dispatchEvent(
          new CustomEvent("custom-value-set", {
            detail: event.detail,
            composed: true,
            bubbles: true
          })
        );
      }
      /** @private */
      _onItemRemoved(event) {
        this.__removeItem(event.detail.item);
      }
      /** @private */
      _preventBlur(event) {
        event.preventDefault();
      }
      /**
       * Fired when the user sets a custom value.
       * @event custom-value-set
       * @param {string} detail the custom value
       */
    }
    defineCustomElement(MultiSelectComboBox);
    registerStyles$1(
      "vaadin-confirm-dialog-overlay",
      [
        overlay,
        dialogOverlay,
        css$e`
      [part='header'] ::slotted(h3) {
        margin-top: 0 !important;
        margin-bottom: 0 !important;
        margin-inline-start: calc(var(--lumo-space-l) - var(--lumo-space-m));
      }

      [part='message'] {
        width: 25em;
        min-width: 100%;
        max-width: 100%;
      }

      ::slotted([slot$='button'][theme~='tertiary']) {
        padding-left: var(--lumo-space-s);
        padding-right: var(--lumo-space-s);
      }

      [part='cancel-button'] {
        flex-grow: 1;
      }

      @media (max-width: 360px) {
        [part='footer'] {
          flex-direction: column-reverse;
          align-items: stretch;
          padding: var(--lumo-space-s) var(--lumo-space-l);
          gap: var(--lumo-space-s);
        }

        ::slotted([slot$='button']) {
          width: 100%;
          margin: 0;
        }
      }
    `
      ],
      { moduleId: "lumo-confirm-dialog-overlay" }
    );
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const ConfirmDialogBaseMixin = (superClass) => class ConfirmDialogBaseMixinClass extends superClass {
      static get properties() {
        return {
          /**
           * Set the `aria-label` attribute for assistive technologies like
           * screen readers. An empty string value for this property (the
           * default) means that the `aria-label` attribute is not present.
           */
          ariaLabel: {
            type: String,
            value: ""
          },
          /**
           * Height to be set on the overlay content.
           */
          contentHeight: {
            type: String
          },
          /**
           * Width to be set on the overlay content.
           */
          contentWidth: {
            type: String
          }
        };
      }
      static get observers() {
        return [
          "__updateContentHeight(contentHeight, _overlayElement)",
          "__updateContentWidth(contentWidth, _overlayElement)"
        ];
      }
      /** @private */
      __updateDimension(overlay2, dimension, value) {
        const prop = `--_vaadin-confirm-dialog-content-${dimension}`;
        if (value) {
          overlay2.style.setProperty(prop, value);
        } else {
          overlay2.style.removeProperty(prop);
        }
      }
      /** @private */
      __updateContentHeight(height, overlay2) {
        if (overlay2) {
          this.__updateDimension(overlay2, "height", height);
        }
      }
      /** @private */
      __updateContentWidth(width, overlay2) {
        if (overlay2) {
          this.__updateDimension(overlay2, "width", width);
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const confirmDialogOverlay = css$e`
  :host {
    --_vaadin-confirm-dialog-content-width: auto;
    --_vaadin-confirm-dialog-content-height: auto;
  }

  [part='overlay'] {
    width: var(--_vaadin-confirm-dialog-content-width);
    height: var(--_vaadin-confirm-dialog-content-height);
  }

  ::slotted([slot='header']) {
    pointer-events: auto;
  }

  /* Make buttons clickable */
  [part='footer'] > * {
    pointer-events: all;
  }
`;
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-confirm-dialog-overlay", [overlayStyles, dialogOverlay$1, confirmDialogOverlay], {
      moduleId: "vaadin-confirm-dialog-overlay-styles"
    });
    class ConfirmDialogOverlay extends OverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
      static get is() {
        return "vaadin-confirm-dialog-overlay";
      }
      static get template() {
        return html`
      <div part="backdrop" id="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <section id="resizerContainer" class="resizer-container">
          <header part="header"><slot name="header"></slot></header>
          <div part="content" id="content">
            <div part="message"><slot></slot></div>
          </div>
          <footer part="footer" role="toolbar">
            <div part="cancel-button">
              <slot name="cancel-button"></slot>
            </div>
            <div part="reject-button">
              <slot name="reject-button"></slot>
            </div>
            <div part="confirm-button">
              <slot name="confirm-button"></slot>
            </div>
          </footer>
        </section>
      </div>
    `;
      }
      /**
       * @protected
       * @override
       */
      ready() {
        super.ready();
        this.setAttribute("has-header", "");
        this.setAttribute("has-footer", "");
      }
    }
    defineCustomElement(ConfirmDialogOverlay);
    class ConfirmDialogDialog extends ConfirmDialogBaseMixin(
      DialogBaseMixin(OverlayClassMixin(ThemePropertyMixin(PolymerElement)))
    ) {
      static get is() {
        return "vaadin-confirm-dialog-dialog";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: none;
        }
      </style>

      <vaadin-confirm-dialog-overlay
        id="overlay"
        opened="[[opened]]"
        on-opened-changed="_onOverlayOpened"
        on-mousedown="_bringOverlayToFront"
        on-touchstart="_bringOverlayToFront"
        theme$="[[_theme]]"
        modeless="[[modeless]]"
        with-backdrop="[[!modeless]]"
        resizable$="[[resizable]]"
        aria-label$="[[ariaLabel]]"
        restore-focus-on-close
        focus-trap
      ></vaadin-confirm-dialog-overlay>
    `;
      }
    }
    defineCustomElement(ConfirmDialogDialog);
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const ConfirmDialogMixin = (superClass) => class ConfirmDialogMixinClass extends superClass {
      static get properties() {
        return {
          /**
           * Sets the `aria-describedby` attribute of the overlay element.
           *
           * By default, all elements inside the message area are linked
           * through the `aria-describedby` attribute. However, there are
           * cases where this can confuse screen reader users (e.g. the dialog
           * may present a password confirmation form). For these cases,
           * it's better to associate only the elements that will help describe
           * the confirmation dialog through this API.
           */
          accessibleDescriptionRef: {
            type: String
          },
          /**
           * True if the overlay is currently displayed.
           * @type {boolean}
           */
          opened: {
            type: Boolean,
            value: false,
            notify: true
          },
          /**
           * Set the confirmation dialog title.
           * @type {string}
           */
          header: {
            type: String,
            value: ""
          },
          /**
           * Set the message or confirmation question.
           */
          message: {
            type: String,
            value: ""
          },
          /**
           * Text displayed on confirm-button.
           * This only affects the default button, custom slotted buttons will not be altered.
           * @attr {string} confirm-text
           * @type {string}
           */
          confirmText: {
            type: String,
            value: "Confirm"
          },
          /**
           * Theme for a confirm-button.
           * This only affects the default button, custom slotted buttons will not be altered.
           * @attr {string} confirm-theme
           * @type {string}
           */
          confirmTheme: {
            type: String,
            value: "primary"
          },
          /**
           * Set to true to disable closing dialog on Escape press
           * @attr {boolean} no-close-on-esc
           * @type {boolean}
           */
          noCloseOnEsc: {
            type: Boolean,
            value: false
          },
          /**
           * Whether to show reject button or not.
           * @attr {boolean} reject-button-visible
           * @type {boolean}
           */
          rejectButtonVisible: {
            type: Boolean,
            reflectToAttribute: true,
            value: false
          },
          /**
           * Text displayed on reject-button.
           * This only affects the default button, custom slotted buttons will not be altered.
           * @attr {string} reject-text
           * @type {string}
           */
          rejectText: {
            type: String,
            value: "Reject"
          },
          /**
           * Theme for a reject-button.
           * This only affects the default button, custom slotted buttons will not be altered.
           * @attr {string} reject-theme
           * @type {string}
           */
          rejectTheme: {
            type: String,
            value: "error tertiary"
          },
          /**
           * Whether to show cancel button or not.
           * @attr {boolean} cancel-button-visible
           * @type {boolean}
           */
          cancelButtonVisible: {
            type: Boolean,
            reflectToAttribute: true,
            value: false
          },
          /**
           * Text displayed on cancel-button.
           * This only affects the default button, custom slotted buttons will not be altered.
           * @attr {string} cancel-text
           * @type {string}
           */
          cancelText: {
            type: String,
            value: "Cancel"
          },
          /**
           * Theme for a cancel-button.
           * This only affects the default button, custom slotted buttons will not be altered.
           * @attr {string} cancel-theme
           * @type {string}
           */
          cancelTheme: {
            type: String,
            value: "tertiary"
          },
          /**
           * A space-delimited list of CSS class names
           * to set on the underlying overlay element.
           *
           * @attr {string} overlay-class
           */
          overlayClass: {
            type: String
          },
          /**
           * A reference to the "Cancel" button which will be teleported to the overlay.
           * @private
           */
          _cancelButton: {
            type: Object
          },
          /**
           * A reference to the "Confirm" button which will be teleported to the overlay.
           * @private
           */
          _confirmButton: {
            type: Object
          },
          /**
           * A reference to the "header" node which will be teleported to the overlay.
           * @private
           */
          _headerNode: {
            type: Object
          },
          /**
           * A list of message nodes which will be placed in the overlay default slot.
           * @private
           */
          _messageNodes: {
            type: Array,
            value: () => []
          },
          /**
           * A reference to the overlay element.
           * @private
           */
          _overlayElement: {
            type: Object,
            sync: true
          },
          /**
           * A reference to the "Reject" button which will be teleported to the overlay.
           * @private
           */
          _rejectButton: {
            type: Object
          },
          /**
           * Height to be set on the overlay content.
           * @protected
           */
          _contentHeight: {
            type: String
          },
          /**
           * Width to be set on the overlay content.
           * @protected
           */
          _contentWidth: {
            type: String
          }
        };
      }
      static get observers() {
        return [
          "__updateConfirmButton(_confirmButton, confirmText, confirmTheme)",
          "__updateCancelButton(_cancelButton, cancelText, cancelTheme, cancelButtonVisible)",
          "__updateHeaderNode(_headerNode, header)",
          "__updateMessageNodes(_messageNodes, message)",
          "__updateRejectButton(_rejectButton, rejectText, rejectTheme, rejectButtonVisible)",
          "__accessibleDescriptionRefChanged(_overlayElement, _messageNodes, accessibleDescriptionRef)"
        ];
      }
      constructor() {
        super();
        this.__cancel = this.__cancel.bind(this);
        this.__confirm = this.__confirm.bind(this);
        this.__reject = this.__reject.bind(this);
      }
      get __slottedNodes() {
        return [this._headerNode, ...this._messageNodes, this._cancelButton, this._confirmButton, this._rejectButton];
      }
      /** @protected */
      ready() {
        super.ready();
        this._headerController = new SlotController(this, "header", "h3", {
          initializer: (node) => {
            this._headerNode = node;
          }
        });
        this.addController(this._headerController);
        this._messageController = new SlotController(this, "", "div", {
          // Allow providing multiple custom nodes in the default slot
          multiple: true,
          observe: false,
          initializer: (node) => {
            const wrapper = document.createElement("div");
            wrapper.style.display = "contents";
            const wrapperId = `confirm-dialog-message-${generateUniqueId()}`;
            wrapper.id = wrapperId;
            this.appendChild(wrapper);
            wrapper.appendChild(node);
            this._messageNodes = [...this._messageNodes, wrapper];
          }
        });
        this.addController(this._messageController);
        this._cancelController = new SlotController(this, "cancel-button", "vaadin-button", {
          initializer: (button2) => {
            this.__setupSlottedButton("cancel", button2);
          }
        });
        this.addController(this._cancelController);
        this._rejectController = new SlotController(this, "reject-button", "vaadin-button", {
          initializer: (button2) => {
            this.__setupSlottedButton("reject", button2);
          }
        });
        this.addController(this._rejectController);
        this._confirmController = new SlotController(this, "confirm-button", "vaadin-button", {
          initializer: (button2) => {
            this.__setupSlottedButton("confirm", button2);
          }
        });
        this.addController(this._confirmController);
      }
      /** @protected */
      _initOverlay(overlay2) {
        overlay2.addEventListener("vaadin-overlay-escape-press", this._escPressed.bind(this));
        overlay2.addEventListener("vaadin-overlay-open", () => this.__onDialogOpened());
        overlay2.addEventListener("vaadin-overlay-closed", () => this.__onDialogClosed());
        overlay2.setAttribute("role", "alertdialog");
      }
      /** @private */
      __onDialogOpened() {
        const overlay2 = this._overlayElement;
        this.__slottedNodes.forEach((node) => {
          overlay2.appendChild(node);
        });
        const confirmButton = overlay2.querySelector('[slot="confirm-button"]');
        if (confirmButton) {
          confirmButton.focus();
        }
      }
      /** @private */
      __onDialogClosed() {
        this.__slottedNodes.forEach((node) => {
          this.appendChild(node);
        });
      }
      /** @private */
      __accessibleDescriptionRefChanged(overlay2, messageNodes, accessibleDescriptionRef) {
        if (!overlay2 || !messageNodes) {
          return;
        }
        if (accessibleDescriptionRef !== void 0) {
          setAriaIDReference(overlay2, "aria-describedby", {
            newId: accessibleDescriptionRef,
            oldId: this.__oldAccessibleDescriptionRef,
            fromUser: true
          });
        } else {
          messageNodes.forEach((node) => {
            setAriaIDReference(overlay2, "aria-describedby", { newId: node.id });
          });
        }
        this.__oldAccessibleDescriptionRef = accessibleDescriptionRef;
      }
      /** @private */
      __setupSlottedButton(type, button2) {
        const property = `_${type}Button`;
        const listener = `__${type}`;
        if (this[property] && this[property] !== button2) {
          this[property].remove();
        }
        button2.addEventListener("click", this[listener]);
        this[property] = button2;
      }
      /** @private */
      __updateCancelButton(button2, cancelText, cancelTheme, showCancel) {
        if (button2) {
          if (button2 === this._cancelController.defaultNode) {
            button2.textContent = cancelText;
            button2.setAttribute("theme", cancelTheme);
          }
          button2.toggleAttribute("hidden", !showCancel);
        }
      }
      /** @private */
      __updateConfirmButton(button2, confirmText, confirmTheme) {
        if (button2 && button2 === this._confirmController.defaultNode) {
          button2.textContent = confirmText;
          button2.setAttribute("theme", confirmTheme);
        }
      }
      /** @private */
      __updateHeaderNode(headerNode, header) {
        if (headerNode && headerNode === this._headerController.defaultNode) {
          headerNode.textContent = header;
        }
      }
      /** @private */
      __updateMessageNodes(nodes, message) {
        if (nodes && nodes.length > 0) {
          const defaultWrapperNode = nodes.find(
            (node) => this._messageController.defaultNode && node === this._messageController.defaultNode.parentElement
          );
          if (defaultWrapperNode) {
            defaultWrapperNode.firstChild.textContent = message;
          }
        }
      }
      /** @private */
      __updateRejectButton(button2, rejectText, rejectTheme, showReject) {
        if (button2) {
          if (button2 === this._rejectController.defaultNode) {
            button2.textContent = rejectText;
            button2.setAttribute("theme", rejectTheme);
          }
          button2.toggleAttribute("hidden", !showReject);
        }
      }
      /** @private */
      _escPressed(event) {
        if (!event.defaultPrevented) {
          this.__cancel();
        }
      }
      /** @private */
      __confirm() {
        this.dispatchEvent(new CustomEvent("confirm"));
        this.opened = false;
      }
      /** @private */
      __cancel() {
        this.dispatchEvent(new CustomEvent("cancel"));
        this.opened = false;
      }
      /** @private */
      __reject() {
        this.dispatchEvent(new CustomEvent("reject"));
        this.opened = false;
      }
      /** @private */
      _getAriaLabel(header) {
        return header || "confirmation";
      }
    };
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class ConfirmDialog extends ConfirmDialogMixin(ElementMixin(ThemePropertyMixin(ControllerMixin(PolymerElement)))) {
      static get template() {
        return html`
      <style>
        :host,
        [hidden] {
          display: none !important;
        }
      </style>

      <vaadin-confirm-dialog-dialog
        id="dialog"
        opened="{{opened}}"
        overlay-class="[[overlayClass]]"
        aria-label="[[_getAriaLabel(header)]]"
        theme$="[[_theme]]"
        no-close-on-outside-click
        no-close-on-esc="[[noCloseOnEsc]]"
        content-height="[[_contentHeight]]"
        content-width="[[_contentWidth]]"
      ></vaadin-confirm-dialog-dialog>

      <div hidden>
        <slot name="header"></slot>
        <slot></slot>
        <slot name="cancel-button"></slot>
        <slot name="reject-button"></slot>
        <slot name="confirm-button"></slot>
      </div>
    `;
      }
      static get is() {
        return "vaadin-confirm-dialog";
      }
      /** @protected */
      ready() {
        super.ready();
        this._overlayElement = this.$.dialog.$.overlay;
        this._initOverlay(this._overlayElement);
      }
      /**
       * @event confirm
       * fired when Confirm button was pressed.
       */
      /**
       * @event cancel
       * fired when Cancel button or Escape key was pressed.
       */
      /**
       * @event reject
       * fired when Reject button was pressed.
       */
    }
    defineCustomElement(ConfirmDialog);
    (function() {
      function tryCatchWrapper(callback) {
        return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Context Menu");
      }
      function getContainer(appId, nodeId) {
        try {
          return window.Vaadin.Flow.clients[appId].getByNodeId(nodeId);
        } catch (error2) {
          console.error("Could not get node %s from app %s", nodeId, appId);
          console.error(error2);
        }
      }
      function initLazy(contextMenu, appId) {
        if (contextMenu.$connector) {
          return;
        }
        contextMenu.$connector = {
          /**
           * Generates and assigns the items to the context menu.
           *
           * @param {number} nodeId
           */
          generateItems: tryCatchWrapper((nodeId) => {
            const items = generateItemsTree(appId, nodeId);
            contextMenu.items = items;
          })
        };
      }
      function generateItemsTree(appId, nodeId) {
        const container = getContainer(appId, nodeId);
        if (!container) {
          return;
        }
        return Array.from(container.children).map((child) => {
          const item2 = {
            component: child,
            checked: child._checked,
            keepOpen: child._keepOpen,
            className: child.className,
            theme: child.__theme
          };
          if (child._hasVaadinItemMixin && child._containerNodeId) {
            item2.children = generateItemsTree(appId, child._containerNodeId);
          }
          child._item = item2;
          return item2;
        });
      }
      function setChecked(component, checked) {
        if (component._item) {
          component._item.checked = checked;
          if (component._item.keepOpen) {
            component.toggleAttribute("menu-item-checked", checked);
          }
        }
      }
      function setKeepOpen(component, keepOpen) {
        if (component._item) {
          component._item.keepOpen = keepOpen;
        }
      }
      function setTheme(component, theme2) {
        if (component._item) {
          component._item.theme = theme2;
        }
      }
      window.Vaadin.Flow.contextMenuConnector = {
        initLazy(...args) {
          return tryCatchWrapper(initLazy)(...args);
        },
        generateItemsTree(...args) {
          return tryCatchWrapper(generateItemsTree)(...args);
        },
        setChecked(...args) {
          return tryCatchWrapper(setChecked)(...args);
        },
        setKeepOpen(...args) {
          return tryCatchWrapper(setKeepOpen)(...args);
        },
        setTheme(...args) {
          return tryCatchWrapper(setTheme)(...args);
        }
      };
    })();
    (function() {
      function tryCatchWrapper(callback) {
        return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Context Menu Target");
      }
      function init(target) {
        if (target.$contextMenuTargetConnector) {
          return;
        }
        target.$contextMenuTargetConnector = {
          openOnHandler: tryCatchWrapper(function(e2) {
            if (target.preventContextMenu && target.preventContextMenu(e2)) {
              return;
            }
            e2.preventDefault();
            e2.stopPropagation();
            this.$contextMenuTargetConnector.openEvent = e2;
            let detail = {};
            if (target.getContextMenuBeforeOpenDetail) {
              detail = target.getContextMenuBeforeOpenDetail(e2);
            }
            target.dispatchEvent(
              new CustomEvent("vaadin-context-menu-before-open", {
                detail
              })
            );
          }),
          updateOpenOn: tryCatchWrapper(function(eventType) {
            this.removeListener();
            this.openOnEventType = eventType;
            customElements.whenDefined("vaadin-context-menu").then(
              tryCatchWrapper(() => {
                if (gestures[eventType]) {
                  addListener(target, eventType, this.openOnHandler);
                } else {
                  target.addEventListener(eventType, this.openOnHandler);
                }
              })
            );
          }),
          removeListener: tryCatchWrapper(function() {
            if (this.openOnEventType) {
              if (gestures[this.openOnEventType]) {
                removeListener(target, this.openOnEventType, this.openOnHandler);
              } else {
                target.removeEventListener(this.openOnEventType, this.openOnHandler);
              }
            }
          }),
          openMenu: tryCatchWrapper(function(contextMenu) {
            contextMenu.open(this.openEvent);
          }),
          removeConnector: tryCatchWrapper(function() {
            this.removeListener();
            target.$contextMenuTargetConnector = void 0;
          })
        };
      }
      window.Vaadin.Flow.contextMenuTargetConnector = {
        init(...args) {
          return tryCatchWrapper(init)(...args);
        }
      };
    })();
    /**
     * @license
     * Copyright (c) 2019 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const customField = css$e`
  :host {
    --lumo-text-field-size: var(--lumo-size-m);
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-m);
    /* align with text-field height + vertical paddings */
    line-height: calc(var(--lumo-text-field-size) + 2 * var(--lumo-space-xs));
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: 0;
  }

  :host::before {
    margin-top: var(--lumo-space-xs);
    height: var(--lumo-text-field-size);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  /* align with text-field label */
  :host([has-label]) [part='label'] {
    padding-bottom: calc(0.5em - var(--lumo-space-xs));
  }

  :host(:not([has-label])) [part='label'],
  :host(:not([has-label]))::before {
    display: none;
  }

  /* align with text-field error message */
  :host([has-error-message]) [part='error-message']::before {
    height: calc(0.4em - var(--lumo-space-xs));
  }

  :host([focused]:not([readonly]):not([disabled])) [part='label'] {
    color: var(--lumo-primary-text-color);
  }

  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'],
  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'] {
      color: var(--lumo-secondary-text-color);
    }
  }

  /* Disabled */
  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  /* Small theme */
  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-text-field-size: var(--lumo-size-s);
  }

  :host([theme~='small'][has-label]) [part='label'] {
    font-size: var(--lumo-font-size-xs);
  }

  :host([theme~='small'][has-label]) [part='error-message'] {
    font-size: var(--lumo-font-size-xxs);
  }

  /* When custom-field is used with components without outer margin */
  :host([theme~='whitespace'][has-label]) [part='label'] {
    padding-bottom: 0.5em;
  }
`;
    registerStyles$1("vaadin-custom-field", [requiredField, helper, customField], {
      moduleId: "lumo-custom-field"
    });
    /**
     * @license
     * Copyright (c) 2019 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const defaultParseValue = (value) => {
      return value.split("	");
    };
    const defaultFormatValue = (inputValues) => {
      return inputValues.join("	");
    };
    const CustomFieldMixin = (superClass) => class CustomFieldMixin extends FieldMixin(FocusMixin(KeyboardMixin(superClass))) {
      static get properties() {
        return {
          /**
           * The name of the control, which is submitted with the form data.
           */
          name: String,
          /**
           * The value of the field. When wrapping several inputs, it will contain `\t`
           * (Tab character) as a delimiter indicating parts intended to be used as the
           * corresponding inputs values.
           * Use the [`formatValue`](#/elements/vaadin-custom-field#property-formatValue)
           * and [`parseValue`](#/elements/vaadin-custom-field#property-parseValue)
           * properties to customize this behavior.
           */
          value: {
            type: String,
            observer: "__valueChanged",
            notify: true
          },
          /**
           * Array of available input nodes
           * @type {!Array<!HTMLElement> | undefined}
           */
          inputs: {
            type: Array,
            readOnly: true
          },
          /**
           * A function to format the values of the individual fields contained by
           * the custom field into a single component value. The function receives
           * an array of all values of the individual fields in the order of their
           * presence in the DOM, and must return a single component value.
           * This function is called each time a value of an internal field is
           * changed.
           *
           * Example:
           * ```js
           * customField.formatValue = (fieldValues) => {
           *   return fieldValues.join("-");
           * }
           * ```
           * @type {!CustomFieldFormatValueFn | undefined}
           */
          formatValue: {
            type: Function
          },
          /**
           * A function to parse the component value into values for the individual
           * fields contained by the custom field. The function receives the
           * component value, and must return an array of values for the individual
           * fields in the order of their presence in the DOM.
           * The function is called each time the value of the component changes.
           *
           * Example:
           * ```js
           * customField.parseValue = (componentValue) => {
           *   return componentValue.split("-");
           * }
           * ```
           * @type {!CustomFieldParseValueFn | undefined}
           */
          parseValue: {
            type: Function
          }
        };
      }
      /** @protected */
      ready() {
        super.ready();
        this.setAttribute("role", "group");
        this.ariaTarget = this;
        this.__childrenObserver = new MutationObserver(() => {
          this.__setInputsFromSlot();
        });
        this.__setInputsFromSlot();
        this.$.slot.addEventListener("slotchange", () => {
          this.__setInputsFromSlot();
          getFlattenedElements(this.$.slot).filter((el) => !this.__isInput(el)).forEach((el) => {
            this.__childrenObserver.observe(el, { childList: true });
          });
        });
        this._tooltipController = new TooltipController(this);
        this.addController(this._tooltipController);
        this._tooltipController.setShouldShow((target) => {
          const inputs = target.inputs || [];
          return !inputs.some((el) => el.opened);
        });
      }
      /** @protected */
      focus() {
        if (this.inputs && this.inputs[0]) {
          this.inputs[0].focus();
        }
      }
      /**
       * Override method inherited from `FocusMixin` to validate on blur.
       * @param {boolean} focused
       * @protected
       */
      _setFocused(focused) {
        super._setFocused(focused);
        if (!focused) {
          this.validate();
        }
      }
      /**
       * Override method inherited from `FocusMixin` to not remove focused
       * state when focus moves to another input in the custom field.
       * @param {FocusEvent} event
       * @return {boolean}
       * @protected
       */
      _shouldRemoveFocus(event) {
        const { relatedTarget } = event;
        return !this.inputs.some((el) => relatedTarget === (el.focusElement || el));
      }
      /**
       * Returns true if the current inputs values satisfy all constraints (if any).
       *
       * @return {boolean}
       */
      checkValidity() {
        const invalidFields = this.inputs.filter((input) => !(input.validate || input.checkValidity).call(input));
        if (invalidFields.length || this.required && !this.value.trim()) {
          return false;
        }
        return true;
      }
      /**
       * @param {KeyboardEvent} e
       * @protected
       * @override
       */
      _onKeyDown(e2) {
        if (e2.key === "Tab") {
          if (this.inputs.indexOf(e2.target) < this.inputs.length - 1 && !e2.shiftKey || this.inputs.indexOf(e2.target) > 0 && e2.shiftKey) {
            this.dispatchEvent(new CustomEvent("internal-tab"));
          } else {
            this.__setValue();
          }
        }
      }
      /** @protected */
      _onInputChange(event) {
        event.stopPropagation();
        this.__setValue();
        this.validate();
        this.dispatchEvent(
          new CustomEvent("change", {
            bubbles: true,
            cancelable: false,
            detail: {
              value: this.value
            }
          })
        );
      }
      /** @private */
      __setValue() {
        this.__settingValue = true;
        const formatFn = this.formatValue || defaultFormatValue;
        this.value = formatFn.apply(this, [this.inputs.map((input) => input.value)]);
        this.__settingValue = false;
      }
      /** @private */
      __isInput(node) {
        const isSlottedInput = node.getAttribute("slot") === "input" || node.getAttribute("slot") === "textarea";
        return !isSlottedInput && (node.validate || node.checkValidity);
      }
      /** @private */
      __getInputsFromSlot() {
        return getFlattenedElements(this.$.slot).filter((node) => this.__isInput(node));
      }
      /** @private */
      __setInputsFromSlot() {
        this._setInputs(this.__getInputsFromSlot());
        this.__setValue();
      }
      /** @private */
      __toggleHasValue(value) {
        this.toggleAttribute("has-value", value !== null && value.trim() !== "");
      }
      /** @private */
      __valueChanged(value, oldValue) {
        if (this.__settingValue || !this.inputs) {
          return;
        }
        this.__toggleHasValue(value);
        const parseFn = this.parseValue || defaultParseValue;
        const valuesArray = parseFn.apply(this, [value]);
        if (!valuesArray || valuesArray.length === 0) {
          console.warn("Value parser has not provided values array");
          return;
        }
        this.inputs.forEach((input, id) => {
          input.value = valuesArray[id];
        });
        if (oldValue !== void 0) {
          this.validate();
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2019 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const customFieldStyles = css$e`
  :host {
    display: inline-flex;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
    /* Size and position this element on the same vertical position as the input-field element
           to make vertical align for the host element work as expected */
  }

  :host([hidden]) {
    display: none !important;
  }

  .vaadin-custom-field-container {
    width: 100%;
    display: flex;
    flex-direction: column;
  }

  .inputs-wrapper {
    flex: none;
  }
`;
    /**
     * @license
     * Copyright (c) 2019 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-custom-field", customFieldStyles, { moduleId: "vaadin-custom-field-styles" });
    class CustomField extends CustomFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
      static get is() {
        return "vaadin-custom-field";
      }
      static get template() {
        return html`
      <div class="vaadin-custom-field-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="inputs-wrapper" part="input-fields" on-change="_onInputChange">
          <slot id="slot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
      }
      /**
       * Fired when the user commits a value change for any of the internal inputs.
       *
       * @event change
       */
    }
    defineCustomElement(CustomField);
    const datePickerOverlay = css$e`
  [part='overlay'] {
    /*
  Width:
      date cell widths
    + month calendar side padding
    + year scroller width
  */
    /* prettier-ignore */
    width:
    calc(
        var(--lumo-size-m) * 7
      + var(--lumo-space-xs) * 2
      + 57px
    );
    height: 100%;
    max-height: calc(var(--lumo-size-m) * 14);
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
  }

  [part='overlay'] {
    flex-direction: column;
  }

  [part='content'] {
    padding: 0;
    height: 100%;
    overflow: hidden;
    -webkit-mask-image: none;
    mask-image: none;
  }

  :host([top-aligned]) [part~='overlay'] {
    margin-top: var(--lumo-space-xs);
  }

  :host([bottom-aligned]) [part~='overlay'] {
    margin-bottom: var(--lumo-space-xs);
  }

  @media (max-width: 420px), (max-height: 420px) {
    [part='overlay'] {
      width: 100vw;
      height: 70vh;
      max-height: 70vh;
    }
  }
`;
    registerStyles$1("vaadin-date-picker-overlay", [menuOverlay, datePickerOverlay], {
      moduleId: "lumo-date-picker-overlay"
    });
    registerStyles$1(
      "vaadin-date-picker-year",
      css$e`
    :host([current]) [part='year-number'] {
      color: var(--lumo-primary-text-color);
    }

    :host(:not([current])) [part='year-number'],
    [part='year-separator'] {
      opacity: var(--_lumo-date-picker-year-opacity, 0.7);
      transition: 0.2s opacity;
    }

    [part='year-number'],
    [part='year-separator'] {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 50%;
      transform: translateY(-50%);
    }

    [part='year-separator']::after {
      color: var(--lumo-disabled-text-color);
      content: '\\2022';
    }
  `,
      { moduleId: "lumo-date-picker-year" }
    );
    registerStyles$1(
      "vaadin-date-picker-overlay-content",
      css$e`
    :host {
      position: relative;
      /* Background for the year scroller, placed here as we are using a mask image on the actual years part */
      background-image: linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));
      background-size: 57px 100%;
      background-position: top right;
      background-repeat: no-repeat;
      cursor: default;
    }

    ::slotted([slot='months']) {
      /* Month calendar height:
              header height + margin-bottom
            + weekdays height + margin-bottom
            + date cell heights
            + small margin between month calendars
        */
      /* prettier-ignore */
      --vaadin-infinite-scroller-item-height:
          calc(
              var(--lumo-font-size-l) + var(--lumo-space-m)
            + var(--lumo-font-size-xs) + var(--lumo-space-s)
            + var(--lumo-size-m) * 6
            + var(--lumo-space-s)
          );
      --vaadin-infinite-scroller-buffer-offset: 10%;
      -webkit-mask-image: linear-gradient(transparent, #000 10%, #000 85%, transparent);
      mask-image: linear-gradient(transparent, #000 10%, #000 85%, transparent);
      position: relative;
      margin-right: 57px;
    }

    ::slotted([slot='years']) {
      /* TODO get rid of fixed magic number */
      --vaadin-infinite-scroller-buffer-width: 97px;
      width: 57px;
      height: auto;
      top: 0;
      bottom: 0;
      font-size: var(--lumo-font-size-s);
      box-shadow: inset 2px 0 4px 0 var(--lumo-shade-5pct);
      -webkit-mask-image: linear-gradient(transparent, #000 35%, #000 65%, transparent);
      mask-image: linear-gradient(transparent, #000 35%, #000 65%, transparent);
      cursor: var(--lumo-clickable-cursor);
    }

    ::slotted([slot='years']:hover) {
      --_lumo-date-picker-year-opacity: 1;
    }

    /* TODO unsupported selector */
    #scrollers {
      position: static;
      display: block;
    }

    /* TODO fix this in vaadin-date-picker that it adapts to the width of the year scroller */
    :host([desktop]) ::slotted([slot='months']) {
      right: auto;
    }

    /* Year scroller position indicator */
    ::slotted([slot='years'])::before {
      border: none;
      width: 1em;
      height: 1em;
      background-color: var(--lumo-base-color);
      background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
      transform: translate(-75%, -50%) rotate(45deg);
      border-top-right-radius: var(--lumo-border-radius-s);
      box-shadow: 2px -2px 6px 0 var(--lumo-shade-5pct);
      z-index: 1;
    }

    [part='toolbar'] {
      padding: var(--lumo-space-s);
      border-bottom-left-radius: var(--lumo-border-radius-l);
      margin-right: 57px;
    }

    [part='toolbar'] ::slotted(vaadin-button) {
      margin: 0;
    }

    /* Narrow viewport mode (fullscreen) */

    :host([fullscreen]) [part='toolbar'] {
      order: -1;
      background-color: var(--lumo-base-color);
    }

    :host([fullscreen]) [part='overlay-header'] {
      order: -2;
      height: var(--lumo-size-m);
      padding: var(--lumo-space-s);
      position: absolute;
      left: 0;
      right: 0;
      justify-content: center;
    }

    :host([fullscreen]) [part='toggle-button'],
    :host([fullscreen]) [part='clear-button'],
    [part='overlay-header'] [part='label'] {
      display: none;
    }

    /* Very narrow screen (year scroller initially hidden) */

    [part='years-toggle-button'] {
      display: flex;
      align-items: center;
      height: var(--lumo-size-s);
      padding: 0 0.5em;
      border-radius: var(--lumo-border-radius-m);
      z-index: 3;
      color: var(--lumo-primary-text-color);
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    :host([years-visible]) [part='years-toggle-button'] {
      background-color: var(--lumo-primary-color);
      color: var(--lumo-primary-contrast-color);
    }

    /* TODO magic number (same as used for media-query in vaadin-date-picker-overlay-content) */
    @media screen and (max-width: 374px) {
      :host {
        background-image: none;
      }

      [part='toolbar'],
      ::slotted([slot='months']) {
        margin-right: 0;
      }

      /* TODO make date-picker adapt to the width of the years part */
      ::slotted([slot='years']) {
        --vaadin-infinite-scroller-buffer-width: 90px;
        width: 50px;
        background-color: var(--lumo-shade-5pct);
      }

      :host([years-visible]) ::slotted([slot='months']) {
        padding-left: 50px;
      }
    }
  `,
      { moduleId: "lumo-date-picker-overlay-content" }
    );
    registerStyles$1(
      "vaadin-month-calendar",
      css$e`
    :host {
      -moz-user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      font-size: var(--lumo-font-size-m);
      color: var(--lumo-body-text-color);
      text-align: center;
      padding: 0 var(--lumo-space-xs);
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
      --_selection-color-text: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    }

    /* Month header */

    [part='month-header'] {
      color: var(--lumo-header-text-color);
      font-size: var(--lumo-font-size-l);
      line-height: 1;
      font-weight: 500;
      margin-bottom: var(--lumo-space-m);
    }

    /* Week days and numbers */

    [part='weekdays'],
    [part='weekday'],
    [part='week-number'] {
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
      color: var(--lumo-secondary-text-color);
    }

    [part='weekdays'] {
      margin-bottom: var(--lumo-space-s);
    }

    [part='weekday']:empty,
    [part='week-number'] {
      width: var(--lumo-size-xs);
    }

    /* Date and week number cells */

    [part~='date'],
    [part='week-number'] {
      box-sizing: border-box;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: var(--lumo-size-m);
      position: relative;
    }

    [part~='date'] {
      transition: color 0.1s;
    }

    [part~='date']:not(:empty) {
      cursor: var(--lumo-clickable-cursor);
    }

    :host([week-numbers]) [part='weekday']:not(:empty),
    :host([week-numbers]) [part~='date'] {
      width: calc((100% - var(--lumo-size-xs)) / 7);
    }

    /* Today date */

    [part~='date'][part~='today'] {
      color: var(--_selection-color-text);
    }

    /* Focused date */

    [part~='date']::before {
      content: '';
      position: absolute;
      z-index: -1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      min-width: 2em;
      min-height: 2em;
      width: 80%;
      height: 80%;
      max-height: 100%;
      max-width: 100%;
      border-radius: var(--lumo-border-radius-m);
    }

    [part~='date'][part~='focused']::before {
      box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color);
    }

    :host(:not([focused])) [part~='date'][part~='focused']::before {
      animation: vaadin-date-picker-month-calendar-focus-date 1.4s infinite;
    }

    @keyframes vaadin-date-picker-month-calendar-focus-date {
      50% {
        box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 calc(var(--_focus-ring-width) + 1px) transparent;
      }
    }

    [part~='date']:not(:empty):not([part~='disabled']):not([part~='selected']):hover::before {
      background-color: var(--lumo-primary-color-10pct);
    }

    [part~='date'][part~='selected'] {
      color: var(--lumo-primary-contrast-color);
    }

    [part~='date'][part~='selected']::before {
      background-color: var(--_selection-color);
    }

    [part~='date'][part~='disabled'] {
      color: var(--lumo-disabled-text-color);
    }

    @media (pointer: coarse) {
      [part~='date']:hover:not([part~='selected'])::before,
      [part~='focused']:not([part~='selected'])::before {
        display: none;
      }

      [part~='date']:not(:empty):not([part~='disabled']):active::before {
        display: block;
      }

      [part~='date'][part~='selected']::before {
        box-shadow: none;
      }
    }

    /* Disabled */

    :host([disabled]) * {
      color: var(--lumo-disabled-text-color) !important;
    }
  `,
      { moduleId: "lumo-month-calendar" }
    );
    const template$5 = document.createElement("template");
    template$5.innerHTML = `
  <style>
    @keyframes vaadin-date-picker-month-calendar-focus-date {
      50% {
        box-shadow: 0 0 0 var(--_focus-ring-width) transparent;
      }
    }
  </style>
`;
    document.head.appendChild(template$5.content);
    const datePicker = css$e`
  :host {
    outline: none;
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-calendar);
  }

  [part='clear-button']::before {
    content: var(--lumo-icons-cross);
  }

  @media (max-width: 420px), (max-height: 420px) {
    [part='overlay-content'] {
      height: 70vh;
    }
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }
`;
    registerStyles$1("vaadin-date-picker", [inputFieldShared, datePicker], { moduleId: "lumo-date-picker" });
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const datePickerOverlayStyles = css$e`
  [part='overlay'] {
    display: flex;
    flex: auto;
  }

  [part~='content'] {
    flex: auto;
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid;
    }
  }
`;
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-date-picker-overlay", [overlayStyles, datePickerOverlayStyles], {
      moduleId: "vaadin-date-picker-overlay-styles"
    });
    class DatePickerOverlay extends PositionMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
      static get is() {
        return "vaadin-date-picker-overlay";
      }
      static get template() {
        return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
      }
    }
    defineCustomElement(DatePickerOverlay);
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    function getISOWeekNumber(date) {
      let dayOfWeek = date.getDay();
      if (dayOfWeek === 0) {
        dayOfWeek = 7;
      }
      const nearestThursdayDiff = 4 - dayOfWeek;
      const nearestThursday = new Date(date.getTime() + nearestThursdayDiff * 24 * 3600 * 1e3);
      const firstOfJanuary = new Date(0, 0);
      firstOfJanuary.setFullYear(nearestThursday.getFullYear());
      const timeDiff = nearestThursday.getTime() - firstOfJanuary.getTime();
      const daysSinceFirstOfJanuary = Math.round(timeDiff / (24 * 3600 * 1e3));
      return Math.floor(daysSinceFirstOfJanuary / 7 + 1);
    }
    function dateEquals(date1, date2) {
      return date1 instanceof Date && date2 instanceof Date && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
    }
    function extractDateParts(date) {
      return {
        day: date.getDate(),
        month: date.getMonth(),
        year: date.getFullYear()
      };
    }
    function dateAllowed(date, min, max, isDateDisabled) {
      let dateIsDisabled = false;
      if (typeof isDateDisabled === "function" && !!date) {
        const dateToCheck = extractDateParts(date);
        dateIsDisabled = isDateDisabled(dateToCheck);
      }
      return (!min || date >= min) && (!max || date <= max) && !dateIsDisabled;
    }
    function getClosestDate(date, dates) {
      return dates.filter((date2) => date2 !== void 0).reduce((closestDate, candidate) => {
        if (!candidate) {
          return closestDate;
        }
        if (!closestDate) {
          return candidate;
        }
        const candidateDiff = Math.abs(date.getTime() - candidate.getTime());
        const closestDateDiff = Math.abs(closestDate.getTime() - date.getTime());
        return candidateDiff < closestDateDiff ? candidate : closestDate;
      });
    }
    function dateAfterXMonths(months) {
      const today = /* @__PURE__ */ new Date();
      const result2 = new Date(today);
      result2.setDate(1);
      result2.setMonth(parseInt(months) + today.getMonth());
      return result2;
    }
    function getAdjustedYear(referenceDate, year, month = 0, day = 1) {
      if (year > 99) {
        throw new Error("The provided year cannot have more than 2 digits.");
      }
      if (year < 0) {
        throw new Error("The provided year cannot be negative.");
      }
      let adjustedYear = year + Math.floor(referenceDate.getFullYear() / 100) * 100;
      if (referenceDate < new Date(adjustedYear - 50, month, day)) {
        adjustedYear -= 100;
      } else if (referenceDate > new Date(adjustedYear + 50, month, day)) {
        adjustedYear += 100;
      }
      return adjustedYear;
    }
    function parseDate(str) {
      const parts = /^([-+]\d{1}|\d{2,4}|[-+]\d{6})-(\d{1,2})-(\d{1,2})$/u.exec(str);
      if (!parts) {
        return void 0;
      }
      const date = new Date(0, 0);
      date.setFullYear(parseInt(parts[1], 10));
      date.setMonth(parseInt(parts[2], 10) - 1);
      date.setDate(parseInt(parts[3], 10));
      return date;
    }
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const template$4 = document.createElement("template");
    template$4.innerHTML = `
  <style>
    :host {
      display: block;
      overflow: hidden;
      height: 500px;
    }

    #scroller {
      position: relative;
      height: 100%;
      overflow: auto;
      outline: none;
      margin-right: -40px;
      -webkit-overflow-scrolling: touch;
      overflow-x: hidden;
    }

    #scroller.notouchscroll {
      -webkit-overflow-scrolling: auto;
    }

    #scroller::-webkit-scrollbar {
      display: none;
    }

    .buffer {
      position: absolute;
      width: var(--vaadin-infinite-scroller-buffer-width, 100%);
      box-sizing: border-box;
      padding-right: 40px;
      top: var(--vaadin-infinite-scroller-buffer-offset, 0);
      animation: fadein 0.2s;
    }

    @keyframes fadein {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
  </style>

  <div id="scroller">
    <div class="buffer"></div>
    <div class="buffer"></div>
    <div id="fullHeight"></div>
  </div>
`;
    class InfiniteScroller extends HTMLElement {
      constructor() {
        super();
        const root2 = this.attachShadow({ mode: "open" });
        root2.appendChild(template$4.content.cloneNode(true));
        this.bufferSize = 20;
        this._initialScroll = 5e5;
        this._initialIndex = 0;
        this._activated = false;
      }
      /**
       * @return {boolean}
       */
      get active() {
        return this._activated;
      }
      set active(active) {
        if (active && !this._activated) {
          this._createPool();
          this._activated = true;
        }
      }
      /**
       * @return {number}
       */
      get bufferOffset() {
        return this._buffers[0].offsetTop;
      }
      /**
       * @return {number}
       */
      get itemHeight() {
        if (!this._itemHeightVal) {
          const itemHeight = getComputedStyle(this).getPropertyValue("--vaadin-infinite-scroller-item-height");
          const tmpStyleProp = "background-position";
          this.$.fullHeight.style.setProperty(tmpStyleProp, itemHeight);
          const itemHeightPx = getComputedStyle(this.$.fullHeight).getPropertyValue(tmpStyleProp);
          this.$.fullHeight.style.removeProperty(tmpStyleProp);
          this._itemHeightVal = parseFloat(itemHeightPx);
        }
        return this._itemHeightVal;
      }
      /** @private */
      get _bufferHeight() {
        return this.itemHeight * this.bufferSize;
      }
      /**
       * @return {number}
       */
      get position() {
        return (this.$.scroller.scrollTop - this._buffers[0].translateY) / this.itemHeight + this._firstIndex;
      }
      /**
       * Current scroller position as index. Can be a fractional number.
       *
       * @type {number}
       */
      set position(index) {
        this._preventScrollEvent = true;
        if (index > this._firstIndex && index < this._firstIndex + this.bufferSize * 2) {
          this.$.scroller.scrollTop = this.itemHeight * (index - this._firstIndex) + this._buffers[0].translateY;
        } else {
          this._initialIndex = ~~index;
          this._reset();
          this._scrollDisabled = true;
          this.$.scroller.scrollTop += index % 1 * this.itemHeight;
          this._scrollDisabled = false;
        }
        if (this._mayHaveMomentum) {
          this.$.scroller.classList.add("notouchscroll");
          this._mayHaveMomentum = false;
          setTimeout(() => {
            this.$.scroller.classList.remove("notouchscroll");
          }, 10);
        }
      }
      /** @protected */
      connectedCallback() {
        if (!this._ready) {
          this._ready = true;
          this.$ = {};
          this.shadowRoot.querySelectorAll("[id]").forEach((node) => {
            this.$[node.id] = node;
          });
          this.$.scroller.addEventListener("scroll", () => this._scroll());
          this._buffers = [...this.shadowRoot.querySelectorAll(".buffer")];
          this.$.fullHeight.style.height = `${this._initialScroll * 2}px`;
          if (isFirefox$4) {
            this.$.scroller.tabIndex = -1;
          }
        }
      }
      /**
       * Force the scroller to update clones after a reset, without
       * waiting for the debouncer to resolve.
       */
      forceUpdate() {
        if (this._debouncerUpdateClones) {
          this._buffers[0].updated = this._buffers[1].updated = false;
          this._updateClones();
          this._debouncerUpdateClones.cancel();
        }
      }
      /**
       * @protected
       * @override
       */
      _createElement() {
      }
      /**
       * @param {HTMLElement} _element
       * @param {number} _index
       * @protected
       * @override
       */
      _updateElement(_element, _index) {
      }
      /** @private */
      _finishInit() {
        if (!this._initDone) {
          this._buffers.forEach((buffer) => {
            [...buffer.children].forEach((slot) => {
              this._ensureStampedInstance(slot._itemWrapper);
            });
          });
          if (!this._buffers[0].translateY) {
            this._reset();
          }
          this._initDone = true;
          this.dispatchEvent(new CustomEvent("init-done"));
        }
      }
      /** @private */
      _translateBuffer(up) {
        const index = up ? 1 : 0;
        this._buffers[index].translateY = this._buffers[index ? 0 : 1].translateY + this._bufferHeight * (index ? -1 : 1);
        this._buffers[index].style.transform = `translate3d(0, ${this._buffers[index].translateY}px, 0)`;
        this._buffers[index].updated = false;
        this._buffers.reverse();
      }
      /** @private */
      _scroll() {
        if (this._scrollDisabled) {
          return;
        }
        const scrollTop = this.$.scroller.scrollTop;
        if (scrollTop < this._bufferHeight || scrollTop > this._initialScroll * 2 - this._bufferHeight) {
          this._initialIndex = ~~this.position;
          this._reset();
        }
        const offset2 = this.itemHeight + this.bufferOffset;
        const upperThresholdReached = scrollTop > this._buffers[1].translateY + offset2;
        const lowerThresholdReached = scrollTop < this._buffers[0].translateY + offset2;
        if (upperThresholdReached || lowerThresholdReached) {
          this._translateBuffer(lowerThresholdReached);
          this._updateClones();
        }
        if (!this._preventScrollEvent) {
          this.dispatchEvent(new CustomEvent("custom-scroll", { bubbles: false, composed: true }));
          this._mayHaveMomentum = true;
        }
        this._preventScrollEvent = false;
        this._debouncerScrollFinish = Debouncer$1.debounce(this._debouncerScrollFinish, timeOut$1.after(200), () => {
          const scrollerRect = this.$.scroller.getBoundingClientRect();
          if (!this._isVisible(this._buffers[0], scrollerRect) && !this._isVisible(this._buffers[1], scrollerRect)) {
            this.position = this.position;
          }
        });
      }
      /** @private */
      _reset() {
        this._scrollDisabled = true;
        this.$.scroller.scrollTop = this._initialScroll;
        this._buffers[0].translateY = this._initialScroll - this._bufferHeight;
        this._buffers[1].translateY = this._initialScroll;
        this._buffers.forEach((buffer) => {
          buffer.style.transform = `translate3d(0, ${buffer.translateY}px, 0)`;
        });
        this._buffers[0].updated = this._buffers[1].updated = false;
        this._updateClones(true);
        this._debouncerUpdateClones = Debouncer$1.debounce(this._debouncerUpdateClones, timeOut$1.after(200), () => {
          this._buffers[0].updated = this._buffers[1].updated = false;
          this._updateClones();
        });
        this._scrollDisabled = false;
      }
      /** @private */
      _createPool() {
        const container = this.getBoundingClientRect();
        this._buffers.forEach((buffer) => {
          for (let i = 0; i < this.bufferSize; i++) {
            const itemWrapper = document.createElement("div");
            itemWrapper.style.height = `${this.itemHeight}px`;
            itemWrapper.instance = {};
            const slotName = `vaadin-infinite-scroller-item-content-${generateUniqueId()}`;
            const slot = document.createElement("slot");
            slot.setAttribute("name", slotName);
            slot._itemWrapper = itemWrapper;
            buffer.appendChild(slot);
            itemWrapper.setAttribute("slot", slotName);
            this.appendChild(itemWrapper);
            if (this._isVisible(itemWrapper, container)) {
              this._ensureStampedInstance(itemWrapper);
            }
          }
        });
        requestAnimationFrame(() => {
          this._finishInit();
        });
      }
      /** @private */
      _ensureStampedInstance(itemWrapper) {
        if (itemWrapper.firstElementChild) {
          return;
        }
        const tmpInstance = itemWrapper.instance;
        itemWrapper.instance = this._createElement();
        itemWrapper.appendChild(itemWrapper.instance);
        Object.keys(tmpInstance).forEach((prop) => {
          itemWrapper.instance[prop] = tmpInstance[prop];
        });
      }
      /** @private */
      _updateClones(viewPortOnly) {
        this._firstIndex = ~~((this._buffers[0].translateY - this._initialScroll) / this.itemHeight) + this._initialIndex;
        const scrollerRect = viewPortOnly ? this.$.scroller.getBoundingClientRect() : void 0;
        this._buffers.forEach((buffer, bufferIndex) => {
          if (!buffer.updated) {
            const firstIndex = this._firstIndex + this.bufferSize * bufferIndex;
            [...buffer.children].forEach((slot, index) => {
              const itemWrapper = slot._itemWrapper;
              if (!viewPortOnly || this._isVisible(itemWrapper, scrollerRect)) {
                this._updateElement(itemWrapper.instance, firstIndex + index);
              }
            });
            buffer.updated = true;
          }
        });
      }
      /** @private */
      _isVisible(element, container) {
        const rect2 = element.getBoundingClientRect();
        return rect2.bottom > container.top && rect2.top < container.bottom;
      }
    }
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const stylesTemplate$1 = document.createElement("template");
    stylesTemplate$1.innerHTML = `
  <style>
    :host {
      --vaadin-infinite-scroller-item-height: 270px;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      height: 100%;
    }
  </style>
`;
    class DatePickerMonthScroller extends InfiniteScroller {
      static get is() {
        return "vaadin-date-picker-month-scroller";
      }
      constructor() {
        super();
        this.bufferSize = 3;
        this.shadowRoot.appendChild(stylesTemplate$1.content.cloneNode(true));
      }
      /**
       * @protected
       * @override
       */
      _createElement() {
        return document.createElement("vaadin-month-calendar");
      }
      /**
       * @param {HTMLElement} element
       * @param {number} index
       * @protected
       * @override
       */
      _updateElement(element, index) {
        element.month = dateAfterXMonths(index);
      }
    }
    defineCustomElement(DatePickerMonthScroller);
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const stylesTemplate = document.createElement("template");
    stylesTemplate.innerHTML = `
  <style>
    :host {
      --vaadin-infinite-scroller-item-height: 80px;
      width: 50px;
      display: block;
      height: 100%;
      position: absolute;
      right: 0;
      transform: translateX(100%);
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      /* Center the year scroller position. */
      --vaadin-infinite-scroller-buffer-offset: 50%;
    }

    :host::before {
      content: '';
      display: block;
      background: transparent;
      width: 0;
      height: 0;
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      border-width: 6px;
      border-style: solid;
      border-color: transparent;
      border-left-color: #000;
    }
  </style>
`;
    class DatePickerYearScroller extends InfiniteScroller {
      static get is() {
        return "vaadin-date-picker-year-scroller";
      }
      constructor() {
        super();
        this.bufferSize = 12;
        this.shadowRoot.appendChild(stylesTemplate.content.cloneNode(true));
      }
      /**
       * @protected
       * @override
       */
      _createElement() {
        return document.createElement("vaadin-date-picker-year");
      }
      /**
       * @param {HTMLElement} element
       * @param {number} index
       * @protected
       * @override
       */
      _updateElement(element, index) {
        element.year = this._yearAfterXYears(index);
      }
      /** @private */
      _yearAfterXYears(index) {
        const today = /* @__PURE__ */ new Date();
        const result2 = new Date(today);
        result2.setFullYear(parseInt(index) + today.getFullYear());
        return result2.getFullYear();
      }
    }
    defineCustomElement(DatePickerYearScroller);
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const DatePickerYearMixin = (superClass) => class DatePickerYearMixin extends superClass {
      static get properties() {
        return {
          year: {
            type: String,
            sync: true
          },
          selectedDate: {
            type: Object,
            sync: true
          }
        };
      }
      static get observers() {
        return ["__updateSelected(year, selectedDate)"];
      }
      /** @private */
      __updateSelected(year, selectedDate) {
        this.toggleAttribute("selected", selectedDate && selectedDate.getFullYear() === year);
        this.toggleAttribute("current", year === (/* @__PURE__ */ new Date()).getFullYear());
      }
    };
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class DatePickerYear extends ThemableMixin(DatePickerYearMixin(PolymerElement)) {
      static get is() {
        return "vaadin-date-picker-year";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: block;
          height: 100%;
        }
      </style>
      <div part="year-number">[[year]]</div>
      <div part="year-separator" aria-hidden="true"></div>
    `;
      }
    }
    defineCustomElement(DatePickerYear);
    /**
    @license
    Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */
    const domRepeatBase = OptionalMutableData(PolymerElement);
    class DomRepeat extends domRepeatBase {
      // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      static get is() {
        return "dom-repeat";
      }
      static get template() {
        return null;
      }
      static get properties() {
        return {
          /**
           * An array containing items determining how many instances of the template
           * to stamp and that that each template instance should bind to.
           */
          items: {
            type: Array
          },
          /**
           * The name of the variable to add to the binding scope for the array
           * element associated with a given template instance.
           */
          as: {
            type: String,
            value: "item"
          },
          /**
           * The name of the variable to add to the binding scope with the index
           * of the instance in the sorted and filtered list of rendered items.
           * Note, for the index in the `this.items` array, use the value of the
           * `itemsIndexAs` property.
           */
          indexAs: {
            type: String,
            value: "index"
          },
          /**
           * The name of the variable to add to the binding scope with the index
           * of the instance in the `this.items` array. Note, for the index of
           * this instance in the sorted and filtered list of rendered items,
           * use the value of the `indexAs` property.
           */
          itemsIndexAs: {
            type: String,
            value: "itemsIndex"
          },
          /**
           * A function that should determine the sort order of the items.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.sort`.
           * Using a sort function has no effect on the underlying `items` array.
           */
          sort: {
            type: Function,
            observer: "__sortChanged"
          },
          /**
           * A function that can be used to filter items out of the view.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.filter`.
           * Using a filter function has no effect on the underlying `items` array.
           */
          filter: {
            type: Function,
            observer: "__filterChanged"
          },
          /**
           * When using a `filter` or `sort` function, the `observe` property
           * should be set to a space-separated list of the names of item
           * sub-fields that should trigger a re-sort or re-filter when changed.
           * These should generally be fields of `item` that the sort or filter
           * function depends on.
           */
          observe: {
            type: String,
            observer: "__observeChanged"
          },
          /**
           * When using a `filter` or `sort` function, the `delay` property
           * determines a debounce time in ms after a change to observed item
           * properties that must pass before the filter or sort is re-run.
           * This is useful in rate-limiting shuffling of the view when
           * item changes may be frequent.
           */
          delay: Number,
          /**
           * Count of currently rendered items after `filter` (if any) has been applied.
           * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
           * set of template instances is rendered.
           *
           */
          renderedItemCount: {
            type: Number,
            notify: !suppressTemplateNotifications,
            readOnly: true
          },
          /**
           * When greater than zero, defines an initial count of template instances
           * to render after setting the `items` array, before the next paint, and
           * puts the `dom-repeat` into "chunking mode".  The remaining items (and
           * any future items as a result of pushing onto the array) will be created
           * and rendered incrementally at each animation frame thereof until all
           * instances have been rendered.
           */
          initialCount: {
            type: Number
          },
          /**
           * When `initialCount` is used, this property defines a frame rate (in
           * fps) to target by throttling the number of instances rendered each
           * frame to not exceed the budget for the target frame rate.  The
           * framerate is effectively the number of `requestAnimationFrame`s that
           * it tries to allow to actually fire in a given second. It does this
           * by measuring the time between `rAF`s and continuously adjusting the
           * number of items created each `rAF` to maintain the target framerate.
           * Setting this to a higher number allows lower latency and higher
           * throughput for event handlers and other tasks, but results in a
           * longer time for the remaining items to complete rendering.
           */
          targetFramerate: {
            type: Number,
            value: 20
          },
          _targetFrameTime: {
            type: Number,
            computed: "__computeFrameTime(targetFramerate)"
          },
          /**
           * When the global `suppressTemplateNotifications` setting is used, setting
           * `notifyDomChange: true` will enable firing `dom-change` events on this
           * element.
           */
          notifyDomChange: {
            type: Boolean
          },
          /**
           * When chunking is enabled via `initialCount` and the `items` array is
           * set to a new array, this flag controls whether the previously rendered
           * instances are reused or not.
           *
           * When `true`, any previously rendered template instances are updated in
           * place to their new item values synchronously in one shot, and then any
           * further items (if any) are chunked out.  When `false`, the list is
           * returned back to its `initialCount` (any instances over the initial
           * count are discarded) and the remainder of the list is chunked back in.
           * Set this to `true` to avoid re-creating the list and losing scroll
           * position, although note that when changing the list to completely
           * different data the render thread will be blocked until all existing
           * instances are updated to their new data.
           */
          reuseChunkedInstances: {
            type: Boolean
          }
        };
      }
      static get observers() {
        return ["__itemsChanged(items.*)"];
      }
      constructor() {
        super();
        this.__instances = [];
        this.__renderDebouncer = null;
        this.__itemsIdxToInstIdx = {};
        this.__chunkCount = null;
        this.__renderStartTime = null;
        this.__itemsArrayChanged = false;
        this.__shouldMeasureChunk = false;
        this.__shouldContinueChunking = false;
        this.__chunkingId = 0;
        this.__sortFn = null;
        this.__filterFn = null;
        this.__observePaths = null;
        this.__ctor = null;
        this.__isDetached = true;
        this.template = null;
        this._templateInfo;
      }
      /**
       * @override
       * @return {void}
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.__isDetached = true;
        for (let i = 0; i < this.__instances.length; i++) {
          this.__detachInstance(i);
        }
        if (this.__chunkingId) {
          cancelAnimationFrame(this.__chunkingId);
        }
      }
      /**
       * @override
       * @return {void}
       */
      connectedCallback() {
        super.connectedCallback();
        if (!hideElementsGlobally()) {
          this.style.display = "none";
        }
        if (this.__isDetached) {
          this.__isDetached = false;
          let wrappedParent = wrap$e(wrap$e(this).parentNode);
          for (let i = 0; i < this.__instances.length; i++) {
            this.__attachInstance(i, wrappedParent);
          }
          if (this.__chunkingId) {
            this.__render();
          }
        }
      }
      __ensureTemplatized() {
        if (!this.__ctor) {
          const thisAsTemplate = (
            /** @type {!HTMLTemplateElement} */
            /** @type {!HTMLElement} */
            this
          );
          let template2 = this.template = thisAsTemplate._templateInfo ? thisAsTemplate : (
            /** @type {!HTMLTemplateElement} */
            this.querySelector("template")
          );
          if (!template2) {
            let observer = new MutationObserver(() => {
              if (this.querySelector("template")) {
                observer.disconnect();
                this.__render();
              } else {
                throw new Error("dom-repeat requires a <template> child");
              }
            });
            observer.observe(this, { childList: true });
            return false;
          }
          let instanceProps = {};
          instanceProps[this.as] = true;
          instanceProps[this.indexAs] = true;
          instanceProps[this.itemsIndexAs] = true;
          this.__ctor = templatize(template2, this, {
            mutableData: this.mutableData,
            parentModel: true,
            instanceProps,
            /**
             * @this {DomRepeat}
             * @param {string} prop Property to set
             * @param {*} value Value to set property to
             */
            forwardHostProp: function(prop, value) {
              let i$ = this.__instances;
              for (let i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
                inst.forwardHostProp(prop, value);
              }
            },
            /**
             * @this {DomRepeat}
             * @param {Object} inst Instance to notify
             * @param {string} prop Property to notify
             * @param {*} value Value to notify
             */
            notifyInstanceProp: function(inst, prop, value) {
              if (matches(this.as, prop)) {
                let idx = inst[this.itemsIndexAs];
                if (prop == this.as) {
                  this.items[idx] = value;
                }
                let path = translate(this.as, `${JSCompiler_renameProperty("items", this)}.${idx}`, prop);
                this.notifyPath(path, value);
              }
            }
          });
        }
        return true;
      }
      __getMethodHost() {
        return this.__dataHost._methodHost || this.__dataHost;
      }
      __functionFromPropertyValue(functionOrMethodName) {
        if (typeof functionOrMethodName === "string") {
          let methodName = functionOrMethodName;
          let obj = this.__getMethodHost();
          return function() {
            return obj[methodName].apply(obj, arguments);
          };
        }
        return functionOrMethodName;
      }
      __sortChanged(sort) {
        this.__sortFn = this.__functionFromPropertyValue(sort);
        if (this.items) {
          this.__debounceRender(this.__render);
        }
      }
      __filterChanged(filter) {
        this.__filterFn = this.__functionFromPropertyValue(filter);
        if (this.items) {
          this.__debounceRender(this.__render);
        }
      }
      __computeFrameTime(rate) {
        return Math.ceil(1e3 / rate);
      }
      __observeChanged() {
        this.__observePaths = this.observe && this.observe.replace(".*", ".").split(" ");
      }
      __handleObservedPaths(path) {
        if (this.__sortFn || this.__filterFn) {
          if (!path) {
            this.__debounceRender(this.__render, this.delay);
          } else if (this.__observePaths) {
            let paths = this.__observePaths;
            for (let i = 0; i < paths.length; i++) {
              if (path.indexOf(paths[i]) === 0) {
                this.__debounceRender(this.__render, this.delay);
              }
            }
          }
        }
      }
      __itemsChanged(change) {
        if (this.items && !Array.isArray(this.items)) {
          console.warn("dom-repeat expected array for `items`, found", this.items);
        }
        if (!this.__handleItemPath(change.path, change.value)) {
          if (change.path === "items") {
            this.__itemsArrayChanged = true;
          }
          this.__debounceRender(this.__render);
        }
      }
      /**
       * @param {function(this:DomRepeat)} fn Function to debounce.
       * @param {number=} delay Delay in ms to debounce by.
       */
      __debounceRender(fn, delay = 0) {
        this.__renderDebouncer = Debouncer.debounce(
          this.__renderDebouncer,
          delay > 0 ? timeOut.after(delay) : microTask$1,
          fn.bind(this)
        );
        enqueueDebouncer(this.__renderDebouncer);
      }
      /**
       * Forces the element to render its content. Normally rendering is
       * asynchronous to a provoking change. This is done for efficiency so
       * that multiple changes trigger only a single render. The render method
       * should be called if, for example, template rendering is required to
       * validate application state.
       * @return {void}
       */
      render() {
        this.__debounceRender(this.__render);
        flush();
      }
      __render() {
        if (!this.__ensureTemplatized()) {
          return;
        }
        let items = this.items || [];
        const isntIdxToItemsIdx = this.__sortAndFilterItems(items);
        const limit = this.__calculateLimit(isntIdxToItemsIdx.length);
        this.__updateInstances(items, limit, isntIdxToItemsIdx);
        if (this.initialCount && (this.__shouldMeasureChunk || this.__shouldContinueChunking)) {
          cancelAnimationFrame(this.__chunkingId);
          this.__chunkingId = requestAnimationFrame(() => {
            this.__chunkingId = null;
            this.__continueChunking();
          });
        }
        this._setRenderedItemCount(this.__instances.length);
        if (!suppressTemplateNotifications || this.notifyDomChange) {
          this.dispatchEvent(new CustomEvent("dom-change", {
            bubbles: true,
            composed: true
          }));
        }
      }
      __sortAndFilterItems(items) {
        let isntIdxToItemsIdx = new Array(items.length);
        for (let i = 0; i < items.length; i++) {
          isntIdxToItemsIdx[i] = i;
        }
        if (this.__filterFn) {
          isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) => this.__filterFn(items[i], idx, array));
        }
        if (this.__sortFn) {
          isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));
        }
        return isntIdxToItemsIdx;
      }
      __calculateLimit(filteredItemCount) {
        let limit = filteredItemCount;
        const currentCount = this.__instances.length;
        if (this.initialCount) {
          let newCount;
          if (!this.__chunkCount || this.__itemsArrayChanged && !this.reuseChunkedInstances) {
            limit = Math.min(filteredItemCount, this.initialCount);
            newCount = Math.max(limit - currentCount, 0);
            this.__chunkCount = newCount || 1;
          } else {
            newCount = Math.min(
              Math.max(filteredItemCount - currentCount, 0),
              this.__chunkCount
            );
            limit = Math.min(currentCount + newCount, filteredItemCount);
          }
          this.__shouldMeasureChunk = newCount === this.__chunkCount;
          this.__shouldContinueChunking = limit < filteredItemCount;
          this.__renderStartTime = performance.now();
        }
        this.__itemsArrayChanged = false;
        return limit;
      }
      __continueChunking() {
        if (this.__shouldMeasureChunk) {
          const renderTime = performance.now() - this.__renderStartTime;
          const ratio = this._targetFrameTime / renderTime;
          this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
        }
        if (this.__shouldContinueChunking) {
          this.__debounceRender(this.__render);
        }
      }
      __updateInstances(items, limit, isntIdxToItemsIdx) {
        const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
        let instIdx;
        for (instIdx = 0; instIdx < limit; instIdx++) {
          let inst = this.__instances[instIdx];
          let itemIdx = isntIdxToItemsIdx[instIdx];
          let item2 = items[itemIdx];
          itemsIdxToInstIdx[itemIdx] = instIdx;
          if (inst) {
            inst._setPendingProperty(this.as, item2);
            inst._setPendingProperty(this.indexAs, instIdx);
            inst._setPendingProperty(this.itemsIndexAs, itemIdx);
            inst._flushProperties();
          } else {
            this.__insertInstance(item2, instIdx, itemIdx);
          }
        }
        for (let i = this.__instances.length - 1; i >= instIdx; i--) {
          this.__detachAndRemoveInstance(i);
        }
      }
      __detachInstance(idx) {
        let inst = this.__instances[idx];
        const wrappedRoot = wrap$e(inst.root);
        for (let i = 0; i < inst.children.length; i++) {
          let el = inst.children[i];
          wrappedRoot.appendChild(el);
        }
        return inst;
      }
      __attachInstance(idx, parent) {
        let inst = this.__instances[idx];
        parent.insertBefore(inst.root, this);
      }
      __detachAndRemoveInstance(idx) {
        this.__detachInstance(idx);
        this.__instances.splice(idx, 1);
      }
      __stampInstance(item2, instIdx, itemIdx) {
        let model = {};
        model[this.as] = item2;
        model[this.indexAs] = instIdx;
        model[this.itemsIndexAs] = itemIdx;
        return new this.__ctor(model);
      }
      __insertInstance(item2, instIdx, itemIdx) {
        const inst = this.__stampInstance(item2, instIdx, itemIdx);
        let beforeRow = this.__instances[instIdx + 1];
        let beforeNode = beforeRow ? beforeRow.children[0] : this;
        wrap$e(wrap$e(this).parentNode).insertBefore(inst.root, beforeNode);
        this.__instances[instIdx] = inst;
        return inst;
      }
      // Implements extension point from Templatize mixin
      /**
       * Shows or hides the template instance top level child elements. For
       * text nodes, `textContent` is removed while "hidden" and replaced when
       * "shown."
       * @param {boolean} hidden Set to true to hide the children;
       * set to false to show them.
       * @return {void}
       * @protected
       */
      _showHideChildren(hidden) {
        for (let i = 0; i < this.__instances.length; i++) {
          this.__instances[i]._showHideChildren(hidden);
        }
      }
      // Called as a side effect of a host items.<key>.<path> path change,
      // responsible for notifying item.<path> changes to inst for key
      __handleItemPath(path, value) {
        let itemsPath = path.slice(6);
        let dot = itemsPath.indexOf(".");
        let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
        if (itemsIdx == parseInt(itemsIdx, 10)) {
          let itemSubPath = dot < 0 ? "" : itemsPath.substring(dot + 1);
          this.__handleObservedPaths(itemSubPath);
          let instIdx = this.__itemsIdxToInstIdx[itemsIdx];
          let inst = this.__instances[instIdx];
          if (inst) {
            let itemPath = this.as + (itemSubPath ? "." + itemSubPath : "");
            inst._setPendingPropertyOrPath(itemPath, value, false, true);
            inst._flushProperties();
          }
          return true;
        }
      }
      /**
       * Returns the item associated with a given element stamped by
       * this `dom-repeat`.
       *
       * Note, to modify sub-properties of the item,
       * `modelForElement(el).set('item.<sub-prop>', value)`
       * should be used.
       *
       * @param {!HTMLElement} el Element for which to return the item.
       * @return {*} Item associated with the element.
       */
      itemForElement(el) {
        let instance = this.modelForElement(el);
        return instance && instance[this.as];
      }
      /**
       * Returns the inst index for a given element stamped by this `dom-repeat`.
       * If `sort` is provided, the index will reflect the sorted order (rather
       * than the original array order).
       *
       * @param {!HTMLElement} el Element for which to return the index.
       * @return {?number} Row index associated with the element (note this may
       *   not correspond to the array index if a user `sort` is applied).
       */
      indexForElement(el) {
        let instance = this.modelForElement(el);
        return instance && instance[this.indexAs];
      }
      /**
       * Returns the template "model" associated with a given element, which
       * serves as the binding scope for the template instance the element is
       * contained in. A template model
       * should be used to manipulate data associated with this template instance.
       *
       * Example:
       *
       *   let model = modelForElement(el);
       *   if (model.index < 10) {
       *     model.set('item.checked', true);
       *   }
       *
       * @param {!HTMLElement} el Element for which to return a template model.
       * @return {TemplateInstanceBase} Model representing the binding scope for
       *   the element.
       */
      modelForElement(el) {
        return modelForElement(this.template, el);
      }
    }
    customElements.define(DomRepeat.is, DomRepeat);
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const MonthCalendarMixin = (superClass) => class MonthCalendarMixinClass extends FocusMixin(superClass) {
      static get properties() {
        return {
          /**
           * A `Date` object defining the month to be displayed. Only year and
           * month properties are actually used.
           */
          month: {
            type: Object,
            value: /* @__PURE__ */ new Date(),
            sync: true
          },
          /**
           * A `Date` object for the currently selected date.
           */
          selectedDate: {
            type: Object,
            notify: true,
            sync: true
          },
          /**
           * A `Date` object for the currently focused date.
           */
          focusedDate: {
            type: Object
          },
          /**
           * Set true to display ISO-8601 week numbers in the calendar. Notice that
           * displaying week numbers is only supported when `i18n.firstDayOfWeek`
           * is 1 (Monday).
           */
          showWeekNumbers: {
            type: Boolean,
            value: false
          },
          i18n: {
            type: Object
          },
          /**
           * Flag stating whether taps on the component should be ignored.
           */
          ignoreTaps: {
            type: Boolean
          },
          /**
           * The earliest date that can be selected. All earlier dates will be disabled.
           */
          minDate: {
            type: Date,
            value: null,
            sync: true
          },
          /**
           * The latest date that can be selected. All later dates will be disabled.
           */
          maxDate: {
            type: Date,
            value: null,
            sync: true
          },
          /**
           * A function to be used to determine whether the user can select a given date.
           * Receives a `DatePickerDate` object of the date to be selected and should return a
           * boolean.
           * @type {Function | undefined}
           */
          isDateDisabled: {
            type: Function,
            value: () => false
          },
          disabled: {
            type: Boolean,
            reflectToAttribute: true
          },
          /** @protected */
          _days: {
            type: Array
          },
          /** @protected */
          _weeks: {
            type: Array
          },
          /** @private */
          _notTapping: {
            type: Boolean
          }
        };
      }
      static get observers() {
        return ["__focusedDateChanged(focusedDate, _days)"];
      }
      get focusableDateElement() {
        return [...this.shadowRoot.querySelectorAll("[part~=date]")].find((datePart) => {
          return dateEquals(datePart.date, this.focusedDate);
        });
      }
      /** @protected */
      ready() {
        super.ready();
        addListener(this.$.monthGrid, "tap", this._handleTap.bind(this));
      }
      /**
       * Returns true if all the dates in the month are out of the allowed range
       * @protected
       */
      _isDisabled(month, minDate, maxDate) {
        const firstDate = new Date(0, 0);
        firstDate.setFullYear(month.getFullYear());
        firstDate.setMonth(month.getMonth());
        firstDate.setDate(1);
        const lastDate = new Date(0, 0);
        lastDate.setFullYear(month.getFullYear());
        lastDate.setMonth(month.getMonth() + 1);
        lastDate.setDate(0);
        if (minDate && maxDate && minDate.getMonth() === maxDate.getMonth() && minDate.getMonth() === month.getMonth() && maxDate.getDate() - minDate.getDate() >= 0) {
          return false;
        }
        return !dateAllowed(firstDate, minDate, maxDate) && !dateAllowed(lastDate, minDate, maxDate);
      }
      /** @protected */
      _getTitle(month, i18n) {
        if (month === void 0 || i18n === void 0) {
          return;
        }
        return i18n.formatTitle(i18n.monthNames[month.getMonth()], month.getFullYear());
      }
      /** @protected */
      _onMonthGridTouchStart() {
        this._notTapping = false;
        setTimeout(() => {
          this._notTapping = true;
        }, 300);
      }
      /** @private */
      _dateAdd(date, delta) {
        date.setDate(date.getDate() + delta);
      }
      /** @private */
      _applyFirstDayOfWeek(weekDayNames, firstDayOfWeek) {
        if (weekDayNames === void 0 || firstDayOfWeek === void 0) {
          return;
        }
        return weekDayNames.slice(firstDayOfWeek).concat(weekDayNames.slice(0, firstDayOfWeek));
      }
      /** @protected */
      _getWeekDayNames(i18n, showWeekNumbers) {
        if (i18n === void 0 || showWeekNumbers === void 0) {
          return [];
        }
        const { weekdays, weekdaysShort, firstDayOfWeek } = i18n;
        const weekDayNamesShort = this._applyFirstDayOfWeek(weekdaysShort, firstDayOfWeek);
        const weekDayNames = this._applyFirstDayOfWeek(weekdays, firstDayOfWeek);
        return weekDayNames.map((day, index) => {
          return {
            weekDay: day,
            weekDayShort: weekDayNamesShort[index]
          };
        });
      }
      /** @private */
      __focusedDateChanged(focusedDate, days) {
        if (Array.isArray(days) && days.some((date) => dateEquals(date, focusedDate))) {
          this.removeAttribute("aria-hidden");
        } else {
          this.setAttribute("aria-hidden", "true");
        }
      }
      /** @protected */
      _getDate(date) {
        return date ? date.getDate() : "";
      }
      /** @protected */
      _showWeekSeparator(showWeekNumbers, i18n) {
        return showWeekNumbers && i18n && i18n.firstDayOfWeek === 1;
      }
      /** @protected */
      _isToday(date) {
        return dateEquals(/* @__PURE__ */ new Date(), date);
      }
      /** @protected */
      _getDays(month, i18n) {
        if (month === void 0 || i18n === void 0) {
          return [];
        }
        const date = new Date(0, 0);
        date.setFullYear(month.getFullYear());
        date.setMonth(month.getMonth());
        date.setDate(1);
        while (date.getDay() !== i18n.firstDayOfWeek) {
          this._dateAdd(date, -1);
        }
        const days = [];
        const startMonth = date.getMonth();
        const targetMonth = month.getMonth();
        while (date.getMonth() === targetMonth || date.getMonth() === startMonth) {
          days.push(date.getMonth() === targetMonth ? new Date(date.getTime()) : null);
          this._dateAdd(date, 1);
        }
        return days;
      }
      /** @protected */
      _getWeeks(days) {
        return days.reduce((acc, day, i) => {
          if (i % 7 === 0) {
            acc.push([]);
          }
          acc[acc.length - 1].push(day);
          return acc;
        }, []);
      }
      /** @protected */
      _handleTap(e2) {
        if (!this.ignoreTaps && !this._notTapping && e2.target.date && !e2.target.hasAttribute("disabled")) {
          this.selectedDate = e2.target.date;
          this.dispatchEvent(
            new CustomEvent("date-tap", { detail: { date: e2.target.date }, bubbles: true, composed: true })
          );
        }
      }
      /** @protected */
      _preventDefault(e2) {
        e2.preventDefault();
      }
      /** @protected */
      __getWeekNumber(days) {
        const date = days.reduce((acc, d) => {
          return !acc && d ? d : acc;
        });
        return getISOWeekNumber(date);
      }
      /** @protected */
      __getDayAriaLabel(date) {
        if (!date) {
          return "";
        }
        let ariaLabel = `${this._getDate(date)} ${this.i18n.monthNames[date.getMonth()]} ${date.getFullYear()}, ${this.i18n.weekdays[date.getDay()]}`;
        if (this._isToday(date)) {
          ariaLabel += `, ${this.i18n.today}`;
        }
        return ariaLabel;
      }
    };
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const monthCalendarStyles = css$e`
  :host {
    display: block;
  }

  #monthGrid {
    width: 100%;
    border-collapse: collapse;
  }

  #days-container tr,
  #weekdays-container tr {
    display: flex;
  }

  [part~='date'] {
    outline: none;
  }

  [part~='disabled'] {
    pointer-events: none;
  }

  [part='week-number'][hidden],
  [part='weekday'][hidden] {
    display: none;
  }

  [part='weekday'],
  [part~='date'] {
    width: calc(100% / 7);
    padding: 0;
    font-weight: normal;
  }

  [part='weekday']:empty,
  [part='week-number'] {
    width: 12.5%;
    flex-shrink: 0;
    padding: 0;
  }

  :host([week-numbers]) [part='weekday']:not(:empty),
  :host([week-numbers]) [part~='date'] {
    width: 12.5%;
  }

  @media (forced-colors: active) {
    [part~='date'][part~='focused'] {
      outline: 1px solid;
    }

    [part~='date'][part~='selected'] {
      outline: 3px solid;
    }
  }
`;
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-month-calendar", monthCalendarStyles, {
      moduleId: "vaadin-month-calendar-styles"
    });
    class MonthCalendar extends MonthCalendarMixin(ThemableMixin(PolymerElement)) {
      static get template() {
        return html`
      <div part="month-header" id="month-header" aria-hidden="true">[[_getTitle(month, i18n)]]</div>
      <table
        id="monthGrid"
        role="grid"
        aria-labelledby="month-header"
        on-touchend="_preventDefault"
        on-touchstart="_onMonthGridTouchStart"
      >
        <thead id="weekdays-container">
          <tr role="row" part="weekdays">
            <th part="weekday" aria-hidden="true" hidden$="[[!_showWeekSeparator(showWeekNumbers, i18n)]]"></th>
            <template is="dom-repeat" items="[[_getWeekDayNames(i18n, showWeekNumbers)]]">
              <th role="columnheader" part="weekday" scope="col" abbr$="[[item.weekDay]]" aria-hidden="true">
                [[item.weekDayShort]]
              </th>
            </template>
          </tr>
        </thead>
        <tbody id="days-container">
          <template is="dom-repeat" items="[[_weeks]]" as="week">
            <tr role="row">
              <td part="week-number" aria-hidden="true" hidden$="[[!_showWeekSeparator(showWeekNumbers, i18n)]]">
                [[__getWeekNumber(week)]]
              </td>
              <template is="dom-repeat" items="[[week]]">
                <td
                  role="gridcell"
                  part$="[[__getDatePart(item, focusedDate, selectedDate, minDate, maxDate, isDateDisabled)]]"
                  date="[[item]]"
                  tabindex$="[[__getDayTabindex(item, focusedDate)]]"
                  disabled$="[[__isDayDisabled(item, minDate, maxDate, isDateDisabled)]]"
                  aria-selected$="[[__getDayAriaSelected(item, selectedDate)]]"
                  aria-disabled$="[[__getDayAriaDisabled(item, minDate, maxDate, isDateDisabled)]]"
                  aria-label$="[[__getDayAriaLabel(item)]]"
                  >[[_getDate(item)]]</td
                >
              </template>
            </tr>
          </template>
        </tbody>
      </table>
    `;
      }
      static get is() {
        return "vaadin-month-calendar";
      }
      static get properties() {
        return {
          /** @protected */
          _days: {
            type: Array,
            computed: "_getDays(month, i18n, minDate, maxDate, isDateDisabled)"
          },
          /** @protected */
          _weeks: {
            type: Array,
            computed: "_getWeeks(_days)"
          },
          disabled: {
            type: Boolean,
            reflectToAttribute: true,
            computed: "_isDisabled(month, minDate, maxDate)"
          }
        };
      }
      static get observers() {
        return ["_showWeekNumbersChanged(showWeekNumbers, i18n)"];
      }
      /** @private */
      _showWeekNumbersChanged(showWeekNumbers, i18n) {
        if (showWeekNumbers && i18n && i18n.firstDayOfWeek === 1) {
          this.setAttribute("week-numbers", "");
        } else {
          this.removeAttribute("week-numbers");
        }
      }
      /** @private */
      __getDatePart(date, focusedDate, selectedDate, minDate, maxDate, isDateDisabled) {
        const result2 = ["date"];
        if (this.__isDayDisabled(date, minDate, maxDate, isDateDisabled)) {
          result2.push("disabled");
        }
        if (this.__isDayFocused(date, focusedDate)) {
          result2.push("focused");
        }
        if (this.__isDaySelected(date, selectedDate)) {
          result2.push("selected");
        }
        if (this._isToday(date)) {
          result2.push("today");
        }
        return result2.join(" ");
      }
      /** @private */
      __isDayFocused(date, focusedDate) {
        return dateEquals(date, focusedDate);
      }
      /** @private */
      __isDaySelected(date, selectedDate) {
        return dateEquals(date, selectedDate);
      }
      /** @private */
      __getDayAriaSelected(date, selectedDate) {
        if (this.__isDaySelected(date, selectedDate)) {
          return "true";
        }
      }
      /** @private */
      __isDayDisabled(date, minDate, maxDate, isDateDisabled) {
        return !dateAllowed(date, minDate, maxDate, isDateDisabled);
      }
      /** @private */
      __getDayAriaDisabled(date, min, max, isDateDisabled) {
        if (date === void 0 || min === void 0 && max === void 0 && isDateDisabled === void 0) {
          return;
        }
        if (this.__isDayDisabled(date, min, max, isDateDisabled)) {
          return "true";
        }
      }
      /** @private */
      __getDayTabindex(date, focusedDate) {
        if (this.__isDayFocused(date, focusedDate)) {
          return "0";
        }
        return "-1";
      }
    }
    defineCustomElement(MonthCalendar);
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const DatePickerOverlayContentMixin = (superClass) => class DatePickerOverlayContentMixin extends superClass {
      static get properties() {
        return {
          scrollDuration: {
            type: Number,
            value: 300
          },
          /**
           * The value for this element.
           */
          selectedDate: {
            type: Object,
            value: null,
            sync: true
          },
          /**
           * Date value which is focused using keyboard.
           */
          focusedDate: {
            type: Object,
            notify: true,
            observer: "_focusedDateChanged",
            sync: true
          },
          _focusedMonthDate: Number,
          /**
           * Date which should be visible when there is no value selected.
           */
          initialPosition: {
            type: Object,
            observer: "_initialPositionChanged"
          },
          _originDate: {
            type: Object,
            value: /* @__PURE__ */ new Date()
          },
          _visibleMonthIndex: Number,
          _desktopMode: {
            type: Boolean,
            observer: "_desktopModeChanged"
          },
          _desktopMediaQuery: {
            type: String,
            value: "(min-width: 375px)"
          },
          _translateX: {
            observer: "_translateXChanged"
          },
          _yearScrollerWidth: {
            value: 50
          },
          i18n: {
            type: Object
          },
          showWeekNumbers: {
            type: Boolean,
            value: false
          },
          _ignoreTaps: Boolean,
          _notTapping: Boolean,
          /**
           * The earliest date that can be selected. All earlier dates will be disabled.
           */
          minDate: {
            type: Object,
            sync: true
          },
          /**
           * The latest date that can be selected. All later dates will be disabled.
           */
          maxDate: {
            type: Object,
            sync: true
          },
          /**
           * A function to be used to determine whether the user can select a given date.
           * Receives a `DatePickerDate` object of the date to be selected and should return a
           * boolean.
           *
           * @type {function(DatePickerDate): boolean | undefined}
           */
          isDateDisabled: {
            type: Function
          },
          /**
           * Input label
           */
          label: String,
          _cancelButton: {
            type: Object
          },
          _todayButton: {
            type: Object
          },
          calendars: {
            type: Array,
            value: () => []
          },
          years: {
            type: Array,
            value: () => []
          }
        };
      }
      static get observers() {
        return [
          "__updateCalendars(calendars, i18n, minDate, maxDate, selectedDate, focusedDate, showWeekNumbers, _ignoreTaps, _theme, isDateDisabled)",
          "__updateCancelButton(_cancelButton, i18n)",
          "__updateTodayButton(_todayButton, i18n, minDate, maxDate, isDateDisabled)",
          "__updateYears(years, selectedDate, _theme)"
        ];
      }
      /**
       * Whether to scroll to a sub-month position when scrolling to a date.
       * This is active if the month scroller is not large enough to fit a
       * full month. In that case we want to scroll to a position between
       * two months in order to have the focused date in the visible area.
       * @returns {boolean} whether to use sub-month scrolling
       * @private
       */
      get __useSubMonthScrolling() {
        return this._monthScroller.clientHeight < this._monthScroller.itemHeight + this._monthScroller.bufferOffset;
      }
      get focusableDateElement() {
        return this.calendars.map((calendar) => calendar.focusableDateElement).find(Boolean);
      }
      /** @protected */
      _addListeners() {
        setTouchAction(this.$.scrollers, "pan-y");
        addListener(this.$.scrollers, "track", this._track.bind(this));
        addListener(this.shadowRoot.querySelector('[part="clear-button"]'), "tap", this._clear.bind(this));
        addListener(this.shadowRoot.querySelector('[part="toggle-button"]'), "tap", this._cancel.bind(this));
        addListener(
          this.shadowRoot.querySelector('[part="years-toggle-button"]'),
          "tap",
          this._toggleYearScroller.bind(this)
        );
      }
      /** @protected */
      _initControllers() {
        this.addController(
          new MediaQueryController(this._desktopMediaQuery, (matches2) => {
            this._desktopMode = matches2;
          })
        );
        this.addController(
          new SlotController(this, "today-button", "vaadin-button", {
            observe: false,
            initializer: (btn) => {
              btn.setAttribute("theme", "tertiary");
              btn.addEventListener("keydown", (e2) => this.__onTodayButtonKeyDown(e2));
              addListener(btn, "tap", this._onTodayTap.bind(this));
              this._todayButton = btn;
            }
          })
        );
        this.addController(
          new SlotController(this, "cancel-button", "vaadin-button", {
            observe: false,
            initializer: (btn) => {
              btn.setAttribute("theme", "tertiary");
              btn.addEventListener("keydown", (e2) => this.__onCancelButtonKeyDown(e2));
              addListener(btn, "tap", this._cancel.bind(this));
              this._cancelButton = btn;
            }
          })
        );
        this.__initMonthScroller();
        this.__initYearScroller();
      }
      reset() {
        this._closeYearScroller();
        this._toggleAnimateClass(true);
      }
      /**
       * Focuses the cancel button
       */
      focusCancel() {
        this._cancelButton.focus();
      }
      /**
       * Scrolls the list to the given Date.
       */
      scrollToDate(date, animate2) {
        const offset2 = this.__useSubMonthScrolling ? this._calculateWeekScrollOffset(date) : 0;
        this._scrollToPosition(this._differenceInMonths(date, this._originDate) + offset2, animate2);
        this._monthScroller.forceUpdate();
      }
      /** @private */
      __initMonthScroller() {
        this.addController(
          new SlotController(this, "months", "vaadin-date-picker-month-scroller", {
            observe: false,
            initializer: (scroller2) => {
              scroller2.addEventListener("custom-scroll", () => {
                this._onMonthScroll();
              });
              scroller2.addEventListener("touchstart", () => {
                this._onMonthScrollTouchStart();
              });
              scroller2.addEventListener("keydown", (e2) => {
                this.__onMonthCalendarKeyDown(e2);
              });
              scroller2.addEventListener("init-done", () => {
                const calendars = [...this.querySelectorAll("vaadin-month-calendar")];
                calendars.forEach((calendar) => {
                  calendar.addEventListener("selected-date-changed", (e2) => {
                    this.selectedDate = e2.detail.value;
                  });
                });
                this.calendars = calendars;
              });
              this._monthScroller = scroller2;
            }
          })
        );
      }
      /** @private */
      __initYearScroller() {
        this.addController(
          new SlotController(this, "years", "vaadin-date-picker-year-scroller", {
            observe: false,
            initializer: (scroller2) => {
              scroller2.setAttribute("aria-hidden", "true");
              addListener(scroller2, "tap", (e2) => {
                this._onYearTap(e2);
              });
              scroller2.addEventListener("custom-scroll", () => {
                this._onYearScroll();
              });
              scroller2.addEventListener("touchstart", () => {
                this._onYearScrollTouchStart();
              });
              scroller2.addEventListener("init-done", () => {
                this.years = [...this.querySelectorAll("vaadin-date-picker-year")];
              });
              this._yearScroller = scroller2;
            }
          })
        );
      }
      /** @private */
      __updateCancelButton(cancelButton, i18n) {
        if (cancelButton) {
          cancelButton.textContent = i18n && i18n.cancel;
        }
      }
      /** @private */
      __updateTodayButton(todayButton, i18n, minDate, maxDate, isDateDisabled) {
        if (todayButton) {
          todayButton.textContent = i18n && i18n.today;
          todayButton.disabled = !this._isTodayAllowed(minDate, maxDate, isDateDisabled);
        }
      }
      // eslint-disable-next-line max-params
      __updateCalendars(calendars, i18n, minDate, maxDate, selectedDate, focusedDate, showWeekNumbers, ignoreTaps, theme2, isDateDisabled) {
        if (calendars && calendars.length) {
          calendars.forEach((calendar) => {
            calendar.i18n = i18n;
            calendar.minDate = minDate;
            calendar.maxDate = maxDate;
            calendar.isDateDisabled = isDateDisabled;
            calendar.focusedDate = focusedDate;
            calendar.selectedDate = selectedDate;
            calendar.showWeekNumbers = showWeekNumbers;
            calendar.ignoreTaps = ignoreTaps;
            if (theme2) {
              calendar.setAttribute("theme", theme2);
            } else {
              calendar.removeAttribute("theme");
            }
          });
        }
      }
      /** @private */
      __updateYears(years, selectedDate, theme2) {
        if (years && years.length) {
          years.forEach((year) => {
            year.selectedDate = selectedDate;
            if (theme2) {
              year.setAttribute("theme", theme2);
            } else {
              year.removeAttribute("theme");
            }
          });
        }
      }
      /**
       * Select a date and fire event indicating user interaction.
       * @protected
       */
      _selectDate(dateToSelect) {
        if (!this._dateAllowed(dateToSelect)) {
          return false;
        }
        this.selectedDate = dateToSelect;
        this.dispatchEvent(
          new CustomEvent("date-selected", { detail: { date: dateToSelect }, bubbles: true, composed: true })
        );
        return true;
      }
      /** @private */
      _desktopModeChanged(desktopMode) {
        this.toggleAttribute("desktop", desktopMode);
      }
      /** @private */
      _focusedDateChanged(focusedDate) {
        this.revealDate(focusedDate);
      }
      /**
       * Scrolls the month and year scrollers enough to reveal the given date.
       */
      revealDate(date, animate2 = true) {
        if (!date) {
          return;
        }
        const diff = this._differenceInMonths(date, this._originDate);
        if (this.__useSubMonthScrolling) {
          const offset2 = this._calculateWeekScrollOffset(date);
          this._scrollToPosition(diff + offset2, animate2);
          return;
        }
        const scrolledAboveViewport = this._monthScroller.position > diff;
        const visibleArea = Math.max(
          this._monthScroller.itemHeight,
          this._monthScroller.clientHeight - this._monthScroller.bufferOffset * 2
        );
        const visibleItems = visibleArea / this._monthScroller.itemHeight;
        const scrolledBelowViewport = this._monthScroller.position + visibleItems - 1 < diff;
        if (scrolledAboveViewport) {
          this._scrollToPosition(diff, animate2);
        } else if (scrolledBelowViewport) {
          this._scrollToPosition(diff - visibleItems + 1, animate2);
        }
      }
      /**
       * Calculates an offset to be added to the month scroll position
       * when using sub-month scrolling, in order ensure that the week
       * that the date is in is visible even for small scroll areas.
       * As the month scroller uses a month as minimal scroll unit
       * (a value of `1` equals one month), we can not exactly identify
       * the position of a specific week. This is a best effort
       * implementation based on manual testing.
       * @param date the date for which to calculate the offset
       * @returns {number} the offset
       * @private
       */
      _calculateWeekScrollOffset(date) {
        const temp = new Date(0, 0);
        temp.setFullYear(date.getFullYear());
        temp.setMonth(date.getMonth());
        temp.setDate(1);
        let week = 0;
        while (temp.getDate() < date.getDate()) {
          temp.setDate(temp.getDate() + 1);
          if (temp.getDay() === this.i18n.firstDayOfWeek) {
            week += 1;
          }
        }
        return week / 6;
      }
      /** @private */
      _initialPositionChanged(initialPosition) {
        if (this._monthScroller && this._yearScroller) {
          this._monthScroller.active = true;
          this._yearScroller.active = true;
        }
        this.scrollToDate(initialPosition);
      }
      /** @private */
      _repositionYearScroller() {
        const monthPosition = this._monthScroller.position;
        this._visibleMonthIndex = Math.floor(monthPosition);
        this._yearScroller.position = (monthPosition + this._originDate.getMonth()) / 12;
      }
      /** @private */
      _repositionMonthScroller() {
        this._monthScroller.position = this._yearScroller.position * 12 - this._originDate.getMonth();
        this._visibleMonthIndex = Math.floor(this._monthScroller.position);
      }
      /** @private */
      _onMonthScroll() {
        this._repositionYearScroller();
        this._doIgnoreTaps();
      }
      /** @private */
      _onYearScroll() {
        this._repositionMonthScroller();
        this._doIgnoreTaps();
      }
      /** @private */
      _onYearScrollTouchStart() {
        this._notTapping = false;
        setTimeout(() => {
          this._notTapping = true;
        }, 300);
        this._repositionMonthScroller();
      }
      /** @private */
      _onMonthScrollTouchStart() {
        this._repositionYearScroller();
      }
      /** @private */
      _doIgnoreTaps() {
        this._ignoreTaps = true;
        this._debouncer = Debouncer$1.debounce(this._debouncer, timeOut$1.after(300), () => {
          this._ignoreTaps = false;
        });
      }
      /** @protected */
      _formatDisplayed(date, i18n, label) {
        if (date && i18n && typeof i18n.formatDate === "function") {
          return i18n.formatDate(extractDateParts(date));
        }
        return label;
      }
      /** @private */
      _onTodayTap() {
        const today = /* @__PURE__ */ new Date();
        if (Math.abs(this._monthScroller.position - this._differenceInMonths(today, this._originDate)) < 1e-3) {
          this._selectDate(today);
          this._close();
        } else {
          this._scrollToCurrentMonth();
        }
      }
      /** @private */
      _scrollToCurrentMonth() {
        if (this.focusedDate) {
          this.focusedDate = /* @__PURE__ */ new Date();
        }
        this.scrollToDate(/* @__PURE__ */ new Date(), true);
      }
      /** @private */
      _onYearTap(e2) {
        if (!this._ignoreTaps && !this._notTapping) {
          const scrollDelta = e2.detail.y - (this._yearScroller.getBoundingClientRect().top + this._yearScroller.clientHeight / 2);
          const yearDelta = scrollDelta / this._yearScroller.itemHeight;
          this._scrollToPosition(this._monthScroller.position + yearDelta * 12, true);
        }
      }
      /** @private */
      _scrollToPosition(targetPosition, animate2) {
        if (this._targetPosition !== void 0) {
          this._targetPosition = targetPosition;
          return;
        }
        if (!animate2) {
          this._monthScroller.position = targetPosition;
          this._targetPosition = void 0;
          this._repositionYearScroller();
          this.__tryFocusDate();
          return;
        }
        this._targetPosition = targetPosition;
        let revealResolve;
        this._revealPromise = new Promise((resolve) => {
          revealResolve = resolve;
        });
        const easingFunction = (t, b, c, d) => {
          t /= d / 2;
          if (t < 1) {
            return c / 2 * t * t + b;
          }
          t -= 1;
          return -c / 2 * (t * (t - 2) - 1) + b;
        };
        let start = 0;
        const initialPosition = this._monthScroller.position;
        const smoothScroll = (timestamp) => {
          if (!start) {
            start = timestamp;
          }
          const currentTime = timestamp - start;
          if (currentTime < this.scrollDuration) {
            const currentPos = easingFunction(
              currentTime,
              initialPosition,
              this._targetPosition - initialPosition,
              this.scrollDuration
            );
            this._monthScroller.position = currentPos;
            window.requestAnimationFrame(smoothScroll);
          } else {
            this.dispatchEvent(
              new CustomEvent("scroll-animation-finished", {
                bubbles: true,
                composed: true,
                detail: {
                  position: this._targetPosition,
                  oldPosition: initialPosition
                }
              })
            );
            this._monthScroller.position = this._targetPosition;
            this._targetPosition = void 0;
            revealResolve();
            this._revealPromise = void 0;
          }
          setTimeout(this._repositionYearScroller.bind(this), 1);
        };
        window.requestAnimationFrame(smoothScroll);
      }
      /** @private */
      _limit(value, range) {
        return Math.min(range.max, Math.max(range.min, value));
      }
      /** @private */
      _handleTrack(e2) {
        if (Math.abs(e2.detail.dx) < 10 || Math.abs(e2.detail.ddy) > 10) {
          return;
        }
        if (Math.abs(e2.detail.ddx) > this._yearScrollerWidth / 3) {
          this._toggleAnimateClass(true);
        }
        const newTranslateX = this._translateX + e2.detail.ddx;
        this._translateX = this._limit(newTranslateX, {
          min: 0,
          max: this._yearScrollerWidth
        });
      }
      /** @private */
      _track(e2) {
        if (this._desktopMode) {
          return;
        }
        switch (e2.detail.state) {
          case "start":
            this._toggleAnimateClass(false);
            break;
          case "track":
            this._handleTrack(e2);
            break;
          case "end":
            this._toggleAnimateClass(true);
            if (this._translateX >= this._yearScrollerWidth / 2) {
              this._closeYearScroller();
            } else {
              this._openYearScroller();
            }
            break;
        }
      }
      /** @private */
      _toggleAnimateClass(enable) {
        if (enable) {
          this.classList.add("animate");
        } else {
          this.classList.remove("animate");
        }
      }
      /** @private */
      _toggleYearScroller() {
        if (this._isYearScrollerVisible()) {
          this._closeYearScroller();
        } else {
          this._openYearScroller();
        }
      }
      /** @private */
      _openYearScroller() {
        this._translateX = 0;
        this.setAttribute("years-visible", "");
      }
      /** @private */
      _closeYearScroller() {
        this.removeAttribute("years-visible");
        this._translateX = this._yearScrollerWidth;
      }
      /** @private */
      _isYearScrollerVisible() {
        return this._translateX < this._yearScrollerWidth / 2;
      }
      /** @private */
      _translateXChanged(x) {
        if (!this._desktopMode) {
          this._monthScroller.style.transform = `translateX(${x - this._yearScrollerWidth}px)`;
          this._yearScroller.style.transform = `translateX(${x}px)`;
        }
      }
      /** @private */
      _yearAfterXMonths(months) {
        return dateAfterXMonths(months).getFullYear();
      }
      /** @private */
      _differenceInMonths(date1, date2) {
        const months = (date1.getFullYear() - date2.getFullYear()) * 12;
        return months - date2.getMonth() + date1.getMonth();
      }
      /** @private */
      _clear() {
        this._selectDate("");
      }
      /** @private */
      _close() {
        this.dispatchEvent(new CustomEvent("close", { bubbles: true, composed: true }));
      }
      /** @private */
      _cancel() {
        this.focusedDate = this.selectedDate;
        this._close();
      }
      /** @protected */
      _preventDefault(e2) {
        e2.preventDefault();
      }
      /** @private */
      __toggleDate(date) {
        if (dateEquals(date, this.selectedDate)) {
          this._clear();
          this.focusedDate = date;
        } else {
          this._selectDate(date);
        }
      }
      /** @private */
      __onMonthCalendarKeyDown(event) {
        let handled = false;
        switch (event.key) {
          case "ArrowDown":
            this._moveFocusByDays(7);
            handled = true;
            break;
          case "ArrowUp":
            this._moveFocusByDays(-7);
            handled = true;
            break;
          case "ArrowRight":
            this._moveFocusByDays(this.__isRTL ? -1 : 1);
            handled = true;
            break;
          case "ArrowLeft":
            this._moveFocusByDays(this.__isRTL ? 1 : -1);
            handled = true;
            break;
          case "Enter":
            if (this._selectDate(this.focusedDate)) {
              this._close();
              handled = true;
            }
            break;
          case " ":
            this.__toggleDate(this.focusedDate);
            handled = true;
            break;
          case "Home":
            this._moveFocusInsideMonth(this.focusedDate, "minDate");
            handled = true;
            break;
          case "End":
            this._moveFocusInsideMonth(this.focusedDate, "maxDate");
            handled = true;
            break;
          case "PageDown":
            this._moveFocusByMonths(event.shiftKey ? 12 : 1);
            handled = true;
            break;
          case "PageUp":
            this._moveFocusByMonths(event.shiftKey ? -12 : -1);
            handled = true;
            break;
          case "Tab":
            this._onTabKeyDown(event, "calendar");
            break;
        }
        if (handled) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
      /** @private */
      _onTabKeyDown(event, section) {
        event.stopPropagation();
        switch (section) {
          case "calendar":
            if (event.shiftKey) {
              event.preventDefault();
              if (this.hasAttribute("fullscreen")) {
                this.focusCancel();
              } else {
                this.__focusInput();
              }
            }
            break;
          case "today":
            if (event.shiftKey) {
              event.preventDefault();
              this.focusDateElement();
            }
            break;
          case "cancel":
            if (!event.shiftKey) {
              event.preventDefault();
              if (this.hasAttribute("fullscreen")) {
                this.focusDateElement();
              } else {
                this.__focusInput();
              }
            }
            break;
        }
      }
      /** @private */
      __onTodayButtonKeyDown(event) {
        if (event.key === "Tab") {
          this._onTabKeyDown(event, "today");
        }
      }
      /** @private */
      __onCancelButtonKeyDown(event) {
        if (event.key === "Tab") {
          this._onTabKeyDown(event, "cancel");
        }
      }
      /** @private */
      __focusInput() {
        this.dispatchEvent(new CustomEvent("focus-input", { bubbles: true, composed: true }));
      }
      /** @private */
      __tryFocusDate() {
        const dateToFocus = this.__pendingDateFocus;
        if (dateToFocus) {
          const dateElement = this.focusableDateElement;
          if (dateElement && dateEquals(dateElement.date, this.__pendingDateFocus)) {
            delete this.__pendingDateFocus;
            dateElement.focus();
          }
        }
      }
      async focusDate(date, keepMonth) {
        const dateToFocus = date || this.selectedDate || this.initialPosition || /* @__PURE__ */ new Date();
        this.focusedDate = dateToFocus;
        if (!keepMonth) {
          this._focusedMonthDate = dateToFocus.getDate();
        }
        await this.focusDateElement(false);
      }
      async focusDateElement(reveal = true) {
        this.__pendingDateFocus = this.focusedDate;
        if (!this.calendars.length) {
          await new Promise((resolve) => {
            afterNextRender(this, () => {
              flush();
              resolve();
            });
          });
        }
        if (reveal) {
          this.revealDate(this.focusedDate);
        }
        if (this._revealPromise) {
          await this._revealPromise;
        }
        this.__tryFocusDate();
      }
      /** @private */
      _focusClosestDate(focus) {
        this.focusDate(getClosestDate(focus, [this.minDate, this.maxDate]));
      }
      /** @private */
      _focusAllowedDate(dateToFocus, diff, keepMonth) {
        if (this._dateAllowed(dateToFocus, void 0, void 0, () => false)) {
          this.focusDate(dateToFocus, keepMonth);
        } else if (this._dateAllowed(this.focusedDate)) {
          if (diff > 0) {
            this.focusDate(this.maxDate);
          } else {
            this.focusDate(this.minDate);
          }
        } else {
          this._focusClosestDate(this.focusedDate);
        }
      }
      /** @private */
      _getDateDiff(months, days) {
        const date = new Date(0, 0);
        date.setFullYear(this.focusedDate.getFullYear());
        date.setMonth(this.focusedDate.getMonth() + months);
        if (days) {
          date.setDate(this.focusedDate.getDate() + days);
        }
        return date;
      }
      /** @private */
      _moveFocusByDays(days) {
        const dateToFocus = this._getDateDiff(0, days);
        this._focusAllowedDate(dateToFocus, days, false);
      }
      /** @private */
      _moveFocusByMonths(months) {
        const dateToFocus = this._getDateDiff(months);
        const targetMonth = dateToFocus.getMonth();
        if (!this._focusedMonthDate) {
          this._focusedMonthDate = this.focusedDate.getDate();
        }
        dateToFocus.setDate(this._focusedMonthDate);
        if (dateToFocus.getMonth() !== targetMonth) {
          dateToFocus.setDate(0);
        }
        this._focusAllowedDate(dateToFocus, months, true);
      }
      /** @private */
      _moveFocusInsideMonth(focusedDate, property) {
        const dateToFocus = new Date(0, 0);
        dateToFocus.setFullYear(focusedDate.getFullYear());
        if (property === "minDate") {
          dateToFocus.setMonth(focusedDate.getMonth());
          dateToFocus.setDate(1);
        } else {
          dateToFocus.setMonth(focusedDate.getMonth() + 1);
          dateToFocus.setDate(0);
        }
        if (this._dateAllowed(dateToFocus)) {
          this.focusDate(dateToFocus);
        } else if (this._dateAllowed(focusedDate)) {
          this.focusDate(this[property]);
        } else {
          this._focusClosestDate(focusedDate);
        }
      }
      /** @private */
      _dateAllowed(date, min = this.minDate, max = this.maxDate, isDateDisabled = this.isDateDisabled) {
        return dateAllowed(date, min, max, isDateDisabled);
      }
      /** @private */
      _isTodayAllowed(min, max, isDateDisabled) {
        const today = /* @__PURE__ */ new Date();
        const todayMidnight = new Date(0, 0);
        todayMidnight.setFullYear(today.getFullYear());
        todayMidnight.setMonth(today.getMonth());
        todayMidnight.setDate(today.getDate());
        return this._dateAllowed(todayMidnight, min, max, isDateDisabled);
      }
      /**
       * Fired when the scroller reaches the target scrolling position.
       * @event scroll-animation-finished
       * @param {Number} detail.position new position
       * @param {Number} detail.oldPosition old position
       */
    };
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const overlayContentStyles = css$e`
  :host {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    outline: none;
  }

  [part='overlay-header'] {
    display: flex;
    flex-shrink: 0;
    flex-wrap: nowrap;
    align-items: center;
  }

  :host(:not([fullscreen])) [part='overlay-header'] {
    display: none;
  }

  [part='label'] {
    flex-grow: 1;
  }

  [hidden] {
    display: none !important;
  }

  [part='years-toggle-button'] {
    display: flex;
  }

  #scrollers {
    display: flex;
    height: 100%;
    width: 100%;
    position: relative;
    overflow: hidden;
  }

  :host([desktop]) ::slotted([slot='months']) {
    right: 50px;
    transform: none !important;
  }

  :host([desktop]) ::slotted([slot='years']) {
    transform: none !important;
  }

  :host(.animate) ::slotted([slot='months']),
  :host(.animate) ::slotted([slot='years']) {
    transition: all 200ms;
  }

  [part='toolbar'] {
    display: flex;
    justify-content: space-between;
    z-index: 2;
    flex-shrink: 0;
  }
`;
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-date-picker-overlay-content", overlayContentStyles, {
      moduleId: "vaadin-date-picker-overlay-content-styles"
    });
    class DatePickerOverlayContent extends DatePickerOverlayContentMixin(
      ControllerMixin(ThemableMixin(DirMixin(PolymerElement)))
    ) {
      static get template() {
        return html`
      <div part="overlay-header" on-touchend="_preventDefault" aria-hidden="true">
        <div part="label">[[_formatDisplayed(selectedDate, i18n, label)]]</div>
        <div part="clear-button" hidden$="[[!selectedDate]]"></div>
        <div part="toggle-button"></div>

        <div part="years-toggle-button" hidden$="[[_desktopMode]]" aria-hidden="true">
          [[_yearAfterXMonths(_visibleMonthIndex)]]
        </div>
      </div>

      <div id="scrollers">
        <slot name="months"></slot>
        <slot name="years"></slot>
      </div>

      <div on-touchend="_preventDefault" role="toolbar" part="toolbar">
        <slot name="today-button"></slot>
        <slot name="cancel-button"></slot>
      </div>
    `;
      }
      static get is() {
        return "vaadin-date-picker-overlay-content";
      }
      /** @protected */
      ready() {
        super.ready();
        this.setAttribute("role", "dialog");
        this._addListeners();
        this._initControllers();
      }
    }
    defineCustomElement(DatePickerOverlayContent);
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const DatePickerMixin = (subclass) => class DatePickerMixinClass extends OverlayClassMixin(
      ControllerMixin(DelegateFocusMixin(InputConstraintsMixin(KeyboardMixin(subclass))))
    ) {
      static get properties() {
        return {
          /**
           * The current selected date.
           * @type {Date | undefined}
           * @protected
           */
          _selectedDate: {
            type: Object,
            sync: true
          },
          /**
           * @type {Date | undefined}
           * @protected
           */
          _focusedDate: {
            type: Object,
            sync: true
          },
          /**
           * Selected date.
           *
           * Supported date formats:
           * - ISO 8601 `"YYYY-MM-DD"` (default)
           * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
           *
           * @type {string}
           */
          value: {
            type: String,
            notify: true,
            value: "",
            sync: true
          },
          /**
           * Date which should be visible when there is no value selected.
           *
           * The same date formats as for the `value` property are supported.
           * @attr {string} initial-position
           */
          initialPosition: String,
          /**
           * Set true to open the date selector overlay.
           */
          opened: {
            type: Boolean,
            reflectToAttribute: true,
            notify: true,
            observer: "_openedChanged",
            sync: true
          },
          /**
           * Set true to prevent the overlay from opening automatically.
           * @attr {boolean} auto-open-disabled
           */
          autoOpenDisabled: Boolean,
          /**
           * Set true to display ISO-8601 week numbers in the calendar. Notice that
           * displaying week numbers is only supported when `i18n.firstDayOfWeek`
           * is 1 (Monday).
           * @attr {boolean} show-week-numbers
           */
          showWeekNumbers: {
            type: Boolean,
            value: false,
            sync: true
          },
          /**
           * @type {boolean}
           * @protected
           */
          _fullscreen: {
            type: Boolean,
            value: false,
            sync: true
          },
          /**
           * @type {string}
           * @protected
           */
          _fullscreenMediaQuery: {
            value: "(max-width: 420px), (max-height: 420px)"
          },
          /**
           * The object used to localize this component.
           * To change the default localization, replace the entire
           * `i18n` object with a custom one.
           *
           * To update individual properties, extend the existing i18n object like so:
           * ```
           * datePicker.i18n = { ...datePicker.i18n, {
           *   formatDate: date => { ... },
           *   parseDate: value => { ... },
           * }};
           * ```
           *
           * The object has the following JSON structure and default values:
           *
           * ```
           * {
           *   // An array with the full names of months starting
           *   // with January.
           *   monthNames: [
           *     'January', 'February', 'March', 'April', 'May',
           *     'June', 'July', 'August', 'September',
           *     'October', 'November', 'December'
           *   ],
           *
           *   // An array of weekday names starting with Sunday. Used
           *   // in screen reader announcements.
           *   weekdays: [
           *     'Sunday', 'Monday', 'Tuesday', 'Wednesday',
           *     'Thursday', 'Friday', 'Saturday'
           *   ],
           *
           *   // An array of short weekday names starting with Sunday.
           *   // Displayed in the calendar.
           *   weekdaysShort: [
           *     'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
           *   ],
           *
           *   // An integer indicating the first day of the week
           *   // (0 = Sunday, 1 = Monday, etc.).
           *   firstDayOfWeek: 0,
           *
           *   // Translation of the Today shortcut button text.
           *   today: 'Today',
           *
           *   // Translation of the Cancel button text.
           *   cancel: 'Cancel',
           *
           *   // Used for adjusting the year value when parsing dates with short years.
           *   // The year values between 0 and 99 are evaluated and adjusted.
           *   // Example: for a referenceDate of 1970-10-30;
           *   //   dateToBeParsed: 40-10-30, result: 1940-10-30
           *   //   dateToBeParsed: 80-10-30, result: 1980-10-30
           *   //   dateToBeParsed: 10-10-30, result: 2010-10-30
           *   // Supported date format: ISO 8601 `"YYYY-MM-DD"` (default)
           *   // The default value is the current date.
           *   referenceDate: '',
           *
           *   // A function to format given `Object` as
           *   // date string. Object is in the format `{ day: ..., month: ..., year: ... }`
           *   // Note: The argument month is 0-based. This means that January = 0 and December = 11.
           *   formatDate: d => {
           *     // returns a string representation of the given
           *     // object in 'MM/DD/YYYY' -format
           *   },
           *
           *   // A function to parse the given text to an `Object` in the format `{ day: ..., month: ..., year: ... }`.
           *   // Must properly parse (at least) text formatted by `formatDate`.
           *   // Setting the property to null will disable keyboard input feature.
           *   // Note: The argument month is 0-based. This means that January = 0 and December = 11.
           *   parseDate: text => {
           *     // Parses a string in 'MM/DD/YY', 'MM/DD' or 'DD' -format to
           *     // an `Object` in the format `{ day: ..., month: ..., year: ... }`.
           *   }
           *
           *   // A function to format given `monthName` and
           *   // `fullYear` integer as calendar title string.
           *   formatTitle: (monthName, fullYear) => {
           *     return monthName + ' ' + fullYear;
           *   }
           * }
           * ```
           *
           * @type {!DatePickerI18n}
           * @default {English/US}
           */
          i18n: {
            type: Object,
            sync: true,
            value: () => {
              return {
                monthNames: [
                  "January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December"
                ],
                weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                firstDayOfWeek: 0,
                today: "Today",
                cancel: "Cancel",
                referenceDate: "",
                formatDate(d) {
                  const yearStr = String(d.year).replace(/\d+/u, (y) => "0000".substr(y.length) + y);
                  return [d.month + 1, d.day, yearStr].join("/");
                },
                parseDate(text) {
                  const parts = text.split("/");
                  const today = /* @__PURE__ */ new Date();
                  let date, month = today.getMonth(), year = today.getFullYear();
                  if (parts.length === 3) {
                    month = parseInt(parts[0]) - 1;
                    date = parseInt(parts[1]);
                    year = parseInt(parts[2]);
                    if (parts[2].length < 3 && year >= 0) {
                      const usedReferenceDate = this.referenceDate ? parseDate(this.referenceDate) : /* @__PURE__ */ new Date();
                      year = getAdjustedYear(usedReferenceDate, year, month, date);
                    }
                  } else if (parts.length === 2) {
                    month = parseInt(parts[0]) - 1;
                    date = parseInt(parts[1]);
                  } else if (parts.length === 1) {
                    date = parseInt(parts[0]);
                  }
                  if (date !== void 0) {
                    return { day: date, month, year };
                  }
                },
                formatTitle: (monthName, fullYear) => {
                  return `${monthName} ${fullYear}`;
                }
              };
            }
          },
          /**
           * The earliest date that can be selected. All earlier dates will be disabled.
           *
           * Supported date formats:
           * - ISO 8601 `"YYYY-MM-DD"` (default)
           * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
           *
           * @type {string | undefined}
           */
          min: {
            type: String,
            sync: true
          },
          /**
           * The latest date that can be selected. All later dates will be disabled.
           *
           * Supported date formats:
           * - ISO 8601 `"YYYY-MM-DD"` (default)
           * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
           *
           * @type {string | undefined}
           */
          max: {
            type: String,
            sync: true
          },
          /**
           * A function to be used to determine whether the user can select a given date.
           * Receives a `DatePickerDate` object of the date to be selected and should return a
           * boolean.
           *
           * @type {function(DatePickerDate): boolean | undefined}
           */
          isDateDisabled: {
            type: Function
          },
          /**
           * The earliest date that can be selected. All earlier dates will be disabled.
           * @type {Date | undefined}
           * @protected
           */
          _minDate: {
            type: Date,
            computed: "__computeMinOrMaxDate(min)",
            sync: true
          },
          /**
           * The latest date that can be selected. All later dates will be disabled.
           * @type {Date | undefined}
           * @protected
           */
          _maxDate: {
            type: Date,
            computed: "__computeMinOrMaxDate(max)",
            sync: true
          },
          /** @private */
          _noInput: {
            type: Boolean,
            computed: "_isNoInput(inputElement, _fullscreen, _ios, i18n, opened, autoOpenDisabled)"
          },
          /** @private */
          _ios: {
            type: Boolean,
            value: isIOS
          },
          /** @private */
          _focusOverlayOnOpen: Boolean,
          /** @private */
          _overlayContent: {
            type: Object,
            sync: true
          },
          /**
           * In date-picker, unlike other components extending `InputMixin`,
           * the property indicates true only if the input has been entered by the user.
           * In the case of programmatic changes, the property is reset to false.
           * Read more about why this workaround is needed:
           * https://github.com/vaadin/web-components/issues/5639
           *
           * @protected
           * @override
           */
          _hasInputValue: {
            type: Boolean
          }
        };
      }
      static get observers() {
        return [
          "_selectedDateChanged(_selectedDate, i18n)",
          "_focusedDateChanged(_focusedDate, i18n)",
          "__updateOverlayContent(_overlayContent, i18n, label, _minDate, _maxDate, _focusedDate, _selectedDate, showWeekNumbers, isDateDisabled)",
          "__updateOverlayContentTheme(_overlayContent, _theme)",
          "__updateOverlayContentFullScreen(_overlayContent, _fullscreen)"
        ];
      }
      static get constraints() {
        return [...super.constraints, "min", "max"];
      }
      constructor() {
        super();
        this._boundOnClick = this._onClick.bind(this);
        this._boundOnScroll = this._onScroll.bind(this);
        this._boundOverlayRenderer = this._overlayRenderer.bind(this);
      }
      /**
       * @override
       * @protected
       */
      get _inputElementValue() {
        return super._inputElementValue;
      }
      /**
       * The setter is overridden to reset the `_hasInputValue` property
       * to false when the input element's value is updated programmatically.
       * In date-picker, `_hasInputValue` is supposed to indicate true only
       * if the input has been entered by the user.
       * Read more about why this workaround is needed:
       * https://github.com/vaadin/web-components/issues/5639
       *
       * @override
       * @protected
       */
      set _inputElementValue(value) {
        super._inputElementValue = value;
        this._hasInputValue = false;
      }
      /**
       * Override a getter from `InputControlMixin` to make it optional
       * and to prevent warning when a clear button is missing,
       * for example when using <vaadin-date-picker-light>.
       * @protected
       * @return {Element | null | undefined}
       */
      get clearElement() {
        return null;
      }
      /** @private */
      get _nativeInput() {
        if (this.inputElement) {
          return this.inputElement.focusElement || this.inputElement;
        }
        return null;
      }
      /**
       * The input element's value when it cannot be parsed as a date, and an empty string otherwise.
       *
       * @return {string}
       * @private
       */
      get __unparsableValue() {
        if (!this._inputElementValue || this.__parseDate(this._inputElementValue)) {
          return "";
        }
        return this._inputElementValue;
      }
      /**
       * Override an event listener from `DelegateFocusMixin`
       * @protected
       */
      _onFocus(event) {
        super._onFocus(event);
        if (this._noInput) {
          event.target.blur();
        }
      }
      /**
       * Override an event listener from `DelegateFocusMixin`
       * @protected
       */
      _onBlur(event) {
        super._onBlur(event);
        if (!this.opened) {
          this.__commitParsedOrFocusedDate();
          if (document.hasFocus()) {
            this.validate();
          }
        }
      }
      /** @protected */
      ready() {
        super.ready();
        this.addEventListener("click", this._boundOnClick);
        this.addController(
          new MediaQueryController(this._fullscreenMediaQuery, (matches2) => {
            this._fullscreen = matches2;
          })
        );
        this.addController(new VirtualKeyboardController(this));
        const overlay2 = this.$.overlay;
        this._overlayElement = overlay2;
        overlay2.renderer = this._boundOverlayRenderer;
        this.addEventListener("mousedown", () => this.__bringToFront());
        this.addEventListener("touchstart", () => this.__bringToFront());
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.opened = false;
      }
      /**
       * Opens the dropdown.
       */
      open() {
        if (!this.disabled && !this.readonly) {
          this.opened = true;
        }
      }
      /**
       * Closes the dropdown.
       */
      close() {
        this.$.overlay.close();
      }
      /** @private */
      _overlayRenderer(root2) {
        if (root2.firstChild) {
          return;
        }
        const content = document.createElement("vaadin-date-picker-overlay-content");
        root2.appendChild(content);
        this._overlayContent = content;
        content.addEventListener("close", () => {
          this._close();
        });
        content.addEventListener("focus-input", this._focusAndSelect.bind(this));
        content.addEventListener("date-tap", (e2) => {
          this.__commitDate(e2.detail.date);
          this._close();
        });
        content.addEventListener("date-selected", (e2) => {
          this.__commitDate(e2.detail.date);
        });
        content.addEventListener("focusin", () => {
          if (this._keyboardActive) {
            this._setFocused(true);
          }
        });
        content.addEventListener("focused-date-changed", (e2) => {
          this._focusedDate = e2.detail.value;
        });
        content.addEventListener("click", (e2) => e2.stopPropagation());
      }
      /**
       * @param {string} dateString
       * @private
       */
      __parseDate(dateString) {
        if (!this.i18n.parseDate) {
          return;
        }
        let dateObject = this.i18n.parseDate(dateString);
        if (dateObject) {
          dateObject = parseDate(`${dateObject.year}-${dateObject.month + 1}-${dateObject.day}`);
        }
        if (dateObject && !isNaN(dateObject.getTime())) {
          return dateObject;
        }
      }
      /**
       * @param {Date} dateObject
       * @private
       */
      __formatDate(dateObject) {
        if (this.i18n.formatDate) {
          return this.i18n.formatDate(extractDateParts(dateObject));
        }
      }
      /**
       * Returns true if the current input value satisfies all constraints (if any)
       *
       * Override the `checkValidity` method for custom validations.
       *
       * @return {boolean} True if the value is valid
       */
      checkValidity() {
        const inputValue = this._inputElementValue;
        const inputValid = !inputValue || !!this._selectedDate && inputValue === this.__formatDate(this._selectedDate);
        const isDateValid = !this._selectedDate || dateAllowed(this._selectedDate, this._minDate, this._maxDate, this.isDateDisabled);
        let inputValidity = true;
        if (this.inputElement) {
          if (this.inputElement.checkValidity) {
            inputValidity = this.inputElement.checkValidity();
          } else if (this.inputElement.validate) {
            inputValidity = this.inputElement.validate();
          }
        }
        return inputValid && isDateValid && inputValidity;
      }
      /**
       * Override method inherited from `FocusMixin`
       * to not call `_setFocused(true)` when focus
       * is restored after closing overlay on click,
       * and to avoid removing `focus-ring` attribute.
       *
       * @param {!FocusEvent} _event
       * @return {boolean}
       * @protected
       * @override
       */
      _shouldSetFocus(_event) {
        return !this._shouldKeepFocusRing;
      }
      /**
       * Override method inherited from `FocusMixin`
       * to prevent removing the `focused` attribute:
       * - when moving focus to the overlay content,
       * - when closing on date click / outside click.
       *
       * @param {!FocusEvent} _event
       * @return {boolean}
       * @protected
       * @override
       */
      _shouldRemoveFocus(_event) {
        return !this.opened;
      }
      /**
       * Override method inherited from `FocusMixin`
       * to store the `focus-ring` state to restore
       * it later when closing on outside click.
       *
       * @param {boolean} focused
       * @protected
       * @override
       */
      _setFocused(focused) {
        super._setFocused(focused);
        this._shouldKeepFocusRing = focused && this._keyboardActive;
      }
      /**
       * Depending on the nature of the value change that has occurred since
       * the last commit attempt, triggers validation and fires an event:
       *
       * Value change             | Event
       * :------------------------|:------------------
       * empty => parsable        | change
       * empty => unparsable      | unparsable-change
       * parsable => empty        | change
       * parsable => parsable     | change
       * parsable => unparsable   | change
       * unparsable => empty      | unparsable-change
       * unparsable => parsable   | change
       * unparsable => unparsable | unparsable-change
       *
       * @private
       */
      __commitValueChange() {
        const unparsableValue = this.__unparsableValue;
        if (this.__committedValue !== this.value) {
          this.validate();
          this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
        } else if (this.__committedUnparsableValue !== unparsableValue) {
          this.validate();
          this.dispatchEvent(new CustomEvent("unparsable-change"));
        }
        this.__committedValue = this.value;
        this.__committedUnparsableValue = unparsableValue;
      }
      /**
       * Sets the given date as the value and commits it.
       *
       * @param {Date} date
       * @private
       */
      __commitDate(date) {
        this.__keepCommittedValue = true;
        this._selectedDate = date;
        this.__keepCommittedValue = false;
        this.__commitValueChange();
      }
      /** @private */
      _close() {
        this._focus();
        this.close();
      }
      /** @private */
      __bringToFront() {
        requestAnimationFrame(() => {
          this.$.overlay.bringToFront();
        });
      }
      /** @private */
      // eslint-disable-next-line max-params
      _isNoInput(inputElement, fullscreen, ios, i18n, opened, autoOpenDisabled) {
        const noInputOnFullscreenMode = fullscreen && (!autoOpenDisabled || opened);
        const noInputOnIos = ios && opened;
        return !inputElement || noInputOnFullscreenMode || noInputOnIos || !i18n.parseDate;
      }
      /** @private */
      _formatISO(date) {
        if (!(date instanceof Date)) {
          return "";
        }
        const pad2 = (num, fmt = "00") => (fmt + num).substr((fmt + num).length - fmt.length);
        let yearSign = "";
        let yearFmt = "0000";
        let yearAbs = date.getFullYear();
        if (yearAbs < 0) {
          yearAbs = -yearAbs;
          yearSign = "-";
          yearFmt = "000000";
        } else if (date.getFullYear() >= 1e4) {
          yearSign = "+";
          yearFmt = "000000";
        }
        const year = yearSign + pad2(yearAbs, yearFmt);
        const month = pad2(date.getMonth() + 1);
        const day = pad2(date.getDate());
        return [year, month, day].join("-");
      }
      /** @protected */
      _inputElementChanged(input) {
        super._inputElementChanged(input);
        if (input) {
          input.autocomplete = "off";
          input.setAttribute("role", "combobox");
          input.setAttribute("aria-haspopup", "dialog");
          input.setAttribute("aria-expanded", !!this.opened);
          this._applyInputValue(this._selectedDate);
        }
      }
      /** @protected */
      _openedChanged(opened) {
        if (this.inputElement) {
          this.inputElement.setAttribute("aria-expanded", opened);
        }
      }
      /** @private */
      _selectedDateChanged(selectedDate, i18n) {
        if (selectedDate === void 0 || i18n === void 0) {
          return;
        }
        if (!this.__keepInputValue) {
          this._applyInputValue(selectedDate);
        }
        this.value = this._formatISO(selectedDate);
        this._ignoreFocusedDateChange = true;
        this._focusedDate = selectedDate;
        this._ignoreFocusedDateChange = false;
      }
      /** @private */
      _focusedDateChanged(focusedDate, i18n) {
        if (focusedDate === void 0 || i18n === void 0) {
          return;
        }
        if (!this._ignoreFocusedDateChange && !this._noInput) {
          this._applyInputValue(focusedDate);
        }
      }
      /**
       * Override the value observer from `InputMixin` to implement custom
       * handling of the `value` property. The date-picker doesn't forward
       * the value directly to the input like the default implementation of `InputMixin`.
       * Instead, it parses the value into a date, puts it in `_selectedDate` which
       * is then displayed in the input with respect to the specified date format.
       *
       * @param {string | undefined} value
       * @param {string | undefined} oldValue
       * @protected
       * @override
       */
      _valueChanged(value, oldValue) {
        const newDate = parseDate(value);
        if (value && !newDate) {
          this.value = oldValue;
          return;
        }
        if (value) {
          if (!dateEquals(this._selectedDate, newDate)) {
            this._selectedDate = newDate;
            if (oldValue !== void 0) {
              this.validate();
            }
          }
        } else {
          this._selectedDate = null;
        }
        if (!this.__keepCommittedValue) {
          this.__committedValue = this.value;
          this.__committedUnparsableValue = "";
        }
        this._toggleHasValue(this._hasValue);
      }
      /** @private */
      // eslint-disable-next-line max-params
      __updateOverlayContent(overlayContent, i18n, label, minDate, maxDate, focusedDate, selectedDate, showWeekNumbers, isDateDisabled) {
        if (overlayContent) {
          overlayContent.i18n = i18n;
          overlayContent.label = label;
          overlayContent.minDate = minDate;
          overlayContent.maxDate = maxDate;
          overlayContent.focusedDate = focusedDate;
          overlayContent.selectedDate = selectedDate;
          overlayContent.showWeekNumbers = showWeekNumbers;
          overlayContent.isDateDisabled = isDateDisabled;
        }
      }
      /** @private */
      __updateOverlayContentTheme(overlayContent, theme2) {
        if (overlayContent) {
          if (theme2) {
            overlayContent.setAttribute("theme", theme2);
          } else {
            overlayContent.removeAttribute("theme");
          }
        }
      }
      /** @private */
      __updateOverlayContentFullScreen(overlayContent, fullscreen) {
        if (overlayContent) {
          overlayContent.toggleAttribute("fullscreen", fullscreen);
        }
      }
      /** @protected */
      _onOverlayEscapePress() {
        this._focusedDate = this._selectedDate;
        this._closedByEscape = true;
        this._close();
        this._closedByEscape = false;
      }
      /** @protected */
      _onOverlayOpened() {
        const content = this._overlayContent;
        content.reset();
        const initialPosition = this._getInitialPosition();
        content.initialPosition = initialPosition;
        const scrollFocusDate = content.focusedDate || initialPosition;
        content.scrollToDate(scrollFocusDate);
        this._ignoreFocusedDateChange = true;
        content.focusedDate = scrollFocusDate;
        this._ignoreFocusedDateChange = false;
        window.addEventListener("scroll", this._boundOnScroll, true);
        if (this._focusOverlayOnOpen) {
          content.focusDateElement();
          this._focusOverlayOnOpen = false;
        } else {
          this._focus();
        }
        const input = this._nativeInput;
        if (this._noInput && input) {
          input.blur();
          this._overlayContent.focusDateElement();
        }
        const focusables = this._noInput ? content : [input, content];
        this.__showOthers = hideOthers(focusables);
      }
      /** @private */
      _getInitialPosition() {
        const parsedInitialPosition = parseDate(this.initialPosition);
        const initialPosition = this._selectedDate || this._overlayContent.initialPosition || parsedInitialPosition || /* @__PURE__ */ new Date();
        return parsedInitialPosition || dateAllowed(initialPosition, this._minDate, this._maxDate, this.isDateDisabled) ? initialPosition : this._minDate || this._maxDate ? getClosestDate(initialPosition, [this._minDate, this._maxDate]) : /* @__PURE__ */ new Date();
      }
      /**
       * Tries to parse the input element's value as a date. If the input value
       * is parsable, commits the resulting date as the value. Otherwise, commits
       * an empty string as the value. If no i18n parser is provided, commits
       * the focused date as the value.
       *
       * @private
       */
      __commitParsedOrFocusedDate() {
        this._ignoreFocusedDateChange = true;
        if (this.i18n.parseDate) {
          const inputValue = this._inputElementValue || "";
          const parsedDate = this.__parseDate(inputValue);
          if (parsedDate) {
            this.__commitDate(parsedDate);
          } else {
            this.__keepInputValue = true;
            this.__commitDate(null);
            this.__keepInputValue = false;
          }
        } else if (this._focusedDate) {
          this.__commitDate(this._focusedDate);
        }
        this._ignoreFocusedDateChange = false;
      }
      /** @protected */
      _onOverlayClosed() {
        if (this.__showOthers) {
          this.__showOthers();
          this.__showOthers = null;
        }
        window.removeEventListener("scroll", this._boundOnScroll, true);
        if (this._closedByEscape) {
          this._applyInputValue(this._selectedDate);
        }
        this.__commitParsedOrFocusedDate();
        if (this._nativeInput && this._nativeInput.selectionStart) {
          this._nativeInput.selectionStart = this._nativeInput.selectionEnd;
        }
        if (!this.value && !this._keyboardActive) {
          this.validate();
        }
      }
      /** @private */
      _onScroll(e2) {
        if (e2.target === window || !this._overlayContent.contains(e2.target)) {
          this._overlayContent._repositionYearScroller();
        }
      }
      /** @protected */
      _focus() {
        if (!this._noInput) {
          this.inputElement.focus();
        }
      }
      /** @private */
      _focusAndSelect() {
        this._focus();
        this._setSelectionRange(0, this._inputElementValue.length);
      }
      /** @private */
      _applyInputValue(date) {
        this._inputElementValue = date ? this.__formatDate(date) : "";
      }
      /** @private */
      _setSelectionRange(a, b) {
        if (this._nativeInput && this._nativeInput.setSelectionRange) {
          this._nativeInput.setSelectionRange(a, b);
        }
      }
      /**
       * Override an event listener from `InputConstraintsMixin`
       * to have date-picker fully control when to fire a change event
       * and trigger validation.
       *
       * @protected
       */
      _onChange(event) {
        event.stopPropagation();
      }
      /**
       * @param {Event} event
       * @private
       */
      _onClick(event) {
        if (!this._isClearButton(event)) {
          this._onHostClick(event);
        }
      }
      /**
       * @param {Event} event
       * @private
       */
      _onHostClick(event) {
        if (!this.autoOpenDisabled || this._noInput) {
          event.preventDefault();
          this.open();
        }
      }
      /**
       * Override an event listener from `InputControlMixin`
       * to validate and dispatch change on clear.
       * @protected
       */
      _onClearButtonClick(event) {
        event.preventDefault();
        this.__commitDate(null);
      }
      /**
       * Override an event listener from `KeyboardMixin`.
       * @param {KeyboardEvent} e
       * @protected
       * @override
       */
      _onKeyDown(e2) {
        super._onKeyDown(e2);
        if (this._noInput) {
          const allowedKeys = [
            9
            // Tab
          ];
          if (allowedKeys.indexOf(e2.keyCode) === -1) {
            e2.preventDefault();
          }
        }
        switch (e2.key) {
          case "ArrowDown":
          case "ArrowUp":
            e2.preventDefault();
            if (this.opened) {
              this._overlayContent.focusDateElement();
            } else {
              this._focusOverlayOnOpen = true;
              this.open();
            }
            break;
          case "Tab":
            if (this.opened) {
              e2.preventDefault();
              e2.stopPropagation();
              this._setSelectionRange(0, 0);
              if (e2.shiftKey) {
                this._overlayContent.focusCancel();
              } else {
                this._overlayContent.focusDateElement();
              }
            }
            break;
        }
      }
      /**
       * Override an event listener from `KeyboardMixin`.
       *
       * @param {!KeyboardEvent} _event
       * @protected
       * @override
       */
      _onEnter(_event) {
        if (this.opened) {
          this.close();
        } else {
          this.__commitParsedOrFocusedDate();
        }
      }
      /**
       * Override an event listener from `KeyboardMixin`.
       * Do not call `super` in order to override clear
       * button logic defined in `InputControlMixin`.
       *
       * @param {!KeyboardEvent} event
       * @protected
       * @override
       */
      _onEscape(event) {
        if (this.opened) {
          return;
        }
        if (this.clearButtonVisible && !!this.value) {
          event.stopPropagation();
          this._onClearButtonClick(event);
          return;
        }
        if (this.inputElement.value === "") {
          this.__commitDate(null);
        } else {
          this._applyInputValue(this._selectedDate);
        }
      }
      /** @protected */
      _isClearButton(event) {
        return event.composedPath()[0] === this.clearElement;
      }
      /**
       * Override an event listener from `InputMixin`
       * @protected
       */
      _onInput() {
        if (!this.opened && this._inputElementValue && !this.autoOpenDisabled) {
          this.open();
        }
        if (this._inputElementValue) {
          const parsedDate = this.__parseDate(this._inputElementValue);
          if (parsedDate) {
            this._ignoreFocusedDateChange = true;
            if (!dateEquals(parsedDate, this._focusedDate)) {
              this._focusedDate = parsedDate;
            }
            this._ignoreFocusedDateChange = false;
          }
        }
      }
      /** @private */
      __computeMinOrMaxDate(dateString) {
        return parseDate(dateString);
      }
      /**
       * Fired when the user commits a value change.
       *
       * @event change
       */
      /**
       * Fired when `value` property value changes.
       *
       * @event value-changed
       */
      /**
       * Fired when `opened` property value changes.
       *
       * @event opened-changed
       */
    };
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const datePickerStyles = css$e`
  :host([opened]) {
    pointer-events: auto;
  }

  :host([dir='rtl']) [part='input-field'] {
    direction: ltr;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
    direction: rtl;
    text-align: left;
  }
`;
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-date-picker", [inputFieldShared$1, datePickerStyles], { moduleId: "vaadin-date-picker-styles" });
    class DatePicker extends DatePickerMixin(InputControlMixin(ThemableMixin(ElementMixin(PolymerElement)))) {
      static get is() {
        return "vaadin-date-picker";
      }
      static get template() {
        return html`
      <div class="vaadin-date-picker-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div part="toggle-button" slot="suffix" aria-hidden="true" on-click="_toggle"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-date-picker-overlay
        id="overlay"
        fullscreen$="[[_fullscreen]]"
        theme$="[[_theme]]"
        opened="{{opened}}"
        on-vaadin-overlay-escape-press="_onOverlayEscapePress"
        on-vaadin-overlay-open="_onOverlayOpened"
        on-vaadin-overlay-closing="_onOverlayClosed"
        restore-focus-on-close
        restore-focus-node="[[inputElement]]"
      ></vaadin-date-picker-overlay>

      <slot name="tooltip"></slot>
    `;
      }
      /**
       * Used by `InputControlMixin` as a reference to the clear button element.
       * @protected
       * @return {!HTMLElement}
       */
      get clearElement() {
        return this.$.clearButton;
      }
      /** @protected */
      ready() {
        super.ready();
        this.addController(
          new InputController(this, (input) => {
            this._setInputElement(input);
            this._setFocusElement(input);
            this.stateTarget = input;
            this.ariaTarget = input;
          })
        );
        this.addController(new LabelledInputController(this.inputElement, this._labelController));
        this._tooltipController = new TooltipController(this);
        this.addController(this._tooltipController);
        this._tooltipController.setPosition("top");
        this._tooltipController.setAriaTarget(this.inputElement);
        this._tooltipController.setShouldShow((target) => !target.opened);
        const toggleButton = this.shadowRoot.querySelector('[part="toggle-button"]');
        toggleButton.addEventListener("mousedown", (e2) => e2.preventDefault());
        this.$.overlay.addEventListener("vaadin-overlay-close", this._onVaadinOverlayClose.bind(this));
      }
      /** @private */
      _onVaadinOverlayClose(e2) {
        if (e2.detail.sourceEvent && e2.detail.sourceEvent.composedPath().includes(this)) {
          e2.preventDefault();
        }
      }
      /** @private */
      _toggle(e2) {
        e2.stopPropagation();
        if (this.$.overlay.opened) {
          this.close();
        } else {
          this.open();
        }
      }
      // Workaround https://github.com/vaadin/web-components/issues/2855
      /** @protected */
      _openedChanged(opened) {
        super._openedChanged(opened);
        this.$.overlay.positionTarget = this.shadowRoot.querySelector('[part="input-field"]');
        this.$.overlay.noVerticalOverlap = true;
      }
    }
    defineCustomElement(DatePicker);
    function requiredArgs(required, args) {
      if (args.length < required) {
        throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
      }
    }
    function _typeof$y(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$y = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$y = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$y(obj);
    }
    function isDate(value) {
      requiredArgs(1, arguments);
      return value instanceof Date || _typeof$y(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
    }
    function _typeof$x(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$x = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$x = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$x(obj);
    }
    function toDate(argument) {
      requiredArgs(1, arguments);
      var argStr = Object.prototype.toString.call(argument);
      if (argument instanceof Date || _typeof$x(argument) === "object" && argStr === "[object Date]") {
        return new Date(argument.getTime());
      } else if (typeof argument === "number" || argStr === "[object Number]") {
        return new Date(argument);
      } else {
        if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
          console.warn(new Error().stack);
        }
        return /* @__PURE__ */ new Date(NaN);
      }
    }
    function isValid(dirtyDate) {
      requiredArgs(1, arguments);
      if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
        return false;
      }
      var date = toDate(dirtyDate);
      return !isNaN(Number(date));
    }
    function toInteger(dirtyNumber) {
      if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
        return NaN;
      }
      var number = Number(dirtyNumber);
      if (isNaN(number)) {
        return number;
      }
      return number < 0 ? Math.ceil(number) : Math.floor(number);
    }
    function addMilliseconds(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var timestamp = toDate(dirtyDate).getTime();
      var amount = toInteger(dirtyAmount);
      return new Date(timestamp + amount);
    }
    function subMilliseconds(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger(dirtyAmount);
      return addMilliseconds(dirtyDate, -amount);
    }
    var MILLISECONDS_IN_DAY = 864e5;
    function getUTCDayOfYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var timestamp = date.getTime();
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
      var startOfYearTimestamp = date.getTime();
      var difference = timestamp - startOfYearTimestamp;
      return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
    }
    function startOfUTCISOWeek(dirtyDate) {
      requiredArgs(1, arguments);
      var weekStartsOn = 1;
      var date = toDate(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
    function getUTCISOWeekYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getUTCFullYear();
      var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
      fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
      var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
      fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }
    function startOfUTCISOWeekYear(dirtyDate) {
      requiredArgs(1, arguments);
      var year = getUTCISOWeekYear(dirtyDate);
      var fourthOfJanuary = /* @__PURE__ */ new Date(0);
      fourthOfJanuary.setUTCFullYear(year, 0, 4);
      fourthOfJanuary.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCISOWeek(fourthOfJanuary);
      return date;
    }
    var MILLISECONDS_IN_WEEK$1 = 6048e5;
    function getUTCISOWeek(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
      return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
    }
    var defaultOptions = {};
    function getDefaultOptions() {
      return defaultOptions;
    }
    function startOfUTCWeek(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      requiredArgs(1, arguments);
      var defaultOptions2 = getDefaultOptions();
      var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
      }
      var date = toDate(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
    function getUTCWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getUTCFullYear();
      var defaultOptions2 = getDefaultOptions();
      var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
      }
      var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
      firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
      var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
      firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }
    function startOfUTCWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      requiredArgs(1, arguments);
      var defaultOptions2 = getDefaultOptions();
      var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
      var year = getUTCWeekYear(dirtyDate, options);
      var firstWeek = /* @__PURE__ */ new Date(0);
      firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCWeek(firstWeek, options);
      return date;
    }
    var MILLISECONDS_IN_WEEK = 6048e5;
    function getUTCWeek(dirtyDate, options) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
      return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
    }
    function addLeadingZeros(number, targetLength) {
      var sign = number < 0 ? "-" : "";
      var output = Math.abs(number).toString();
      while (output.length < targetLength) {
        output = "0" + output;
      }
      return sign + output;
    }
    var formatters$1 = {
      // Year
      y: function y(date, token) {
        var signedYear = date.getUTCFullYear();
        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
      },
      // Month
      M: function M(date, token) {
        var month = date.getUTCMonth();
        return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
      },
      // Day of the month
      d: function d(date, token) {
        return addLeadingZeros(date.getUTCDate(), token.length);
      },
      // AM or PM
      a: function a(date, token) {
        var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return dayPeriodEnumValue.toUpperCase();
          case "aaa":
            return dayPeriodEnumValue;
          case "aaaaa":
            return dayPeriodEnumValue[0];
          case "aaaa":
          default:
            return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
      },
      // Hour [1-12]
      h: function h(date, token) {
        return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
      },
      // Hour [0-23]
      H: function H2(date, token) {
        return addLeadingZeros(date.getUTCHours(), token.length);
      },
      // Minute
      m: function m(date, token) {
        return addLeadingZeros(date.getUTCMinutes(), token.length);
      },
      // Second
      s: function s(date, token) {
        return addLeadingZeros(date.getUTCSeconds(), token.length);
      },
      // Fraction of second
      S: function S(date, token) {
        var numberOfDigits = token.length;
        var milliseconds = date.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
        return addLeadingZeros(fractionalSeconds, token.length);
      }
    };
    var dayPeriodEnum = {
      am: "am",
      pm: "pm",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    };
    var formatters = {
      // Era
      G: function G2(date, token, localize2) {
        var era = date.getUTCFullYear() > 0 ? 1 : 0;
        switch (token) {
          case "G":
          case "GG":
          case "GGG":
            return localize2.era(era, {
              width: "abbreviated"
            });
          case "GGGGG":
            return localize2.era(era, {
              width: "narrow"
            });
          case "GGGG":
          default:
            return localize2.era(era, {
              width: "wide"
            });
        }
      },
      // Year
      y: function y(date, token, localize2) {
        if (token === "yo") {
          var signedYear = date.getUTCFullYear();
          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize2.ordinalNumber(year, {
            unit: "year"
          });
        }
        return formatters$1.y(date, token);
      },
      // Local week-numbering year
      Y: function Y(date, token, localize2, options) {
        var signedWeekYear = getUTCWeekYear(date, options);
        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
        if (token === "YY") {
          var twoDigitYear = weekYear % 100;
          return addLeadingZeros(twoDigitYear, 2);
        }
        if (token === "Yo") {
          return localize2.ordinalNumber(weekYear, {
            unit: "year"
          });
        }
        return addLeadingZeros(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function R2(date, token) {
        var isoWeekYear = getUTCISOWeekYear(date);
        return addLeadingZeros(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function u(date, token) {
        var year = date.getUTCFullYear();
        return addLeadingZeros(year, token.length);
      },
      // Quarter
      Q: function Q(date, token, localize2) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
        switch (token) {
          case "Q":
            return String(quarter);
          case "QQ":
            return addLeadingZeros(quarter, 2);
          case "Qo":
            return localize2.ordinalNumber(quarter, {
              unit: "quarter"
            });
          case "QQQ":
            return localize2.quarter(quarter, {
              width: "abbreviated",
              context: "formatting"
            });
          case "QQQQQ":
            return localize2.quarter(quarter, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return localize2.quarter(quarter, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone quarter
      q: function q(date, token, localize2) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
        switch (token) {
          case "q":
            return String(quarter);
          case "qq":
            return addLeadingZeros(quarter, 2);
          case "qo":
            return localize2.ordinalNumber(quarter, {
              unit: "quarter"
            });
          case "qqq":
            return localize2.quarter(quarter, {
              width: "abbreviated",
              context: "standalone"
            });
          case "qqqqq":
            return localize2.quarter(quarter, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return localize2.quarter(quarter, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // Month
      M: function M(date, token, localize2) {
        var month = date.getUTCMonth();
        switch (token) {
          case "M":
          case "MM":
            return formatters$1.M(date, token);
          case "Mo":
            return localize2.ordinalNumber(month + 1, {
              unit: "month"
            });
          case "MMM":
            return localize2.month(month, {
              width: "abbreviated",
              context: "formatting"
            });
          case "MMMMM":
            return localize2.month(month, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return localize2.month(month, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone month
      L: function L(date, token, localize2) {
        var month = date.getUTCMonth();
        switch (token) {
          case "L":
            return String(month + 1);
          case "LL":
            return addLeadingZeros(month + 1, 2);
          case "Lo":
            return localize2.ordinalNumber(month + 1, {
              unit: "month"
            });
          case "LLL":
            return localize2.month(month, {
              width: "abbreviated",
              context: "standalone"
            });
          case "LLLLL":
            return localize2.month(month, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return localize2.month(month, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // Local week of year
      w: function w2(date, token, localize2, options) {
        var week = getUTCWeek(date, options);
        if (token === "wo") {
          return localize2.ordinalNumber(week, {
            unit: "week"
          });
        }
        return addLeadingZeros(week, token.length);
      },
      // ISO week of year
      I: function I(date, token, localize2) {
        var isoWeek = getUTCISOWeek(date);
        if (token === "Io") {
          return localize2.ordinalNumber(isoWeek, {
            unit: "week"
          });
        }
        return addLeadingZeros(isoWeek, token.length);
      },
      // Day of the month
      d: function d(date, token, localize2) {
        if (token === "do") {
          return localize2.ordinalNumber(date.getUTCDate(), {
            unit: "date"
          });
        }
        return formatters$1.d(date, token);
      },
      // Day of year
      D: function D(date, token, localize2) {
        var dayOfYear = getUTCDayOfYear(date);
        if (token === "Do") {
          return localize2.ordinalNumber(dayOfYear, {
            unit: "dayOfYear"
          });
        }
        return addLeadingZeros(dayOfYear, token.length);
      },
      // Day of week
      E: function E(date, token, localize2) {
        var dayOfWeek = date.getUTCDay();
        switch (token) {
          case "E":
          case "EE":
          case "EEE":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "EEEEE":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "EEEE":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Local day of week
      e: function e2(date, token, localize2, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "e":
            return String(localDayOfWeek);
          case "ee":
            return addLeadingZeros(localDayOfWeek, 2);
          case "eo":
            return localize2.ordinalNumber(localDayOfWeek, {
              unit: "day"
            });
          case "eee":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "eeeee":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "eeee":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone local day of week
      c: function c(date, token, localize2, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "c":
            return String(localDayOfWeek);
          case "cc":
            return addLeadingZeros(localDayOfWeek, token.length);
          case "co":
            return localize2.ordinalNumber(localDayOfWeek, {
              unit: "day"
            });
          case "ccc":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "standalone"
            });
          case "ccccc":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "standalone"
            });
          case "cccc":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // ISO day of week
      i: function i(date, token, localize2) {
        var dayOfWeek = date.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch (token) {
          case "i":
            return String(isoDayOfWeek);
          case "ii":
            return addLeadingZeros(isoDayOfWeek, token.length);
          case "io":
            return localize2.ordinalNumber(isoDayOfWeek, {
              unit: "day"
            });
          case "iii":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "iiiii":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "iiiiii":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "iiii":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM or PM
      a: function a(date, token, localize2) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "aaa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "aaaaa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM, PM, midnight, noon
      b: function b(date, token, localize2) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;
        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        }
        switch (token) {
          case "b":
          case "bb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "bbb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "bbbbb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function B(date, token, localize2) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;
        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "BBBBB":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Hour [1-12]
      h: function h(date, token, localize2) {
        if (token === "ho") {
          var hours = date.getUTCHours() % 12;
          if (hours === 0) hours = 12;
          return localize2.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return formatters$1.h(date, token);
      },
      // Hour [0-23]
      H: function H2(date, token, localize2) {
        if (token === "Ho") {
          return localize2.ordinalNumber(date.getUTCHours(), {
            unit: "hour"
          });
        }
        return formatters$1.H(date, token);
      },
      // Hour [0-11]
      K: function K(date, token, localize2) {
        var hours = date.getUTCHours() % 12;
        if (token === "Ko") {
          return localize2.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return addLeadingZeros(hours, token.length);
      },
      // Hour [1-24]
      k: function k(date, token, localize2) {
        var hours = date.getUTCHours();
        if (hours === 0) hours = 24;
        if (token === "ko") {
          return localize2.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return addLeadingZeros(hours, token.length);
      },
      // Minute
      m: function m(date, token, localize2) {
        if (token === "mo") {
          return localize2.ordinalNumber(date.getUTCMinutes(), {
            unit: "minute"
          });
        }
        return formatters$1.m(date, token);
      },
      // Second
      s: function s(date, token, localize2) {
        if (token === "so") {
          return localize2.ordinalNumber(date.getUTCSeconds(), {
            unit: "second"
          });
        }
        return formatters$1.s(date, token);
      },
      // Fraction of second
      S: function S(date, token) {
        return formatters$1.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function X(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        if (timezoneOffset === 0) {
          return "Z";
        }
        switch (token) {
          case "X":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "XXXX":
          case "XX":
            return formatTimezone(timezoneOffset);
          case "XXXXX":
          case "XXX":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function x(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          case "x":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "xxxx":
          case "xx":
            return formatTimezone(timezoneOffset);
          case "xxxxx":
          case "xxx":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (GMT)
      O: function O(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          case "O":
          case "OO":
          case "OOO":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "OOOO":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (specific non-location)
      z: function z(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          case "z":
          case "zz":
          case "zzz":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "zzzz":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Seconds timestamp
      t: function t(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = Math.floor(originalDate.getTime() / 1e3);
        return addLeadingZeros(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function T(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = originalDate.getTime();
        return addLeadingZeros(timestamp, token.length);
      }
    };
    function formatTimezoneShort(offset2, dirtyDelimiter) {
      var sign = offset2 > 0 ? "-" : "+";
      var absOffset = Math.abs(offset2);
      var hours = Math.floor(absOffset / 60);
      var minutes = absOffset % 60;
      if (minutes === 0) {
        return sign + String(hours);
      }
      var delimiter = dirtyDelimiter;
      return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
    }
    function formatTimezoneWithOptionalMinutes(offset2, dirtyDelimiter) {
      if (offset2 % 60 === 0) {
        var sign = offset2 > 0 ? "-" : "+";
        return sign + addLeadingZeros(Math.abs(offset2) / 60, 2);
      }
      return formatTimezone(offset2, dirtyDelimiter);
    }
    function formatTimezone(offset2, dirtyDelimiter) {
      var delimiter = dirtyDelimiter || "";
      var sign = offset2 > 0 ? "-" : "+";
      var absOffset = Math.abs(offset2);
      var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
      var minutes = addLeadingZeros(absOffset % 60, 2);
      return sign + hours + delimiter + minutes;
    }
    var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
      switch (pattern) {
        case "P":
          return formatLong2.date({
            width: "short"
          });
        case "PP":
          return formatLong2.date({
            width: "medium"
          });
        case "PPP":
          return formatLong2.date({
            width: "long"
          });
        case "PPPP":
        default:
          return formatLong2.date({
            width: "full"
          });
      }
    };
    var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
      switch (pattern) {
        case "p":
          return formatLong2.time({
            width: "short"
          });
        case "pp":
          return formatLong2.time({
            width: "medium"
          });
        case "ppp":
          return formatLong2.time({
            width: "long"
          });
        case "pppp":
        default:
          return formatLong2.time({
            width: "full"
          });
      }
    };
    var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
      var matchResult = pattern.match(/(P+)(p+)?/) || [];
      var datePattern = matchResult[1];
      var timePattern = matchResult[2];
      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong2);
      }
      var dateTimeFormat;
      switch (datePattern) {
        case "P":
          dateTimeFormat = formatLong2.dateTime({
            width: "short"
          });
          break;
        case "PP":
          dateTimeFormat = formatLong2.dateTime({
            width: "medium"
          });
          break;
        case "PPP":
          dateTimeFormat = formatLong2.dateTime({
            width: "long"
          });
          break;
        case "PPPP":
        default:
          dateTimeFormat = formatLong2.dateTime({
            width: "full"
          });
          break;
      }
      return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
    };
    var longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
    function getTimezoneOffsetInMilliseconds(date) {
      var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      utcDate.setUTCFullYear(date.getFullYear());
      return date.getTime() - utcDate.getTime();
    }
    var protectedDayOfYearTokens = ["D", "DD"];
    var protectedWeekYearTokens = ["YY", "YYYY"];
    function isProtectedDayOfYearToken(token) {
      return protectedDayOfYearTokens.indexOf(token) !== -1;
    }
    function isProtectedWeekYearToken(token) {
      return protectedWeekYearTokens.indexOf(token) !== -1;
    }
    function throwProtectedError(token, format2, input) {
      if (token === "YYYY") {
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === "YY") {
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === "D") {
        throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === "DD") {
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      }
    }
    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
      },
      xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
      },
      halfAMinute: "half a minute",
      lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
      },
      xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
      },
      aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
      },
      xHours: {
        one: "1 hour",
        other: "{{count}} hours"
      },
      xDays: {
        one: "1 day",
        other: "{{count}} days"
      },
      aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
      },
      xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
      },
      aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
      },
      xMonths: {
        one: "1 month",
        other: "{{count}} months"
      },
      aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
      },
      xYears: {
        one: "1 year",
        other: "{{count}} years"
      },
      overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
      },
      almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
      }
    };
    var formatDistance = function formatDistance2(token, count, options) {
      var result2;
      var tokenValue = formatDistanceLocale[token];
      if (typeof tokenValue === "string") {
        result2 = tokenValue;
      } else if (count === 1) {
        result2 = tokenValue.one;
      } else {
        result2 = tokenValue.other.replace("{{count}}", count.toString());
      }
      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "in " + result2;
        } else {
          return result2 + " ago";
        }
      }
      return result2;
    };
    function buildFormatLongFn(args) {
      return function() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var width = options.width ? String(options.width) : args.defaultWidth;
        var format2 = args.formats[width] || args.formats[args.defaultWidth];
        return format2;
      };
    }
    var dateFormats = {
      full: "EEEE, MMMM do, y",
      long: "MMMM do, y",
      medium: "MMM d, y",
      short: "MM/dd/yyyy"
    };
    var timeFormats = {
      full: "h:mm:ss a zzzz",
      long: "h:mm:ss a z",
      medium: "h:mm:ss a",
      short: "h:mm a"
    };
    var dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    var formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: "full"
      })
    };
    var formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: "P"
    };
    var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
      return formatRelativeLocale[token];
    };
    function buildLocalizeFn(args) {
      return function(dirtyIndex, options) {
        var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
        var valuesArray;
        if (context === "formatting" && args.formattingValues) {
          var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          var _defaultWidth = args.defaultWidth;
          var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
          valuesArray = args.values[_width] || args.values[_defaultWidth];
        }
        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
        return valuesArray[index];
      };
    }
    var eraValues = {
      narrow: ["B", "A"],
      abbreviated: ["BC", "AD"],
      wide: ["Before Christ", "Anno Domini"]
    };
    var quarterValues = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["Q1", "Q2", "Q3", "Q4"],
      wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    };
    var monthValues = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    };
    var dayValues = {
      narrow: ["S", "M", "T", "W", "T", "F", "S"],
      short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    };
    var dayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      }
    };
    var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
      var number = Number(dirtyNumber);
      var rem100 = number % 100;
      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + "st";
          case 2:
            return number + "nd";
          case 3:
            return number + "rd";
        }
      }
      return number + "th";
    };
    var localize = {
      ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: function argumentCallback(quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
      })
    };
    function buildMatchFn(args) {
      return function(string) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);
        if (!matchResult) {
          return null;
        }
        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
          return pattern.test(matchedString);
        }) : findKey(parsePatterns, function(pattern) {
          return pattern.test(matchedString);
        });
        var value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value,
          rest
        };
      };
    }
    function findKey(object, predicate) {
      for (var key in object) {
        if (object.hasOwnProperty(key) && predicate(object[key])) {
          return key;
        }
      }
      return void 0;
    }
    function findIndex(array, predicate) {
      for (var key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
          return key;
        }
      }
      return void 0;
    }
    function buildMatchPatternFn(args) {
      return function(string) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var matchResult = string.match(args.matchPattern);
        if (!matchResult) return null;
        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);
        if (!parseResult) return null;
        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value,
          rest
        };
      };
    }
    var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function valueCallback(value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: function valueCallback(index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
      })
    };
    var locale = {
      code: "en-US",
      formatDistance,
      formatLong,
      formatRelative,
      localize,
      match,
      options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
      }
    };
    var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp$1 = /^'([^]*?)'?$/;
    var doubleQuoteRegExp$1 = /''/g;
    var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
    function format(dirtyDate, dirtyFormatStr, options) {
      var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _defaultOptions$local3, _defaultOptions$local4;
      requiredArgs(2, arguments);
      var formatStr = String(dirtyFormatStr);
      var defaultOptions2 = getDefaultOptions();
      var locale$1 = (_ref = (_options$locale = void 0) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : locale;
      var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = void 0) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : void 0) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
      }
      var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = void 0) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : void 0) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
      }
      if (!locale$1.localize) {
        throw new RangeError("locale must contain localize property");
      }
      if (!locale$1.formatLong) {
        throw new RangeError("locale must contain formatLong property");
      }
      var originalDate = toDate(dirtyDate);
      if (!isValid(originalDate)) {
        throw new RangeError("Invalid time value");
      }
      var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
      var utcDate = subMilliseconds(originalDate, timezoneOffset);
      var formatterOptions = {
        firstWeekContainsDate,
        weekStartsOn,
        locale: locale$1,
        _originalDate: originalDate
      };
      var result2 = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
        var firstCharacter = substring[0];
        if (firstCharacter === "p" || firstCharacter === "P") {
          var longFormatter = longFormatters[firstCharacter];
          return longFormatter(substring, locale$1.formatLong);
        }
        return substring;
      }).join("").match(formattingTokensRegExp$1).map(function(substring) {
        if (substring === "''") {
          return "'";
        }
        var firstCharacter = substring[0];
        if (firstCharacter === "'") {
          return cleanEscapedString$1(substring);
        }
        var formatter = formatters[firstCharacter];
        if (formatter) {
          if (isProtectedWeekYearToken(substring)) {
            throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
          }
          if (isProtectedDayOfYearToken(substring)) {
            throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
          }
          return formatter(utcDate, substring, locale$1.localize, formatterOptions);
        }
        if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        return substring;
      }).join("");
      return result2;
    }
    function cleanEscapedString$1(input) {
      var matched = input.match(escapedStringRegExp$1);
      if (!matched) {
        return input;
      }
      return matched[1].replace(doubleQuoteRegExp$1, "'");
    }
    function assign(target, object) {
      if (target == null) {
        throw new TypeError("assign requires that input parameter not be null or undefined");
      }
      for (var property in object) {
        if (Object.prototype.hasOwnProperty.call(object, property)) {
          target[property] = object[property];
        }
      }
      return target;
    }
    function _typeof$w(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$w = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$w = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$w(obj);
    }
    function _inherits$v(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$v(subClass, superClass);
    }
    function _setPrototypeOf$v(o, p) {
      _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$v(o, p);
    }
    function _createSuper$v(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$v();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$v(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$v(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$v(this, result2);
      };
    }
    function _possibleConstructorReturn$v(self, call) {
      if (call && (_typeof$w(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$v(self);
    }
    function _assertThisInitialized$v(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$v() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$v(o) {
      _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$v(o);
    }
    function _classCallCheck$w(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$w(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$w(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$w(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _defineProperty$v(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var TIMEZONE_UNIT_PRIORITY = 10;
    var Setter = /* @__PURE__ */ function() {
      function Setter2() {
        _classCallCheck$w(this, Setter2);
        _defineProperty$v(this, "subPriority", 0);
      }
      _createClass$w(Setter2, [{
        key: "validate",
        value: function validate(_utcDate, _options) {
          return true;
        }
      }]);
      return Setter2;
    }();
    var ValueSetter = /* @__PURE__ */ function(_Setter) {
      _inherits$v(ValueSetter2, _Setter);
      var _super = _createSuper$v(ValueSetter2);
      function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
        var _this;
        _classCallCheck$w(this, ValueSetter2);
        _this = _super.call(this);
        _this.value = value;
        _this.validateValue = validateValue;
        _this.setValue = setValue;
        _this.priority = priority;
        if (subPriority) {
          _this.subPriority = subPriority;
        }
        return _this;
      }
      _createClass$w(ValueSetter2, [{
        key: "validate",
        value: function validate(utcDate, options) {
          return this.validateValue(utcDate, this.value, options);
        }
      }, {
        key: "set",
        value: function set2(utcDate, flags, options) {
          return this.setValue(utcDate, flags, this.value, options);
        }
      }]);
      return ValueSetter2;
    }(Setter);
    var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
      _inherits$v(DateToSystemTimezoneSetter2, _Setter2);
      var _super2 = _createSuper$v(DateToSystemTimezoneSetter2);
      function DateToSystemTimezoneSetter2() {
        var _this2;
        _classCallCheck$w(this, DateToSystemTimezoneSetter2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this2 = _super2.call.apply(_super2, [this].concat(args));
        _defineProperty$v(_assertThisInitialized$v(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
        _defineProperty$v(_assertThisInitialized$v(_this2), "subPriority", -1);
        return _this2;
      }
      _createClass$w(DateToSystemTimezoneSetter2, [{
        key: "set",
        value: function set2(date, flags) {
          if (flags.timestampIsSet) {
            return date;
          }
          var convertedDate = /* @__PURE__ */ new Date(0);
          convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
          convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
          return convertedDate;
        }
      }]);
      return DateToSystemTimezoneSetter2;
    }(Setter);
    function _classCallCheck$v(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$v(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$v(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$v(Constructor.prototype, protoProps);
      return Constructor;
    }
    var Parser = /* @__PURE__ */ function() {
      function Parser2() {
        _classCallCheck$v(this, Parser2);
      }
      _createClass$v(Parser2, [{
        key: "run",
        value: function run(dateString, token, match2, options) {
          var result2 = this.parse(dateString, token, match2, options);
          if (!result2) {
            return null;
          }
          return {
            setter: new ValueSetter(result2.value, this.validate, this.set, this.priority, this.subPriority),
            rest: result2.rest
          };
        }
      }, {
        key: "validate",
        value: function validate(_utcDate, _value, _options) {
          return true;
        }
      }]);
      return Parser2;
    }();
    function _typeof$v(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$v = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$v = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$v(obj);
    }
    function _classCallCheck$u(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$u(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$u(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$u(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$u(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$u(subClass, superClass);
    }
    function _setPrototypeOf$u(o, p) {
      _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$u(o, p);
    }
    function _createSuper$u(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$u();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$u(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$u(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$u(this, result2);
      };
    }
    function _possibleConstructorReturn$u(self, call) {
      if (call && (_typeof$v(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$u(self);
    }
    function _assertThisInitialized$u(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$u() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$u(o) {
      _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$u(o);
    }
    function _defineProperty$u(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var EraParser = /* @__PURE__ */ function(_Parser) {
      _inherits$u(EraParser2, _Parser);
      var _super = _createSuper$u(EraParser2);
      function EraParser2() {
        var _this;
        _classCallCheck$u(this, EraParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$u(_assertThisInitialized$u(_this), "priority", 140);
        _defineProperty$u(_assertThisInitialized$u(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
        return _this;
      }
      _createClass$u(EraParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "G":
            case "GG":
            case "GGG":
              return match2.era(dateString, {
                width: "abbreviated"
              }) || match2.era(dateString, {
                width: "narrow"
              });
            case "GGGGG":
              return match2.era(dateString, {
                width: "narrow"
              });
            case "GGGG":
            default:
              return match2.era(dateString, {
                width: "wide"
              }) || match2.era(dateString, {
                width: "abbreviated"
              }) || match2.era(dateString, {
                width: "narrow"
              });
          }
        }
      }, {
        key: "set",
        value: function set2(date, flags, value) {
          flags.era = value;
          date.setUTCFullYear(value, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return EraParser2;
    }(Parser);
    var millisecondsInMinute = 6e4;
    var millisecondsInHour = 36e5;
    var millisecondsInSecond = 1e3;
    var numericPatterns = {
      month: /^(1[0-2]|0?\d)/,
      // 0 to 12
      date: /^(3[0-1]|[0-2]?\d)/,
      // 0 to 31
      dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
      // 0 to 366
      week: /^(5[0-3]|[0-4]?\d)/,
      // 0 to 53
      hour23h: /^(2[0-3]|[0-1]?\d)/,
      // 0 to 23
      hour24h: /^(2[0-4]|[0-1]?\d)/,
      // 0 to 24
      hour11h: /^(1[0-1]|0?\d)/,
      // 0 to 11
      hour12h: /^(1[0-2]|0?\d)/,
      // 0 to 12
      minute: /^[0-5]?\d/,
      // 0 to 59
      second: /^[0-5]?\d/,
      // 0 to 59
      singleDigit: /^\d/,
      // 0 to 9
      twoDigits: /^\d{1,2}/,
      // 0 to 99
      threeDigits: /^\d{1,3}/,
      // 0 to 999
      fourDigits: /^\d{1,4}/,
      // 0 to 9999
      anyDigitsSigned: /^-?\d+/,
      singleDigitSigned: /^-?\d/,
      // 0 to 9, -0 to -9
      twoDigitsSigned: /^-?\d{1,2}/,
      // 0 to 99, -0 to -99
      threeDigitsSigned: /^-?\d{1,3}/,
      // 0 to 999, -0 to -999
      fourDigitsSigned: /^-?\d{1,4}/
      // 0 to 9999, -0 to -9999
    };
    var timezonePatterns = {
      basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
      basic: /^([+-])(\d{2})(\d{2})|Z/,
      basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
      extended: /^([+-])(\d{2}):(\d{2})|Z/,
      extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
    };
    function mapValue(parseFnResult, mapFn) {
      if (!parseFnResult) {
        return parseFnResult;
      }
      return {
        value: mapFn(parseFnResult.value),
        rest: parseFnResult.rest
      };
    }
    function parseNumericPattern(pattern, dateString) {
      var matchResult = dateString.match(pattern);
      if (!matchResult) {
        return null;
      }
      return {
        value: parseInt(matchResult[0], 10),
        rest: dateString.slice(matchResult[0].length)
      };
    }
    function parseTimezonePattern(pattern, dateString) {
      var matchResult = dateString.match(pattern);
      if (!matchResult) {
        return null;
      }
      if (matchResult[0] === "Z") {
        return {
          value: 0,
          rest: dateString.slice(1)
        };
      }
      var sign = matchResult[1] === "+" ? 1 : -1;
      var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
      var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
      var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
      return {
        value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
        rest: dateString.slice(matchResult[0].length)
      };
    }
    function parseAnyDigitsSigned(dateString) {
      return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
    }
    function parseNDigits(n, dateString) {
      switch (n) {
        case 1:
          return parseNumericPattern(numericPatterns.singleDigit, dateString);
        case 2:
          return parseNumericPattern(numericPatterns.twoDigits, dateString);
        case 3:
          return parseNumericPattern(numericPatterns.threeDigits, dateString);
        case 4:
          return parseNumericPattern(numericPatterns.fourDigits, dateString);
        default:
          return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
      }
    }
    function parseNDigitsSigned(n, dateString) {
      switch (n) {
        case 1:
          return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
        case 2:
          return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
        case 3:
          return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
        case 4:
          return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
        default:
          return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
      }
    }
    function dayPeriodEnumToHours(dayPeriod) {
      switch (dayPeriod) {
        case "morning":
          return 4;
        case "evening":
          return 17;
        case "pm":
        case "noon":
        case "afternoon":
          return 12;
        case "am":
        case "midnight":
        case "night":
        default:
          return 0;
      }
    }
    function normalizeTwoDigitYear(twoDigitYear, currentYear) {
      var isCommonEra = currentYear > 0;
      var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
      var result2;
      if (absCurrentYear <= 50) {
        result2 = twoDigitYear || 100;
      } else {
        var rangeEnd = absCurrentYear + 50;
        var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
        var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
        result2 = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
      }
      return isCommonEra ? result2 : 1 - result2;
    }
    function isLeapYearIndex(year) {
      return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
    }
    function _typeof$u(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$u = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$u = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$u(obj);
    }
    function _classCallCheck$t(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$t(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$t(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$t(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$t(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$t(subClass, superClass);
    }
    function _setPrototypeOf$t(o, p) {
      _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$t(o, p);
    }
    function _createSuper$t(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$t(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$t(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$t(this, result2);
      };
    }
    function _possibleConstructorReturn$t(self, call) {
      if (call && (_typeof$u(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$t(self);
    }
    function _assertThisInitialized$t(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$t() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$t(o) {
      _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$t(o);
    }
    function _defineProperty$t(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var YearParser = /* @__PURE__ */ function(_Parser) {
      _inherits$t(YearParser2, _Parser);
      var _super = _createSuper$t(YearParser2);
      function YearParser2() {
        var _this;
        _classCallCheck$t(this, YearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$t(_assertThisInitialized$t(_this), "priority", 130);
        _defineProperty$t(_assertThisInitialized$t(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass$t(YearParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          var valueCallback = function valueCallback2(year) {
            return {
              year,
              isTwoDigitYear: token === "yy"
            };
          };
          switch (token) {
            case "y":
              return mapValue(parseNDigits(4, dateString), valueCallback);
            case "yo":
              return mapValue(match2.ordinalNumber(dateString, {
                unit: "year"
              }), valueCallback);
            default:
              return mapValue(parseNDigits(token.length, dateString), valueCallback);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value.isTwoDigitYear || value.year > 0;
        }
      }, {
        key: "set",
        value: function set2(date, flags, value) {
          var currentYear = date.getUTCFullYear();
          if (value.isTwoDigitYear) {
            var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
            date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
            date.setUTCHours(0, 0, 0, 0);
            return date;
          }
          var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
          date.setUTCFullYear(year, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return YearParser2;
    }(Parser);
    function _typeof$t(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$t = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$t = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$t(obj);
    }
    function _classCallCheck$s(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$s(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$s(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$s(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$s(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$s(subClass, superClass);
    }
    function _setPrototypeOf$s(o, p) {
      _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$s(o, p);
    }
    function _createSuper$s(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$s(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$s(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$s(this, result2);
      };
    }
    function _possibleConstructorReturn$s(self, call) {
      if (call && (_typeof$t(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$s(self);
    }
    function _assertThisInitialized$s(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$s() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$s(o) {
      _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$s(o);
    }
    function _defineProperty$s(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
      _inherits$s(LocalWeekYearParser2, _Parser);
      var _super = _createSuper$s(LocalWeekYearParser2);
      function LocalWeekYearParser2() {
        var _this;
        _classCallCheck$s(this, LocalWeekYearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$s(_assertThisInitialized$s(_this), "priority", 130);
        _defineProperty$s(_assertThisInitialized$s(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
        return _this;
      }
      _createClass$s(LocalWeekYearParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          var valueCallback = function valueCallback2(year) {
            return {
              year,
              isTwoDigitYear: token === "YY"
            };
          };
          switch (token) {
            case "Y":
              return mapValue(parseNDigits(4, dateString), valueCallback);
            case "Yo":
              return mapValue(match2.ordinalNumber(dateString, {
                unit: "year"
              }), valueCallback);
            default:
              return mapValue(parseNDigits(token.length, dateString), valueCallback);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value.isTwoDigitYear || value.year > 0;
        }
      }, {
        key: "set",
        value: function set2(date, flags, value, options) {
          var currentYear = getUTCWeekYear(date, options);
          if (value.isTwoDigitYear) {
            var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
            date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
            date.setUTCHours(0, 0, 0, 0);
            return startOfUTCWeek(date, options);
          }
          var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
          date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
          date.setUTCHours(0, 0, 0, 0);
          return startOfUTCWeek(date, options);
        }
      }]);
      return LocalWeekYearParser2;
    }(Parser);
    function _typeof$s(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$s = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$s = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$s(obj);
    }
    function _classCallCheck$r(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$r(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$r(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$r(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$r(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$r(subClass, superClass);
    }
    function _setPrototypeOf$r(o, p) {
      _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$r(o, p);
    }
    function _createSuper$r(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$r(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$r(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$r(this, result2);
      };
    }
    function _possibleConstructorReturn$r(self, call) {
      if (call && (_typeof$s(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$r(self);
    }
    function _assertThisInitialized$r(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$r() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$r(o) {
      _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$r(o);
    }
    function _defineProperty$r(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
      _inherits$r(ISOWeekYearParser2, _Parser);
      var _super = _createSuper$r(ISOWeekYearParser2);
      function ISOWeekYearParser2() {
        var _this;
        _classCallCheck$r(this, ISOWeekYearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$r(_assertThisInitialized$r(_this), "priority", 130);
        _defineProperty$r(_assertThisInitialized$r(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass$r(ISOWeekYearParser2, [{
        key: "parse",
        value: function parse2(dateString, token) {
          if (token === "R") {
            return parseNDigitsSigned(4, dateString);
          }
          return parseNDigitsSigned(token.length, dateString);
        }
      }, {
        key: "set",
        value: function set2(_date, _flags, value) {
          var firstWeekOfYear = /* @__PURE__ */ new Date(0);
          firstWeekOfYear.setUTCFullYear(value, 0, 4);
          firstWeekOfYear.setUTCHours(0, 0, 0, 0);
          return startOfUTCISOWeek(firstWeekOfYear);
        }
      }]);
      return ISOWeekYearParser2;
    }(Parser);
    function _typeof$r(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$r = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$r = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$r(obj);
    }
    function _classCallCheck$q(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$q(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$q(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$q(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$q(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$q(subClass, superClass);
    }
    function _setPrototypeOf$q(o, p) {
      _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$q(o, p);
    }
    function _createSuper$q(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$q(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$q(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$q(this, result2);
      };
    }
    function _possibleConstructorReturn$q(self, call) {
      if (call && (_typeof$r(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$q(self);
    }
    function _assertThisInitialized$q(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$q() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$q(o) {
      _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$q(o);
    }
    function _defineProperty$q(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
      _inherits$q(ExtendedYearParser2, _Parser);
      var _super = _createSuper$q(ExtendedYearParser2);
      function ExtendedYearParser2() {
        var _this;
        _classCallCheck$q(this, ExtendedYearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$q(_assertThisInitialized$q(_this), "priority", 130);
        _defineProperty$q(_assertThisInitialized$q(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass$q(ExtendedYearParser2, [{
        key: "parse",
        value: function parse2(dateString, token) {
          if (token === "u") {
            return parseNDigitsSigned(4, dateString);
          }
          return parseNDigitsSigned(token.length, dateString);
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCFullYear(value, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return ExtendedYearParser2;
    }(Parser);
    function _typeof$q(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$q = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$q = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$q(obj);
    }
    function _classCallCheck$p(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$p(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$p(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$p(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$p(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$p(subClass, superClass);
    }
    function _setPrototypeOf$p(o, p) {
      _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$p(o, p);
    }
    function _createSuper$p(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$p(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$p(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$p(this, result2);
      };
    }
    function _possibleConstructorReturn$p(self, call) {
      if (call && (_typeof$q(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$p(self);
    }
    function _assertThisInitialized$p(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$p() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$p(o) {
      _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$p(o);
    }
    function _defineProperty$p(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var QuarterParser = /* @__PURE__ */ function(_Parser) {
      _inherits$p(QuarterParser2, _Parser);
      var _super = _createSuper$p(QuarterParser2);
      function QuarterParser2() {
        var _this;
        _classCallCheck$p(this, QuarterParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$p(_assertThisInitialized$p(_this), "priority", 120);
        _defineProperty$p(_assertThisInitialized$p(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass$p(QuarterParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "Q":
            case "QQ":
              return parseNDigits(token.length, dateString);
            case "Qo":
              return match2.ordinalNumber(dateString, {
                unit: "quarter"
              });
            case "QQQ":
              return match2.quarter(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.quarter(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "QQQQQ":
              return match2.quarter(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "QQQQ":
            default:
              return match2.quarter(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.quarter(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.quarter(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 4;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMonth((value - 1) * 3, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return QuarterParser2;
    }(Parser);
    function _typeof$p(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$p = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$p = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$p(obj);
    }
    function _classCallCheck$o(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$o(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$o(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$o(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$o(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$o(subClass, superClass);
    }
    function _setPrototypeOf$o(o, p) {
      _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$o(o, p);
    }
    function _createSuper$o(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$o(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$o(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$o(this, result2);
      };
    }
    function _possibleConstructorReturn$o(self, call) {
      if (call && (_typeof$p(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$o(self);
    }
    function _assertThisInitialized$o(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$o() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$o(o) {
      _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$o(o);
    }
    function _defineProperty$o(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
      _inherits$o(StandAloneQuarterParser2, _Parser);
      var _super = _createSuper$o(StandAloneQuarterParser2);
      function StandAloneQuarterParser2() {
        var _this;
        _classCallCheck$o(this, StandAloneQuarterParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$o(_assertThisInitialized$o(_this), "priority", 120);
        _defineProperty$o(_assertThisInitialized$o(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass$o(StandAloneQuarterParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "q":
            case "qq":
              return parseNDigits(token.length, dateString);
            case "qo":
              return match2.ordinalNumber(dateString, {
                unit: "quarter"
              });
            case "qqq":
              return match2.quarter(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match2.quarter(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "qqqqq":
              return match2.quarter(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "qqqq":
            default:
              return match2.quarter(dateString, {
                width: "wide",
                context: "standalone"
              }) || match2.quarter(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match2.quarter(dateString, {
                width: "narrow",
                context: "standalone"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 4;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMonth((value - 1) * 3, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return StandAloneQuarterParser2;
    }(Parser);
    function _typeof$o(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$o = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$o = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$o(obj);
    }
    function _classCallCheck$n(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$n(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$n(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$n(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$n(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$n(subClass, superClass);
    }
    function _setPrototypeOf$n(o, p) {
      _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$n(o, p);
    }
    function _createSuper$n(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$n(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$n(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$n(this, result2);
      };
    }
    function _possibleConstructorReturn$n(self, call) {
      if (call && (_typeof$o(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$n(self);
    }
    function _assertThisInitialized$n(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$n() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$n(o) {
      _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$n(o);
    }
    function _defineProperty$n(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var MonthParser = /* @__PURE__ */ function(_Parser) {
      _inherits$n(MonthParser2, _Parser);
      var _super = _createSuper$n(MonthParser2);
      function MonthParser2() {
        var _this;
        _classCallCheck$n(this, MonthParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$n(_assertThisInitialized$n(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
        _defineProperty$n(_assertThisInitialized$n(_this), "priority", 110);
        return _this;
      }
      _createClass$n(MonthParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          var valueCallback = function valueCallback2(value) {
            return value - 1;
          };
          switch (token) {
            case "M":
              return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
            case "MM":
              return mapValue(parseNDigits(2, dateString), valueCallback);
            case "Mo":
              return mapValue(match2.ordinalNumber(dateString, {
                unit: "month"
              }), valueCallback);
            case "MMM":
              return match2.month(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.month(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "MMMMM":
              return match2.month(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "MMMM":
            default:
              return match2.month(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.month(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.month(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 11;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMonth(value, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return MonthParser2;
    }(Parser);
    function _typeof$n(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$n = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$n = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$n(obj);
    }
    function _classCallCheck$m(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$m(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$m(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$m(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$m(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$m(subClass, superClass);
    }
    function _setPrototypeOf$m(o, p) {
      _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$m(o, p);
    }
    function _createSuper$m(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$m(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$m(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$m(this, result2);
      };
    }
    function _possibleConstructorReturn$m(self, call) {
      if (call && (_typeof$n(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$m(self);
    }
    function _assertThisInitialized$m(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$m() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$m(o) {
      _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$m(o);
    }
    function _defineProperty$m(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
      _inherits$m(StandAloneMonthParser2, _Parser);
      var _super = _createSuper$m(StandAloneMonthParser2);
      function StandAloneMonthParser2() {
        var _this;
        _classCallCheck$m(this, StandAloneMonthParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$m(_assertThisInitialized$m(_this), "priority", 110);
        _defineProperty$m(_assertThisInitialized$m(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass$m(StandAloneMonthParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          var valueCallback = function valueCallback2(value) {
            return value - 1;
          };
          switch (token) {
            case "L":
              return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
            case "LL":
              return mapValue(parseNDigits(2, dateString), valueCallback);
            case "Lo":
              return mapValue(match2.ordinalNumber(dateString, {
                unit: "month"
              }), valueCallback);
            case "LLL":
              return match2.month(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match2.month(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "LLLLL":
              return match2.month(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "LLLL":
            default:
              return match2.month(dateString, {
                width: "wide",
                context: "standalone"
              }) || match2.month(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match2.month(dateString, {
                width: "narrow",
                context: "standalone"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 11;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMonth(value, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return StandAloneMonthParser2;
    }(Parser);
    function setUTCWeek(dirtyDate, dirtyWeek, options) {
      requiredArgs(2, arguments);
      var date = toDate(dirtyDate);
      var week = toInteger(dirtyWeek);
      var diff = getUTCWeek(date, options) - week;
      date.setUTCDate(date.getUTCDate() - diff * 7);
      return date;
    }
    function _typeof$m(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$m = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$m = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$m(obj);
    }
    function _classCallCheck$l(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$l(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$l(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$l(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$l(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$l(subClass, superClass);
    }
    function _setPrototypeOf$l(o, p) {
      _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$l(o, p);
    }
    function _createSuper$l(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$l(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$l(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$l(this, result2);
      };
    }
    function _possibleConstructorReturn$l(self, call) {
      if (call && (_typeof$m(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$l(self);
    }
    function _assertThisInitialized$l(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$l() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$l(o) {
      _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$l(o);
    }
    function _defineProperty$l(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
      _inherits$l(LocalWeekParser2, _Parser);
      var _super = _createSuper$l(LocalWeekParser2);
      function LocalWeekParser2() {
        var _this;
        _classCallCheck$l(this, LocalWeekParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$l(_assertThisInitialized$l(_this), "priority", 100);
        _defineProperty$l(_assertThisInitialized$l(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
        return _this;
      }
      _createClass$l(LocalWeekParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "w":
              return parseNumericPattern(numericPatterns.week, dateString);
            case "wo":
              return match2.ordinalNumber(dateString, {
                unit: "week"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 53;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value, options) {
          return startOfUTCWeek(setUTCWeek(date, value, options), options);
        }
      }]);
      return LocalWeekParser2;
    }(Parser);
    function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
      requiredArgs(2, arguments);
      var date = toDate(dirtyDate);
      var isoWeek = toInteger(dirtyISOWeek);
      var diff = getUTCISOWeek(date) - isoWeek;
      date.setUTCDate(date.getUTCDate() - diff * 7);
      return date;
    }
    function _typeof$l(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$l = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$l = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$l(obj);
    }
    function _classCallCheck$k(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$k(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$k(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$k(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$k(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$k(subClass, superClass);
    }
    function _setPrototypeOf$k(o, p) {
      _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$k(o, p);
    }
    function _createSuper$k(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$k(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$k(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$k(this, result2);
      };
    }
    function _possibleConstructorReturn$k(self, call) {
      if (call && (_typeof$l(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$k(self);
    }
    function _assertThisInitialized$k(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$k() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$k(o) {
      _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$k(o);
    }
    function _defineProperty$k(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
      _inherits$k(ISOWeekParser2, _Parser);
      var _super = _createSuper$k(ISOWeekParser2);
      function ISOWeekParser2() {
        var _this;
        _classCallCheck$k(this, ISOWeekParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$k(_assertThisInitialized$k(_this), "priority", 100);
        _defineProperty$k(_assertThisInitialized$k(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass$k(ISOWeekParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "I":
              return parseNumericPattern(numericPatterns.week, dateString);
            case "Io":
              return match2.ordinalNumber(dateString, {
                unit: "week"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 53;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          return startOfUTCISOWeek(setUTCISOWeek(date, value));
        }
      }]);
      return ISOWeekParser2;
    }(Parser);
    function _typeof$k(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$k = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$k = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$k(obj);
    }
    function _classCallCheck$j(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$j(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$j(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$j(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$j(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$j(subClass, superClass);
    }
    function _setPrototypeOf$j(o, p) {
      _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$j(o, p);
    }
    function _createSuper$j(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$j(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$j(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$j(this, result2);
      };
    }
    function _possibleConstructorReturn$j(self, call) {
      if (call && (_typeof$k(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$j(self);
    }
    function _assertThisInitialized$j(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$j() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$j(o) {
      _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$j(o);
    }
    function _defineProperty$j(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var DateParser = /* @__PURE__ */ function(_Parser) {
      _inherits$j(DateParser2, _Parser);
      var _super = _createSuper$j(DateParser2);
      function DateParser2() {
        var _this;
        _classCallCheck$j(this, DateParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$j(_assertThisInitialized$j(_this), "priority", 90);
        _defineProperty$j(_assertThisInitialized$j(_this), "subPriority", 1);
        _defineProperty$j(_assertThisInitialized$j(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass$j(DateParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "d":
              return parseNumericPattern(numericPatterns.date, dateString);
            case "do":
              return match2.ordinalNumber(dateString, {
                unit: "date"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(date, value) {
          var year = date.getUTCFullYear();
          var isLeapYear = isLeapYearIndex(year);
          var month = date.getUTCMonth();
          if (isLeapYear) {
            return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
          } else {
            return value >= 1 && value <= DAYS_IN_MONTH[month];
          }
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCDate(value);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return DateParser2;
    }(Parser);
    function _typeof$j(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$j = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$j = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$j(obj);
    }
    function _classCallCheck$i(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$i(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$i(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$i(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$i(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$i(subClass, superClass);
    }
    function _setPrototypeOf$i(o, p) {
      _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$i(o, p);
    }
    function _createSuper$i(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$i(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$i(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$i(this, result2);
      };
    }
    function _possibleConstructorReturn$i(self, call) {
      if (call && (_typeof$j(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$i(self);
    }
    function _assertThisInitialized$i(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$i() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$i(o) {
      _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$i(o);
    }
    function _defineProperty$i(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
      _inherits$i(DayOfYearParser2, _Parser);
      var _super = _createSuper$i(DayOfYearParser2);
      function DayOfYearParser2() {
        var _this;
        _classCallCheck$i(this, DayOfYearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$i(_assertThisInitialized$i(_this), "priority", 90);
        _defineProperty$i(_assertThisInitialized$i(_this), "subpriority", 1);
        _defineProperty$i(_assertThisInitialized$i(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass$i(DayOfYearParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "D":
            case "DD":
              return parseNumericPattern(numericPatterns.dayOfYear, dateString);
            case "Do":
              return match2.ordinalNumber(dateString, {
                unit: "date"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(date, value) {
          var year = date.getUTCFullYear();
          var isLeapYear = isLeapYearIndex(year);
          if (isLeapYear) {
            return value >= 1 && value <= 366;
          } else {
            return value >= 1 && value <= 365;
          }
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMonth(0, value);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return DayOfYearParser2;
    }(Parser);
    function setUTCDay(dirtyDate, dirtyDay, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      requiredArgs(2, arguments);
      var defaultOptions2 = getDefaultOptions();
      var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
      }
      var date = toDate(dirtyDate);
      var day = toInteger(dirtyDay);
      var currentDay = date.getUTCDay();
      var remainder = day % 7;
      var dayIndex = (remainder + 7) % 7;
      var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
      date.setUTCDate(date.getUTCDate() + diff);
      return date;
    }
    function _typeof$i(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$i = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$i = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$i(obj);
    }
    function _classCallCheck$h(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$h(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$h(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$h(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$h(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$h(subClass, superClass);
    }
    function _setPrototypeOf$h(o, p) {
      _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$h(o, p);
    }
    function _createSuper$h(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$h(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$h(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$h(this, result2);
      };
    }
    function _possibleConstructorReturn$h(self, call) {
      if (call && (_typeof$i(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$h(self);
    }
    function _assertThisInitialized$h(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$h() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$h(o) {
      _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$h(o);
    }
    function _defineProperty$h(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DayParser = /* @__PURE__ */ function(_Parser) {
      _inherits$h(DayParser2, _Parser);
      var _super = _createSuper$h(DayParser2);
      function DayParser2() {
        var _this;
        _classCallCheck$h(this, DayParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$h(_assertThisInitialized$h(_this), "priority", 90);
        _defineProperty$h(_assertThisInitialized$h(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass$h(DayParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "E":
            case "EE":
            case "EEE":
              return match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEEE":
              return match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEEEE":
              return match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEE":
            default:
              return match2.day(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 6;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value, options) {
          date = setUTCDay(date, value, options);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return DayParser2;
    }(Parser);
    function _typeof$h(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$h = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$h = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$h(obj);
    }
    function _classCallCheck$g(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$g(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$g(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$g(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$g(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$g(subClass, superClass);
    }
    function _setPrototypeOf$g(o, p) {
      _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$g(o, p);
    }
    function _createSuper$g(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$g(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$g(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$g(this, result2);
      };
    }
    function _possibleConstructorReturn$g(self, call) {
      if (call && (_typeof$h(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$g(self);
    }
    function _assertThisInitialized$g(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$g() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$g(o) {
      _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$g(o);
    }
    function _defineProperty$g(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var LocalDayParser = /* @__PURE__ */ function(_Parser) {
      _inherits$g(LocalDayParser2, _Parser);
      var _super = _createSuper$g(LocalDayParser2);
      function LocalDayParser2() {
        var _this;
        _classCallCheck$g(this, LocalDayParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$g(_assertThisInitialized$g(_this), "priority", 90);
        _defineProperty$g(_assertThisInitialized$g(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
        return _this;
      }
      _createClass$g(LocalDayParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2, options) {
          var valueCallback = function valueCallback2(value) {
            var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
            return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
          };
          switch (token) {
            case "e":
            case "ee":
              return mapValue(parseNDigits(token.length, dateString), valueCallback);
            case "eo":
              return mapValue(match2.ordinalNumber(dateString, {
                unit: "day"
              }), valueCallback);
            case "eee":
              return match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "eeeee":
              return match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "eeeeee":
              return match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "eeee":
            default:
              return match2.day(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 6;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value, options) {
          date = setUTCDay(date, value, options);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return LocalDayParser2;
    }(Parser);
    function _typeof$g(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$g = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$g = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$g(obj);
    }
    function _classCallCheck$f(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$f(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$f(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$f(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$f(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$f(subClass, superClass);
    }
    function _setPrototypeOf$f(o, p) {
      _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$f(o, p);
    }
    function _createSuper$f(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$f(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$f(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$f(this, result2);
      };
    }
    function _possibleConstructorReturn$f(self, call) {
      if (call && (_typeof$g(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$f(self);
    }
    function _assertThisInitialized$f(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$f() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$f(o) {
      _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$f(o);
    }
    function _defineProperty$f(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
      _inherits$f(StandAloneLocalDayParser2, _Parser);
      var _super = _createSuper$f(StandAloneLocalDayParser2);
      function StandAloneLocalDayParser2() {
        var _this;
        _classCallCheck$f(this, StandAloneLocalDayParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$f(_assertThisInitialized$f(_this), "priority", 90);
        _defineProperty$f(_assertThisInitialized$f(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
        return _this;
      }
      _createClass$f(StandAloneLocalDayParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2, options) {
          var valueCallback = function valueCallback2(value) {
            var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
            return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
          };
          switch (token) {
            case "c":
            case "cc":
              return mapValue(parseNDigits(token.length, dateString), valueCallback);
            case "co":
              return mapValue(match2.ordinalNumber(dateString, {
                unit: "day"
              }), valueCallback);
            case "ccc":
              return match2.day(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match2.day(dateString, {
                width: "short",
                context: "standalone"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "ccccc":
              return match2.day(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "cccccc":
              return match2.day(dateString, {
                width: "short",
                context: "standalone"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "cccc":
            default:
              return match2.day(dateString, {
                width: "wide",
                context: "standalone"
              }) || match2.day(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match2.day(dateString, {
                width: "short",
                context: "standalone"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "standalone"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 6;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value, options) {
          date = setUTCDay(date, value, options);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return StandAloneLocalDayParser2;
    }(Parser);
    function setUTCISODay(dirtyDate, dirtyDay) {
      requiredArgs(2, arguments);
      var day = toInteger(dirtyDay);
      if (day % 7 === 0) {
        day = day - 7;
      }
      var weekStartsOn = 1;
      var date = toDate(dirtyDate);
      var currentDay = date.getUTCDay();
      var remainder = day % 7;
      var dayIndex = (remainder + 7) % 7;
      var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
      date.setUTCDate(date.getUTCDate() + diff);
      return date;
    }
    function _typeof$f(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$f = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$f = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$f(obj);
    }
    function _classCallCheck$e(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$e(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$e(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$e(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$e(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$e(subClass, superClass);
    }
    function _setPrototypeOf$e(o, p) {
      _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$e(o, p);
    }
    function _createSuper$e(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$e(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$e(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$e(this, result2);
      };
    }
    function _possibleConstructorReturn$e(self, call) {
      if (call && (_typeof$f(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$e(self);
    }
    function _assertThisInitialized$e(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$e() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$e(o) {
      _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$e(o);
    }
    function _defineProperty$e(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ISODayParser = /* @__PURE__ */ function(_Parser) {
      _inherits$e(ISODayParser2, _Parser);
      var _super = _createSuper$e(ISODayParser2);
      function ISODayParser2() {
        var _this;
        _classCallCheck$e(this, ISODayParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$e(_assertThisInitialized$e(_this), "priority", 90);
        _defineProperty$e(_assertThisInitialized$e(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass$e(ISODayParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          var valueCallback = function valueCallback2(value) {
            if (value === 0) {
              return 7;
            }
            return value;
          };
          switch (token) {
            case "i":
            case "ii":
              return parseNDigits(token.length, dateString);
            case "io":
              return match2.ordinalNumber(dateString, {
                unit: "day"
              });
            case "iii":
              return mapValue(match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              }), valueCallback);
            case "iiiii":
              return mapValue(match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              }), valueCallback);
            case "iiiiii":
              return mapValue(match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              }), valueCallback);
            case "iiii":
            default:
              return mapValue(match2.day(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              }), valueCallback);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 7;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date = setUTCISODay(date, value);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return ISODayParser2;
    }(Parser);
    function _typeof$e(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$e = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$e = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$e(obj);
    }
    function _classCallCheck$d(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$d(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$d(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$d(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$d(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$d(subClass, superClass);
    }
    function _setPrototypeOf$d(o, p) {
      _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$d(o, p);
    }
    function _createSuper$d(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$d(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$d(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$d(this, result2);
      };
    }
    function _possibleConstructorReturn$d(self, call) {
      if (call && (_typeof$e(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$d(self);
    }
    function _assertThisInitialized$d(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$d() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$d(o) {
      _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$d(o);
    }
    function _defineProperty$d(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var AMPMParser = /* @__PURE__ */ function(_Parser) {
      _inherits$d(AMPMParser2, _Parser);
      var _super = _createSuper$d(AMPMParser2);
      function AMPMParser2() {
        var _this;
        _classCallCheck$d(this, AMPMParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$d(_assertThisInitialized$d(_this), "priority", 80);
        _defineProperty$d(_assertThisInitialized$d(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
        return _this;
      }
      _createClass$d(AMPMParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "a":
            case "aa":
            case "aaa":
              return match2.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "aaaaa":
              return match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "aaaa":
            default:
              return match2.dayPeriod(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
          return date;
        }
      }]);
      return AMPMParser2;
    }(Parser);
    function _typeof$d(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$d = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$d = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$d(obj);
    }
    function _classCallCheck$c(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$c(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$c(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$c(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$c(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$c(subClass, superClass);
    }
    function _setPrototypeOf$c(o, p) {
      _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$c(o, p);
    }
    function _createSuper$c(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$c(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$c(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$c(this, result2);
      };
    }
    function _possibleConstructorReturn$c(self, call) {
      if (call && (_typeof$d(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$c(self);
    }
    function _assertThisInitialized$c(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$c() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$c(o) {
      _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$c(o);
    }
    function _defineProperty$c(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
      _inherits$c(AMPMMidnightParser2, _Parser);
      var _super = _createSuper$c(AMPMMidnightParser2);
      function AMPMMidnightParser2() {
        var _this;
        _classCallCheck$c(this, AMPMMidnightParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$c(_assertThisInitialized$c(_this), "priority", 80);
        _defineProperty$c(_assertThisInitialized$c(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
        return _this;
      }
      _createClass$c(AMPMMidnightParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "b":
            case "bb":
            case "bbb":
              return match2.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "bbbbb":
              return match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "bbbb":
            default:
              return match2.dayPeriod(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
          return date;
        }
      }]);
      return AMPMMidnightParser2;
    }(Parser);
    function _typeof$c(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$c = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$c = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$c(obj);
    }
    function _classCallCheck$b(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$b(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$b(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$b(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$b(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$b(subClass, superClass);
    }
    function _setPrototypeOf$b(o, p) {
      _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$b(o, p);
    }
    function _createSuper$b(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$b(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$b(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$b(this, result2);
      };
    }
    function _possibleConstructorReturn$b(self, call) {
      if (call && (_typeof$c(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$b(self);
    }
    function _assertThisInitialized$b(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$b() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$b(o) {
      _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$b(o);
    }
    function _defineProperty$b(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
      _inherits$b(DayPeriodParser2, _Parser);
      var _super = _createSuper$b(DayPeriodParser2);
      function DayPeriodParser2() {
        var _this;
        _classCallCheck$b(this, DayPeriodParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$b(_assertThisInitialized$b(_this), "priority", 80);
        _defineProperty$b(_assertThisInitialized$b(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
        return _this;
      }
      _createClass$b(DayPeriodParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "B":
            case "BB":
            case "BBB":
              return match2.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "BBBBB":
              return match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "BBBB":
            default:
              return match2.dayPeriod(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
          return date;
        }
      }]);
      return DayPeriodParser2;
    }(Parser);
    function _typeof$b(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$b = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$b = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$b(obj);
    }
    function _classCallCheck$a(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$a(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$a(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$a(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$a(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$a(subClass, superClass);
    }
    function _setPrototypeOf$a(o, p) {
      _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$a(o, p);
    }
    function _createSuper$a(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$a(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$a(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$a(this, result2);
      };
    }
    function _possibleConstructorReturn$a(self, call) {
      if (call && (_typeof$b(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$a(self);
    }
    function _assertThisInitialized$a(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$a() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$a(o) {
      _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$a(o);
    }
    function _defineProperty$a(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
      _inherits$a(Hour1to12Parser2, _Parser);
      var _super = _createSuper$a(Hour1to12Parser2);
      function Hour1to12Parser2() {
        var _this;
        _classCallCheck$a(this, Hour1to12Parser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$a(_assertThisInitialized$a(_this), "priority", 70);
        _defineProperty$a(_assertThisInitialized$a(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
        return _this;
      }
      _createClass$a(Hour1to12Parser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "h":
              return parseNumericPattern(numericPatterns.hour12h, dateString);
            case "ho":
              return match2.ordinalNumber(dateString, {
                unit: "hour"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 12;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          var isPM = date.getUTCHours() >= 12;
          if (isPM && value < 12) {
            date.setUTCHours(value + 12, 0, 0, 0);
          } else if (!isPM && value === 12) {
            date.setUTCHours(0, 0, 0, 0);
          } else {
            date.setUTCHours(value, 0, 0, 0);
          }
          return date;
        }
      }]);
      return Hour1to12Parser2;
    }(Parser);
    function _typeof$a(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$a = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$a = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$a(obj);
    }
    function _classCallCheck$9(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$9(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$9(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$9(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$9(subClass, superClass);
    }
    function _setPrototypeOf$9(o, p) {
      _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$9(o, p);
    }
    function _createSuper$9(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$9(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$9(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$9(this, result2);
      };
    }
    function _possibleConstructorReturn$9(self, call) {
      if (call && (_typeof$a(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$9(self);
    }
    function _assertThisInitialized$9(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$9() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$9(o) {
      _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$9(o);
    }
    function _defineProperty$9(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
      _inherits$9(Hour0to23Parser2, _Parser);
      var _super = _createSuper$9(Hour0to23Parser2);
      function Hour0to23Parser2() {
        var _this;
        _classCallCheck$9(this, Hour0to23Parser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$9(_assertThisInitialized$9(_this), "priority", 70);
        _defineProperty$9(_assertThisInitialized$9(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
        return _this;
      }
      _createClass$9(Hour0to23Parser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "H":
              return parseNumericPattern(numericPatterns.hour23h, dateString);
            case "Ho":
              return match2.ordinalNumber(dateString, {
                unit: "hour"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 23;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCHours(value, 0, 0, 0);
          return date;
        }
      }]);
      return Hour0to23Parser2;
    }(Parser);
    function _typeof$9(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$9 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$9 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$9(obj);
    }
    function _classCallCheck$8(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$8(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$8(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$8(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$8(subClass, superClass);
    }
    function _setPrototypeOf$8(o, p) {
      _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$8(o, p);
    }
    function _createSuper$8(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$8(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$8(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$8(this, result2);
      };
    }
    function _possibleConstructorReturn$8(self, call) {
      if (call && (_typeof$9(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$8(self);
    }
    function _assertThisInitialized$8(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$8() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$8(o) {
      _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$8(o);
    }
    function _defineProperty$8(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
      _inherits$8(Hour0To11Parser2, _Parser);
      var _super = _createSuper$8(Hour0To11Parser2);
      function Hour0To11Parser2() {
        var _this;
        _classCallCheck$8(this, Hour0To11Parser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$8(_assertThisInitialized$8(_this), "priority", 70);
        _defineProperty$8(_assertThisInitialized$8(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
        return _this;
      }
      _createClass$8(Hour0To11Parser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "K":
              return parseNumericPattern(numericPatterns.hour11h, dateString);
            case "Ko":
              return match2.ordinalNumber(dateString, {
                unit: "hour"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 11;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          var isPM = date.getUTCHours() >= 12;
          if (isPM && value < 12) {
            date.setUTCHours(value + 12, 0, 0, 0);
          } else {
            date.setUTCHours(value, 0, 0, 0);
          }
          return date;
        }
      }]);
      return Hour0To11Parser2;
    }(Parser);
    function _typeof$8(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$8 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$8 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$8(obj);
    }
    function _classCallCheck$7(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$7(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$7(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$7(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$7(subClass, superClass);
    }
    function _setPrototypeOf$7(o, p) {
      _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$7(o, p);
    }
    function _createSuper$7(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$7(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$7(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$7(this, result2);
      };
    }
    function _possibleConstructorReturn$7(self, call) {
      if (call && (_typeof$8(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$7(self);
    }
    function _assertThisInitialized$7(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$7() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$7(o) {
      _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$7(o);
    }
    function _defineProperty$7(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
      _inherits$7(Hour1To24Parser2, _Parser);
      var _super = _createSuper$7(Hour1To24Parser2);
      function Hour1To24Parser2() {
        var _this;
        _classCallCheck$7(this, Hour1To24Parser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$7(_assertThisInitialized$7(_this), "priority", 70);
        _defineProperty$7(_assertThisInitialized$7(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
        return _this;
      }
      _createClass$7(Hour1To24Parser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "k":
              return parseNumericPattern(numericPatterns.hour24h, dateString);
            case "ko":
              return match2.ordinalNumber(dateString, {
                unit: "hour"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 24;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          var hours = value <= 24 ? value % 24 : value;
          date.setUTCHours(hours, 0, 0, 0);
          return date;
        }
      }]);
      return Hour1To24Parser2;
    }(Parser);
    function _typeof$7(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$7 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$7 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$7(obj);
    }
    function _classCallCheck$6(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$6(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$6(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$6(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$6(subClass, superClass);
    }
    function _setPrototypeOf$6(o, p) {
      _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$6(o, p);
    }
    function _createSuper$6(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$6(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$6(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$6(this, result2);
      };
    }
    function _possibleConstructorReturn$6(self, call) {
      if (call && (_typeof$7(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$6(self);
    }
    function _assertThisInitialized$6(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$6() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$6(o) {
      _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$6(o);
    }
    function _defineProperty$6(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var MinuteParser = /* @__PURE__ */ function(_Parser) {
      _inherits$6(MinuteParser2, _Parser);
      var _super = _createSuper$6(MinuteParser2);
      function MinuteParser2() {
        var _this;
        _classCallCheck$6(this, MinuteParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$6(_assertThisInitialized$6(_this), "priority", 60);
        _defineProperty$6(_assertThisInitialized$6(_this), "incompatibleTokens", ["t", "T"]);
        return _this;
      }
      _createClass$6(MinuteParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "m":
              return parseNumericPattern(numericPatterns.minute, dateString);
            case "mo":
              return match2.ordinalNumber(dateString, {
                unit: "minute"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 59;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMinutes(value, 0, 0);
          return date;
        }
      }]);
      return MinuteParser2;
    }(Parser);
    function _typeof$6(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$6 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$6 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$6(obj);
    }
    function _classCallCheck$5(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$5(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$5(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$5(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$5(subClass, superClass);
    }
    function _setPrototypeOf$5(o, p) {
      _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$5(o, p);
    }
    function _createSuper$5(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$5(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$5(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$5(this, result2);
      };
    }
    function _possibleConstructorReturn$5(self, call) {
      if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$5(self);
    }
    function _assertThisInitialized$5(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$5() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$5(o) {
      _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$5(o);
    }
    function _defineProperty$5(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var SecondParser = /* @__PURE__ */ function(_Parser) {
      _inherits$5(SecondParser2, _Parser);
      var _super = _createSuper$5(SecondParser2);
      function SecondParser2() {
        var _this;
        _classCallCheck$5(this, SecondParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$5(_assertThisInitialized$5(_this), "priority", 50);
        _defineProperty$5(_assertThisInitialized$5(_this), "incompatibleTokens", ["t", "T"]);
        return _this;
      }
      _createClass$5(SecondParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "s":
              return parseNumericPattern(numericPatterns.second, dateString);
            case "so":
              return match2.ordinalNumber(dateString, {
                unit: "second"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 59;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCSeconds(value, 0);
          return date;
        }
      }]);
      return SecondParser2;
    }(Parser);
    function _typeof$5(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$5 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$5 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$5(obj);
    }
    function _classCallCheck$4(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$4(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$4(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$4(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$4(subClass, superClass);
    }
    function _setPrototypeOf$4(o, p) {
      _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$4(o, p);
    }
    function _createSuper$4(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$4(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$4(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$4(this, result2);
      };
    }
    function _possibleConstructorReturn$4(self, call) {
      if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$4(self);
    }
    function _assertThisInitialized$4(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$4() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$4(o) {
      _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$4(o);
    }
    function _defineProperty$4(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
      _inherits$4(FractionOfSecondParser2, _Parser);
      var _super = _createSuper$4(FractionOfSecondParser2);
      function FractionOfSecondParser2() {
        var _this;
        _classCallCheck$4(this, FractionOfSecondParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$4(_assertThisInitialized$4(_this), "priority", 30);
        _defineProperty$4(_assertThisInitialized$4(_this), "incompatibleTokens", ["t", "T"]);
        return _this;
      }
      _createClass$4(FractionOfSecondParser2, [{
        key: "parse",
        value: function parse2(dateString, token) {
          var valueCallback = function valueCallback2(value) {
            return Math.floor(value * Math.pow(10, -token.length + 3));
          };
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMilliseconds(value);
          return date;
        }
      }]);
      return FractionOfSecondParser2;
    }(Parser);
    function _typeof$4(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$4 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$4 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$4(obj);
    }
    function _classCallCheck$3(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$3(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$3(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$3(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$3(subClass, superClass);
    }
    function _setPrototypeOf$3(o, p) {
      _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$3(o, p);
    }
    function _createSuper$3(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$3(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$3(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$3(this, result2);
      };
    }
    function _possibleConstructorReturn$3(self, call) {
      if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$3(self);
    }
    function _assertThisInitialized$3(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$3() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$3(o) {
      _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$3(o);
    }
    function _defineProperty$3(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
      _inherits$3(ISOTimezoneWithZParser2, _Parser);
      var _super = _createSuper$3(ISOTimezoneWithZParser2);
      function ISOTimezoneWithZParser2() {
        var _this;
        _classCallCheck$3(this, ISOTimezoneWithZParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$3(_assertThisInitialized$3(_this), "priority", 10);
        _defineProperty$3(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T", "x"]);
        return _this;
      }
      _createClass$3(ISOTimezoneWithZParser2, [{
        key: "parse",
        value: function parse2(dateString, token) {
          switch (token) {
            case "X":
              return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
            case "XX":
              return parseTimezonePattern(timezonePatterns.basic, dateString);
            case "XXXX":
              return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
            case "XXXXX":
              return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
            case "XXX":
            default:
              return parseTimezonePattern(timezonePatterns.extended, dateString);
          }
        }
      }, {
        key: "set",
        value: function set2(date, flags, value) {
          if (flags.timestampIsSet) {
            return date;
          }
          return new Date(date.getTime() - value);
        }
      }]);
      return ISOTimezoneWithZParser2;
    }(Parser);
    function _typeof$3(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$3 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$3 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$3(obj);
    }
    function _classCallCheck$2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$2(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$2(subClass, superClass);
    }
    function _setPrototypeOf$2(o, p) {
      _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$2(o, p);
    }
    function _createSuper$2(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$2(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$2(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$2(this, result2);
      };
    }
    function _possibleConstructorReturn$2(self, call) {
      if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$2(self);
    }
    function _assertThisInitialized$2(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$2() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$2(o) {
      _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$2(o);
    }
    function _defineProperty$2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
      _inherits$2(ISOTimezoneParser2, _Parser);
      var _super = _createSuper$2(ISOTimezoneParser2);
      function ISOTimezoneParser2() {
        var _this;
        _classCallCheck$2(this, ISOTimezoneParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$2(_assertThisInitialized$2(_this), "priority", 10);
        _defineProperty$2(_assertThisInitialized$2(_this), "incompatibleTokens", ["t", "T", "X"]);
        return _this;
      }
      _createClass$2(ISOTimezoneParser2, [{
        key: "parse",
        value: function parse2(dateString, token) {
          switch (token) {
            case "x":
              return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
            case "xx":
              return parseTimezonePattern(timezonePatterns.basic, dateString);
            case "xxxx":
              return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
            case "xxxxx":
              return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
            case "xxx":
            default:
              return parseTimezonePattern(timezonePatterns.extended, dateString);
          }
        }
      }, {
        key: "set",
        value: function set2(date, flags, value) {
          if (flags.timestampIsSet) {
            return date;
          }
          return new Date(date.getTime() - value);
        }
      }]);
      return ISOTimezoneParser2;
    }(Parser);
    function _typeof$2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$2 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$2 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$2(obj);
    }
    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$1(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$1(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits$1(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf$1(subClass, superClass);
    }
    function _setPrototypeOf$1(o, p) {
      _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf$1(o, p);
    }
    function _createSuper$1(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$1(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$1(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$1(this, result2);
      };
    }
    function _possibleConstructorReturn$1(self, call) {
      if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized$1(self);
    }
    function _assertThisInitialized$1(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf$1(o) {
      _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$1(o);
    }
    function _defineProperty$1(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
      _inherits$1(TimestampSecondsParser2, _Parser);
      var _super = _createSuper$1(TimestampSecondsParser2);
      function TimestampSecondsParser2() {
        var _this;
        _classCallCheck$1(this, TimestampSecondsParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$1(_assertThisInitialized$1(_this), "priority", 40);
        _defineProperty$1(_assertThisInitialized$1(_this), "incompatibleTokens", "*");
        return _this;
      }
      _createClass$1(TimestampSecondsParser2, [{
        key: "parse",
        value: function parse2(dateString) {
          return parseAnyDigitsSigned(dateString);
        }
      }, {
        key: "set",
        value: function set2(_date, _flags, value) {
          return [new Date(value * 1e3), {
            timestampIsSet: true
          }];
        }
      }]);
      return TimestampSecondsParser2;
    }(Parser);
    function _typeof$1(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$1 = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$1 = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$1(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result2 = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result2);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
      _inherits(TimestampMillisecondsParser2, _Parser);
      var _super = _createSuper(TimestampMillisecondsParser2);
      function TimestampMillisecondsParser2() {
        var _this;
        _classCallCheck(this, TimestampMillisecondsParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 20);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
        return _this;
      }
      _createClass(TimestampMillisecondsParser2, [{
        key: "parse",
        value: function parse2(dateString) {
          return parseAnyDigitsSigned(dateString);
        }
      }, {
        key: "set",
        value: function set2(_date, _flags, value) {
          return [new Date(value), {
            timestampIsSet: true
          }];
        }
      }]);
      return TimestampMillisecondsParser2;
    }(Parser);
    var parsers = {
      G: new EraParser(),
      y: new YearParser(),
      Y: new LocalWeekYearParser(),
      R: new ISOWeekYearParser(),
      u: new ExtendedYearParser(),
      Q: new QuarterParser(),
      q: new StandAloneQuarterParser(),
      M: new MonthParser(),
      L: new StandAloneMonthParser(),
      w: new LocalWeekParser(),
      I: new ISOWeekParser(),
      d: new DateParser(),
      D: new DayOfYearParser(),
      E: new DayParser(),
      e: new LocalDayParser(),
      c: new StandAloneLocalDayParser(),
      i: new ISODayParser(),
      a: new AMPMParser(),
      b: new AMPMMidnightParser(),
      B: new DayPeriodParser(),
      h: new Hour1to12Parser(),
      H: new Hour0to23Parser(),
      K: new Hour0To11Parser(),
      k: new Hour1To24Parser(),
      m: new MinuteParser(),
      s: new SecondParser(),
      S: new FractionOfSecondParser(),
      X: new ISOTimezoneWithZParser(),
      x: new ISOTimezoneParser(),
      t: new TimestampSecondsParser(),
      T: new TimestampMillisecondsParser()
    };
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e2(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var notWhitespaceRegExp = /\S/;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
      var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _defaultOptions$local3, _defaultOptions$local4;
      requiredArgs(3, arguments);
      var dateString = String(dirtyDateString);
      var formatString = String(dirtyFormatString);
      var defaultOptions2 = getDefaultOptions();
      var locale$1 = (_ref = (_options$locale = void 0) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : locale;
      if (!locale$1.match) {
        throw new RangeError("locale must contain match property");
      }
      var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = void 0) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : void 0) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
      }
      var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = void 0) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : void 0) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
      }
      if (formatString === "") {
        if (dateString === "") {
          return toDate(dirtyReferenceDate);
        } else {
          return /* @__PURE__ */ new Date(NaN);
        }
      }
      var subFnOptions = {
        firstWeekContainsDate,
        weekStartsOn,
        locale: locale$1
      };
      var setters = [new DateToSystemTimezoneSetter()];
      var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
        var firstCharacter = substring[0];
        if (firstCharacter in longFormatters) {
          var longFormatter = longFormatters[firstCharacter];
          return longFormatter(substring, locale$1.formatLong);
        }
        return substring;
      }).join("").match(formattingTokensRegExp);
      var usedTokens = [];
      var _iterator = _createForOfIteratorHelper(tokens), _step;
      try {
        var _loop = function _loop2() {
          var token = _step.value;
          if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
            throwProtectedError(token, formatString, dirtyDateString);
          }
          if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
            throwProtectedError(token, formatString, dirtyDateString);
          }
          var firstCharacter = token[0];
          var parser = parsers[firstCharacter];
          if (parser) {
            var incompatibleTokens = parser.incompatibleTokens;
            if (Array.isArray(incompatibleTokens)) {
              var incompatibleToken = usedTokens.find(function(usedToken) {
                return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
              });
              if (incompatibleToken) {
                throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
              }
            } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
              throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
            }
            usedTokens.push({
              token: firstCharacter,
              fullToken: token
            });
            var parseResult = parser.run(dateString, token, locale$1.match, subFnOptions);
            if (!parseResult) {
              return {
                v: /* @__PURE__ */ new Date(NaN)
              };
            }
            setters.push(parseResult.setter);
            dateString = parseResult.rest;
          } else {
            if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
              throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
            }
            if (token === "''") {
              token = "'";
            } else if (firstCharacter === "'") {
              token = cleanEscapedString(token);
            }
            if (dateString.indexOf(token) === 0) {
              dateString = dateString.slice(token.length);
            } else {
              return {
                v: /* @__PURE__ */ new Date(NaN)
              };
            }
          }
        };
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _ret = _loop();
          if (_typeof(_ret) === "object") return _ret.v;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      var uniquePrioritySetters = setters.map(function(setter2) {
        return setter2.priority;
      }).sort(function(a, b) {
        return b - a;
      }).filter(function(priority, index, array) {
        return array.indexOf(priority) === index;
      }).map(function(priority) {
        return setters.filter(function(setter2) {
          return setter2.priority === priority;
        }).sort(function(a, b) {
          return b.subPriority - a.subPriority;
        });
      }).map(function(setterArray) {
        return setterArray[0];
      });
      var date = toDate(dirtyReferenceDate);
      if (isNaN(date.getTime())) {
        return /* @__PURE__ */ new Date(NaN);
      }
      var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
      var flags = {};
      var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var setter = _step2.value;
          if (!setter.validate(utcDate, subFnOptions)) {
            return /* @__PURE__ */ new Date(NaN);
          }
          var result2 = setter.set(utcDate, flags, subFnOptions);
          if (Array.isArray(result2)) {
            utcDate = result2[0];
            assign(flags, result2[1]);
          } else {
            utcDate = result2;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return utcDate;
    }
    function cleanEscapedString(input) {
      return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
    }
    (function() {
      const tryCatchWrapper = function(callback) {
        return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Date Picker");
      };
      window.Vaadin.Flow.datepickerConnector = {
        initLazy: (datepicker) => tryCatchWrapper(function(datepicker2) {
          if (datepicker2.$connector) {
            return;
          }
          datepicker2.$connector = {};
          const createLocaleBasedDateFormat = function(locale2) {
            try {
              (/* @__PURE__ */ new Date()).toLocaleDateString(locale2);
            } catch (e2) {
              console.warn("The locale is not supported, using default format setting (ISO 8601).");
              return "yyyy-MM-dd";
            }
            const testDate = new Date(Date.UTC(1234, 4, 6));
            let pattern = testDate.toLocaleDateString(locale2, { timeZone: "UTC" });
            pattern = pattern.replace(/([a-zA-Z]+)/g, "'$1'").replace("06", "dd").replace("6", "d").replace("05", "MM").replace("5", "M").replace("1234", "yyyy");
            const isValidPattern = pattern.includes("d") && pattern.includes("M") && pattern.includes("y");
            if (!isValidPattern) {
              console.warn("The locale is not supported, using default format setting (ISO 8601).");
              return "yyyy-MM-dd";
            }
            return pattern;
          };
          const createFormatterAndParser = tryCatchWrapper(function(formats) {
            if (!formats || formats.length === 0) {
              throw new Error("Array of custom date formats is null or empty");
            }
            function getShortYearFormat(format2) {
              if (format2.includes("yyyy") && !format2.includes("yyyyy")) {
                return format2.replace("yyyy", "yy");
              }
              if (format2.includes("YYYY") && !format2.includes("YYYYY")) {
                return format2.replace("YYYY", "YY");
              }
              return void 0;
            }
            function isFormatWithYear(format2) {
              return format2.includes("y") || format2.includes("Y");
            }
            function isShortYearFormat(format2) {
              return !format2.includes("yyyy") && !format2.includes("YYYY");
            }
            function getExtendedFormats(formats2) {
              return formats2.reduce((acc, format2) => {
                if (isFormatWithYear(format2) && !isShortYearFormat(format2)) {
                  acc.push(getShortYearFormat(format2));
                }
                acc.push(format2);
                return acc;
              }, []);
            }
            function correctFullYear(date) {
              if (datepicker2.$connector._lastParseStatus === "error") {
                return;
              }
              if (datepicker2.$connector._lastParseStatus === "successful") {
                if (datepicker2.$connector._lastParsedDate.day === date.getDate() && datepicker2.$connector._lastParsedDate.month === date.getMonth() && datepicker2.$connector._lastParsedDate.year % 100 === date.getFullYear() % 100) {
                  date.setFullYear(datepicker2.$connector._lastParsedDate.year);
                }
                return;
              }
              const currentValue = parseDate(datepicker2.value);
              if (isValid(currentValue) && currentValue.getDate() === date.getDate() && currentValue.getMonth() === date.getMonth() && currentValue.getFullYear() % 100 === date.getFullYear() % 100) {
                date.setFullYear(currentValue.getFullYear());
              }
            }
            function formatDate(dateParts) {
              const format$12 = formats[0];
              const date = parseDate(`${dateParts.year}-${dateParts.month + 1}-${dateParts.day}`);
              return format(date, format$12);
            }
            function doParseDate(dateString, format2, referenceDate) {
              const refDate = isFormatWithYear(format2) ? referenceDate : /* @__PURE__ */ new Date();
              const date = parse(dateString, format2, refDate);
              if (isValid(date)) {
                if (isFormatWithYear(format2) && isShortYearFormat(format2)) {
                  correctFullYear(date);
                }
                return {
                  day: date.getDate(),
                  month: date.getMonth(),
                  year: date.getFullYear()
                };
              }
            }
            function parseDate$1(dateString) {
              const referenceDate = _getReferenceDate();
              for (let format2 of getExtendedFormats(formats)) {
                const parsedDate = doParseDate(dateString, format2, referenceDate);
                if (parsedDate) {
                  datepicker2.$connector._lastParseStatus = "successful";
                  datepicker2.$connector._lastParsedDate = parsedDate;
                  return parsedDate;
                }
              }
              datepicker2.$connector._lastParseStatus = "error";
              return false;
            }
            return {
              formatDate,
              parseDate: parseDate$1
            };
          });
          function _getReferenceDate() {
            const { referenceDate } = datepicker2.i18n;
            return referenceDate ? new Date(referenceDate.year, referenceDate.month, referenceDate.day) : /* @__PURE__ */ new Date();
          }
          datepicker2.$connector.updateI18n = tryCatchWrapper(function(locale2, i18n) {
            const hasCustomFormats = i18n && i18n.dateFormats && i18n.dateFormats.length > 0;
            if (i18n && i18n.referenceDate) {
              i18n.referenceDate = extractDateParts(new Date(i18n.referenceDate));
            }
            const usedFormats = hasCustomFormats ? i18n.dateFormats : [createLocaleBasedDateFormat(locale2)];
            const formatterAndParser = createFormatterAndParser(usedFormats);
            datepicker2.i18n = Object.assign({}, datepicker2.i18n, i18n, formatterAndParser);
          });
          datepicker2.addEventListener("opened-changed", () => datepicker2.$connector._lastParseStatus = void 0);
        })(datepicker)
      };
    })();
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-time-picker-item", [item, comboBoxItem], {
      moduleId: "lumo-time-picker-item"
    });
    registerStyles$1(
      "vaadin-time-picker-overlay",
      [
        overlay,
        menuOverlayCore,
        comboBoxOverlay,
        css$e`
      :host {
        --_vaadin-time-picker-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-time-picker-items-container-border-style: solid;
      }
    `
      ],
      {
        moduleId: "lumo-time-picker-overlay"
      }
    );
    const timePicker = css$e`
  [part~='toggle-button']::before {
    content: var(--lumo-icons-clock);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }
`;
    registerStyles$1("vaadin-time-picker", [inputFieldShared, timePicker], { moduleId: "lumo-time-picker" });
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class TimePickerItem extends ComboBoxItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
      static get is() {
        return "vaadin-time-picker-item";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
      }
    }
    defineCustomElement(TimePickerItem);
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const timePickerOverlayStyles = css$e`
  #overlay {
    width: var(--vaadin-time-picker-overlay-width, var(--_vaadin-time-picker-overlay-default-width, auto));
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;
    registerStyles$1("vaadin-time-picker-overlay", [overlayStyles, timePickerOverlayStyles], {
      moduleId: "vaadin-time-picker-overlay-styles"
    });
    class TimePickerOverlay extends ComboBoxOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
      static get is() {
        return "vaadin-time-picker-overlay";
      }
      static get template() {
        return html`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
      }
    }
    defineCustomElement(TimePickerOverlay);
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class TimePickerScroller extends ComboBoxScrollerMixin(PolymerElement) {
      static get is() {
        return "vaadin-time-picker-scroller";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-time-picker-items-container-border-width);
          border-style: var(--_vaadin-time-picker-items-container-border-style);
          border-color: var(--_vaadin-time-picker-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
      }
    }
    defineCustomElement(TimePickerScroller);
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class TimePickerComboBox extends ComboBoxMixin(ThemableMixin(PolymerElement)) {
      static get is() {
        return "vaadin-time-picker-combo-box";
      }
      static get template() {
        return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <slot></slot>

      <vaadin-time-picker-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[positionTarget]]"
        no-vertical-overlap
        restore-focus-node="[[inputElement]]"
      ></vaadin-time-picker-overlay>
    `;
      }
      static get properties() {
        return {
          positionTarget: {
            type: Object
          }
        };
      }
      /**
       * Tag name prefix used by scroller and items.
       * @protected
       * @return {string}
       */
      get _tagNamePrefix() {
        return "vaadin-time-picker";
      }
      /**
       * Reference to the clear button element.
       * @protected
       * @return {!HTMLElement}
       */
      get clearElement() {
        return this.querySelector('[part="clear-button"]');
      }
      /**
       * @override
       * @protected
       */
      get _inputElementValue() {
        return super._inputElementValue;
      }
      /**
       * The setter is overridden to ensure the `_hasInputValue` property
       * doesn't wrongly indicate true after the input element's value
       * is reverted or cleared programmatically.
       *
       * @override
       * @protected
       */
      set _inputElementValue(value) {
        super._inputElementValue = value;
        this._hasInputValue = value.length > 0;
      }
      /** @protected */
      ready() {
        super.ready();
        this.allowCustomValue = true;
        this._toggleElement = this.querySelector(".toggle-button");
        this.setAttribute("dir", "ltr");
      }
    }
    defineCustomElement(TimePickerComboBox);
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const MIN_ALLOWED_TIME = "00:00:00.000";
    const MAX_ALLOWED_TIME = "23:59:59.999";
    registerStyles$1("vaadin-time-picker", inputFieldShared$1, { moduleId: "vaadin-time-picker-styles" });
    class TimePicker extends PatternMixin(InputControlMixin(ThemableMixin(ElementMixin(PolymerElement)))) {
      static get is() {
        return "vaadin-time-picker";
      }
      static get template() {
        return html`
      <style>
        /* See https://github.com/vaadin/vaadin-time-picker/issues/145 */
        :host([dir='rtl']) [part='input-field'] {
          direction: ltr;
        }

        :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
          direction: rtl;
          text-align: left;
        }

        [part~='toggle-button'] {
          cursor: pointer;
        }
      </style>

      <div class="vaadin-time-picker-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-time-picker-combo-box
          id="comboBox"
          filtered-items="[[__dropdownItems]]"
          value="{{_comboBoxValue}}"
          opened="{{opened}}"
          disabled="[[disabled]]"
          readonly="[[readonly]]"
          clear-button-visible="[[clearButtonVisible]]"
          auto-open-disabled="[[autoOpenDisabled]]"
          overlay-class="[[overlayClass]]"
          position-target="[[_inputContainer]]"
          theme$="[[_theme]]"
          on-change="__onComboBoxChange"
          on-has-input-value-changed="__onComboBoxHasInputValueChanged"
        >
          <vaadin-input-container
            part="input-field"
            readonly="[[readonly]]"
            disabled="[[disabled]]"
            invalid="[[invalid]]"
            theme$="[[_theme]]"
          >
            <slot name="prefix" slot="prefix"></slot>
            <slot name="input"></slot>
            <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
            <div id="toggleButton" class="toggle-button" part="toggle-button" slot="suffix" aria-hidden="true"></div>
          </vaadin-input-container>
        </vaadin-time-picker-combo-box>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
      <slot name="tooltip"></slot>
    `;
      }
      static get properties() {
        return {
          /**
           * The time value for this element.
           *
           * Supported time formats are in ISO 8601:
           * - `hh:mm` (default)
           * - `hh:mm:ss`
           * - `hh:mm:ss.fff`
           * @type {string}
           */
          value: {
            type: String,
            notify: true,
            value: ""
          },
          /**
           * True if the dropdown is open, false otherwise.
           */
          opened: {
            type: Boolean,
            notify: true,
            value: false,
            reflectToAttribute: true
          },
          /**
           * Minimum time allowed.
           *
           * Supported time formats are in ISO 8601:
           * - `hh:mm`
           * - `hh:mm:ss`
           * - `hh:mm:ss.fff`
           * @type {string}
           */
          min: {
            type: String,
            value: ""
          },
          /**
           * Maximum time allowed.
           *
           * Supported time formats are in ISO 8601:
           * - `hh:mm`
           * - `hh:mm:ss`
           * - `hh:mm:ss.fff`
           * @type {string}
           */
          max: {
            type: String,
            value: ""
          },
          /**
           * Defines the time interval (in seconds) between the items displayed
           * in the time selection box. The default is 1 hour (i.e. `3600`).
           *
           * It also configures the precision of the value string. By default
           * the component formats values as `hh:mm` but setting a step value
           * lower than one minute or one second, format resolution changes to
           * `hh:mm:ss` and `hh:mm:ss.fff` respectively.
           *
           * Unit must be set in seconds, and for correctly configuring intervals
           * in the dropdown, it need to evenly divide a day.
           *
           * Note: it is possible to define step that is dividing an hour in inexact
           * fragments (i.e. 5760 seconds which equals 1 hour 36 minutes), but it is
           * not recommended to use it for better UX experience.
           */
          step: {
            type: Number
          },
          /**
           * Set true to prevent the overlay from opening automatically.
           * @attr {boolean} auto-open-disabled
           */
          autoOpenDisabled: Boolean,
          /**
           * A space-delimited list of CSS class names to set on the overlay element.
           *
           * @attr {string} overlay-class
           */
          overlayClass: {
            type: String
          },
          /** @private */
          __dropdownItems: {
            type: Array
          },
          /**
           * The object used to localize this component.
           * To change the default localization, replace the entire
           * _i18n_ object or just the property you want to modify.
           *
           * The object has the following JSON structure:
           *
           * ```
           * {
           *   // A function to format given `Object` as
           *   // time string. Object is in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
           *   formatTime: (time) => {
           *     // returns a string representation of the given
           *     // object in `hh` / 'hh:mm' / 'hh:mm:ss' / 'hh:mm:ss.fff' - formats
           *   },
           *
           *   // A function to parse the given text to an `Object` in the format
           *   // `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`.
           *   // Must properly parse (at least) text
           *   // formatted by `formatTime`.
           *   parseTime: text => {
           *     // Parses a string in object/string that can be formatted by`formatTime`.
           *   }
           * }
           * ```
           *
           * Both `formatTime` and `parseTime` need to be implemented
           * to ensure the component works properly.
           *
           * @type {!TimePickerI18n}
           */
          i18n: {
            type: Object,
            value: () => {
              return {
                formatTime: (time) => {
                  if (!time) {
                    return;
                  }
                  const pad2 = (num = 0, fmt = "00") => (fmt + num).substr((fmt + num).length - fmt.length);
                  let timeString = `${pad2(time.hours)}:${pad2(time.minutes)}`;
                  if (time.seconds !== void 0) {
                    timeString += `:${pad2(time.seconds)}`;
                  }
                  if (time.milliseconds !== void 0) {
                    timeString += `.${pad2(time.milliseconds, "000")}`;
                  }
                  return timeString;
                },
                parseTime: (text) => {
                  const MATCH_HOURS = "(\\d|[0-1]\\d|2[0-3])";
                  const MATCH_MINUTES = "(\\d|[0-5]\\d)";
                  const MATCH_SECONDS = MATCH_MINUTES;
                  const MATCH_MILLISECONDS = "(\\d{1,3})";
                  const re = new RegExp(
                    `^${MATCH_HOURS}(?::${MATCH_MINUTES}(?::${MATCH_SECONDS}(?:\\.${MATCH_MILLISECONDS})?)?)?$`,
                    "u"
                  );
                  const parts = re.exec(text);
                  if (parts) {
                    if (parts[4]) {
                      while (parts[4].length < 3) {
                        parts[4] += "0";
                      }
                    }
                    return { hours: parts[1], minutes: parts[2], seconds: parts[3], milliseconds: parts[4] };
                  }
                }
              };
            }
          },
          /** @private */
          _comboBoxValue: {
            type: String,
            observer: "__comboBoxValueChanged"
          },
          /** @private */
          _inputContainer: Object
        };
      }
      static get observers() {
        return ["__updateDropdownItems(i18n.*, min, max, step)"];
      }
      static get constraints() {
        return [...super.constraints, "min", "max"];
      }
      /**
       * Used by `InputControlMixin` as a reference to the clear button element.
       * @protected
       * @return {!HTMLElement}
       */
      get clearElement() {
        return this.$.clearButton;
      }
      /**
       * The input element's value when it cannot be parsed as a time, and an empty string otherwise.
       *
       * @private
       * @return {string}
       */
      get __unparsableValue() {
        if (this._inputElementValue && !this.i18n.parseTime(this._inputElementValue)) {
          return this._inputElementValue;
        }
        return "";
      }
      /** @protected */
      ready() {
        super.ready();
        this.addController(
          new InputController(this, (input) => {
            this._setInputElement(input);
            this._setFocusElement(input);
            this.stateTarget = input;
            this.ariaTarget = input;
          })
        );
        this.addController(new LabelledInputController(this.inputElement, this._labelController));
        this._inputContainer = this.shadowRoot.querySelector('[part~="input-field"]');
        this._tooltipController = new TooltipController(this);
        this._tooltipController.setShouldShow((timePicker2) => !timePicker2.opened);
        this._tooltipController.setPosition("top");
        this._tooltipController.setAriaTarget(this.inputElement);
        this.addController(this._tooltipController);
      }
      /**
       * Override method inherited from `InputMixin` to forward the input to combo-box.
       * @protected
       * @override
       */
      _inputElementChanged(input) {
        super._inputElementChanged(input);
        if (input) {
          this.$.comboBox._setInputElement(input);
        }
      }
      /**
       * Opens the dropdown list.
       */
      open() {
        if (!this.disabled && !this.readonly) {
          this.opened = true;
        }
      }
      /**
       * Closes the dropdown list.
       */
      close() {
        this.opened = false;
      }
      /**
       * Returns true if the current input value satisfies all constraints (if any).
       * You can override this method for custom validations.
       *
       * @return {boolean} True if the value is valid
       */
      checkValidity() {
        return !!(this.inputElement.checkValidity() && (!this.value || this._timeAllowed(this.i18n.parseTime(this.value))) && (!this._comboBoxValue || this.i18n.parseTime(this._comboBoxValue)));
      }
      /**
       * @param {boolean} focused
       * @override
       * @protected
       */
      _setFocused(focused) {
        super._setFocused(focused);
        if (!focused) {
          this.__commitValueChange();
          if (document.hasFocus()) {
            this.validate();
          }
        }
      }
      /** @private */
      __validDayDivisor(step) {
        return !step || 24 * 3600 % step === 0 || step < 1 && step % 1 * 1e3 % 1 === 0;
      }
      /**
       * Override an event listener from `KeyboardMixin`.
       * @param {!KeyboardEvent} e
       * @protected
       */
      _onKeyDown(e2) {
        super._onKeyDown(e2);
        if (this.readonly || this.disabled || this.__dropdownItems.length) {
          return;
        }
        const stepResolution = this.__validDayDivisor(this.step) && this.step || 60;
        if (e2.keyCode === 40) {
          this.__onArrowPressWithStep(-stepResolution);
        } else if (e2.keyCode === 38) {
          this.__onArrowPressWithStep(stepResolution);
        }
      }
      /**
       * Override an event listener from `KeyboardMixin`.
       * Do not call `super` in order to override clear
       * button logic defined in `InputControlMixin`.
       * @param {Event} event
       * @protected
       */
      _onEscape() {
      }
      /** @private */
      __onArrowPressWithStep(step) {
        const objWithStep = this.__addStep(this.__getMsec(this.__memoValue), step, true);
        this.__memoValue = objWithStep;
        this.__useMemo = true;
        this._comboBoxValue = this.i18n.formatTime(objWithStep);
        this.__useMemo = false;
        this.__commitValueChange();
      }
      /**
       * Depending on the nature of the value change that has occurred since
       * the last commit attempt, triggers validation and fires an event:
       *
       * Value change             | Event
       * -------------------------|-------------------
       * empty => parsable        | change
       * empty => unparsable      | unparsable-change
       * parsable => empty        | change
       * parsable => parsable     | change
       * parsable => unparsable   | change
       * unparsable => empty      | unparsable-change
       * unparsable => parsable   | change
       * unparsable => unparsable | unparsable-change
       *
       * @private
       */
      __commitValueChange() {
        const unparsableValue = this.__unparsableValue;
        if (this.__committedValue !== this.value) {
          this.validate();
          this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
        } else if (this.__committedUnparsableValue !== unparsableValue) {
          this.validate();
          this.dispatchEvent(new CustomEvent("unparsable-change"));
        }
        this.__committedValue = this.value;
        this.__committedUnparsableValue = unparsableValue;
      }
      /**
       * Returning milliseconds from Object in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
       * @private
       */
      __getMsec(obj) {
        let result2 = (obj && obj.hours || 0) * 60 * 60 * 1e3;
        result2 += (obj && obj.minutes || 0) * 60 * 1e3;
        result2 += (obj && obj.seconds || 0) * 1e3;
        result2 += obj && parseInt(obj.milliseconds) || 0;
        return result2;
      }
      /**
       * Returning seconds from Object in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
       * @private
       */
      __getSec(obj) {
        let result2 = (obj && obj.hours || 0) * 60 * 60;
        result2 += (obj && obj.minutes || 0) * 60;
        result2 += obj && obj.seconds || 0;
        result2 += obj && obj.milliseconds / 1e3 || 0;
        return result2;
      }
      /**
       * Returning Object in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
       * from the result of adding step value in milliseconds to the milliseconds amount.
       * With `precision` parameter rounding the value to the closest step valid interval.
       * @private
       */
      __addStep(msec, step, precision) {
        if (msec === 0 && step < 0) {
          msec = 24 * 60 * 60 * 1e3;
        }
        const stepMsec = step * 1e3;
        const diffToNext = msec % stepMsec;
        if (stepMsec < 0 && diffToNext && precision) {
          msec -= diffToNext;
        } else if (stepMsec > 0 && diffToNext && precision) {
          msec -= diffToNext - stepMsec;
        } else {
          msec += stepMsec;
        }
        const hh = Math.floor(msec / 1e3 / 60 / 60);
        msec -= hh * 1e3 * 60 * 60;
        const mm = Math.floor(msec / 1e3 / 60);
        msec -= mm * 1e3 * 60;
        const ss = Math.floor(msec / 1e3);
        msec -= ss * 1e3;
        return { hours: hh < 24 ? hh : 0, minutes: mm, seconds: ss, milliseconds: msec };
      }
      /** @private */
      __updateDropdownItems(i8n, min, max, step) {
        const minTimeObj = this.__validateTime(this.__parseISO(min || MIN_ALLOWED_TIME));
        const minSec = this.__getSec(minTimeObj);
        const maxTimeObj = this.__validateTime(this.__parseISO(max || MAX_ALLOWED_TIME));
        const maxSec = this.__getSec(maxTimeObj);
        this.__dropdownItems = this.__generateDropdownList(minSec, maxSec, step);
        if (step !== this.__oldStep) {
          this.__oldStep = step;
          const parsedObj = this.__validateTime(this.__parseISO(this.value));
          this.__updateValue(parsedObj);
        }
        if (this.value) {
          this._comboBoxValue = this.i18n.formatTime(this.i18n.parseTime(this.value));
        }
      }
      /** @private */
      __generateDropdownList(minSec, maxSec, step) {
        if (step < 15 * 60 || !this.__validDayDivisor(step)) {
          return [];
        }
        const generatedList = [];
        if (!step) {
          step = 3600;
        }
        let time = -step + minSec;
        while (time + step >= minSec && time + step <= maxSec) {
          const timeObj = this.__validateTime(this.__addStep(time * 1e3, step));
          time += step;
          const formatted = this.i18n.formatTime(timeObj);
          generatedList.push({ label: formatted, value: formatted });
        }
        return generatedList;
      }
      /**
       * Override an observer from `InputMixin`.
       * @protected
       * @override
       */
      _valueChanged(value, oldValue) {
        const parsedObj = this.__memoValue = this.__parseISO(value);
        const newValue = this.__formatISO(parsedObj) || "";
        if (!this.__keepCommittedValue) {
          this.__committedValue = value;
          this.__committedUnparsableValue = "";
        }
        if (value !== "" && value !== null && !parsedObj) {
          this.value = oldValue === void 0 ? "" : oldValue;
        } else if (value !== newValue) {
          this.value = newValue;
        } else if (this.__keepInvalidInput) {
          delete this.__keepInvalidInput;
        } else {
          this.__updateInputValue(parsedObj);
        }
        this._toggleHasValue(this._hasValue);
      }
      /** @private */
      __comboBoxValueChanged(value, oldValue) {
        if (value === "" && oldValue === void 0) {
          return;
        }
        const parsedObj = this.__useMemo ? this.__memoValue : this.i18n.parseTime(value);
        const newValue = this.i18n.formatTime(parsedObj) || "";
        if (parsedObj) {
          if (value !== newValue) {
            this._comboBoxValue = newValue;
          } else {
            this.__keepCommittedValue = true;
            this.__updateValue(parsedObj);
            this.__keepCommittedValue = false;
          }
        } else {
          if (this.value !== "" && value !== "") {
            this.__keepInvalidInput = true;
          }
          this.__keepCommittedValue = true;
          this.value = "";
          this.__keepCommittedValue = false;
        }
      }
      /** @private */
      __onComboBoxChange(event) {
        event.stopPropagation();
        this.__commitValueChange();
      }
      /**
       * Synchronizes the `_hasInputValue` property with the internal combo-box's one.
       *
       * @private
       */
      __onComboBoxHasInputValueChanged() {
        this._hasInputValue = this.$.comboBox._hasInputValue;
      }
      /** @private */
      __updateValue(obj) {
        const timeString = this.__formatISO(this.__validateTime(obj)) || "";
        this.value = timeString;
      }
      /** @private */
      __updateInputValue(obj) {
        const timeString = this.i18n.formatTime(this.__validateTime(obj)) || "";
        this._comboBoxValue = timeString;
      }
      /** @private */
      __validateTime(timeObject) {
        if (timeObject) {
          const stepSegment = this.__getStepSegment();
          timeObject.hours = parseInt(timeObject.hours);
          timeObject.minutes = parseInt(timeObject.minutes || 0);
          timeObject.seconds = stepSegment < 3 ? void 0 : parseInt(timeObject.seconds || 0);
          timeObject.milliseconds = stepSegment < 4 ? void 0 : parseInt(timeObject.milliseconds || 0);
        }
        return timeObject;
      }
      /** @private */
      __getStepSegment() {
        if (this.step % 3600 === 0) {
          return 1;
        } else if (this.step % 60 === 0 || !this.step) {
          return 2;
        } else if (this.step % 1 === 0) {
          return 3;
        } else if (this.step < 1) {
          return 4;
        }
        return void 0;
      }
      /** @private */
      __formatISO(time) {
        return TimePicker.properties.i18n.value().formatTime(time);
      }
      /** @private */
      __parseISO(text) {
        return TimePicker.properties.i18n.value().parseTime(text);
      }
      /**
       * Returns true if `time` satisfies the `min` and `max` constraints (if any).
       *
       * @param {!TimePickerTime} time Value to check against constraints
       * @return {boolean} True if `time` satisfies the constraints
       * @protected
       */
      _timeAllowed(time) {
        const parsedMin = this.i18n.parseTime(this.min || MIN_ALLOWED_TIME);
        const parsedMax = this.i18n.parseTime(this.max || MAX_ALLOWED_TIME);
        return (!this.__getMsec(parsedMin) || this.__getMsec(time) >= this.__getMsec(parsedMin)) && (!this.__getMsec(parsedMax) || this.__getMsec(time) <= this.__getMsec(parsedMax));
      }
      /**
       * Override method inherited from `InputControlMixin`.
       * @protected
       */
      _onClearButtonClick() {
      }
      /**
       * Override method inherited from `InputConstraintsMixin`.
       * @protected
       */
      _onChange() {
      }
      /**
       * Override method inherited from `InputMixin`.
       * @protected
       */
      _onInput() {
      }
      /**
       * Fired when the user commits a value change.
       *
       * @event change
       */
    }
    defineCustomElement(TimePicker);
    const dateTimePicker = css$e`
  ::slotted([slot='date-picker']) {
    margin-inline-end: 2px;
    --vaadin-input-field-top-end-radius: 0;
    --vaadin-input-field-bottom-end-radius: 0;
  }

  ::slotted([slot='time-picker']) {
    --vaadin-input-field-top-start-radius: 0;
    --vaadin-input-field-bottom-start-radius: 0;
  }
`;
    registerStyles$1("vaadin-date-time-picker", [dateTimePicker, requiredField, helper, customField], {
      moduleId: "lumo-date-time-picker"
    });
    /**
     * @license
     * Copyright (c) 2019 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-date-time-picker", inputFieldShared$1, { moduleId: "vaadin-date-time-picker" });
    function getPropertyFromPrototype(clazz, prop) {
      while (clazz) {
        if (clazz.properties && clazz.properties[prop]) {
          return clazz.properties[prop];
        }
        clazz = Object.getPrototypeOf(clazz);
      }
    }
    const datePickerI18nDefaults = getPropertyFromPrototype(DatePicker, "i18n").value();
    const timePickerI18nDefaults = getPropertyFromPrototype(TimePicker, "i18n").value();
    const datePickerI18nProps = Object.keys(datePickerI18nDefaults);
    const timePickerI18nProps = Object.keys(timePickerI18nDefaults);
    class PickerSlotController extends SlotController {
      constructor(host, type) {
        super(host, `${type}-picker`, `vaadin-${type}-picker`, {
          initializer: (picker, host2) => {
            const prop = `__${type}Picker`;
            host2[prop] = picker;
          }
        });
      }
    }
    class DateTimePicker extends FieldMixin(DisabledMixin(FocusMixin(ThemableMixin(ElementMixin(PolymerElement))))) {
      static get template() {
        return html`
      <style>
        .vaadin-date-time-picker-container {
          --vaadin-field-default-width: auto;
        }

        .slots {
          display: flex;
          --vaadin-field-default-width: 12em;
        }

        .slots ::slotted([slot='date-picker']) {
          min-width: 0;
          flex: 1 1 auto;
        }

        .slots ::slotted([slot='time-picker']) {
          min-width: 0;
          flex: 1 1.65 auto;
        }
      </style>

      <div class="vaadin-date-time-picker-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="slots">
          <slot name="date-picker" id="dateSlot"></slot>
          <slot name="time-picker" id="timeSlot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
      }
      static get is() {
        return "vaadin-date-time-picker";
      }
      static get properties() {
        return {
          /**
           * The name of the control, which is submitted with the form data.
           */
          name: {
            type: String
          },
          /**
           * The value for this element.
           *
           * Supported date time format is based on ISO 8601 (without a time zone designator):
           * - Minute precision `"YYYY-MM-DDThh:mm"` (default)
           * - Second precision `"YYYY-MM-DDThh:mm:ss"`
           * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
           * @type {string}
           */
          value: {
            type: String,
            notify: true,
            value: "",
            observer: "__valueChanged"
          },
          /**
           * The earliest allowed value (date and time) that can be selected. All earlier values will be disabled.
           *
           * Supported date time format is based on ISO 8601 (without a time zone designator):
           * - Minute precision `"YYYY-MM-DDThh:mm"`
           * - Second precision `"YYYY-MM-DDThh:mm:ss"`
           * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
           *
           * @type {string | undefined}
           */
          min: {
            type: String,
            observer: "__minChanged"
          },
          /**
           * The latest value (date and time) that can be selected. All later values will be disabled.
           *
           * Supported date time format is based on ISO 8601 (without a time zone designator):
           * - Minute precision `"YYYY-MM-DDThh:mm"`
           * - Second precision `"YYYY-MM-DDThh:mm:ss"`
           * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
           *
           * @type {string | undefined}
           */
          max: {
            type: String,
            observer: "__maxChanged"
          },
          /**
           * The earliest value that can be selected. All earlier values will be disabled.
           * @private
           */
          __minDateTime: {
            type: Date,
            value: ""
          },
          /**
           * The latest value that can be selected. All later values will be disabled.
           * @private
           */
          __maxDateTime: {
            type: Date,
            value: ""
          },
          /**
           * A placeholder string for the date field.
           * @attr {string} date-placeholder
           */
          datePlaceholder: {
            type: String
          },
          /**
           * A placeholder string for the time field.
           * @attr {string} time-placeholder
           */
          timePlaceholder: {
            type: String
          },
          /**
           * Defines the time interval (in seconds) between the items displayed
           * in the time selection box. The default is 1 hour (i.e. `3600`).
           *
           * It also configures the precision of the time part of the value string. By default
           * the component formats time values as `hh:mm` but setting a step value
           * lower than one minute or one second, format resolution changes to
           * `hh:mm:ss` and `hh:mm:ss.fff` respectively.
           *
           * Unit must be set in seconds, and for correctly configuring intervals
           * in the dropdown, it need to evenly divide a day.
           *
           * Note: it is possible to define step that is dividing an hour in inexact
           * fragments (i.e. 5760 seconds which equals 1 hour 36 minutes), but it is
           * not recommended to use it for better UX.
           */
          step: {
            type: Number
          },
          /**
           * Date which should be visible in the date picker overlay when there is no value selected.
           *
           * The same date formats as for the `value` property are supported but without the time part.
           * @attr {string} initial-position
           */
          initialPosition: String,
          /**
           * Set true to display ISO-8601 week numbers in the calendar. Notice that
           * displaying week numbers is only supported when `i18n.firstDayOfWeek`
           * is 1 (Monday).
           * @attr {boolean} show-week-numbers
           */
          showWeekNumbers: {
            type: Boolean,
            value: false
          },
          /**
           * Set to true to prevent the overlays from opening automatically.
           * @attr {boolean} auto-open-disabled
           */
          autoOpenDisabled: Boolean,
          /**
           * Set to true to make this element read-only.
           * @type {boolean}
           */
          readonly: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          /**
           * Specify that this control should have input focus when the page loads.
           * @type {boolean}
           */
          autofocus: {
            type: Boolean
          },
          /**
           * The current selected date time.
           * @private
           */
          __selectedDateTime: {
            type: Date
          },
          /**
           * The object used to localize this component.
           * To change the default localization, replace the entire
           * `i18n` object or just the properties you want to modify.
           *
           * The object is a combination of the i18n properties supported by
           * [`<vaadin-date-picker>`](#/elements/vaadin-date-picker) and
           * [`<vaadin-time-picker>`](#/elements/vaadin-time-picker).
           * @type {!DateTimePickerI18n}
           */
          i18n: {
            type: Object,
            value: () => ({ ...datePickerI18nDefaults, ...timePickerI18nDefaults })
          },
          /**
           * A space-delimited list of CSS class names to set on the overlay elements
           * of the internal components controlled by the `<vaadin-date-time-picker>`:
           *
           * - [`<vaadin-date-picker>`](#/elements/vaadin-date-picker#property-overlayClass)
           * - [`<vaadin-time-picker>`](#/elements/vaadin-time-picker#property-overlayClass)
           *
           * @attr {string} overlay-class
           */
          overlayClass: {
            type: String
          },
          /**
           * The current slotted date picker.
           * @private
           */
          __datePicker: {
            type: HTMLElement,
            observer: "__datePickerChanged"
          },
          /**
           * The current slotted time picker.
           * @private
           */
          __timePicker: {
            type: HTMLElement,
            observer: "__timePickerChanged"
          }
        };
      }
      static get observers() {
        return [
          "__selectedDateTimeChanged(__selectedDateTime)",
          "__datePlaceholderChanged(datePlaceholder, __datePicker)",
          "__timePlaceholderChanged(timePlaceholder, __timePicker)",
          "__stepChanged(step, __timePicker)",
          "__initialPositionChanged(initialPosition, __datePicker)",
          "__showWeekNumbersChanged(showWeekNumbers, __datePicker)",
          "__requiredChanged(required, __datePicker, __timePicker)",
          "__invalidChanged(invalid, __datePicker, __timePicker)",
          "__disabledChanged(disabled, __datePicker, __timePicker)",
          "__readonlyChanged(readonly, __datePicker, __timePicker)",
          "__i18nChanged(i18n, __datePicker, __timePicker)",
          "__autoOpenDisabledChanged(autoOpenDisabled, __datePicker, __timePicker)",
          "__themeChanged(_theme, __datePicker, __timePicker)",
          "__overlayClassChanged(overlayClass, __datePicker, __timePicker)",
          "__pickersChanged(__datePicker, __timePicker)",
          "__labelOrAccessibleNameChanged(label, accessibleName, i18n, __datePicker, __timePicker)"
        ];
      }
      constructor() {
        super();
        this.__defaultDateMinMaxValue = void 0;
        this.__defaultTimeMinValue = "00:00:00.000";
        this.__defaultTimeMaxValue = "23:59:59.999";
        this.__changeEventHandler = this.__changeEventHandler.bind(this);
        this.__valueChangedEventHandler = this.__valueChangedEventHandler.bind(this);
      }
      /** @private */
      get __inputs() {
        return [this.__datePicker, this.__timePicker];
      }
      /** @private */
      get __formattedValue() {
        const [dateValue, timeValue] = this.__inputs.map((picker) => picker.value);
        if (dateValue && timeValue) {
          return [dateValue, timeValue].join("T");
        }
        return "";
      }
      /** @protected */
      ready() {
        super.ready();
        this._datePickerController = new PickerSlotController(this, "date");
        this.addController(this._datePickerController);
        this._timePickerController = new PickerSlotController(this, "time");
        this.addController(this._timePickerController);
        if (this.autofocus && !this.disabled) {
          window.requestAnimationFrame(() => this.focus());
        }
        this.setAttribute("role", "group");
        this._tooltipController = new TooltipController(this);
        this.addController(this._tooltipController);
        this._tooltipController.setPosition("top");
        this._tooltipController.setShouldShow((target) => {
          return target.__datePicker && !target.__datePicker.opened && target.__timePicker && !target.__timePicker.opened;
        });
        this.ariaTarget = this;
      }
      focus() {
        if (this.__datePicker) {
          this.__datePicker.focus();
        }
      }
      /**
       * Override method inherited from `FocusMixin` to validate on blur.
       * @param {boolean} focused
       * @protected
       * @override
       */
      _setFocused(focused) {
        super._setFocused(focused);
        if (!focused && document.hasFocus()) {
          this.validate();
        }
      }
      /**
       * Override method inherited from `FocusMixin` to not remove focused
       * state when focus moves between pickers or to the overlay.
       * @param {FocusEvent} event
       * @return {boolean}
       * @protected
       * @override
       */
      _shouldRemoveFocus(event) {
        const target = event.relatedTarget;
        const overlayContent = this.__datePicker._overlayContent;
        if (this.__datePicker.contains(target) || this.__timePicker.contains(target) || overlayContent && overlayContent.contains(target)) {
          return false;
        }
        return true;
      }
      /** @private */
      __syncI18n(target, source, props = Object.keys(source.i18n)) {
        props.forEach((prop) => {
          if (source.i18n && source.i18n.hasOwnProperty(prop)) {
            target.set(`i18n.${prop}`, source.i18n[prop]);
          }
        });
      }
      /** @private */
      __changeEventHandler(event) {
        event.stopPropagation();
        if (this.__dispatchChangeForValue === this.value) {
          this.validate();
          this.__dispatchChange();
        }
        this.__dispatchChangeForValue = void 0;
      }
      /** @private */
      __addInputListeners(node) {
        node.addEventListener("change", this.__changeEventHandler);
        node.addEventListener("value-changed", this.__valueChangedEventHandler);
      }
      /** @private */
      __removeInputListeners(node) {
        node.removeEventListener("change", this.__changeEventHandler);
        node.removeEventListener("value-changed", this.__valueChangedEventHandler);
      }
      /** @private */
      __isDefaultPicker(picker, type) {
        const controller = this[`_${type}PickerController`];
        return controller && picker === controller.defaultNode;
      }
      /** @private */
      __datePickerChanged(newDatePicker, existingDatePicker) {
        if (!newDatePicker) {
          return;
        }
        if (existingDatePicker) {
          this.__removeInputListeners(existingDatePicker);
          existingDatePicker.remove();
        }
        this.__addInputListeners(newDatePicker);
        if (this.__isDefaultPicker(newDatePicker, "date")) {
          newDatePicker.placeholder = this.datePlaceholder;
          newDatePicker.invalid = this.invalid;
          newDatePicker.initialPosition = this.initialPosition;
          newDatePicker.showWeekNumbers = this.showWeekNumbers;
          this.__syncI18n(newDatePicker, this, datePickerI18nProps);
        } else {
          this.datePlaceholder = newDatePicker.placeholder;
          this.initialPosition = newDatePicker.initialPosition;
          this.showWeekNumbers = newDatePicker.showWeekNumbers;
          this.__syncI18n(this, newDatePicker, datePickerI18nProps);
        }
        newDatePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
        newDatePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
        newDatePicker.validate = () => {
        };
        newDatePicker._validateInput = () => {
        };
      }
      /** @private */
      __timePickerChanged(newTimePicker, existingTimePicker) {
        if (!newTimePicker) {
          return;
        }
        if (existingTimePicker) {
          this.__removeInputListeners(existingTimePicker);
          existingTimePicker.remove();
        }
        this.__addInputListeners(newTimePicker);
        if (this.__isDefaultPicker(newTimePicker, "time")) {
          newTimePicker.placeholder = this.timePlaceholder;
          newTimePicker.step = this.step;
          newTimePicker.invalid = this.invalid;
          this.__syncI18n(newTimePicker, this, timePickerI18nProps);
        } else {
          this.timePlaceholder = newTimePicker.placeholder;
          this.step = newTimePicker.step;
          this.__syncI18n(this, newTimePicker, timePickerI18nProps);
        }
        this.__updateTimePickerMinMax();
        newTimePicker.validate = () => {
        };
      }
      /** @private */
      __updateTimePickerMinMax() {
        if (this.__timePicker && this.__datePicker) {
          const selectedDate = this.__parseDate(this.__datePicker.value);
          const isMinMaxSameDay = dateEquals(this.__minDateTime, this.__maxDateTime);
          const oldTimeValue = this.__timePicker.value;
          if (this.__minDateTime && dateEquals(selectedDate, this.__minDateTime) || isMinMaxSameDay) {
            this.__timePicker.min = this.__dateToIsoTimeString(this.__minDateTime);
          } else {
            this.__timePicker.min = this.__defaultTimeMinValue;
          }
          if (this.__maxDateTime && dateEquals(selectedDate, this.__maxDateTime) || isMinMaxSameDay) {
            this.__timePicker.max = this.__dateToIsoTimeString(this.__maxDateTime);
          } else {
            this.__timePicker.max = this.__defaultTimeMaxValue;
          }
          if (this.__timePicker.value !== oldTimeValue) {
            this.__timePicker.value = oldTimeValue;
          }
        }
      }
      /** @private */
      __i18nChanged(i18n, datePicker2, timePicker2) {
        if (datePicker2) {
          datePicker2.i18n = { ...datePicker2.i18n, ...i18n };
        }
        if (timePicker2) {
          timePicker2.i18n = { ...timePicker2.i18n, ...i18n };
        }
      }
      /** @private */
      __labelOrAccessibleNameChanged(label, accessibleName, i18n, datePicker2, timePicker2) {
        const name = accessibleName || label || "";
        if (datePicker2) {
          datePicker2.accessibleName = `${name} ${i18n.dateLabel || ""}`.trim();
        }
        if (timePicker2) {
          timePicker2.accessibleName = `${name} ${i18n.timeLabel || ""}`.trim();
        }
      }
      /** @private */
      __datePlaceholderChanged(datePlaceholder, datePicker2) {
        if (datePicker2) {
          datePicker2.placeholder = datePlaceholder;
        }
      }
      /** @private */
      __timePlaceholderChanged(timePlaceholder, timePicker2) {
        if (timePicker2) {
          timePicker2.placeholder = timePlaceholder;
        }
      }
      /** @private */
      __stepChanged(step, timePicker2) {
        if (timePicker2 && timePicker2.step !== step) {
          timePicker2.step = step;
        }
      }
      /** @private */
      __initialPositionChanged(initialPosition, datePicker2) {
        if (datePicker2) {
          datePicker2.initialPosition = initialPosition;
        }
      }
      /** @private */
      __showWeekNumbersChanged(showWeekNumbers, datePicker2) {
        if (datePicker2) {
          datePicker2.showWeekNumbers = showWeekNumbers;
        }
      }
      /** @private */
      __invalidChanged(invalid, datePicker2, timePicker2) {
        if (datePicker2) {
          datePicker2.invalid = invalid;
        }
        if (timePicker2) {
          timePicker2.invalid = invalid;
        }
      }
      /** @private */
      __requiredChanged(required, datePicker2, timePicker2) {
        if (datePicker2) {
          datePicker2.required = required;
        }
        if (timePicker2) {
          timePicker2.required = required;
        }
      }
      /** @private */
      __disabledChanged(disabled, datePicker2, timePicker2) {
        if (datePicker2) {
          datePicker2.disabled = disabled;
        }
        if (timePicker2) {
          timePicker2.disabled = disabled;
        }
      }
      /** @private */
      __readonlyChanged(readonly, datePicker2, timePicker2) {
        if (datePicker2) {
          datePicker2.readonly = readonly;
        }
        if (timePicker2) {
          timePicker2.readonly = readonly;
        }
      }
      /**
       * String (ISO date) to Date object
       * @param {string} str e.g. 'yyyy-mm-dd'
       * @return {Date | undefined}
       * @private
       */
      __parseDate(str) {
        return parseDate(str);
      }
      /**
       * Date object to string (ISO date)
       * @param {Date} date
       * @param {string} defaultValue
       * @return {string} e.g. 'yyyy-mm-dd' (or defaultValue when date is falsy)
       * @private
       */
      __formatDateISO(date, defaultValue) {
        if (!date) {
          return defaultValue;
        }
        return DatePicker.prototype._formatISO(date);
      }
      /**
       * Custom time object to string (ISO time)
       * @param {!TimePickerTime} time Time components as properties { hours, minutes, seconds, milliseconds }
       * @return {string} e.g. 'hh:mm', 'hh:mm:ss', 'hh:mm:ss.fff'
       * @private
       */
      __formatTimeISO(time) {
        return timePickerI18nDefaults.formatTime(time);
      }
      /**
       * String (ISO time) to custom time object
       * @param {string} str e.g. 'hh:mm', 'hh:mm:ss', 'hh:mm:ss.fff'
       * @return {!TimePickerTime | undefined} Time components as properties { hours, minutes, seconds, milliseconds }
       * @private
       */
      __parseTimeISO(str) {
        return timePickerI18nDefaults.parseTime(str);
      }
      /**
       * String (ISO date time) to Date object
       * @param {string} str e.g. 'yyyy-mm-ddThh:mm', 'yyyy-mm-ddThh:mm:ss', 'yyyy-mm-ddThh:mm:ss.fff'
       * @return {Date | undefined}
       * @private
       */
      __parseDateTime(str) {
        const [dateValue, timeValue] = str.split("T");
        if (!(dateValue && timeValue)) {
          return;
        }
        const date = this.__parseDate(dateValue);
        if (!date) {
          return;
        }
        const time = this.__parseTimeISO(timeValue);
        if (!time) {
          return;
        }
        date.setHours(parseInt(time.hours));
        date.setMinutes(parseInt(time.minutes || 0));
        date.setSeconds(parseInt(time.seconds || 0));
        date.setMilliseconds(parseInt(time.milliseconds || 0));
        return date;
      }
      /**
       * Date object to string (ISO date time)
       * @param {Date} date
       * @return {string} e.g. 'yyyy-mm-ddThh:mm', 'yyyy-mm-ddThh:mm:ss', 'yyyy-mm-ddThh:mm:ss.fff'
       *                  (depending on precision defined by "step" property)
       * @private
       */
      __formatDateTime(date) {
        if (!date) {
          return "";
        }
        const dateValue = this.__formatDateISO(date, "");
        const timeValue = this.__dateToIsoTimeString(date);
        return `${dateValue}T${timeValue}`;
      }
      /**
       * Date object to string (ISO time)
       * @param {Date} date
       * @return {string} e.g. 'hh:mm', 'hh:mm:ss', 'hh:mm:ss.fff' (depending on precision defined by "step" property)
       * @private
       */
      __dateToIsoTimeString(date) {
        return this.__formatTimeISO(
          this.__validateTime({
            hours: date.getHours(),
            minutes: date.getMinutes(),
            seconds: date.getSeconds(),
            milliseconds: date.getMilliseconds()
          })
        );
      }
      /**
       * @param {!TimePickerTime} timeObject
       * @return {!TimePickerTime}
       * @private
       */
      __validateTime(timeObject) {
        if (timeObject) {
          const stepSegment = this.__getStepSegment();
          timeObject.seconds = stepSegment < 3 ? void 0 : timeObject.seconds;
          timeObject.milliseconds = stepSegment < 4 ? void 0 : timeObject.milliseconds;
        }
        return timeObject;
      }
      /**
       * Returns true if the current input value satisfies all constraints (if any)
       *
       * You can override the `checkValidity` method for custom validations.
       * @return {boolean}
       */
      checkValidity() {
        const hasInvalidFields = this.__inputs.some((input) => !input.checkValidity());
        const hasEmptyFields = this.required && this.__inputs.some((el) => !el.value);
        if (hasInvalidFields || hasEmptyFields) {
          return false;
        }
        return true;
      }
      // Copied from vaadin-time-picker
      /** @private */
      __getStepSegment() {
        const step = this.step == null ? 60 : parseFloat(this.step);
        if (step % 3600 === 0) {
          return 1;
        } else if (step % 60 === 0 || !step) {
          return 2;
        } else if (step % 1 === 0) {
          return 3;
        } else if (step < 1) {
          return 4;
        }
      }
      /**
       * @param {Date} date1
       * @param {Date} date2
       * @return {boolean}
       * @private
       */
      __dateTimeEquals(date1, date2) {
        if (!dateEquals(date1, date2)) {
          return false;
        }
        return date1.getHours() === date2.getHours() && date1.getMinutes() === date2.getMinutes() && date1.getSeconds() === date2.getSeconds() && date1.getMilliseconds() === date2.getMilliseconds();
      }
      /** @private */
      __handleDateTimeChange(property, parsedProperty, value, oldValue) {
        if (!value) {
          this[property] = "";
          this[parsedProperty] = "";
          return;
        }
        const dateTime = this.__parseDateTime(value);
        if (!dateTime) {
          this[property] = oldValue;
          return;
        }
        if (!this.__dateTimeEquals(this[parsedProperty], dateTime)) {
          this[parsedProperty] = dateTime;
        }
      }
      /** @private */
      __valueChanged(value, oldValue) {
        this.__handleDateTimeChange("value", "__selectedDateTime", value, oldValue);
        if (oldValue !== void 0) {
          this.__dispatchChangeForValue = value;
        }
        this.toggleAttribute("has-value", !!value);
        this.__updateTimePickerMinMax();
      }
      /** @private */
      __dispatchChange() {
        this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
      }
      /** @private */
      __minChanged(value, oldValue) {
        this.__handleDateTimeChange("min", "__minDateTime", value, oldValue);
        if (this.__datePicker) {
          this.__datePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
        }
        this.__updateTimePickerMinMax();
        if (this.__datePicker && this.__timePicker && this.value) {
          this.validate();
        }
      }
      /** @private */
      __maxChanged(value, oldValue) {
        this.__handleDateTimeChange("max", "__maxDateTime", value, oldValue);
        if (this.__datePicker) {
          this.__datePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
        }
        this.__updateTimePickerMinMax();
        if (this.__datePicker && this.__timePicker && this.value) {
          this.validate();
        }
      }
      /** @private */
      __selectedDateTimeChanged(selectedDateTime) {
        const formattedValue = this.__formatDateTime(selectedDateTime);
        if (this.value !== formattedValue) {
          this.value = formattedValue;
        }
        const isDatePickerReady = Boolean(this.__datePicker && this.__datePicker.$);
        if (isDatePickerReady && !this.__ignoreInputValueChange) {
          this.__ignoreInputValueChange = true;
          const [dateValue, timeValue] = this.value.split("T");
          this.__datePicker.value = dateValue || "";
          this.__timePicker.value = timeValue || "";
          this.__ignoreInputValueChange = false;
        }
      }
      /** @private */
      __valueChangedEventHandler() {
        if (this.__ignoreInputValueChange) {
          return;
        }
        const value = this.__formattedValue;
        const [date, time] = value.split("T");
        this.__ignoreInputValueChange = true;
        this.__updateTimePickerMinMax();
        if (date && time) {
          if (value !== this.value) {
            this.value = value;
          }
        } else {
          this.value = "";
        }
        this.__ignoreInputValueChange = false;
      }
      /** @private */
      __autoOpenDisabledChanged(autoOpenDisabled, datePicker2, timePicker2) {
        if (datePicker2) {
          datePicker2.autoOpenDisabled = autoOpenDisabled;
        }
        if (timePicker2) {
          timePicker2.autoOpenDisabled = autoOpenDisabled;
        }
      }
      /** @private */
      __themeChanged(theme2, datePicker2, timePicker2) {
        if (!datePicker2 || !timePicker2) {
          return;
        }
        [datePicker2, timePicker2].forEach((picker) => {
          if (theme2) {
            picker.setAttribute("theme", theme2);
          } else {
            picker.removeAttribute("theme");
          }
        });
      }
      /** @private */
      __overlayClassChanged(overlayClass, datePicker2, timePicker2) {
        if (!datePicker2 || !timePicker2) {
          return;
        }
        datePicker2.overlayClass = overlayClass;
        timePicker2.overlayClass = overlayClass;
      }
      /** @private */
      __pickersChanged(datePicker2, timePicker2) {
        if (!datePicker2 || !timePicker2) {
          return;
        }
        if (this.__isDefaultPicker(datePicker2, "date") !== this.__isDefaultPicker(timePicker2, "time")) {
          return;
        }
        if (datePicker2.value) {
          this.__valueChangedEventHandler();
        } else if (this.value) {
          this.__selectedDateTimeChanged(this.__selectedDateTime);
          if (this.min || this.max) {
            this.validate();
          }
        }
      }
      /**
       * Fired when the user commits a value change.
       *
       * @event change
       */
    }
    defineCustomElement(DateTimePicker);
    const EASTERN_ARABIC_DIGIT_MAP = {
      "\\u0660": "0",
      "\\u0661": "1",
      "\\u0662": "2",
      "\\u0663": "3",
      "\\u0664": "4",
      "\\u0665": "5",
      "\\u0666": "6",
      "\\u0667": "7",
      "\\u0668": "8",
      "\\u0669": "9"
    };
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function parseEasternArabicDigits(digits) {
      return digits.replace(/[\u0660-\u0669]/g, function(char) {
        const unicode = "\\u0" + char.charCodeAt(0).toString(16);
        return EASTERN_ARABIC_DIGIT_MAP[unicode];
      });
    }
    function getAmOrPmString(locale2, testTime) {
      const testTimeString = testTime.toLocaleTimeString(locale2);
      const amOrPmRegExp = /[^\d\u0660-\u0669]/;
      const matches2 = (
        // In most locales, the time ends with AM/PM:
        testTimeString.match(new RegExp(`${amOrPmRegExp.source}+$`, "g")) || // In some locales, the time starts with AM/PM e.g in Chinese:
        testTimeString.match(new RegExp(`^${amOrPmRegExp.source}+`, "g"))
      );
      return matches2 && matches2[0].trim();
    }
    function getSeparator(locale2) {
      let timeString = TEST_PM_TIME.toLocaleTimeString(locale2);
      const pmString = getPmString(locale2);
      if (pmString && timeString.startsWith(pmString)) {
        timeString = timeString.replace(pmString, "");
      }
      const matches2 = timeString.match(/[^\u0660-\u0669\s\d]/);
      return matches2 && matches2[0];
    }
    function searchAmOrPmToken(timeString, amOrPmString) {
      if (!amOrPmString) return null;
      const tokenRegExpString = amOrPmString.split(/\s*/).map(escapeRegExp).join("\\s*");
      const tokenRegExp = new RegExp(tokenRegExpString, "i");
      const tokenMatches = timeString.match(tokenRegExp);
      if (tokenMatches) {
        return tokenMatches[0];
      }
    }
    const TEST_PM_TIME = /* @__PURE__ */ new Date("August 19, 1975 23:15:30");
    const TEST_AM_TIME = /* @__PURE__ */ new Date("August 19, 1975 05:15:30");
    function getPmString(locale2) {
      return getAmOrPmString(locale2, TEST_PM_TIME);
    }
    function getAmString(locale2) {
      return getAmOrPmString(locale2, TEST_AM_TIME);
    }
    function parseDigitsIntoInteger(digits) {
      return parseInt(parseEasternArabicDigits(digits));
    }
    function parseMillisecondsIntoInteger(milliseconds) {
      milliseconds = parseEasternArabicDigits(milliseconds);
      if (milliseconds.length === 1) {
        milliseconds += "00";
      } else if (milliseconds.length === 2) {
        milliseconds += "0";
      }
      return parseInt(milliseconds);
    }
    function formatMilliseconds(timeString, milliseconds, amString, pmString) {
      let cleanedTimeString = timeString;
      if (timeString.endsWith(amString)) {
        cleanedTimeString = timeString.replace(" " + amString, "");
      } else if (timeString.endsWith(pmString)) {
        cleanedTimeString = timeString.replace(" " + pmString, "");
      }
      if (milliseconds) {
        let millisecondsString = milliseconds < 10 ? "0" : "";
        millisecondsString += milliseconds < 100 ? "0" : "";
        millisecondsString += milliseconds;
        cleanedTimeString += "." + millisecondsString;
      } else {
        cleanedTimeString += ".000";
      }
      if (timeString.endsWith(amString)) {
        cleanedTimeString = cleanedTimeString + " " + amString;
      } else if (timeString.endsWith(pmString)) {
        cleanedTimeString = cleanedTimeString + " " + pmString;
      }
      return cleanedTimeString;
    }
    (function() {
      const tryCatchWrapper = function(callback) {
        return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Time Picker");
      };
      function when(predicate, callback, timeout = 0) {
        if (predicate()) {
          callback();
        } else {
          setTimeout(() => when(predicate, callback, 200), timeout);
        }
      }
      function parseISO(text) {
        const timeObject = TimePicker.properties.i18n.value().parseTime(text);
        return {
          hours: parseInt(timeObject.hours || 0),
          minutes: parseInt(timeObject.minutes || 0),
          seconds: parseInt(timeObject.seconds || 0),
          milliseconds: parseInt(timeObject.milliseconds || 0)
        };
      }
      window.Vaadin.Flow.timepickerConnector = {
        initLazy: (timepicker) => tryCatchWrapper(function(timepicker2) {
          if (timepicker2.$connector) {
            return;
          }
          timepicker2.$connector = {};
          timepicker2.$connector.setLocale = tryCatchWrapper(function(locale2) {
            let previousValueObject;
            if (timepicker2.value && timepicker2.value !== "") {
              previousValueObject = parseISO(timepicker2.value);
            }
            try {
              TEST_PM_TIME.toLocaleTimeString(locale2);
            } catch (e2) {
              locale2 = "en-US";
              throw new Error(
                "vaadin-time-picker: The locale " + locale2 + " is not supported, falling back to default locale setting(en-US)."
              );
            }
            const pmString = getPmString(locale2);
            const amString = getAmString(locale2);
            const separator = getSeparator(locale2);
            const includeSeconds = function() {
              return timepicker2.step && timepicker2.step < 60;
            };
            const includeMilliSeconds = function() {
              return timepicker2.step && timepicker2.step < 1;
            };
            let cachedTimeString;
            let cachedTimeObject;
            timepicker2.i18n = {
              formatTime: tryCatchWrapper(function(timeObject) {
                if (!timeObject) return;
                const timeToBeFormatted = /* @__PURE__ */ new Date();
                timeToBeFormatted.setHours(timeObject.hours);
                timeToBeFormatted.setMinutes(timeObject.minutes);
                timeToBeFormatted.setSeconds(timeObject.seconds !== void 0 ? timeObject.seconds : 0);
                let localeTimeString = timeToBeFormatted.toLocaleTimeString(locale2, {
                  hour: "numeric",
                  minute: "numeric",
                  second: includeSeconds() ? "numeric" : void 0
                });
                if (includeMilliSeconds()) {
                  localeTimeString = formatMilliseconds(localeTimeString, timeObject.milliseconds, amString, pmString);
                }
                return localeTimeString;
              }),
              parseTime: tryCatchWrapper(function(timeString) {
                if (timeString && timeString === cachedTimeString && cachedTimeObject) {
                  return cachedTimeObject;
                }
                if (!timeString) {
                  return;
                }
                const amToken = searchAmOrPmToken(timeString, amString);
                const pmToken = searchAmOrPmToken(timeString, pmString);
                const numbersOnlyTimeString = timeString.replace(amToken || "", "").replace(pmToken || "", "").trim();
                const numbersRegExp = new RegExp("([\\d\\u0660-\\u0669]){1,2}(?:" + separator + ")?", "g");
                let hours = numbersRegExp.exec(numbersOnlyTimeString);
                if (hours) {
                  hours = parseDigitsIntoInteger(hours[0].replace(separator, ""));
                  if (amToken !== pmToken) {
                    if (hours === 12 && amToken) {
                      hours = 0;
                    }
                    if (hours !== 12 && pmToken) {
                      hours += 12;
                    }
                  }
                  const minutes = numbersRegExp.exec(numbersOnlyTimeString);
                  const seconds = minutes && numbersRegExp.exec(numbersOnlyTimeString);
                  const millisecondRegExp = /[[\.][\d\u0660-\u0669]{1,3}$/;
                  let milliseconds = seconds && includeMilliSeconds() && millisecondRegExp.exec(numbersOnlyTimeString);
                  if (milliseconds && milliseconds["index"] <= seconds["index"]) {
                    milliseconds = void 0;
                  }
                  cachedTimeObject = hours !== void 0 && {
                    hours,
                    minutes: minutes ? parseDigitsIntoInteger(minutes[0].replace(separator, "")) : 0,
                    seconds: seconds ? parseDigitsIntoInteger(seconds[0].replace(separator, "")) : 0,
                    milliseconds: minutes && seconds && milliseconds ? parseMillisecondsIntoInteger(milliseconds[0].replace(".", "")) : 0
                  };
                  cachedTimeString = timeString;
                  return cachedTimeObject;
                }
              })
            };
            if (previousValueObject) {
              when(
                () => timepicker2.$,
                () => {
                  const newValue = timepicker2.i18n.formatTime(previousValueObject);
                  if (timepicker2.inputElement.value !== newValue) {
                    timepicker2.inputElement.value = newValue;
                    timepicker2.$.comboBox.value = newValue;
                  }
                }
              );
            }
          });
        })(timepicker)
      };
    })();
    window.Vaadin = window.Vaadin || {};
    window.Vaadin.Flow = window.Vaadin.Flow || {};
    window.Vaadin.Flow.dndConnector = {
      __ondragenterListener: function(event) {
        const effect = event.currentTarget["__dropEffect"];
        if (!event.currentTarget.hasAttribute("disabled")) {
          if (effect) {
            event.dataTransfer.dropEffect = effect;
          }
          if (effect !== "none") {
            if (event.currentTarget.classList.contains("v-drag-over-target")) {
              event.currentTarget["__skip-leave"] = true;
            } else {
              event.currentTarget.classList.add("v-drag-over-target");
            }
            event.preventDefault();
            event.stopPropagation();
          }
        }
      },
      __ondragoverListener: function(event) {
        if (!event.currentTarget.hasAttribute("disabled")) {
          const effect = event.currentTarget["__dropEffect"];
          if (effect) {
            event.dataTransfer.dropEffect = effect;
          }
          event.preventDefault();
          event.stopPropagation();
        }
      },
      __ondragleaveListener: function(event) {
        if (event.currentTarget["__skip-leave"]) {
          event.currentTarget["__skip-leave"] = false;
        } else {
          event.currentTarget.classList.remove("v-drag-over-target");
        }
        event.stopPropagation();
      },
      __ondropListener: function(event) {
        const effect = event.currentTarget["__dropEffect"];
        if (effect) {
          event.dataTransfer.dropEffect = effect;
        }
        event.currentTarget.classList.remove("v-drag-over-target");
        event.preventDefault();
        event.stopPropagation();
      },
      updateDropTarget: function(element) {
        if (element["__active"]) {
          element.addEventListener("dragenter", this.__ondragenterListener, false);
          element.addEventListener("dragover", this.__ondragoverListener, false);
          element.addEventListener("dragleave", this.__ondragleaveListener, false);
          element.addEventListener("drop", this.__ondropListener, false);
        } else {
          element.removeEventListener("dragenter", this.__ondragenterListener, false);
          element.removeEventListener("dragover", this.__ondragoverListener, false);
          element.removeEventListener("dragleave", this.__ondragleaveListener, false);
          element.removeEventListener("drop", this.__ondropListener, false);
          element.classList.remove("v-drag-over-target");
        }
      },
      /** DRAG SOURCE METHODS: */
      __dragstartListener: function(event) {
        event.stopPropagation();
        event.dataTransfer.setData("text/plain", "");
        if (event.currentTarget.hasAttribute("disabled")) {
          event.preventDefault();
        } else {
          if (event.currentTarget["__effectAllowed"]) {
            event.dataTransfer.effectAllowed = event.currentTarget["__effectAllowed"];
          }
          event.currentTarget.classList.add("v-dragged");
        }
      },
      __dragendListener: function(event) {
        event.currentTarget.classList.remove("v-dragged");
      },
      updateDragSource: function(element) {
        if (element["draggable"]) {
          element.addEventListener("dragstart", this.__dragstartListener, false);
          element.addEventListener("dragend", this.__dragendListener, false);
        } else {
          element.removeEventListener("dragstart", this.__dragstartListener, false);
          element.removeEventListener("dragend", this.__dragendListener, false);
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1(
      "vaadin-field-outline",
      css$e`
    :host {
      transition: opacity 0.3s;
      -webkit-mask-image: none !important;
      mask-image: none !important;
    }

    :host::before {
      content: '';
      position: absolute;
      inset: 0;
      box-shadow: 0 0 0 2px var(--_active-user-color);
      border-radius: var(--lumo-border-radius-s);
      transition: box-shadow 0.3s;
    }

    :host([context$='checkbox'])::before {
      box-shadow: 0 0 0 2px var(--lumo-base-color), 0 0 0 4px var(--_active-user-color);
    }

    :host([context$='radio-button'])::before {
      border-radius: 50%;
      box-shadow: 0 0 0 3px var(--lumo-base-color), 0 0 0 5px var(--_active-user-color);
    }

    :host([context$='item'])::before {
      box-shadow: inset 0 0 0 2px var(--_active-user-color);
    }
  `,
      { moduleId: "lumo-field-outline" }
    );
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1(
      "vaadin-user-tags-overlay",
      [
        overlay,
        css$e`
      [part='overlay'] {
        will-change: opacity, transform;
      }

      :host([opening]) [part='overlay'] {
        animation: 0.1s lumo-user-tags-enter ease-out both;
      }

      @keyframes lumo-user-tags-enter {
        0% {
          opacity: 0;
        }
      }

      :host([closing]) [part='overlay'] {
        animation: 0.1s lumo-user-tags-exit both;
      }

      @keyframes lumo-user-tags-exit {
        100% {
          opacity: 0;
        }
      }
    `
      ],
      {
        moduleId: "lumo-user-tags-overlay"
      }
    );
    registerStyles$1(
      "vaadin-user-tag",
      css$e`
    :host {
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-xxs);
      border-radius: var(--lumo-border-radius-s);
      box-shadow: var(--lumo-box-shadow-xs);
      --vaadin-user-tag-offset: var(--lumo-space-xs);
    }

    [part='name'] {
      color: var(--lumo-primary-contrast-color);
      padding: 0.3em calc(0.3em + var(--lumo-border-radius-s) / 4);
      line-height: 1;
      font-weight: 500;
      min-width: calc(var(--lumo-line-height-xs) * 1em + 0.45em);
    }
  `,
      { moduleId: "lumo-user-tag" }
    );
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class UserTag extends ThemableMixin(DirMixin(PolymerElement)) {
      static get is() {
        return "vaadin-user-tag";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: block;
          box-sizing: border-box;
          margin: 0 0 var(--vaadin-user-tag-offset);
          opacity: 0;
          height: 1.3rem;
          transition: opacity 0.2s ease-in-out;
          background-color: var(--vaadin-user-tag-color);
          color: #fff;
          cursor: default;
          -webkit-user-select: none;
          user-select: none;
          --vaadin-user-tag-offset: 4px;
        }

        :host(.show) {
          opacity: 1;
        }

        :host(:last-of-type) {
          margin-bottom: 0;
        }

        [part='name'] {
          overflow: hidden;
          white-space: nowrap;
          text-overflow: ellipsis;
          box-sizing: border-box;
          padding: 2px 4px;
          height: 1.3rem;
          font-size: 13px;
        }
      </style>
      <div part="name">[[name]]</div>
    `;
      }
      static get properties() {
        return {
          /**
           * Name of the user.
           */
          name: {
            type: String
          },
          /**
           * Id of the user.
           */
          uid: {
            type: String
          },
          /**
           * Color index of the user.
           */
          colorIndex: {
            type: Number,
            observer: "_colorIndexChanged"
          }
        };
      }
      /** @protected */
      ready() {
        super.ready();
        this.addEventListener("mousedown", this._onClick.bind(this), true);
      }
      /** @private */
      _colorIndexChanged(index) {
        if (index != null) {
          this.style.setProperty("--vaadin-user-tag-color", `var(--vaadin-user-color-${index})`);
        }
      }
      /**
       * @param {Event} e
       * @private
       */
      _onClick(e2) {
        e2.preventDefault();
        this.dispatchEvent(
          new CustomEvent("user-tag-click", {
            bubbles: true,
            composed: true,
            detail: {
              name: this.name
            }
          })
        );
      }
    }
    defineCustomElement(UserTag);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const userTagsOverlayStyles = css$e`
  :host {
    background: transparent;
    box-shadow: none;
  }

  [part='overlay'] {
    box-shadow: none;
    background: transparent;
    position: relative;
    left: -4px;
    padding: 4px;
    outline: none;
    overflow: visible;
  }

  ::slotted([part='tags']) {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }

  :host([dir='rtl']) [part='overlay'] {
    left: auto;
    right: -4px;
  }

  [part='content'] {
    padding: 0;
  }

  :host([opening]),
  :host([closing]) {
    animation: 0.14s user-tags-overlay-dummy-animation;
  }

  @keyframes user-tags-overlay-dummy-animation {
    0% {
      opacity: 1;
    }

    100% {
      opacity: 1;
    }
  }
`;
    registerStyles$1("vaadin-user-tags-overlay", [overlayStyles, userTagsOverlayStyles]);
    class UserTagsOverlay extends PositionMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
      static get is() {
        return "vaadin-user-tags-overlay";
      }
      static get template() {
        return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
      }
    }
    defineCustomElement(UserTagsOverlay);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const listenOnce = (elem, type) => {
      return new Promise((resolve) => {
        const listener = () => {
          elem.removeEventListener(type, listener);
          resolve();
        };
        elem.addEventListener(type, listener);
      });
    };
    class UserTags extends PolymerElement {
      static get is() {
        return "vaadin-user-tags";
      }
      static get template() {
        return html`
      <style>
        :host {
          position: absolute;
        }
      </style>
      <vaadin-user-tags-overlay
        id="overlay"
        modeless
        opened="[[opened]]"
        no-vertical-overlap
        on-vaadin-overlay-open="_onOverlayOpen"
      ></vaadin-user-tags-overlay>
    `;
      }
      static get properties() {
        return {
          /**
           * True when the field has focus. In this case, the overlay
           * with a list of the user tags needs to be always visible.
           */
          hasFocus: {
            type: Boolean,
            value: false,
            observer: "_hasFocusChanged"
          },
          /**
           * True when the overlay is opened.
           */
          opened: {
            type: Boolean,
            value: false
          },
          /**
           * True when the overlay is flashing: quickly shown and then hidden
           * once a different user starts to interact with the field.
           */
          flashing: {
            type: Boolean,
            value: false
          },
          /**
           * A target element that the overlay is positioned to.
           */
          target: {
            type: Object,
            observer: "__targetChanged"
          },
          /**
           * A list of users who focused the field.
           */
          users: {
            type: Array,
            value: () => []
          },
          duration: {
            type: Number,
            value: 200
          },
          delay: {
            type: Number,
            value: 2e3
          },
          /** @private */
          __flashQueue: {
            type: Array,
            value: () => []
          },
          /** @private */
          __isTargetVisible: {
            type: Boolean,
            value: false
          }
        };
      }
      constructor() {
        super();
        this.__targetVisibilityObserver = new IntersectionObserver(
          ([entry]) => {
            this.__onTargetVisibilityChange(entry.isIntersecting);
          },
          { threshold: 1 }
        );
      }
      /** @protected */
      get wrapper() {
        return this.$.overlay.querySelector('[part="tags"]');
      }
      /** @protected */
      connectedCallback() {
        super.connectedCallback();
        if (this.target) {
          this.__targetVisibilityObserver.observe(this.target);
        }
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.opened = false;
        if (this.target) {
          this.__targetVisibilityObserver.unobserve(this.target);
        }
      }
      /** @protected */
      ready() {
        super.ready();
        this.$.overlay.renderer = (root2) => {
          if (!root2.firstChild) {
            const tags = document.createElement("div");
            tags.setAttribute("part", "tags");
            root2.appendChild(tags);
          }
        };
        this.$.overlay.requestContentUpdate();
      }
      /** @private */
      __onTargetVisibilityChange(isVisible) {
        this.__isTargetVisible = isVisible;
        if (isVisible && this.__flashQueue.length > 0 && !this.flashing) {
          this.flashTags(this.__flashQueue.shift());
          return;
        }
        if (isVisible && this.hasFocus) {
          this.opened = true;
          return;
        }
        if (!isVisible && this.opened) {
          this.opened = false;
        }
      }
      /** @private */
      __targetChanged(newTarget, oldTarget) {
        this.$.overlay.positionTarget = newTarget;
        if (oldTarget) {
          this.__targetVisibilityObserver.unobserve(oldTarget);
        }
        if (newTarget) {
          this.__targetVisibilityObserver.observe(newTarget);
        }
      }
      /** @private */
      _hasFocusChanged(hasFocus) {
        if (hasFocus && this.flashing) {
          this.stopFlash();
        }
      }
      createUserTag(user) {
        const tag = document.createElement("vaadin-user-tag");
        tag.name = user.name;
        tag.uid = user.id;
        tag.colorIndex = user.colorIndex;
        return tag;
      }
      getTagForUser(user) {
        return Array.from(this.wrapper.children).find((tag) => tag.uid === user.id);
      }
      getChangedTags(addedUsers, removedUsers) {
        const removed = removedUsers.map((user) => this.getTagForUser(user));
        const added = addedUsers.map((user) => this.getTagForUser(user) || this.createUserTag(user));
        return { added, removed };
      }
      getChangedUsers(users, splices) {
        const usersToAdd = [];
        const usersToRemove = [];
        splices.forEach((splice) => {
          splice.removed.forEach((user) => {
            usersToRemove.push(user);
          });
          for (let i = splice.addedCount - 1; i >= 0; i--) {
            usersToAdd.push(users[splice.index + i]);
          }
        });
        const addedUsers = usersToAdd.filter((u) => !usersToRemove.some((u2) => u.id === u2.id));
        const removedUsers = usersToRemove.filter((u) => !usersToAdd.some((u2) => u.id === u2.id));
        return { addedUsers, removedUsers };
      }
      applyTagsStart({ added, removed }) {
        const wrapper = this.wrapper;
        removed.forEach((tag) => {
          if (tag) {
            tag.classList.add("removing");
            tag.classList.remove("show");
          }
        });
        added.forEach((tag) => wrapper.insertBefore(tag, wrapper.firstChild));
      }
      applyTagsEnd({ added, removed }) {
        const wrapper = this.wrapper;
        removed.forEach((tag) => {
          if (tag && tag.parentNode === wrapper) {
            wrapper.removeChild(tag);
          }
        });
        added.forEach((tag) => tag && tag.classList.add("show"));
      }
      setUsers(users) {
        this.requestContentUpdate();
        const splices = calculateSplices(users, this.users);
        if (splices.length === 0) {
          return;
        }
        const { addedUsers, removedUsers } = this.getChangedUsers(users, splices);
        if (addedUsers.length === 0 && removedUsers.length === 0) {
          return;
        }
        const changedTags = this.getChangedTags(addedUsers, removedUsers);
        if (this.__flashQueue.length > 0) {
          removedUsers.forEach((user, i) => {
            if (changedTags.removed[i] === null) {
              return;
            }
            this.__flashQueue.forEach((tags) => {
              if (tags.some((tag) => tag.uid === user.id)) {
                this.splice("__flashQueue", i, 1);
              }
            });
          });
        }
        if (this.opened && this.hasFocus) {
          this.updateTags(users, changedTags);
        } else if (addedUsers.length > 0 && document.visibilityState !== "hidden") {
          const addedTags = changedTags.added;
          const removedTags = changedTags.removed;
          this.updateTagsSync(users, {
            added: [],
            removed: removedTags
          });
          if (this.flashing || !this.__isTargetVisible) {
            this.push("__flashQueue", addedTags);
          } else {
            this.flashTags(addedTags);
          }
        } else {
          this.updateTagsSync(users, changedTags);
        }
      }
      /** @private */
      _onOverlayOpen() {
        Array.from(this.wrapper.children).forEach((tag) => {
          if (!tag.classList.contains("removing")) {
            tag.classList.add("show");
          }
        });
      }
      flashTags(added) {
        this.flashing = true;
        const wrapper = this.wrapper;
        const hidden = Array.from(wrapper.children);
        hidden.forEach((tag) => {
          tag.style.display = "none";
        });
        added.forEach((tag) => {
          wrapper.insertBefore(tag, wrapper.firstChild);
        });
        this.flashPromise = new Promise((resolve) => {
          listenOnce(this.$.overlay, "vaadin-overlay-open").then(() => {
            this._debounceFlashStart = Debouncer$1.debounce(
              this._debounceFlashStart,
              timeOut$1.after(this.duration + this.delay),
              () => {
                if (!this.hasFocus) {
                  added.forEach((tag) => tag.classList.remove("show"));
                }
                this._debounceFlashEnd = Debouncer$1.debounce(this._debounceFlashEnd, timeOut$1.after(this.duration), () => {
                  const finishFlash = () => {
                    hidden.forEach((tag) => {
                      tag.style.display = "block";
                    });
                    this.flashing = false;
                    resolve();
                  };
                  if (this.hasFocus) {
                    finishFlash();
                  } else {
                    listenOnce(this.$.overlay, "animationend").then(() => {
                      finishFlash();
                    });
                    this.opened = false;
                  }
                });
              }
            );
          });
        }).then(() => {
          if (this.__flashQueue.length > 0) {
            const tags = this.__flashQueue[0];
            this.splice("__flashQueue", 0, 1);
            this.flashTags(tags);
          }
        });
        this.opened = true;
      }
      stopFlash() {
        if (this._debounceFlashStart) {
          this._debounceFlashStart.flush();
        }
        if (this._debounceFlashEnd) {
          this._debounceFlashEnd.flush();
        }
        this.$.overlay._flushAnimation("closing");
      }
      updateTags(users, changed) {
        this.applyTagsStart(changed);
        this._debounceRender = Debouncer$1.debounce(this._debounceRender, timeOut$1.after(this.duration), () => {
          this.set("users", users);
          this.applyTagsEnd(changed);
          if (users.length === 0 && this.opened) {
            this.opened = false;
          }
        });
      }
      updateTagsSync(users, changed) {
        this.applyTagsStart(changed);
        this.set("users", users);
        this.applyTagsEnd(changed);
      }
      show() {
        this.hasFocus = true;
        if (this.__isTargetVisible) {
          this.opened = true;
        }
      }
      hide() {
        this.hasFocus = false;
        this.opened = false;
      }
      requestContentUpdate() {
        if (this._debounceRender && this._debounceRender.isActive()) {
          this._debounceRender.flush();
        }
      }
    }
    defineCustomElement(UserTags);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class FieldOutline extends ThemableMixin(DirMixin(PolymerElement)) {
      static get is() {
        return "vaadin-field-outline";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: block;
          box-sizing: border-box;
          position: absolute;
          inset: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          user-select: none;
          opacity: 0;
          --_active-user-color: transparent;
        }

        :host([has-active-user]) {
          opacity: 1;
        }
      </style>
    `;
      }
      static get properties() {
        return {
          /**
           * A user who last interacted with the field.
           */
          user: {
            type: Object,
            value: null,
            observer: "_userChanged"
          }
        };
      }
      /** @protected */
      ready() {
        super.ready();
        this.setAttribute("part", "outline");
        this._field = this.getRootNode().host;
      }
      /** @private */
      _userChanged(user) {
        this.toggleAttribute("has-active-user", Boolean(user));
        const value = user ? `var(--vaadin-user-color-${user.colorIndex})` : "transparent";
        const prop = "--_active-user-color";
        this.style.setProperty(prop, value);
        if (this._field) {
          this._field.style.setProperty(prop, value);
        }
      }
    }
    defineCustomElement(FieldOutline);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const getOutlineTarget = (element, tagName) => {
      switch (tagName) {
        case "vaadin-big-decimal-field":
        case "vaadin-combo-box":
        case "vaadin-date-picker":
        case "vaadin-email-field":
        case "vaadin-integer-field":
        case "vaadin-number-field":
        case "vaadin-password-field":
        case "vaadin-select":
        case "vaadin-text-area":
        case "vaadin-text-field":
        case "vaadin-time-picker":
          return element.shadowRoot.querySelector('[part="input-field"]');
        case "vaadin-checkbox":
          return element.shadowRoot.querySelector('[part="checkbox"]');
        case "vaadin-radio-button":
          return element.shadowRoot.querySelector('[part="radio"]');
        default:
          return element;
      }
    };
    const fields = /* @__PURE__ */ new WeakMap();
    const initOutline = (field) => {
      if (!fields.has(field)) {
        const tagName = field.tagName.toLowerCase();
        const target = getOutlineTarget(field, tagName);
        target.style.position = "relative";
        if (tagName.endsWith("text-area")) {
          target.style.overflow = "visible";
        }
        const style = document.createElement("style");
        style.textContent = `
      :host([active]) [part="outline"],
      :host([focus-ring]) [part="outline"] {
        display: none;
      }
    `;
        field.shadowRoot.appendChild(style);
        const outline = document.createElement("vaadin-field-outline");
        (target === field ? field.shadowRoot : target).appendChild(outline);
        outline.setAttribute("context", tagName);
        fields.set(field, { root: field, target, outline });
      }
      return fields.get(field);
    };
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class ComponentObserver {
      constructor(component) {
        this.component = component;
        this.initTags(component);
      }
      getFields() {
        return [this.component];
      }
      getFieldIndex(field) {
        return this.getFields().indexOf(field);
      }
      getFocusTarget(_event) {
        return this.component;
      }
      initTags(component) {
        const tags = document.createElement("vaadin-user-tags");
        component.shadowRoot.appendChild(tags);
        tags.target = component;
        this._tags = tags;
        component.addEventListener("mouseenter", (event) => {
          if (event.relatedTarget === this._tags.$.overlay) {
            return;
          }
          this._mouse = true;
          this._mouseDebouncer = Debouncer$1.debounce(this._mouseDebouncer, timeOut$1.after(200), () => {
            if (this._mouse) {
              this._tags.show();
            }
          });
        });
        component.addEventListener("mouseleave", (event) => {
          if (event.relatedTarget === this._tags.$.overlay) {
            return;
          }
          this._mouse = false;
          if (!this._hasFocus) {
            this._tags.hide();
          }
        });
        component.addEventListener("vaadin-highlight-show", (_event) => {
          this._hasFocus = true;
          if (this._debouncer && this._debouncer.isActive()) {
            this._debouncer.cancel();
          } else {
            this._tags.show();
          }
        });
        component.addEventListener("vaadin-highlight-hide", (_event) => {
          this._hasFocus = false;
          if (!this._mouse) {
            this._debouncer = Debouncer$1.debounce(this._debouncer, timeOut$1.after(1), () => {
              this._tags.hide();
            });
          }
        });
        this._tags.$.overlay.addEventListener("mouseleave", (event) => {
          if (event.relatedTarget === component) {
            return;
          }
          this._mouse = false;
          if (!component.hasAttribute("focused")) {
            this._tags.hide();
          }
        });
      }
      setOutlines(users) {
        const fields2 = this.getFields();
        fields2.forEach((field, idx) => {
          const { outline } = initOutline(field);
          const index = fields2.length === 1 ? 0 : users.map((user) => user.fieldIndex).indexOf(idx);
          outline.user = users[index];
        });
      }
      showOutline(field) {
        this.fire("show", field);
      }
      hideOutline(field) {
        this.fire("hide", field);
      }
      fire(action, field) {
        this.component.dispatchEvent(
          new CustomEvent(`vaadin-highlight-${action}`, {
            bubbles: true,
            composed: true,
            detail: { fieldIndex: this.getFieldIndex(field) }
          })
        );
      }
      redraw(users) {
        this._tags.setUsers(users);
        this.setOutlines(users);
      }
    }
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class FieldObserver extends ComponentObserver {
      constructor(field) {
        super(field);
        this.addListeners(field);
      }
      addListeners(field) {
        field.addEventListener("focusin", (event) => this.onFocusIn(event));
        field.addEventListener("focusout", (event) => this.onFocusOut(event));
      }
      onFocusIn(event) {
        const target = this.getFocusTarget(event);
        this.showOutline(target);
      }
      onFocusOut(event) {
        const target = this.getFocusTarget(event);
        this.hideOutline(target);
      }
    }
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class CheckboxGroupObserver extends FieldObserver {
      getFields() {
        return this.component.__checkboxes;
      }
      getFocusTarget(event) {
        const fields2 = this.getFields();
        return Array.from(event.composedPath()).find((node) => fields2.includes(node));
      }
    }
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class DatePickerObserver extends ComponentObserver {
      constructor(datePicker2) {
        super(datePicker2);
        this.datePicker = datePicker2;
        this.fullscreenFocus = false;
        this.blurWhileOpened = false;
        this.addListeners(datePicker2);
      }
      addListeners(datePicker2) {
        this.overlay = datePicker2.$.overlay;
        datePicker2.addEventListener("blur", (event) => this.onBlur(event), true);
        datePicker2.addEventListener("opened-changed", (event) => this.onOpenedChanged(event));
        this.overlay.addEventListener("focusout", (event) => this.onOverlayFocusOut(event));
        datePicker2.addEventListener("focusin", (event) => this.onFocusIn(event));
        datePicker2.addEventListener("focusout", (event) => this.onFocusOut(event));
      }
      isEventInOverlay(node) {
        return this.datePicker._overlayContent && this.datePicker._overlayContent.contains(node);
      }
      onBlur(event) {
        const datePicker2 = this.datePicker;
        if (datePicker2._fullscreen && !this.isEventInOverlay(event.relatedTarget)) {
          this.fullscreenFocus = true;
        }
      }
      onFocusIn(event) {
        if (this.isEventInOverlay(event.relatedTarget)) {
          return;
        }
        if (this.blurWhileOpened) {
          this.blurWhileOpened = false;
          return;
        }
        this.showOutline(this.datePicker);
      }
      onFocusOut(event) {
        if (this.fullscreenFocus || this.isEventInOverlay(event.relatedTarget)) ;
        else if (!this.datePicker.opened) {
          this.hideOutline(this.datePicker);
        } else {
          this.blurWhileOpened = true;
        }
      }
      onOverlayFocusOut(event) {
        if (!this.datePicker.contains(event.relatedTarget)) {
          this.blurWhileOpened = true;
        }
      }
      onOpenedChanged(event) {
        if (event.detail.value === true && this.fullscreenFocus) {
          this.fullscreenFocus = false;
          this.showOutline(this.datePicker);
        }
        if (event.detail.value === false && this.blurWhileOpened) {
          this.blurWhileOpened = false;
          this.hideOutline(this.datePicker);
        }
      }
    }
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class DateObserver extends DatePickerObserver {
      constructor(datePicker2, host) {
        super(datePicker2);
        this.component = host;
      }
      getFieldIndex() {
        return 0;
      }
    }
    class TimeObserver extends FieldObserver {
      constructor(timePicker2, host) {
        super(timePicker2);
        this.component = host;
        this.timePicker = timePicker2;
      }
      getFocusTarget(_event) {
        return this.timePicker;
      }
      getFieldIndex() {
        return 1;
      }
    }
    class DateTimePickerObserver extends ComponentObserver {
      constructor(picker) {
        super(picker);
        const [datePicker2, timePicker2] = this.getFields();
        this.dateObserver = new DateObserver(datePicker2, picker);
        this.timeObserver = new TimeObserver(timePicker2, picker);
      }
      getFields() {
        return this.component.__inputs;
      }
    }
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class ListBoxObserver extends FieldObserver {
      getFields() {
        return this.component.items || [];
      }
      getFocusTarget(event) {
        const fields2 = this.getFields();
        return Array.from(event.composedPath()).find((node) => fields2.includes(node));
      }
    }
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class RadioGroupObserver extends FieldObserver {
      getFields() {
        return this.component.__radioButtons;
      }
      getFocusTarget(event) {
        const fields2 = this.getFields();
        return Array.from(event.composedPath()).find((node) => fields2.includes(node));
      }
    }
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class SelectObserver extends FieldObserver {
      constructor(select) {
        super(select);
        this.blurWhileOpened = false;
        this.overlay = select._overlayElement;
      }
      addListeners(select) {
        super.addListeners(select);
        select.addEventListener("opened-changed", (event) => {
          if (select._phone && event.detail.value === false) {
            this.hideOutline(select);
          }
        });
      }
      onFocusIn(event) {
        if (this.overlay.contains(event.relatedTarget)) {
          return;
        }
        if (!this.component._phone && this.overlay.hasAttribute("closing")) {
          return;
        }
        super.onFocusIn(event);
      }
      onFocusOut(event) {
        if (this.overlay.contains(event.relatedTarget)) {
          return;
        }
        super.onFocusOut(event);
      }
    }
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const initFieldObserver = (field) => {
      let result2;
      switch (field.tagName.toLowerCase()) {
        case "vaadin-date-picker":
          result2 = new DatePickerObserver(field);
          break;
        case "vaadin-date-time-picker":
          result2 = new DateTimePickerObserver(field);
          break;
        case "vaadin-select":
          result2 = new SelectObserver(field);
          break;
        case "vaadin-checkbox-group":
          result2 = new CheckboxGroupObserver(field);
          break;
        case "vaadin-radio-group":
          result2 = new RadioGroupObserver(field);
          break;
        case "vaadin-list-box":
          result2 = new ListBoxObserver(field);
          break;
        default:
          result2 = new FieldObserver(field);
      }
      return result2;
    };
    class FieldHighlighterController {
      constructor(host) {
        this.host = host;
        this.user = null;
        this.users = [];
      }
      get user() {
        return this._user;
      }
      set user(user) {
        this._user = user;
        if (user) {
          const msg = `${user.name} started editing`;
          const { label } = this.host;
          announce(label ? `${msg} ${label}` : msg);
        }
      }
      hostConnected() {
        this.redraw();
      }
      addUser(user) {
        if (user) {
          this.users.push(user);
          this.redraw();
          this.user = user;
        }
      }
      setUsers(users) {
        if (Array.isArray(users)) {
          this.users = users;
          this.redraw();
          this.user = users[users.length - 1] || null;
        }
      }
      removeUser(user) {
        if (user && user.id !== void 0) {
          let index;
          for (let i = 0; i < this.users.length; i++) {
            if (this.users[i].id === user.id) {
              index = i;
              break;
            }
          }
          if (index !== void 0) {
            this.users.splice(index, 1);
            this.redraw();
            if (this.users.length > 0) {
              this.user = this.users[this.users.length - 1];
            } else {
              this.user = null;
            }
          }
        }
      }
      redraw() {
        this.observer.redraw([...this.users].reverse());
      }
    }
    class FieldHighlighter extends HTMLElement {
      static get is() {
        return "vaadin-field-highlighter";
      }
      static init(field) {
        if (!field._highlighterController) {
          const instance = new FieldHighlighterController(field);
          field.setAttribute("has-highlighter", "");
          instance.observer = initFieldObserver(field);
          field.addController(instance);
          field._highlighterController = instance;
        }
        return field._highlighterController;
      }
      static addUser(field, user) {
        this.init(field).addUser(user);
      }
      static removeUser(field, user) {
        this.init(field).removeUser(user);
      }
      static setUsers(field, users) {
        this.init(field).setUsers(users);
      }
    }
    defineCustomElement(FieldHighlighter);
    registerStyles$1(
      "vaadin-form-layout",
      css$e`
    :host {
      --vaadin-form-layout-column-spacing: var(--lumo-space-l);
    }
  `,
      { moduleId: "lumo-form-layout" }
    );
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class FormLayout extends ResizeMixin(ElementMixin(ThemableMixin(PolymerElement))) {
      static get template() {
        return html`
      <style>
        :host {
          display: block;
          max-width: 100%;
          animation: 1ms vaadin-form-layout-appear;
          /* CSS API for host */
          --vaadin-form-item-label-width: 8em;
          --vaadin-form-item-label-spacing: 1em;
          --vaadin-form-item-row-spacing: 1em;
          --vaadin-form-layout-column-spacing: 2em; /* (default) */
          align-self: stretch;
        }

        @keyframes vaadin-form-layout-appear {
          to {
            opacity: 1 !important; /* stylelint-disable-line keyframe-declaration-no-important */
          }
        }

        :host([hidden]) {
          display: none !important;
        }

        #layout {
          display: flex;

          align-items: baseline; /* default \`stretch\` is not appropriate */

          flex-wrap: wrap; /* the items should wrap */
        }

        #layout ::slotted(*) {
          /* Items should neither grow nor shrink. */
          flex-grow: 0;
          flex-shrink: 0;

          /* Margins make spacing between the columns */
          margin-left: calc(0.5 * var(--vaadin-form-layout-column-spacing));
          margin-right: calc(0.5 * var(--vaadin-form-layout-column-spacing));
        }

        #layout ::slotted(br) {
          display: none;
        }
      </style>
      <div id="layout">
        <slot id="slot"></slot>
      </div>
    `;
      }
      static get is() {
        return "vaadin-form-layout";
      }
      static get properties() {
        return {
          /**
           * @typedef FormLayoutResponsiveStep
           * @type {object}
           * @property {string} minWidth - The threshold value for this step in CSS length units.
           * @property {number} columns - Number of columns. Only natural numbers are valid.
           * @property {string} labelsPosition - Labels position option, valid values: `"aside"` (default), `"top"`.
           */
          /**
           * Allows specifying a responsive behavior with the number of columns
           * and the label position depending on the layout width.
           *
           * Format: array of objects, each object defines one responsive step
           * with `minWidth` CSS length, `columns` number, and optional
           * `labelsPosition` string of `"aside"` or `"top"`. At least one item is required.
           *
           * #### Examples
           *
           * ```javascript
           * formLayout.responsiveSteps = [{columns: 1}];
           * // The layout is always a single column, labels aside.
           * ```
           *
           * ```javascript
           * formLayout.responsiveSteps = [
           *   {minWidth: 0, columns: 1},
           *   {minWidth: '40em', columns: 2}
           * ];
           * // Sets two responsive steps:
           * // 1. When the layout width is < 40em, one column, labels aside.
           * // 2. Width >= 40em, two columns, labels aside.
           * ```
           *
           * ```javascript
           * formLayout.responsiveSteps = [
           *   {minWidth: 0, columns: 1, labelsPosition: 'top'},
           *   {minWidth: '20em', columns: 1},
           *   {minWidth: '40em', columns: 2}
           * ];
           * // Default value. Three responsive steps:
           * // 1. Width < 20em, one column, labels on top.
           * // 2. 20em <= width < 40em, one column, labels aside.
           * // 3. Width >= 40em, two columns, labels aside.
           * ```
           *
           * @type {!Array<!FormLayoutResponsiveStep>}
           */
          responsiveSteps: {
            type: Array,
            value() {
              return [
                { minWidth: 0, columns: 1, labelsPosition: "top" },
                { minWidth: "20em", columns: 1 },
                { minWidth: "40em", columns: 2 }
              ];
            },
            observer: "_responsiveStepsChanged"
          },
          /**
           * Current number of columns in the layout
           * @private
           */
          _columnCount: {
            type: Number
          },
          /**
           * Indicates that labels are on top
           * @private
           */
          _labelsOnTop: {
            type: Boolean
          }
        };
      }
      static get observers() {
        return ["_invokeUpdateLayout(_columnCount, _labelsOnTop)"];
      }
      /** @protected */
      ready() {
        this._styleElement = document.createElement("style");
        this.appendChild(this._styleElement);
        this._styleElement.textContent = " ";
        super.ready();
        this.addEventListener("animationend", this.__onAnimationEnd);
      }
      /** @protected */
      connectedCallback() {
        super.connectedCallback();
        requestAnimationFrame(() => this._selectResponsiveStep());
        requestAnimationFrame(() => this._updateLayout());
        this._observeChildrenColspanChange();
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.__mutationObserver.disconnect();
        this.__childObserver.disconnect();
      }
      /** @private */
      _observeChildrenColspanChange() {
        const mutationObserverConfig = { attributes: true };
        this.__mutationObserver = new MutationObserver((mutationRecord) => {
          mutationRecord.forEach((mutation) => {
            if (mutation.type === "attributes" && (mutation.attributeName === "colspan" || mutation.attributeName === "data-colspan" || mutation.attributeName === "hidden")) {
              this._updateLayout();
            }
          });
        });
        [...this.children].forEach((child) => {
          this.__mutationObserver.observe(child, mutationObserverConfig);
        });
        this.__childObserver = new MutationObserver((mutations) => {
          const addedNodes = [];
          const removedNodes = [];
          mutations.forEach((mutation) => {
            addedNodes.push(...this._getObservableNodes(mutation.addedNodes));
            removedNodes.push(...this._getObservableNodes(mutation.removedNodes));
          });
          addedNodes.forEach((child) => {
            this.__mutationObserver.observe(child, mutationObserverConfig);
          });
          if (addedNodes.length > 0 || removedNodes.length > 0) {
            this._updateLayout();
          }
        });
        this.__childObserver.observe(this, { childList: true });
      }
      /** @private */
      _getObservableNodes(nodeList) {
        const ignore = ["template", "style", "dom-repeat", "dom-if"];
        return Array.from(nodeList).filter(
          (node) => node.nodeType === Node.ELEMENT_NODE && ignore.indexOf(node.localName.toLowerCase()) === -1
        );
      }
      /** @private */
      _naturalNumberOrOne(n) {
        if (typeof n === "number" && n >= 1 && n < Infinity) {
          return Math.floor(n);
        }
        return 1;
      }
      /** @private */
      _isValidCSSLength(value) {
        if (value === "inherit" || value === "normal") {
          return false;
        }
        this._styleElement.firstChild.nodeValue = `#styleElement { word-spacing: ${value}; }`;
        if (!this._styleElement.sheet) {
          return true;
        }
        return ["", null].indexOf(this._styleElement.sheet.cssRules[0].style.getPropertyValue("word-spacing")) < 0;
      }
      /** @private */
      _responsiveStepsChanged(responsiveSteps, oldResponsiveSteps) {
        try {
          if (!Array.isArray(responsiveSteps)) {
            throw new Error('Invalid "responsiveSteps" type, an Array is required.');
          }
          if (responsiveSteps.length < 1) {
            throw new Error('Invalid empty "responsiveSteps" array, at least one item is required.');
          }
          responsiveSteps.forEach((step) => {
            if (this._naturalNumberOrOne(step.columns) !== step.columns) {
              throw new Error(`Invalid 'columns' value of ${step.columns}, a natural number is required.`);
            }
            if (step.minWidth !== void 0 && !this._isValidCSSLength(step.minWidth)) {
              throw new Error(`Invalid 'minWidth' value of ${step.minWidth}, a valid CSS length required.`);
            }
            if (step.labelsPosition !== void 0 && ["aside", "top"].indexOf(step.labelsPosition) === -1) {
              throw new Error(
                `Invalid 'labelsPosition' value of ${step.labelsPosition}, 'aside' or 'top' string is required.`
              );
            }
          });
        } catch (e2) {
          if (oldResponsiveSteps && oldResponsiveSteps !== responsiveSteps) {
            console.warn(`${e2.message} Using previously set 'responsiveSteps' instead.`);
            this.responsiveSteps = oldResponsiveSteps;
          } else {
            console.warn(`${e2.message} Using default 'responsiveSteps' instead.`);
            this.responsiveSteps = [
              { minWidth: 0, columns: 1, labelsPosition: "top" },
              { minWidth: "20em", columns: 1 },
              { minWidth: "40em", columns: 2 }
            ];
          }
        }
        this._selectResponsiveStep();
      }
      /** @private */
      __onAnimationEnd(e2) {
        if (e2.animationName.indexOf("vaadin-form-layout-appear") === 0) {
          this._selectResponsiveStep();
        }
      }
      /** @private */
      _selectResponsiveStep() {
        let selectedStep;
        const tmpStyleProp = "background-position";
        this.responsiveSteps.forEach((step) => {
          this.$.layout.style.setProperty(tmpStyleProp, step.minWidth);
          const stepMinWidthPx = parseFloat(getComputedStyle(this.$.layout).getPropertyValue(tmpStyleProp));
          if (stepMinWidthPx <= this.offsetWidth) {
            selectedStep = step;
          }
        });
        this.$.layout.style.removeProperty(tmpStyleProp);
        if (selectedStep) {
          this._columnCount = selectedStep.columns;
          this._labelsOnTop = selectedStep.labelsPosition === "top";
        }
      }
      /** @private */
      _invokeUpdateLayout() {
        this._updateLayout();
      }
      /**
       * Update the layout.
       * @protected
       */
      _updateLayout() {
        const style = getComputedStyle(this);
        const columnSpacing = style.getPropertyValue("--vaadin-form-layout-column-spacing");
        const direction = style.direction;
        const marginStartProp = `margin-${direction === "ltr" ? "left" : "right"}`;
        const marginEndProp = `margin-${direction === "ltr" ? "right" : "left"}`;
        const containerWidth = this.offsetWidth;
        let col = 0;
        Array.from(this.children).filter((child) => child.localName === "br" || getComputedStyle(child).display !== "none").forEach((child, index, children) => {
          if (child.localName === "br") {
            col = 0;
            return;
          }
          const attrColspan = child.getAttribute("colspan") || child.getAttribute("data-colspan");
          let colspan;
          colspan = this._naturalNumberOrOne(parseFloat(attrColspan));
          colspan = Math.min(colspan, this._columnCount);
          const childRatio = colspan / this._columnCount;
          child.style.width = `calc(${childRatio * 99.9}% - ${1 - childRatio} * ${columnSpacing})`;
          if (col + colspan > this._columnCount) {
            col = 0;
          }
          if (col === 0) {
            child.style.setProperty(marginStartProp, "0px");
          } else {
            child.style.removeProperty(marginStartProp);
          }
          const nextIndex = index + 1;
          const nextLineBreak = nextIndex < children.length && children[nextIndex].localName === "br";
          if (col + colspan === this._columnCount) {
            child.style.setProperty(marginEndProp, "0px");
          } else if (nextLineBreak) {
            const colspanRatio = (this._columnCount - col - colspan) / this._columnCount;
            child.style.setProperty(
              marginEndProp,
              `calc(${colspanRatio * containerWidth}px + ${colspanRatio} * ${columnSpacing})`
            );
          } else {
            child.style.removeProperty(marginEndProp);
          }
          col = (col + colspan) % this._columnCount;
          if (child.localName === "vaadin-form-item") {
            if (this._labelsOnTop) {
              if (child.getAttribute("label-position") !== "top") {
                child.__useLayoutLabelPosition = true;
                child.setAttribute("label-position", "top");
              }
            } else if (child.__useLayoutLabelPosition) {
              delete child.__useLayoutLabelPosition;
              child.removeAttribute("label-position");
            }
          }
        });
      }
      /**
       * @protected
       * @override
       */
      _onResize() {
        this._selectResponsiveStep();
      }
    }
    defineCustomElement(FormLayout);
    registerStyles$1(
      "vaadin-form-item",
      css$e`
    :host {
      --vaadin-form-item-row-spacing: 0;
    }

    /* font-weight, margin-bottom, transition and line-height same as for part label in text-field */
    [part='label'] {
      color: var(--lumo-secondary-text-color);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-s);
      font-weight: 500;
      margin-top: var(--lumo-space-m);
      margin-left: calc(var(--lumo-border-radius-m) / 4);
      margin-bottom: var(--lumo-space-xs);
      transition: color 0.4s;
      line-height: 1.333;
    }

    [part='required-indicator']::after {
      content: var(--lumo-required-field-indicator, '\\2022');
      transition: opacity 0.2s;
      opacity: 0;
      color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
      position: relative;
      width: 1em;
      text-align: center;
    }

    :host([required]) [part='required-indicator']::after {
      opacity: 1;
    }

    :host([invalid]) [part='required-indicator']::after {
      color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
    }
  `,
      { moduleId: "lumo-form-item" }
    );
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class FormItem extends ThemableMixin(PolymerElement) {
      static get template() {
        return html`
      <style>
        :host {
          display: inline-flex;
          flex-direction: row;
          align-items: baseline;
          margin: calc(0.5 * var(--vaadin-form-item-row-spacing, 1em)) 0;
        }

        :host([label-position='top']) {
          flex-direction: column;
          align-items: stretch;
        }

        :host([hidden]) {
          display: none !important;
        }

        #label {
          width: var(--vaadin-form-item-label-width, 8em);
          flex: 0 0 auto;
        }

        :host([label-position='top']) #label {
          width: auto;
        }

        #spacing {
          width: var(--vaadin-form-item-label-spacing, 1em);
          flex: 0 0 auto;
        }

        #content {
          flex: 1 1 auto;
        }

        #content ::slotted(.full-width) {
          box-sizing: border-box;
          width: 100%;
          min-width: 0;
        }
      </style>
      <div id="label" part="label" on-click="__onLabelClick">
        <slot name="label" id="labelSlot" on-slotchange="__onLabelSlotChange"></slot>
        <span part="required-indicator" aria-hidden="true"></span>
      </div>
      <div id="spacing"></div>
      <div id="content">
        <slot id="contentSlot" on-slotchange="__onContentSlotChange"></slot>
      </div>
    `;
      }
      static get is() {
        return "vaadin-form-item";
      }
      constructor() {
        super();
        this.__updateInvalidState = this.__updateInvalidState.bind(this);
        this.__fieldNodeObserver = new MutationObserver(() => this.__updateRequiredState(this.__fieldNode.required));
        this.__labelNode = null;
        this.__fieldNode = null;
      }
      /**
       * Returns a target element to add ARIA attributes to for a field.
       *
       * - For Vaadin field components, the method returns an element
       * obtained through the `ariaTarget` property defined in `FieldMixin`.
       * - In other cases, the method returns the field element itself.
       *
       * @param {HTMLElement} field
       * @protected
       */
      _getFieldAriaTarget(field) {
        return field.ariaTarget || field;
      }
      /**
       * Links the label to a field by adding the label id to
       * the `aria-labelledby` attribute of the field's ARIA target element.
       *
       * @param {HTMLElement} field
       * @private
       */
      __linkLabelToField(field) {
        addValueToAttribute(this._getFieldAriaTarget(field), "aria-labelledby", this.__labelId);
      }
      /**
       * Unlinks the label from a field by removing the label id from
       * the `aria-labelledby` attribute of the field's ARIA target element.
       *
       * @param {HTMLElement} field
       * @private
       */
      __unlinkLabelFromField(field) {
        removeValueFromAttribute(this._getFieldAriaTarget(field), "aria-labelledby", this.__labelId);
      }
      /** @private */
      __onLabelClick() {
        const fieldNode = this.__fieldNode;
        if (fieldNode) {
          fieldNode.focus();
          fieldNode.click();
        }
      }
      /** @private */
      __getValidateFunction(field) {
        return field.validate || field.checkValidity;
      }
      /**
       * A `slotchange` event handler for the label slot.
       *
       * - Ensures the label id is only assigned to the first label node.
       * - Ensures the label node is linked to the first field node via the `aria-labelledby` attribute
       * if both nodes are provided, and unlinked otherwise.
       *
       * @private
       */
      __onLabelSlotChange() {
        if (this.__labelNode) {
          this.__labelNode = null;
          if (this.__fieldNode) {
            this.__unlinkLabelFromField(this.__fieldNode);
          }
        }
        const newLabelNode = this.$.labelSlot.assignedElements()[0];
        if (newLabelNode) {
          this.__labelNode = newLabelNode;
          if (this.__labelNode.id) {
            this.__labelId = this.__labelNode.id;
          } else {
            this.__labelId = `label-${this.localName}-${generateUniqueId()}`;
            this.__labelNode.id = this.__labelId;
          }
          if (this.__fieldNode) {
            this.__linkLabelToField(this.__fieldNode);
          }
        }
      }
      /**
       * A `slotchange` event handler for the content slot.
       *
       * - Ensures the label node is only linked to the first field node via the `aria-labelledby` attribute.
       * - Sets up an observer for the `required` attribute changes on the first field
       * to reflect the attribute on the component. Ensures the observer is disconnected from the field
       * as soon as it is removed or replaced by another one.
       *
       * @private
       */
      __onContentSlotChange() {
        if (this.__fieldNode) {
          this.__unlinkLabelFromField(this.__fieldNode);
          this.__updateRequiredState(false);
          this.__fieldNodeObserver.disconnect();
          this.__fieldNode = null;
        }
        const fieldNodes = this.$.contentSlot.assignedElements();
        if (fieldNodes.length > 1) {
          console.warn(
            `WARNING: Since Vaadin 23, placing multiple fields directly to a <vaadin-form-item> is deprecated.
Please wrap fields with a <vaadin-custom-field> instead.`
          );
        }
        const newFieldNode = fieldNodes.find((field) => {
          return !!this.__getValidateFunction(field);
        });
        if (newFieldNode) {
          this.__fieldNode = newFieldNode;
          this.__updateRequiredState(this.__fieldNode.required);
          this.__fieldNodeObserver.observe(this.__fieldNode, { attributes: true, attributeFilter: ["required"] });
          if (this.__labelNode) {
            this.__linkLabelToField(this.__fieldNode);
          }
        }
      }
      /** @private */
      __updateRequiredState(required) {
        if (required) {
          this.setAttribute("required", "");
          this.__fieldNode.addEventListener("blur", this.__updateInvalidState);
          this.__fieldNode.addEventListener("change", this.__updateInvalidState);
        } else {
          this.removeAttribute("invalid");
          this.removeAttribute("required");
          this.__fieldNode.removeEventListener("blur", this.__updateInvalidState);
          this.__fieldNode.removeEventListener("change", this.__updateInvalidState);
        }
      }
      /** @private */
      __updateInvalidState() {
        const isValid2 = this.__getValidateFunction(this.__fieldNode).call(this.__fieldNode);
        this.toggleAttribute("invalid", isValid2 === false);
      }
    }
    defineCustomElement(FormItem);
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const GridColumnGroupMixin = (superClass) => class extends ColumnBaseMixin(superClass) {
      static get properties() {
        return {
          /** @private */
          _childColumns: {
            value() {
              return this._getChildColumns(this);
            }
          },
          /**
           * Flex grow ratio for the column group as the sum of the ratios of its child columns.
           * @attr {number} flex-grow
           */
          flexGrow: {
            type: Number,
            readOnly: true,
            sync: true
          },
          /**
           * Width of the column group as the sum of the widths of its child columns.
           */
          width: {
            type: String,
            readOnly: true
          },
          /** @private */
          _visibleChildColumns: Array,
          /** @private */
          _colSpan: Number,
          /** @private */
          _rootColumns: Array
        };
      }
      static get observers() {
        return [
          "_groupFrozenChanged(frozen, _rootColumns)",
          "_groupFrozenToEndChanged(frozenToEnd, _rootColumns)",
          "_groupHiddenChanged(hidden)",
          "_colSpanChanged(_colSpan, _headerCell, _footerCell)",
          "_groupOrderChanged(_order, _rootColumns)",
          "_groupReorderStatusChanged(_reorderStatus, _rootColumns)",
          "_groupResizableChanged(resizable, _rootColumns)"
        ];
      }
      /** @protected */
      connectedCallback() {
        super.connectedCallback();
        this._addNodeObserver();
        this._updateFlexAndWidth();
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback();
        if (this._observer) {
          this._observer.disconnect();
        }
      }
      /**
       * @param {string} path
       * @param {unknown=} value
       * @protected
       */
      _columnPropChanged(path, value) {
        if (path === "hidden") {
          this._preventHiddenSynchronization = true;
          this._updateVisibleChildColumns(this._childColumns);
          this._preventHiddenSynchronization = false;
        }
        if (/flexGrow|width|hidden|_childColumns/u.test(path)) {
          this._updateFlexAndWidth();
        }
        if (path === "frozen" && !this.frozen) {
          this.frozen = value;
        }
        if (path === "lastFrozen" && !this._lastFrozen) {
          this._lastFrozen = value;
        }
        if (path === "frozenToEnd" && !this.frozenToEnd) {
          this.frozenToEnd = value;
        }
        if (path === "firstFrozenToEnd" && !this._firstFrozenToEnd) {
          this._firstFrozenToEnd = value;
        }
      }
      /** @private */
      _groupOrderChanged(order, rootColumns) {
        if (rootColumns) {
          const _rootColumns = rootColumns.slice(0);
          if (!order) {
            _rootColumns.forEach((column) => {
              column._order = 0;
            });
            return;
          }
          const trailingZeros = /(0+)$/u.exec(order).pop().length;
          const childCountDigits = ~~(Math.log(rootColumns.length) / Math.LN10) + 1;
          const scope = 10 ** (trailingZeros - childCountDigits);
          if (_rootColumns[0] && _rootColumns[0]._order) {
            _rootColumns.sort((a, b) => a._order - b._order);
          }
          updateColumnOrders(_rootColumns, scope, order);
        }
      }
      /** @private */
      _groupReorderStatusChanged(reorderStatus, rootColumns) {
        if (reorderStatus === void 0 || rootColumns === void 0) {
          return;
        }
        rootColumns.forEach((column) => {
          column._reorderStatus = reorderStatus;
        });
      }
      /** @private */
      _groupResizableChanged(resizable, rootColumns) {
        if (resizable === void 0 || rootColumns === void 0) {
          return;
        }
        rootColumns.forEach((column) => {
          column.resizable = resizable;
        });
      }
      /** @private */
      _updateVisibleChildColumns(childColumns) {
        this._visibleChildColumns = Array.prototype.filter.call(childColumns, (col) => !col.hidden);
        this._colSpan = this._visibleChildColumns.length;
        this._updateAutoHidden();
      }
      /** @protected */
      _updateFlexAndWidth() {
        if (!this._visibleChildColumns) {
          return;
        }
        if (this._visibleChildColumns.length > 0) {
          const width = this._visibleChildColumns.reduce((prev, curr) => {
            prev += ` + ${(curr.width || "0px").replace("calc", "")}`;
            return prev;
          }, "").substring(3);
          this._setWidth(`calc(${width})`);
        } else {
          this._setWidth("0px");
        }
        this._setFlexGrow(
          Array.prototype.reduce.call(this._visibleChildColumns, (prev, curr) => prev + curr.flexGrow, 0)
        );
      }
      /**
       * This method is called before the group's frozen value is being propagated to the child columns.
       * In case some of the child columns are frozen, while others are not, the non-frozen ones
       * will get automatically frozen as well. As this may sometimes be unintended, this method
       * shows a warning in the console in such cases.
       * @private
       */
      __scheduleAutoFreezeWarning(columns, frozenProp) {
        if (this._grid) {
          const frozenAttr = frozenProp.replace(/([A-Z])/gu, "-$1").toLowerCase();
          const firstColumnFrozen = columns[0][frozenProp] || columns[0].hasAttribute(frozenAttr);
          const allSameFrozen = columns.every((column) => {
            return (column[frozenProp] || column.hasAttribute(frozenAttr)) === firstColumnFrozen;
          });
          if (!allSameFrozen) {
            this._grid.__autoFreezeWarningDebouncer = Debouncer$1.debounce(
              this._grid.__autoFreezeWarningDebouncer,
              animationFrame,
              () => {
                console.warn(
                  `WARNING: Joining ${frozenProp} and non-${frozenProp} Grid columns inside the same column group! This will automatically freeze all the joined columns to avoid rendering issues. If this was intentional, consider marking each joined column explicitly as ${frozenProp}. Otherwise, exclude the ${frozenProp} columns from the joined group.`
                );
              }
            );
          }
        }
      }
      /** @private */
      _groupFrozenChanged(frozen, rootColumns) {
        if (rootColumns === void 0 || frozen === void 0) {
          return;
        }
        if (frozen !== false) {
          this.__scheduleAutoFreezeWarning(rootColumns, "frozen");
          Array.from(rootColumns).forEach((col) => {
            col.frozen = frozen;
          });
        }
      }
      /** @private */
      _groupFrozenToEndChanged(frozenToEnd, rootColumns) {
        if (rootColumns === void 0 || frozenToEnd === void 0) {
          return;
        }
        if (frozenToEnd !== false) {
          this.__scheduleAutoFreezeWarning(rootColumns, "frozenToEnd");
          Array.from(rootColumns).forEach((col) => {
            col.frozenToEnd = frozenToEnd;
          });
        }
      }
      /** @private */
      _groupHiddenChanged(hidden) {
        if (hidden || this.__groupHiddenInitialized) {
          this._synchronizeHidden();
        }
        this.__groupHiddenInitialized = true;
      }
      /** @private */
      _updateAutoHidden() {
        const wasAutoHidden = this._autoHidden;
        this._autoHidden = (this._visibleChildColumns || []).length === 0;
        if (wasAutoHidden || this._autoHidden) {
          this.hidden = this._autoHidden;
        }
      }
      /** @private */
      _synchronizeHidden() {
        if (this._childColumns && !this._preventHiddenSynchronization) {
          this._childColumns.forEach((column) => {
            column.hidden = this.hidden;
          });
        }
      }
      /** @private */
      _colSpanChanged(colSpan, headerCell, footerCell) {
        if (headerCell) {
          headerCell.setAttribute("colspan", colSpan);
          if (this._grid) {
            this._grid._a11yUpdateCellColspan(headerCell, colSpan);
          }
        }
        if (footerCell) {
          footerCell.setAttribute("colspan", colSpan);
          if (this._grid) {
            this._grid._a11yUpdateCellColspan(footerCell, colSpan);
          }
        }
      }
      /**
       * @param {!GridColumnGroup} el
       * @return {!Array<!GridColumn>}
       * @protected
       */
      _getChildColumns(el) {
        return ColumnObserver.getColumns(el);
      }
      /** @private */
      _addNodeObserver() {
        this._observer = new ColumnObserver(this, () => {
          this._preventHiddenSynchronization = true;
          this._rootColumns = this._getChildColumns(this);
          this._childColumns = this._rootColumns;
          this._updateVisibleChildColumns(this._childColumns);
          this._preventHiddenSynchronization = false;
          if (this._grid && this._grid._debounceUpdateColumnTree) {
            this._grid._debounceUpdateColumnTree();
          }
        });
        this._observer.flush();
      }
      /**
       * @param {!Node} node
       * @return {boolean}
       * @protected
       */
      _isColumnElement(node) {
        return node.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(node.localName);
      }
    };
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class GridColumnGroup extends GridColumnGroupMixin(PolymerElement) {
      static get is() {
        return "vaadin-grid-column-group";
      }
    }
    defineCustomElement(GridColumnGroup);
    registerStyles$1(
      "vaadin-grid-sorter",
      css$e`
    :host {
      justify-content: flex-start;
      align-items: baseline;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      cursor: var(--lumo-clickable-cursor);
    }

    [part='content'] {
      display: inline-block;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    [part='indicators'] {
      margin-left: var(--lumo-space-s);
    }

    [part='indicators']::before {
      transform: scale(0.8);
    }

    :host(:not([direction]):not(:hover)) [part='indicators'] {
      color: var(--lumo-tertiary-text-color);
    }

    :host([direction]) {
      color: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    }

    [part='order'] {
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part='indicators'] {
      margin-right: var(--lumo-space-s);
      margin-left: 0;
    }
  `,
      { moduleId: "lumo-grid-sorter" }
    );
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const template$3 = document.createElement("template");
    template$3.innerHTML = `
  <style>
    @font-face {
      font-family: 'vaadin-grid-sorter-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQwAA0AAAAABuwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAEFAAAABkAAAAcfep+mUdERUYAAAP4AAAAHAAAAB4AJwAOT1MvMgAAAZgAAAA/AAAAYA8TBPpjbWFwAAAB7AAAAFUAAAFeF1fZ4mdhc3AAAAPwAAAACAAAAAgAAAAQZ2x5ZgAAAlgAAABcAAAAnMvguMloZWFkAAABMAAAAC8AAAA2C5Ap72hoZWEAAAFgAAAAHQAAACQGbQPHaG10eAAAAdgAAAAUAAAAHAoAAABsb2NhAAACRAAAABIAAAASAIwAYG1heHAAAAGAAAAAFgAAACAACwAKbmFtZQAAArQAAAECAAACZxWCgKhwb3N0AAADuAAAADUAAABZCrApUXicY2BkYGAA4rDECVrx/DZfGbhZGEDgyqNPOxH0/wNMq5kPALkcDEwgUQBWRA0dAHicY2BkYGA+8P8AAwMLAwgwrWZgZEAFbABY4QM8AAAAeJxjYGRgYOAAQiYGEICQSAAAAi8AFgAAeJxjYGY6yziBgZWBgWkm0xkGBoZ+CM34msGYkZMBFTAKoAkwODAwvmRiPvD/AIMDMxCD1CDJKjAwAgBktQsXAHicY2GAAMZQCM0EwqshbAALxAEKeJxjYGBgZoBgGQZGBhCIAPIYwXwWBhsgzcXAwcAEhIwMCi+Z/v/9/x+sSuElA4T9/4k4K1gHFwMMMILMY2QDYmaoABOQYGJABUA7WBiGNwAAJd4NIQAAAAAAAAAACAAIABAAGAAmAEAATgAAeJyNjLENgDAMBP9tIURJwQCMQccSZgk2i5fIYBDAidJjycXr7x5EPwE2wY8si7jmyBNXGo/bNBerxJNrpxhbO3/fEFpx8ZICpV+ghxJ74fAMe+h7Ox14AbrsHB14nK2QQWrDMBRER4mTkhQK3ZRQKOgCNk7oGQqhhEIX2WSlWEI1BAlkJ5CDdNsj5Ey9Rncdi38ES+jzNJo/HwTgATcoDEthhY3wBHc4CE+pfwsX5F/hGe7Vo/AcK/UhvMSz+mGXKhZU6pww8ISz3oWn1BvhgnwTnuEJf8Jz1OpFeIlX9YULDLdFi4ASHolkSR0iuYdjLak1vAequBhj21D61Nqyi6l3qWybGPjySbPHGScGJl6dP58MYcQRI0bts7mjebBqrFENH7t3qWtj0OuqHnXcW7b0HOTZFnKryRGW2hFX1m0O2vEM3opNMfTau+CS6Z3Vx6veNnEXY6jwDxhsc2gAAHicY2BiwA84GBgYmRiYGJkZmBlZGFkZ2djScyoLMgzZS/MyDQwMwLSrpYEBlIbxjQDrzgsuAAAAAAEAAf//AA94nGNgZGBg4AFiMSBmYmAEQnYgZgHzGAAD6wA2eJxjYGBgZACCKyoz1cD0o087YTQATOcIewAAAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
    document.head.appendChild(template$3.content);
    registerStyles$1(
      "vaadin-grid-sorter",
      css$e`
    :host {
      display: inline-flex;
      cursor: pointer;
      max-width: 100%;
    }

    [part='content'] {
      flex: 1 1 auto;
    }

    [part='indicators'] {
      position: relative;
      align-self: center;
      flex: none;
    }

    [part='order'] {
      display: inline;
      vertical-align: super;
    }

    [part='indicators']::before {
      font-family: 'vaadin-grid-sorter-icons';
      display: inline-block;
    }

    :host(:not([direction])) [part='indicators']::before {
      content: '\\e901';
    }

    :host([direction='asc']) [part='indicators']::before {
      content: '\\e900';
    }

    :host([direction='desc']) [part='indicators']::before {
      content: '\\e902';
    }
  `,
      { moduleId: "vaadin-grid-sorter-styles" }
    );
    const GridSorterMixin = (superClass) => class GridSorterMixinClass extends superClass {
      static get properties() {
        return {
          /**
           * JS Path of the property in the item used for sorting the data.
           */
          path: String,
          /**
           * How to sort the data.
           * Possible values are `asc` to use an ascending algorithm, `desc` to sort the data in
           * descending direction, or `null` for not sorting the data.
           * @type {GridSorterDirection | undefined}
           */
          direction: {
            type: String,
            reflectToAttribute: true,
            notify: true,
            value: null,
            sync: true
          },
          /**
           * @type {number | null}
           * @protected
           */
          _order: {
            type: Number,
            value: null,
            sync: true
          }
        };
      }
      static get observers() {
        return ["_pathOrDirectionChanged(path, direction)"];
      }
      /** @protected */
      ready() {
        super.ready();
        this.addEventListener("click", this._onClick.bind(this));
      }
      /** @protected */
      connectedCallback() {
        super.connectedCallback();
        if (this._grid) {
          this._grid.__applySorters();
        } else {
          this.__dispatchSorterChangedEvenIfPossible();
        }
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback();
        if (!this.parentNode && this._grid) {
          this._grid.__removeSorters([this]);
        } else if (this._grid) {
          this._grid.__applySorters();
        }
      }
      /** @private */
      _pathOrDirectionChanged() {
        this.__dispatchSorterChangedEvenIfPossible();
      }
      /** @private */
      __dispatchSorterChangedEvenIfPossible() {
        if (this.path === void 0 || this.direction === void 0 || !this.isConnected) {
          return;
        }
        this.dispatchEvent(
          new CustomEvent("sorter-changed", {
            detail: { shiftClick: Boolean(this._shiftClick), fromSorterClick: Boolean(this._fromSorterClick) },
            bubbles: true,
            composed: true
          })
        );
        this._fromSorterClick = false;
        this._shiftClick = false;
      }
      /** @private */
      _getDisplayOrder(order) {
        return order === null ? "" : order + 1;
      }
      /** @private */
      _onClick(e2) {
        if (e2.defaultPrevented) {
          return;
        }
        const activeElement = this.getRootNode().activeElement;
        if (this !== activeElement && this.contains(activeElement)) {
          return;
        }
        e2.preventDefault();
        this._shiftClick = e2.shiftKey;
        this._fromSorterClick = true;
        if (this.direction === "asc") {
          this.direction = "desc";
        } else if (this.direction === "desc") {
          this.direction = null;
        } else {
          this.direction = "asc";
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class GridSorter extends GridSorterMixin(ThemableMixin(DirMixin(PolymerElement))) {
      static get template() {
        return html`
      <div part="content">
        <slot></slot>
      </div>
      <div part="indicators">
        <span part="order">[[_getDisplayOrder(_order)]]</span>
      </div>
    `;
      }
      static get is() {
        return "vaadin-grid-sorter";
      }
    }
    defineCustomElement(GridSorter);
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const GridSelectionColumnBaseMixin = (superClass) => class GridSelectionColumnBaseMixin extends superClass {
      static get properties() {
        return {
          /**
           * Width of the cells for this column.
           */
          width: {
            type: String,
            value: "58px",
            sync: true
          },
          /**
           * Override `autoWidth` to enable auto-width
           */
          autoWidth: {
            type: Boolean,
            value: true
          },
          /**
           * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
           * @attr {number} flex-grow
           * @type {number}
           */
          flexGrow: {
            type: Number,
            value: 0,
            sync: true
          },
          /**
           * When true, all the items are selected.
           * @attr {boolean} select-all
           * @type {boolean}
           */
          selectAll: {
            type: Boolean,
            value: false,
            notify: true,
            sync: true
          },
          /**
           * When true, the active gets automatically selected.
           * @attr {boolean} auto-select
           * @type {boolean}
           */
          autoSelect: {
            type: Boolean,
            value: false,
            sync: true
          },
          /**
           * When true, rows can be selected by dragging over the selection column.
           * @attr {boolean} drag-select
           * @type {boolean}
           */
          dragSelect: {
            type: Boolean,
            value: false,
            sync: true
          },
          /** @protected */
          _indeterminate: {
            type: Boolean,
            sync: true
          },
          /** @protected */
          _selectAllHidden: Boolean
        };
      }
      static get observers() {
        return [
          "_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header, selectAll, _indeterminate, _selectAllHidden)"
        ];
      }
      /**
       * Renders the Select All checkbox to the header cell.
       *
       * @override
       */
      _defaultHeaderRenderer(root2, _column) {
        let checkbox = root2.firstElementChild;
        if (!checkbox) {
          checkbox = document.createElement("vaadin-checkbox");
          checkbox.setAttribute("aria-label", "Select All");
          checkbox.classList.add("vaadin-grid-select-all-checkbox");
          root2.appendChild(checkbox);
          checkbox.addEventListener("checked-changed", this.__onSelectAllCheckedChanged.bind(this));
        }
        const checked = this.__isChecked(this.selectAll, this._indeterminate);
        checkbox.__rendererChecked = checked;
        checkbox.checked = checked;
        checkbox.hidden = this._selectAllHidden;
        checkbox.indeterminate = this._indeterminate;
      }
      /**
       * Renders the Select Row checkbox to the body cell.
       *
       * @override
       */
      _defaultRenderer(root2, _column, { item: item2, selected }) {
        let checkbox = root2.firstElementChild;
        if (!checkbox) {
          checkbox = document.createElement("vaadin-checkbox");
          checkbox.setAttribute("aria-label", "Select Row");
          root2.appendChild(checkbox);
          checkbox.addEventListener("checked-changed", this.__onSelectRowCheckedChanged.bind(this));
          addListener(root2, "track", this.__onCellTrack.bind(this));
          root2.addEventListener("mousedown", this.__onCellMouseDown.bind(this));
          root2.addEventListener("click", this.__onCellClick.bind(this));
        }
        checkbox.__item = item2;
        checkbox.__rendererChecked = selected;
        checkbox.checked = selected;
      }
      /**
       * Updates the select all state when the Select All checkbox is switched.
       * The listener handles only user-fired events.
       *
       * @private
       */
      __onSelectAllCheckedChanged(e2) {
        if (e2.target.checked === e2.target.__rendererChecked) {
          return;
        }
        if (this._indeterminate || e2.target.checked) {
          this._selectAll();
        } else {
          this._deselectAll();
        }
      }
      /**
       * Selects or deselects the row when the Select Row checkbox is switched.
       * The listener handles only user-fired events.
       *
       * @private
       */
      __onSelectRowCheckedChanged(e2) {
        if (e2.target.checked === e2.target.__rendererChecked) {
          return;
        }
        if (e2.target.checked) {
          this._selectItem(e2.target.__item);
        } else {
          this._deselectItem(e2.target.__item);
        }
      }
      /** @private */
      __onCellTrack(event) {
        if (!this.dragSelect) {
          return;
        }
        this.__dragCurrentY = event.detail.y;
        this.__dragDy = event.detail.dy;
        if (event.detail.state === "start") {
          const renderedRows = this._grid._getRenderedRows();
          const dragStartRow = renderedRows.find((row) => row.contains(event.currentTarget.assignedSlot));
          this.__selectOnDrag = !this._grid._isSelected(dragStartRow._item);
          this.__dragStartIndex = dragStartRow.index;
          this.__dragStartItem = dragStartRow._item;
          this.__dragAutoScroller();
        } else if (event.detail.state === "end") {
          if (this.__dragStartItem) {
            if (this.__selectOnDrag) {
              this._selectItem(this.__dragStartItem);
            } else {
              this._deselectItem(this.__dragStartItem);
            }
          }
          setTimeout(() => {
            this.__dragStartIndex = void 0;
          });
        }
      }
      /** @private */
      __onCellMouseDown(e2) {
        if (this.dragSelect) {
          e2.preventDefault();
        }
      }
      /** @private */
      __onCellClick(e2) {
        if (this.__dragStartIndex !== void 0) {
          e2.preventDefault();
        }
      }
      /** @private */
      _onCellKeyDown(e2) {
        const target = e2.composedPath()[0];
        if (e2.keyCode === 32 && (target === this._headerCell || this._cells.includes(target) && !this.autoSelect)) {
          const checkbox = target._content.firstElementChild;
          checkbox.checked = !checkbox.checked;
        }
      }
      /** @private */
      __dragAutoScroller() {
        if (this.__dragStartIndex === void 0) {
          return;
        }
        const renderedRows = this._grid._getRenderedRows();
        const hoveredRow = renderedRows.find((row) => {
          const rowRect = row.getBoundingClientRect();
          return this.__dragCurrentY >= rowRect.top && this.__dragCurrentY <= rowRect.bottom;
        });
        let hoveredIndex = hoveredRow ? hoveredRow.index : void 0;
        const scrollableArea = this.__getScrollableArea();
        if (this.__dragCurrentY < scrollableArea.top) {
          hoveredIndex = this._grid._firstVisibleIndex;
        } else if (this.__dragCurrentY > scrollableArea.bottom) {
          hoveredIndex = this._grid._lastVisibleIndex;
        }
        if (hoveredIndex !== void 0) {
          renderedRows.forEach((row) => {
            if (hoveredIndex > this.__dragStartIndex && row.index >= this.__dragStartIndex && row.index <= hoveredIndex || hoveredIndex < this.__dragStartIndex && row.index <= this.__dragStartIndex && row.index >= hoveredIndex) {
              if (this.__selectOnDrag) {
                this._selectItem(row._item);
              } else {
                this._deselectItem(row._item);
              }
              this.__dragStartItem = void 0;
            }
          });
        }
        const scrollTriggerArea = scrollableArea.height * 0.15;
        const maxScrollAmount = 10;
        if (this.__dragDy < 0 && this.__dragCurrentY < scrollableArea.top + scrollTriggerArea) {
          const dy = scrollableArea.top + scrollTriggerArea - this.__dragCurrentY;
          const percentage = Math.min(1, dy / scrollTriggerArea);
          this._grid.$.table.scrollTop -= percentage * maxScrollAmount;
        }
        if (this.__dragDy > 0 && this.__dragCurrentY > scrollableArea.bottom - scrollTriggerArea) {
          const dy = this.__dragCurrentY - (scrollableArea.bottom - scrollTriggerArea);
          const percentage = Math.min(1, dy / scrollTriggerArea);
          this._grid.$.table.scrollTop += percentage * maxScrollAmount;
        }
        setTimeout(() => this.__dragAutoScroller(), 10);
      }
      /**
       * Gets the scrollable area of the grid as a bounding client rect. The
       * scrollable area is the bounding rect of the grid minus the header and
       * footer.
       *
       * @private
       */
      __getScrollableArea() {
        const gridRect = this._grid.$.table.getBoundingClientRect();
        const headerRect = this._grid.$.header.getBoundingClientRect();
        const footerRect = this._grid.$.footer.getBoundingClientRect();
        return {
          top: gridRect.top + headerRect.height,
          bottom: gridRect.bottom - footerRect.height,
          left: gridRect.left,
          right: gridRect.right,
          height: gridRect.height - headerRect.height - footerRect.height,
          width: gridRect.width
        };
      }
      /**
       * Override to handle the user selecting all items.
       * @protected
       */
      _selectAll() {
      }
      /**
       * Override to handle the user deselecting all items.
       * @protected
       */
      _deselectAll() {
      }
      /**
       * Override to handle the user selecting an item.
       * @param {Object} item the item to select
       * @protected
       */
      _selectItem(item2) {
      }
      /**
       * Override to handle the user deselecting an item.
       * @param {Object} item the item to deselect
       * @protected
       */
      _deselectItem(item2) {
      }
      /**
       * IOS needs indeterminate + checked at the same time
       * @private
       */
      __isChecked(selectAll, indeterminate) {
        return indeterminate || selectAll;
      }
    };
    class GridFlowSelectionColumn extends GridSelectionColumnBaseMixin(GridColumn) {
      static get is() {
        return "vaadin-grid-flow-selection-column";
      }
      static get properties() {
        return {
          /**
           * Override property to enable auto-width
           */
          autoWidth: {
            type: Boolean,
            value: true
          },
          /**
           * Override property to set custom width
           */
          width: {
            type: String,
            value: "56px"
          }
        };
      }
      /**
       * Override method from `GridSelectionColumnBaseMixin` to add ID to select all
       * checkbox
       *
       * @override
       */
      _defaultHeaderRenderer(root2, _column) {
        super._defaultHeaderRenderer(root2, _column);
        const checkbox = root2.firstElementChild;
        if (checkbox) {
          checkbox.id = "selectAllCheckbox";
        }
      }
      /**
       * Override a method from `GridSelectionColumnBaseMixin` to handle the user
       * selecting all items.
       *
       * @protected
       * @override
       */
      _selectAll() {
        this.selectAll = true;
        this.$server.selectAll();
      }
      /**
       * Override a method from `GridSelectionColumnBaseMixin` to handle the user
       * deselecting all items.
       *
       * @protected
       * @override
       */
      _deselectAll() {
        this.selectAll = false;
        this.$server.deselectAll();
      }
      /**
       * Override a method from `GridSelectionColumnBaseMixin` to handle the user
       * selecting an item.
       *
       * @param {Object} item the item to select
       * @protected
       * @override
       */
      _selectItem(item2) {
        this._grid.$connector.doSelection([item2], true);
      }
      /**
       * Override a method from `GridSelectionColumnBaseMixin` to handle the user
       * deselecting an item.
       *
       * @param {Object} item the item to deselect
       * @protected
       * @override
       */
      _deselectItem(item2) {
        this._grid.$connector.doDeselection([item2], true);
        this.selectAll = false;
      }
    }
    customElements.define(GridFlowSelectionColumn.is, GridFlowSelectionColumn);
    (function() {
      const tryCatchWrapper = function(callback) {
        return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Grid");
      };
      window.Vaadin.Flow.gridConnector = {
        initLazy: (grid) => tryCatchWrapper(function(grid2) {
          if (grid2.$connector) {
            return;
          }
          const dataProviderController = grid2._dataProviderController;
          dataProviderController.ensureFlatIndexHierarchyOriginal = dataProviderController.ensureFlatIndexHierarchy;
          dataProviderController.ensureFlatIndexHierarchy = tryCatchWrapper(function(flatIndex) {
            const { item: item2 } = this.getFlatIndexContext(flatIndex);
            if (!item2 || !this.isExpanded(item2)) {
              return;
            }
            const isCached = grid2.$connector.hasCacheForParentKey(grid2.getItemId(item2));
            if (isCached) {
              this.ensureFlatIndexHierarchyOriginal(flatIndex);
            } else {
              grid2.$connector.beforeEnsureFlatIndexHierarchy(flatIndex, item2);
            }
          });
          dataProviderController.isLoadingOriginal = dataProviderController.isLoading;
          dataProviderController.isLoading = tryCatchWrapper(function() {
            return grid2.$connector.hasEnsureSubCacheQueue() || this.isLoadingOriginal();
          });
          dataProviderController.getItemSubCache = tryCatchWrapper(function(item2) {
            return this.getItemContext(item2)?.subCache;
          });
          let cache = {};
          const parentRequestDelay = 50;
          const parentRequestBatchMaxSize = 20;
          let parentRequestQueue = [];
          let parentRequestDebouncer;
          let ensureSubCacheQueue = [];
          let ensureSubCacheDebouncer;
          const rootRequestDelay = 150;
          let rootRequestDebouncer;
          let lastRequestedRanges = {};
          const root2 = "null";
          lastRequestedRanges[root2] = [0, 0];
          let currentUpdateClearRange = null;
          let currentUpdateSetRange = null;
          const validSelectionModes = ["SINGLE", "NONE", "MULTI"];
          let selectedKeys = {};
          let selectionMode = "SINGLE";
          let sorterDirectionsSetFromServer = false;
          grid2.size = 0;
          grid2.itemIdPath = "key";
          function createEmptyItemFromKey(key) {
            return { [grid2.itemIdPath]: key };
          }
          grid2.$connector = {};
          grid2.$connector.hasCacheForParentKey = tryCatchWrapper((parentKey) => cache[parentKey]?.size !== void 0);
          grid2.$connector.hasEnsureSubCacheQueue = tryCatchWrapper(() => ensureSubCacheQueue.length > 0);
          grid2.$connector.hasParentRequestQueue = tryCatchWrapper(() => parentRequestQueue.length > 0);
          grid2.$connector.hasRootRequestQueue = tryCatchWrapper(() => {
            const { pendingRequests } = dataProviderController.rootCache;
            return Object.keys(pendingRequests).length > 0 || !!rootRequestDebouncer?.isActive();
          });
          grid2.$connector.beforeEnsureFlatIndexHierarchy = tryCatchWrapper(function(flatIndex, item2) {
            ensureSubCacheQueue.push({
              flatIndex,
              itemkey: grid2.getItemId(item2)
            });
            ensureSubCacheDebouncer = Debouncer.debounce(ensureSubCacheDebouncer, animationFrame$1, () => {
              while (ensureSubCacheQueue.length) {
                grid2.$connector.flushEnsureSubCache();
              }
            });
          });
          grid2.$connector.doSelection = tryCatchWrapper(function(items, userOriginated) {
            if (selectionMode === "NONE" || !items.length || userOriginated && grid2.hasAttribute("disabled")) {
              return;
            }
            if (selectionMode === "SINGLE") {
              selectedKeys = {};
            }
            items.forEach((item2) => {
              if (item2) {
                selectedKeys[item2.key] = item2;
                item2.selected = true;
                if (userOriginated) {
                  grid2.$server.select(item2.key);
                }
              }
              const isSelectedItemDifferentOrNull = !grid2.activeItem || !item2 || item2.key != grid2.activeItem.key;
              if (!userOriginated && selectionMode === "SINGLE" && isSelectedItemDifferentOrNull) {
                grid2.activeItem = item2;
              }
            });
            grid2.selectedItems = Object.values(selectedKeys);
          });
          grid2.$connector.doDeselection = tryCatchWrapper(function(items, userOriginated) {
            if (selectionMode === "NONE" || !items.length || userOriginated && grid2.hasAttribute("disabled")) {
              return;
            }
            const updatedSelectedItems = grid2.selectedItems.slice();
            while (items.length) {
              const itemToDeselect = items.shift();
              for (let i = 0; i < updatedSelectedItems.length; i++) {
                const selectedItem = updatedSelectedItems[i];
                if (itemToDeselect?.key === selectedItem.key) {
                  updatedSelectedItems.splice(i, 1);
                  break;
                }
              }
              if (itemToDeselect) {
                delete selectedKeys[itemToDeselect.key];
                delete itemToDeselect.selected;
                if (userOriginated) {
                  grid2.$server.deselect(itemToDeselect.key);
                }
              }
            }
            grid2.selectedItems = updatedSelectedItems;
          });
          grid2.__activeItemChanged = tryCatchWrapper(function(newVal, oldVal) {
            if (selectionMode != "SINGLE") {
              return;
            }
            if (!newVal) {
              if (oldVal && selectedKeys[oldVal.key]) {
                if (grid2.__deselectDisallowed) {
                  grid2.activeItem = oldVal;
                } else {
                  grid2.$connector.doDeselection([oldVal], true);
                }
              }
            } else if (!selectedKeys[newVal.key]) {
              grid2.$connector.doSelection([newVal], true);
            }
          });
          grid2._createPropertyObserver("activeItem", "__activeItemChanged", true);
          grid2.__activeItemChangedDetails = tryCatchWrapper(function(newVal, oldVal) {
            if (grid2.__disallowDetailsOnClick) {
              return;
            }
            if (newVal == null && oldVal === void 0) {
              return;
            }
            if (newVal && !newVal.detailsOpened) {
              grid2.$server.setDetailsVisible(newVal.key);
            } else {
              grid2.$server.setDetailsVisible(null);
            }
          });
          grid2._createPropertyObserver("activeItem", "__activeItemChangedDetails", true);
          grid2.$connector._getSameLevelPage = tryCatchWrapper(function(parentKey, currentCache, currentCacheItemIndex) {
            const currentParentKey = currentCache.parentItem ? grid2.getItemId(currentCache.parentItem) : root2;
            if (currentParentKey === parentKey) {
              return Math.floor(currentCacheItemIndex / grid2.pageSize);
            }
            const { parentCache, parentCacheIndex } = currentCache;
            if (!parentCache) {
              return null;
            }
            return this._getSameLevelPage(parentKey, parentCache, parentCacheIndex);
          });
          grid2.$connector.flushEnsureSubCache = tryCatchWrapper(function() {
            const pendingFetch = ensureSubCacheQueue.shift();
            if (pendingFetch) {
              dataProviderController.ensureFlatIndexHierarchyOriginal(pendingFetch.flatIndex);
              return true;
            }
            return false;
          });
          grid2.$connector.debounceRootRequest = tryCatchWrapper(function(page) {
            const delay = grid2._hasData ? rootRequestDelay : 0;
            rootRequestDebouncer = Debouncer.debounce(rootRequestDebouncer, timeOut.after(delay), () => {
              grid2.$connector.fetchPage(
                (firstIndex, size) => grid2.$server.setRequestedRange(firstIndex, size),
                page,
                root2
              );
            });
          });
          grid2.$connector.flushParentRequests = tryCatchWrapper(function() {
            const pendingFetches = [];
            parentRequestQueue.splice(0, parentRequestBatchMaxSize).forEach(({ parentKey, page }) => {
              grid2.$connector.fetchPage(
                (firstIndex, size) => pendingFetches.push({ parentKey, firstIndex, size }),
                page,
                parentKey
              );
            });
            if (pendingFetches.length) {
              grid2.$server.setParentRequestedRanges(pendingFetches);
            }
          });
          grid2.$connector.debounceParentRequest = tryCatchWrapper(function(parentKey, page) {
            parentRequestQueue = parentRequestQueue.filter((request) => request.parentKey !== parentKey);
            parentRequestQueue.push({ parentKey, page });
            parentRequestDebouncer = Debouncer.debounce(parentRequestDebouncer, timeOut.after(parentRequestDelay), () => {
              while (parentRequestQueue.length) {
                grid2.$connector.flushParentRequests();
              }
            });
          });
          grid2.$connector.fetchPage = tryCatchWrapper(function(fetch, page, parentKey) {
            if (parentKey === root2) {
              page = Math.min(page, Math.floor((grid2.size - 1) / grid2.pageSize));
            }
            const visibleRows = grid2._getRenderedRows();
            let start = visibleRows.length > 0 ? visibleRows[0].index : 0;
            let end = visibleRows.length > 0 ? visibleRows[visibleRows.length - 1].index : 0;
            let buffer = end - start;
            let firstNeededIndex = Math.max(0, start - buffer);
            let lastNeededIndex = Math.min(end + buffer, grid2._flatSize);
            let pageRange = [null, null];
            for (let idx = firstNeededIndex; idx <= lastNeededIndex; idx++) {
              const { cache: cache2, index } = dataProviderController.getFlatIndexContext(idx);
              const sameLevelPage = grid2.$connector._getSameLevelPage(parentKey, cache2, index);
              if (sameLevelPage === null) {
                continue;
              }
              pageRange[0] = Math.min(pageRange[0] ?? sameLevelPage, sameLevelPage);
              pageRange[1] = Math.max(pageRange[1] ?? sameLevelPage, sameLevelPage);
            }
            if (pageRange.some((p) => p === null) || page < pageRange[0] || page > pageRange[1]) {
              pageRange = [page, page];
            }
            let lastRequestedRange = lastRequestedRanges[parentKey] || [-1, -1];
            if (lastRequestedRange[0] != pageRange[0] || lastRequestedRange[1] != pageRange[1]) {
              lastRequestedRanges[parentKey] = pageRange;
              let pageCount = pageRange[1] - pageRange[0] + 1;
              fetch(pageRange[0] * grid2.pageSize, pageCount * grid2.pageSize);
            }
          });
          grid2.dataProvider = tryCatchWrapper(function(params, callback) {
            if (params.pageSize != grid2.pageSize) {
              throw "Invalid pageSize";
            }
            let page = params.page;
            if (params.parentItem) {
              let parentUniqueKey = grid2.getItemId(params.parentItem);
              const parentItemSubCache = dataProviderController.getItemSubCache(params.parentItem);
              if (cache[parentUniqueKey]?.[page] && parentItemSubCache) {
                ensureSubCacheQueue = [];
                callback(cache[parentUniqueKey][page], cache[parentUniqueKey].size);
              } else {
                grid2.$connector.debounceParentRequest(parentUniqueKey, page);
              }
            } else {
              if (grid2.size === 0) {
                callback([], 0);
                return;
              }
              if (cache[root2]?.[page]) {
                callback(cache[root2][page]);
              } else {
                grid2.$connector.debounceRootRequest(page);
              }
            }
          });
          grid2.$connector.setSorterDirections = tryCatchWrapper(function(directions) {
            sorterDirectionsSetFromServer = true;
            setTimeout(
              tryCatchWrapper(() => {
                try {
                  const sorters = Array.from(grid2.querySelectorAll("vaadin-grid-sorter"));
                  grid2._sorters.forEach((sorter) => {
                    if (!sorters.includes(sorter)) {
                      sorters.push(sorter);
                    }
                  });
                  sorters.forEach((sorter) => {
                    sorter.direction = null;
                  });
                  if (grid2.multiSortPriority !== "append") {
                    directions = directions.reverse();
                  }
                  directions.forEach(({ column, direction }) => {
                    sorters.forEach((sorter) => {
                      if (sorter.getAttribute("path") === column) {
                        sorter.direction = direction;
                      }
                    });
                  });
                  grid2.__applySorters();
                } finally {
                  sorterDirectionsSetFromServer = false;
                }
              })
            );
          });
          grid2._updateItem = tryCatchWrapper(function(row, item2) {
            Grid.prototype._updateItem.call(grid2, row, item2);
            if (!row.hidden) {
              Array.from(row.children).forEach((cell) => {
                Array.from(cell?._content?.__templateInstance?.children || []).forEach((content) => {
                  if (content._attachRenderedComponentIfAble) {
                    content._attachRenderedComponentIfAble();
                  }
                  Array.from(content?.children || []).forEach((innerContent) => {
                    if (innerContent._attachRenderedComponentIfAble) {
                      innerContent._attachRenderedComponentIfAble();
                    }
                  });
                });
              });
            }
            if (selectionMode === validSelectionModes[1]) {
              row.removeAttribute("aria-selected");
              Array.from(row.children).forEach((cell) => cell.removeAttribute("aria-selected"));
            }
          });
          const itemExpandedChanged = tryCatchWrapper(function(item2, expanded) {
            if (item2 == void 0 || grid2.$server.updateExpandedState == void 0) {
              return;
            }
            let parentKey = grid2.getItemId(item2);
            grid2.$server.updateExpandedState(parentKey, expanded);
          });
          grid2.expandItem = tryCatchWrapper(function(item2) {
            itemExpandedChanged(item2, true);
            Grid.prototype.expandItem.call(grid2, item2);
          });
          grid2.collapseItem = tryCatchWrapper(function(item2) {
            itemExpandedChanged(item2, false);
            Grid.prototype.collapseItem.call(grid2, item2);
          });
          const itemsUpdated = function(items) {
            if (!items || !Array.isArray(items)) {
              throw "Attempted to call itemsUpdated with an invalid value: " + JSON.stringify(items);
            }
            let detailsOpenedItems = Array.from(grid2.detailsOpenedItems);
            let updatedSelectedItem = false;
            for (let i = 0; i < items.length; ++i) {
              const item2 = items[i];
              if (!item2) {
                continue;
              }
              if (item2.detailsOpened) {
                if (grid2._getItemIndexInArray(item2, detailsOpenedItems) < 0) {
                  detailsOpenedItems.push(item2);
                }
              } else if (grid2._getItemIndexInArray(item2, detailsOpenedItems) >= 0) {
                detailsOpenedItems.splice(grid2._getItemIndexInArray(item2, detailsOpenedItems), 1);
              }
              if (selectedKeys[item2.key]) {
                selectedKeys[item2.key] = item2;
                item2.selected = true;
                updatedSelectedItem = true;
              }
            }
            grid2.detailsOpenedItems = detailsOpenedItems;
            if (updatedSelectedItem) {
              grid2.selectedItems.splice(0, grid2.selectedItems.length, ...Object.values(selectedKeys));
            }
          };
          const updateGridCache = function(page, parentKey = root2) {
            const items = cache[parentKey][page];
            const parentItem = createEmptyItemFromKey(parentKey);
            let gridCache = parentKey === root2 ? dataProviderController.rootCache : dataProviderController.getItemSubCache(parentItem);
            if (gridCache && !gridCache.pendingRequests[page]) {
              gridCache.setPage(page, items || Array.from({ length: grid2.pageSize }));
            }
            return items;
          };
          const updateAllGridRowsInDomBasedOnCache = function() {
            updateGridFlatSize();
            grid2.__updateVisibleRows();
          };
          const updateGridFlatSize = function() {
            dataProviderController.recalculateFlatSize();
            grid2._flatSize = dataProviderController.flatSize;
          };
          const updateGridItemsInDomBasedOnCache = function(items) {
            if (!items || !grid2.$ || grid2.$.items.childElementCount === 0) {
              return;
            }
            const itemKeys = items.map((item2) => item2.key);
            const indexes = grid2._getRenderedRows().filter((row) => row._item && itemKeys.includes(row._item.key)).map((row) => row.index);
            if (indexes.length > 0) {
              grid2.__updateVisibleRows(indexes[0], indexes[indexes.length - 1]);
            }
          };
          grid2.$connector.set = tryCatchWrapper(function(index, items, parentKey) {
            if (index % grid2.pageSize != 0) {
              throw "Got new data to index " + index + " which is not aligned with the page size of " + grid2.pageSize;
            }
            let pkey = parentKey || root2;
            const firstPage = index / grid2.pageSize;
            const updatedPageCount = Math.ceil(items.length / grid2.pageSize);
            if (pkey === root2) {
              currentUpdateSetRange = [firstPage, firstPage + updatedPageCount - 1];
            }
            for (let i = 0; i < updatedPageCount; i++) {
              let page = firstPage + i;
              let slice = items.slice(i * grid2.pageSize, (i + 1) * grid2.pageSize);
              if (!cache[pkey]) {
                cache[pkey] = {};
              }
              cache[pkey][page] = slice;
              grid2.$connector.doSelection(slice.filter((item2) => item2.selected));
              grid2.$connector.doDeselection(slice.filter((item2) => !item2.selected && selectedKeys[item2.key]));
              const updatedItems = updateGridCache(page, pkey);
              if (updatedItems) {
                itemsUpdated(updatedItems);
                updateGridItemsInDomBasedOnCache(updatedItems);
              }
            }
          });
          const itemToCacheLocation = function(item2) {
            let parent = item2.parentUniqueKey || root2;
            if (cache[parent]) {
              for (let page in cache[parent]) {
                for (let index in cache[parent][page]) {
                  if (grid2.getItemId(cache[parent][page][index]) === grid2.getItemId(item2)) {
                    return { page, index, parentKey: parent };
                  }
                }
              }
            }
            return null;
          };
          grid2.$connector.updateHierarchicalData = tryCatchWrapper(function(updatedItems) {
            let pagesToUpdate = [];
            for (let i = 0; i < updatedItems.length; i++) {
              let cacheLocation = itemToCacheLocation(updatedItems[i]);
              if (cacheLocation) {
                cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i];
                let key = cacheLocation.parentKey + ":" + cacheLocation.page;
                if (!pagesToUpdate[key]) {
                  pagesToUpdate[key] = {
                    parentKey: cacheLocation.parentKey,
                    page: cacheLocation.page
                  };
                }
              }
            }
            let keys2 = Object.keys(pagesToUpdate);
            for (let i = 0; i < keys2.length; i++) {
              let pageToUpdate = pagesToUpdate[keys2[i]];
              const affectedUpdatedItems = updateGridCache(pageToUpdate.page, pageToUpdate.parentKey);
              if (affectedUpdatedItems) {
                itemsUpdated(affectedUpdatedItems);
                updateGridItemsInDomBasedOnCache(affectedUpdatedItems);
              }
            }
          });
          grid2.$connector.updateFlatData = tryCatchWrapper(function(updatedItems) {
            for (let i = 0; i < updatedItems.length; i++) {
              let cacheLocation = itemToCacheLocation(updatedItems[i]);
              if (cacheLocation) {
                cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i];
                const index = parseInt(cacheLocation.page) * grid2.pageSize + parseInt(cacheLocation.index);
                const { rootCache } = dataProviderController;
                if (rootCache.items[index]) {
                  rootCache.items[index] = updatedItems[i];
                }
              }
            }
            itemsUpdated(updatedItems);
            updateGridItemsInDomBasedOnCache(updatedItems);
          });
          grid2.$connector.clearExpanded = tryCatchWrapper(function() {
            grid2.expandedItems = [];
            ensureSubCacheQueue = [];
            parentRequestQueue = [];
          });
          const sanitizeLastRequestedRange = function() {
            const range = lastRequestedRanges[root2];
            if (!range || !currentUpdateClearRange) {
              return;
            }
            const numClearedPages = currentUpdateClearRange[1] - currentUpdateClearRange[0] + 1;
            const clearedPages = Array.from({ length: numClearedPages }, (_, i) => currentUpdateClearRange[0] + i);
            if (currentUpdateSetRange) {
              const [first, last] = currentUpdateSetRange;
              for (let page = first; page <= last; page++) {
                const index = clearedPages.indexOf(page);
                if (index >= 0) {
                  clearedPages.splice(index, 1);
                }
              }
            }
            if (clearedPages.some((page) => page >= range[0] && page <= range[1])) {
              range[0] = -1;
              range[1] = -1;
            }
          };
          grid2.$connector.clear = tryCatchWrapper(function(index, length, parentKey) {
            let pkey = parentKey || root2;
            if (!cache[pkey] || Object.keys(cache[pkey]).length === 0) {
              return;
            }
            if (index % grid2.pageSize != 0) {
              throw "Got cleared data for index " + index + " which is not aligned with the page size of " + grid2.pageSize;
            }
            let firstPage = Math.floor(index / grid2.pageSize);
            let updatedPageCount = Math.ceil(length / grid2.pageSize);
            if (pkey === root2) {
              currentUpdateClearRange = [firstPage, firstPage + updatedPageCount - 1];
            }
            for (let i = 0; i < updatedPageCount; i++) {
              let page = firstPage + i;
              let items = cache[pkey][page];
              grid2.$connector.doDeselection(items.filter((item2) => selectedKeys[item2.key]));
              items.forEach((item2) => grid2.closeItemDetails(item2));
              delete cache[pkey][page];
              updateGridCache(page, parentKey);
              updateGridItemsInDomBasedOnCache(items);
            }
            let cacheToClear = dataProviderController.rootCache;
            if (parentKey) {
              const parentItem = createEmptyItemFromKey(pkey);
              cacheToClear = dataProviderController.getItemSubCache(parentItem);
            }
            const endIndex = index + updatedPageCount * grid2.pageSize;
            for (let itemIndex = index; itemIndex < endIndex; itemIndex++) {
              delete cacheToClear.items[itemIndex];
              cacheToClear.removeSubCache(itemIndex);
            }
            updateGridFlatSize();
          });
          grid2.$connector.reset = tryCatchWrapper(function() {
            grid2.size = 0;
            cache = {};
            dataProviderController.rootCache.items = [];
            lastRequestedRanges = {};
            if (ensureSubCacheDebouncer) {
              ensureSubCacheDebouncer.cancel();
            }
            if (parentRequestDebouncer) {
              parentRequestDebouncer.cancel();
            }
            if (rootRequestDebouncer) {
              rootRequestDebouncer.cancel();
            }
            ensureSubCacheDebouncer = void 0;
            parentRequestDebouncer = void 0;
            ensureSubCacheQueue = [];
            parentRequestQueue = [];
            updateAllGridRowsInDomBasedOnCache();
          });
          grid2.$connector.updateSize = (newSize) => grid2.size = newSize;
          grid2.$connector.updateUniqueItemIdPath = (path) => grid2.itemIdPath = path;
          grid2.$connector.expandItems = tryCatchWrapper(function(items) {
            let newExpandedItems = Array.from(grid2.expandedItems);
            items.filter((item2) => !grid2._isExpanded(item2)).forEach((item2) => newExpandedItems.push(item2));
            grid2.expandedItems = newExpandedItems;
          });
          grid2.$connector.collapseItems = tryCatchWrapper(function(items) {
            let newExpandedItems = Array.from(grid2.expandedItems);
            items.forEach((item2) => {
              let index = grid2._getItemIndexInArray(item2, newExpandedItems);
              if (index >= 0) {
                newExpandedItems.splice(index, 1);
              }
            });
            grid2.expandedItems = newExpandedItems;
            items.forEach((item2) => grid2.$connector.removeFromQueue(item2));
          });
          grid2.$connector.removeFromQueue = tryCatchWrapper(function(item2) {
            const itemSubCache = dataProviderController.getItemSubCache(item2);
            Object.values(itemSubCache?.pendingRequests || {}).forEach((callback) => callback([]));
            const itemId = grid2.getItemId(item2);
            ensureSubCacheQueue = ensureSubCacheQueue.filter((item22) => item22.itemkey !== itemId);
            parentRequestQueue = parentRequestQueue.filter((item22) => item22.parentKey !== itemId);
          });
          grid2.$connector.confirmParent = tryCatchWrapper(function(id, parentKey, levelSize) {
            if (!cache[parentKey]) {
              cache[parentKey] = {};
            }
            const hasSizeChanged = cache[parentKey].size !== levelSize;
            cache[parentKey].size = levelSize;
            if (levelSize === 0) {
              cache[parentKey][0] = [];
            }
            const parentItem = createEmptyItemFromKey(parentKey);
            const parentItemSubCache = dataProviderController.getItemSubCache(parentItem);
            if (parentItemSubCache) {
              const { pendingRequests } = parentItemSubCache;
              Object.entries(pendingRequests).forEach(([page, callback]) => {
                let lastRequestedRange = lastRequestedRanges[parentKey] || [0, 0];
                if (cache[parentKey] && cache[parentKey][page] || page < lastRequestedRange[0] || page > lastRequestedRange[1]) {
                  let items = cache[parentKey][page] || new Array(levelSize);
                  callback(items, levelSize);
                } else if (callback && levelSize === 0) {
                  callback([], levelSize);
                }
              });
              if (hasSizeChanged && Object.keys(pendingRequests).length === 0) {
                parentItemSubCache.size = levelSize;
                updateGridFlatSize();
              }
            }
            grid2.$server.confirmParentUpdate(id, parentKey);
          });
          grid2.$connector.confirm = tryCatchWrapper(function(id) {
            const { pendingRequests } = dataProviderController.rootCache;
            Object.entries(pendingRequests).forEach(([page, callback]) => {
              const lastRequestedRange = lastRequestedRanges[root2] || [0, 0];
              const lastAvailablePage = grid2.size ? Math.ceil(grid2.size / grid2.pageSize) - 1 : 0;
              const lastRequestedRangeEnd = Math.min(lastRequestedRange[1], lastAvailablePage);
              if (cache[root2]?.[page]) {
                callback(cache[root2][page]);
              } else if (page < lastRequestedRange[0] || +page > lastRequestedRangeEnd) {
                callback(new Array(grid2.pageSize));
                grid2.requestContentUpdate();
              } else if (callback && grid2.size === 0) {
                callback([]);
              }
            });
            sanitizeLastRequestedRange();
            currentUpdateSetRange = null;
            currentUpdateClearRange = null;
            grid2.$server.confirmUpdate(id);
          });
          grid2.$connector.ensureHierarchy = tryCatchWrapper(function() {
            for (let parentKey in cache) {
              if (parentKey !== root2) {
                delete cache[parentKey];
              }
            }
            lastRequestedRanges = {};
            dataProviderController.rootCache.removeSubCaches();
            updateAllGridRowsInDomBasedOnCache();
          });
          grid2.$connector.setSelectionMode = tryCatchWrapper(function(mode) {
            if ((typeof mode === "string" || mode instanceof String) && validSelectionModes.indexOf(mode) >= 0) {
              selectionMode = mode;
              selectedKeys = {};
              grid2.$connector.updateMultiSelectable();
            } else {
              throw "Attempted to set an invalid selection mode";
            }
          });
          grid2.$connector.updateMultiSelectable = tryCatchWrapper(function() {
            if (!grid2.$) {
              return;
            }
            if (selectionMode === validSelectionModes[0]) {
              grid2.$.table.setAttribute("aria-multiselectable", false);
            } else if (selectionMode === validSelectionModes[1]) {
              grid2.$.table.removeAttribute("aria-multiselectable");
            } else {
              grid2.$.table.setAttribute("aria-multiselectable", true);
            }
          });
          grid2._createPropertyObserver("isAttached", () => grid2.$connector.updateMultiSelectable());
          const singleTimeRenderer = (renderer) => {
            return (root22) => {
              if (renderer) {
                renderer(root22);
                renderer = null;
              }
            };
          };
          grid2.$connector.setHeaderRenderer = tryCatchWrapper(function(column, options) {
            const { content, showSorter, sorterPath } = options;
            if (content === null) {
              column.headerRenderer = null;
              return;
            }
            column.headerRenderer = singleTimeRenderer((root22) => {
              root22.innerHTML = "";
              let contentRoot = root22;
              if (showSorter) {
                const sorter = document.createElement("vaadin-grid-sorter");
                sorter.setAttribute("path", sorterPath);
                const ariaLabel = content instanceof Node ? content.textContent : content;
                if (ariaLabel) {
                  sorter.setAttribute("aria-label", `Sort by ${ariaLabel}`);
                }
                root22.appendChild(sorter);
                contentRoot = sorter;
              }
              if (content instanceof Node) {
                contentRoot.appendChild(content);
              } else {
                contentRoot.textContent = content;
              }
            });
          });
          grid2._getActiveSorters = function() {
            return this._sorters.filter((sorter) => sorter.direction);
          };
          grid2.__applySorters = () => {
            const sorters = grid2._mapSorters();
            const sortersChanged = JSON.stringify(grid2._previousSorters) !== JSON.stringify(sorters);
            grid2._previousSorters = sorters;
            Grid.prototype.__applySorters.call(grid2);
            if (sortersChanged && !sorterDirectionsSetFromServer) {
              grid2.$server.sortersChanged(sorters);
            }
          };
          grid2.$connector.setFooterRenderer = tryCatchWrapper(function(column, options) {
            const { content } = options;
            if (content === null) {
              column.footerRenderer = null;
              return;
            }
            column.footerRenderer = singleTimeRenderer((root22) => {
              root22.innerHTML = "";
              if (content instanceof Node) {
                root22.appendChild(content);
              } else {
                root22.textContent = content;
              }
            });
          });
          grid2.addEventListener(
            "vaadin-context-menu-before-open",
            tryCatchWrapper(function(e2) {
              const { key, columnId } = e2.detail;
              grid2.$server.updateContextMenuTargetItem(key, columnId);
            })
          );
          grid2.getContextMenuBeforeOpenDetail = tryCatchWrapper(function(event) {
            const sourceEvent = event.detail.sourceEvent || event;
            const eventContext = grid2.getEventContext(sourceEvent);
            const key = eventContext.item?.key || "";
            const columnId = eventContext.column?.id || "";
            return { key, columnId };
          });
          grid2.preventContextMenu = tryCatchWrapper(function(event) {
            const isLeftClick = event.type === "click";
            const { column } = grid2.getEventContext(event);
            return isLeftClick && column instanceof GridFlowSelectionColumn;
          });
          grid2.addEventListener(
            "click",
            tryCatchWrapper((e2) => _fireClickEvent(e2, "item-click"))
          );
          grid2.addEventListener(
            "dblclick",
            tryCatchWrapper((e2) => _fireClickEvent(e2, "item-double-click"))
          );
          grid2.addEventListener(
            "column-resize",
            tryCatchWrapper((e2) => {
              const cols = grid2._getColumnsInOrder().filter((col) => !col.hidden);
              cols.forEach((col) => {
                col.dispatchEvent(new CustomEvent("column-drag-resize"));
              });
              grid2.dispatchEvent(
                new CustomEvent("column-drag-resize", {
                  detail: {
                    resizedColumnKey: e2.detail.resizedColumn._flowId
                  }
                })
              );
            })
          );
          grid2.addEventListener(
            "column-reorder",
            tryCatchWrapper((e2) => {
              const columns = grid2._columnTree.slice(0).pop().filter((c) => c._flowId).sort((b, a) => b._order - a._order).map((c) => c._flowId);
              grid2.dispatchEvent(
                new CustomEvent("column-reorder-all-columns", {
                  detail: { columns }
                })
              );
            })
          );
          grid2.addEventListener(
            "cell-focus",
            tryCatchWrapper((e2) => {
              const eventContext = grid2.getEventContext(e2);
              const expectedSectionValues = ["header", "body", "footer"];
              if (expectedSectionValues.indexOf(eventContext.section) === -1) {
                return;
              }
              grid2.dispatchEvent(
                new CustomEvent("grid-cell-focus", {
                  detail: {
                    itemKey: eventContext.item ? eventContext.item.key : null,
                    internalColumnId: eventContext.column ? eventContext.column._flowId : null,
                    section: eventContext.section
                  }
                })
              );
            })
          );
          function _fireClickEvent(event, eventName) {
            if (event.defaultPrevented) {
              return;
            }
            const target = event.target;
            if (isFocusable(target) || target instanceof HTMLLabelElement) {
              return;
            }
            const eventContext = grid2.getEventContext(event);
            const section = eventContext.section;
            if (eventContext.item && section !== "details") {
              event.itemKey = eventContext.item.key;
              if (eventContext.column) {
                event.internalColumnId = eventContext.column._flowId;
              }
              grid2.dispatchEvent(new CustomEvent(eventName, { detail: event }));
            }
          }
          grid2.cellClassNameGenerator = tryCatchWrapper(function(column, rowData) {
            const style = rowData.item.style;
            if (!style) {
              return;
            }
            return (style.row || "") + " " + (column && style[column._flowId] || "");
          });
          grid2.cellPartNameGenerator = tryCatchWrapper(function(column, rowData) {
            const part = rowData.item.part;
            if (!part) {
              return;
            }
            return (part.row || "") + " " + (column && part[column._flowId] || "");
          });
          grid2.dropFilter = tryCatchWrapper((rowData) => rowData.item && !rowData.item.dropDisabled);
          grid2.dragFilter = tryCatchWrapper((rowData) => rowData.item && !rowData.item.dragDisabled);
          grid2.addEventListener(
            "grid-dragstart",
            tryCatchWrapper((e2) => {
              if (grid2._isSelected(e2.detail.draggedItems[0])) {
                if (grid2.__selectionDragData) {
                  Object.keys(grid2.__selectionDragData).forEach((type) => {
                    e2.detail.setDragData(type, grid2.__selectionDragData[type]);
                  });
                } else {
                  (grid2.__dragDataTypes || []).forEach((type) => {
                    e2.detail.setDragData(type, e2.detail.draggedItems.map((item2) => item2.dragData[type]).join("\n"));
                  });
                }
                if (grid2.__selectionDraggedItemsCount > 1) {
                  e2.detail.setDraggedItemsCount(grid2.__selectionDraggedItemsCount);
                }
              } else {
                (grid2.__dragDataTypes || []).forEach((type) => {
                  e2.detail.setDragData(type, e2.detail.draggedItems[0].dragData[type]);
                });
              }
            })
          );
        })(grid)
      };
    })();
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const passwordFieldButton = css$e`
  :host {
    position: absolute;
    right: 0;
    top: 0;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    min-width: auto;
    background: transparent;
    outline: none;
  }
`;
    registerStyles$1("vaadin-password-field-button", [button, passwordFieldButton], {
      moduleId: "lumo-password-field-button"
    });
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const passwordField = css$e`
  [part='reveal-button']::before {
    content: var(--lumo-icons-eye);
  }

  :host([password-visible]) [part='reveal-button']::before {
    content: var(--lumo-icons-eye-disabled);
  }

  /* Make it easy to hide the button across the whole app */
  [part='reveal-button'] {
    position: relative;
    display: var(--lumo-password-field-reveal-button-display, block);
  }

  [part='reveal-button'][hidden] {
    display: none !important;
  }
`;
    registerStyles$1("vaadin-password-field", [inputFieldShared, passwordField], { moduleId: "lumo-password-field" });
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-password-field-button", buttonStyles, { moduleId: "vaadin-password-field-button-styles" });
    class PasswordFieldButton extends ButtonMixin(DirMixin(ThemableMixin(PolymerElement))) {
      static get is() {
        return "vaadin-password-field-button";
      }
      static get template() {
        return html``;
      }
    }
    defineCustomElement(PasswordFieldButton);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const PasswordFieldMixin = (superClass) => class PasswordFieldMixinClass extends SlotStylesMixin(DisabledMixin(FocusMixin(InputMixin(superClass)))) {
      static get properties() {
        return {
          /**
           * Set to true to hide the eye icon which toggles the password visibility.
           * @attr {boolean} reveal-button-hidden
           */
          revealButtonHidden: {
            type: Boolean,
            observer: "_revealButtonHiddenChanged",
            value: false
          },
          /**
           * True if the password is visible ([type=text]).
           * @attr {boolean} password-visible
           */
          passwordVisible: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            observer: "_passwordVisibleChanged",
            readOnly: true
          },
          /**
           * An object with translated strings used for localization.
           * It has the following structure and default values:
           *
           * ```
           * {
           *   // Translation of the reveal icon button accessible label
           *   reveal: 'Show password'
           * }
           * ```
           */
          i18n: {
            type: Object,
            value: () => {
              return {
                reveal: "Show password"
              };
            }
          }
        };
      }
      static get observers() {
        return ["__i18nChanged(i18n)"];
      }
      constructor() {
        super();
        this._setType("password");
        this.__boundRevealButtonClick = this._onRevealButtonClick.bind(this);
        this.__boundRevealButtonMouseDown = this._onRevealButtonMouseDown.bind(this);
        this.__lastChange = "";
      }
      /** @protected */
      get slotStyles() {
        const tag = this.localName;
        return [
          ...super.slotStyles,
          `
          ${tag} [slot="input"]::-ms-reveal {
            display: none;
          }
        `
        ];
      }
      /** @protected */
      get _revealNode() {
        return this._revealButtonController && this._revealButtonController.node;
      }
      /** @protected */
      ready() {
        super.ready();
        this._revealPart = this.shadowRoot.querySelector('[part="reveal-button"]');
        this._revealButtonController = new SlotController(this, "reveal", "vaadin-password-field-button", {
          initializer: (btn) => {
            btn.disabled = this.disabled;
            btn.addEventListener("click", this.__boundRevealButtonClick);
            btn.addEventListener("mousedown", this.__boundRevealButtonMouseDown);
          }
        });
        this.addController(this._revealButtonController);
        this.__updateAriaLabel(this.i18n);
        this._updateToggleState(false);
        this._toggleRevealHidden(this.revealButtonHidden);
        if (this.inputElement) {
          this.inputElement.autocapitalize = "off";
        }
      }
      /**
       * Override an event listener inherited from `InputControlMixin`
       * to store the value at the moment of the native `change` event.
       * @param {Event} event
       * @protected
       * @override
       */
      _onChange(event) {
        super._onChange(event);
        this.__lastChange = this.inputElement.value;
      }
      /**
       * Override method inherited from `FocusMixin` to mark field as focused
       * when focus moves to the reveal button using Shift Tab.
       * @param {Event} event
       * @return {boolean}
       * @protected
       */
      _shouldSetFocus(event) {
        return event.target === this.inputElement || event.target === this._revealNode;
      }
      /**
       * Override method inherited from `FocusMixin` to not hide password
       * when focus moves to the reveal button or back to the input.
       * @param {Event} event
       * @return {boolean}
       * @protected
       */
      _shouldRemoveFocus(event) {
        return !(event.relatedTarget === this._revealNode || event.relatedTarget === this.inputElement && event.target === this._revealNode);
      }
      /**
       * Override method inherited from `FocusMixin` to toggle password visibility.
       * @param {boolean} focused
       * @protected
       * @override
       */
      _setFocused(focused) {
        super._setFocused(focused);
        if (!focused) {
          this._setPasswordVisible(false);
          if (this.__lastChange !== this.inputElement.value) {
            this.__lastChange = this.inputElement.value;
            this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
          }
        } else {
          const isButtonFocused = this.getRootNode().activeElement === this._revealNode;
          this.toggleAttribute("focus-ring", this._keyboardActive && !isButtonFocused);
        }
      }
      /** @private */
      __updateAriaLabel(i18n) {
        if (i18n && i18n.reveal && this._revealNode) {
          this._revealNode.setAttribute("aria-label", i18n.reveal);
        }
      }
      /** @private */
      __i18nChanged(i18n) {
        this.__updateAriaLabel(i18n);
      }
      /** @private */
      _revealButtonHiddenChanged(hidden) {
        this._toggleRevealHidden(hidden);
      }
      /** @private */
      _togglePasswordVisibility() {
        this._setPasswordVisible(!this.passwordVisible);
      }
      /** @private */
      _onRevealButtonClick() {
        this._togglePasswordVisibility();
      }
      /** @private */
      _onRevealButtonMouseDown(e2) {
        e2.preventDefault();
        this.inputElement.focus();
      }
      /** @private */
      _toggleRevealHidden(hidden) {
        if (this._revealNode) {
          if (hidden) {
            this._revealPart.setAttribute("hidden", "");
            this._revealNode.setAttribute("tabindex", "-1");
            this._revealNode.setAttribute("aria-hidden", "true");
          } else {
            this._revealPart.removeAttribute("hidden");
            this._revealNode.setAttribute("tabindex", "0");
            this._revealNode.removeAttribute("aria-hidden");
          }
        }
      }
      /** @private */
      _updateToggleState(passwordVisible) {
        if (this._revealNode) {
          this._revealNode.setAttribute("aria-pressed", passwordVisible ? "true" : "false");
        }
      }
      /** @private */
      _passwordVisibleChanged(passwordVisible) {
        this._setType(passwordVisible ? "text" : "password");
        this._updateToggleState(passwordVisible);
      }
      /**
       * Override method inherited from `DisabledMixin` to synchronize the reveal button
       * disabled state with the password field disabled state.
       * @param {boolean} disabled
       * @param {boolean} oldDisabled
       * @protected
       */
      _disabledChanged(disabled, oldDisabled) {
        super._disabledChanged(disabled, oldDisabled);
        if (this._revealNode) {
          this._revealNode.disabled = disabled;
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const ownTemplate = html`
  <div part="reveal-button" slot="suffix">
    <slot name="reveal"></slot>
  </div>
`;
    let memoizedTemplate;
    class PasswordField extends PasswordFieldMixin(TextField) {
      static get is() {
        return "vaadin-password-field";
      }
      static get template() {
        if (!memoizedTemplate) {
          memoizedTemplate = super.template.cloneNode(true);
          const revealButton = ownTemplate.content.querySelector('[part="reveal-button"]');
          const inputField = memoizedTemplate.content.querySelector('[part="input-field"]');
          inputField.appendChild(revealButton);
        }
        return memoizedTemplate;
      }
    }
    defineCustomElement(PasswordField);
    const loginFormWrapper$1 = css$e`
  :host {
    max-width: calc(var(--lumo-size-m) * 10);
    background: var(--lumo-base-color) linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
  }

  [part='form'] {
    padding: var(--lumo-space-l);
  }

  [part='form-title'] {
    margin-top: calc(var(--lumo-font-size-xxxl) - var(--lumo-font-size-xxl));
  }

  ::slotted([slot='submit']) {
    margin-top: var(--lumo-space-l);
    margin-bottom: var(--lumo-space-s);
  }

  ::slotted([slot='forgot-password']) {
    margin: var(--lumo-space-s) auto;
  }

  [part='error-message'] {
    background-color: var(--lumo-error-color-10pct);
    padding: var(--lumo-space-m);
    border-radius: var(--lumo-border-radius-m);
    margin-top: var(--lumo-space-m);
    margin-bottom: var(--lumo-space-s);
    color: var(--lumo-error-text-color);
  }

  :host(:not([dir='rtl'])) [part='error-message'] {
    padding-left: var(--lumo-size-m);
  }

  :host([dir='rtl']) [part='error-message'] {
    padding-right: var(--lumo-size-m);
  }

  [part='error-message']::before {
    content: var(--lumo-icons-error);
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-m);
    position: absolute;
    width: var(--lumo-size-m);
    height: 1em;
    line-height: 1;
    text-align: center;
  }

  :host(:not([dir='rtl'])) [part='error-message']::before {
    /* Visual centering */
    margin-left: calc(var(--lumo-size-m) * -0.95);
  }

  :host([dir='rtl']) [part='error-message']::before {
    /* Visual centering */
    margin-right: calc(var(--lumo-size-m) * -0.95);
  }

  [part='error-message-title'] {
    margin: 0 0 0.25em;
    color: inherit;
  }

  [part='error-message-description'] {
    font-size: var(--lumo-font-size-s);
    line-height: var(--lumo-line-height-s);
    margin: 0;
    opacity: 0.9;
  }

  [part='footer'] {
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-s);
    color: var(--lumo-secondary-text-color);
  }
`;
    registerStyles$1("vaadin-login-form-wrapper", [color$h, typography, loginFormWrapper$1], {
      moduleId: "lumo-login-form-wrapper"
    });
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const loginFormWrapperStyles = css$e`
  :host {
    overflow: hidden;
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='form'] {
    flex: 1;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
  }

  [part='form-title'] {
    margin: 0;
  }

  [part='error-message'] {
    position: relative;
  }
`;
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-login-form-wrapper", loginFormWrapperStyles, {
      moduleId: "vaadin-login-form-wrapper-styles"
    });
    class LoginFormWrapper extends ThemableMixin(PolymerElement) {
      static get template() {
        return html`
      <section part="form">
        <h2 part="form-title">[[i18n.form.title]]</h2>
        <div part="error-message" hidden$="[[!error]]">
          <h5 part="error-message-title">[[i18n.errorMessage.title]]</h5>
          <p part="error-message-description">[[i18n.errorMessage.message]]</p>
        </div>

        <slot name="form"></slot>

        <slot name="custom-form-area"></slot>

        <slot name="submit"></slot>

        <slot name="forgot-password"></slot>

        <div part="footer">
          <slot name="footer"></slot>
          <p>[[i18n.additionalInformation]]</p>
        </div>
      </section>
    `;
      }
      static get is() {
        return "vaadin-login-form-wrapper";
      }
      static get properties() {
        return {
          /**
           * If set, the error message is shown. The message is hidden by default.
           * When set, it changes the disabled state of the submit button.
           * @type {boolean}
           */
          error: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          /**
           * The object used to localize this component.
           */
          i18n: {
            type: Object
          }
        };
      }
    }
    defineCustomElement(LoginFormWrapper);
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const LoginMixin = (superClass) => class LoginMixin extends superClass {
      /**
       * Fired when user clicks on the "Forgot password" button.
       *
       * @event forgot-password
       */
      /**
       * Fired when an user submits the login.
       * The event contains `username` and `password` values in the `detail` property.
       *
       * @event login
       */
      static get properties() {
        return {
          /**
           * If set, a synchronous POST call will be fired to the path defined.
           * The `login` event is also dispatched, so `event.preventDefault()` can be called to prevent the POST call.
           * @type {string | null}
           */
          action: {
            type: String,
            value: null
          },
          /**
           * If set, disable the "Log in" button and prevent user from submitting login form.
           * It is re-enabled automatically, when error is set to true, allowing form resubmission
           * after user makes changes.
           * @type {boolean}
           */
          disabled: {
            type: Boolean,
            value: false,
            notify: true
          },
          /**
           * If set, the error message is shown. The message is hidden by default.
           * When set, it changes the disabled state of the submit button.
           * @type {boolean}
           */
          error: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            notify: true
          },
          /**
           * Whether to hide the forgot password button. The button is visible by default.
           * @type {boolean}
           * @attr {boolean} no-forgot-password
           */
          noForgotPassword: {
            type: Boolean,
            value: false
          },
          /**
           * If set, the user name field automatically receives focus when the component is attached to the document.
           * @type {boolean}
           * @attr {boolean} no-autofocus
           */
          noAutofocus: {
            type: Boolean,
            value: false
          },
          /**
           * The object used to localize this component.
           * For changing the default localization, change the entire
           * _i18n_ object or just the property you want to modify.
           *
           * The object has the following JSON structure (by default it doesn't include `additionalInformation`
           * and `header` sections, `header` can be added to override `title` and `description` properties
           * in `vaadin-login-overlay`):
           *
           * ```
           * {
           *   header: {
           *     title: 'App name',
           *     description: 'Inspiring application description'
           *   },
           *   form: {
           *     title: 'Log in',
           *     username: 'Username',
           *     password: 'Password',
           *     submit: 'Log in',
           *     forgotPassword: 'Forgot password'
           *   },
           *   errorMessage: {
           *     title: 'Incorrect username or password',
           *     message: 'Check that you have entered the correct username and password and try again.',
           *     username: 'Username is required',
           *     password: 'Password is required'
           *   },
           *   additionalInformation: 'In case you need to provide some additional info for the user.'
           * }
           * ```
           *
           * @type {!LoginI18n}
           * @default {English/US}
           */
          i18n: {
            type: Object,
            value() {
              return {
                form: {
                  title: "Log in",
                  username: "Username",
                  password: "Password",
                  submit: "Log in",
                  forgotPassword: "Forgot password"
                },
                errorMessage: {
                  title: "Incorrect username or password",
                  message: "Check that you have entered the correct username and password and try again.",
                  username: "Username is required",
                  password: "Password is required"
                }
              };
            }
          },
          /**
           * If set, prevents auto enabling the component when error property is set to true.
           * @private
           */
          _preventAutoEnable: {
            type: Boolean,
            value: false
          }
        };
      }
    };
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const LoginFormMixin = (superClass) => class LoginFormMixin extends LoginMixin(superClass) {
      static get observers() {
        return ["_errorChanged(error)"];
      }
      get _customFields() {
        return [...this.$.vaadinLoginFormWrapper.children].filter((node) => {
          return node.getAttribute("slot") === "custom-form-area" && node.hasAttribute("name");
        });
      }
      /** @protected */
      async connectedCallback() {
        super.connectedCallback();
        if (!this.noAutofocus) {
          await new Promise(requestAnimationFrame);
          this.$.vaadinLoginUsername.focus();
        }
      }
      /** @private */
      _errorChanged() {
        if (this.error && !this._preventAutoEnable) {
          this.disabled = false;
        }
      }
      /**
       * Submits the form.
       */
      submit() {
        const userName = this.$.vaadinLoginUsername;
        const password = this.$.vaadinLoginPassword;
        if (this.disabled || !(userName.validate() && password.validate())) {
          return;
        }
        this.error = false;
        this.disabled = true;
        const detail = {
          username: userName.value,
          password: password.value
        };
        const fields2 = this._customFields;
        if (fields2.length) {
          detail.custom = {};
          fields2.forEach((field) => {
            detail.custom[field.name] = field.value;
          });
        }
        const loginEventDetails = {
          bubbles: true,
          cancelable: true,
          detail
        };
        const firedEvent = this.dispatchEvent(new CustomEvent("login", loginEventDetails));
        if (this.action && firedEvent) {
          const csrfMetaName = document.querySelector("meta[name=_csrf_parameter]");
          const csrfMetaValue = document.querySelector("meta[name=_csrf]");
          if (csrfMetaName && csrfMetaValue) {
            this.$.csrf.name = csrfMetaName.content;
            this.$.csrf.value = csrfMetaValue.content;
          }
          this.querySelector("form").submit();
        }
      }
      /** @protected */
      _onFormData(event) {
        const { formData } = event;
        if (this._customFields.length) {
          this._customFields.forEach((field) => {
            formData.append(field.name, field.value);
          });
        }
      }
      /** @protected */
      _handleInputKeydown(e2) {
        if (e2.key === "Enter") {
          const { currentTarget: inputActive } = e2;
          const nextInput = inputActive.id === "vaadinLoginUsername" ? this.$.vaadinLoginPassword : this.$.vaadinLoginUsername;
          if (inputActive.validate()) {
            if (nextInput.checkValidity()) {
              this.submit();
            } else {
              nextInput.focus();
            }
          }
        }
      }
      /** @protected */
      _handleInputKeyup(e2) {
        const input = e2.currentTarget;
        if (e2.key === "Tab" && input instanceof HTMLInputElement) {
          input.select();
        }
      }
      /** @protected */
      _onForgotPasswordClick() {
        this.dispatchEvent(new CustomEvent("forgot-password"));
      }
    };
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class LoginForm extends LoginFormMixin(ElementMixin(ThemableMixin(PolymerElement))) {
      static get template() {
        return html`
      <style>
        vaadin-login-form-wrapper > form > * {
          width: 100%;
        }
      </style>
      <vaadin-login-form-wrapper id="vaadinLoginFormWrapper" theme$="[[_theme]]" error="[[error]]" i18n="[[i18n]]">
        <form method="POST" action$="[[action]]" on-formdata="_onFormData" slot="form">
          <input id="csrf" type="hidden" />
          <vaadin-text-field
            name="username"
            label="[[i18n.form.username]]"
            error-message="[[i18n.errorMessage.username]]"
            id="vaadinLoginUsername"
            required
            on-keydown="_handleInputKeydown"
            autocapitalize="none"
            autocorrect="off"
            spellcheck="false"
            autocomplete="username"
          >
            <input type="text" slot="input" on-keyup="_handleInputKeyup" />
          </vaadin-text-field>

          <vaadin-password-field
            name="password"
            label="[[i18n.form.password]]"
            error-message="[[i18n.errorMessage.password]]"
            id="vaadinLoginPassword"
            required
            on-keydown="_handleInputKeydown"
            spellcheck="false"
            autocomplete="current-password"
          >
            <input type="password" slot="input" on-keyup="_handleInputKeyup" />
          </vaadin-password-field>
        </form>

        <vaadin-button slot="submit" theme="primary contained submit" on-click="submit" disabled$="[[disabled]]">
          [[i18n.form.submit]]
        </vaadin-button>

        <vaadin-button
          slot="forgot-password"
          theme="tertiary small"
          on-click="_onForgotPasswordClick"
          hidden$="[[noForgotPassword]]"
        >
          [[i18n.form.forgotPassword]]
        </vaadin-button>
      </vaadin-login-form-wrapper>
    `;
      }
      static get is() {
        return "vaadin-login-form";
      }
      /**
       * @param {StampedTemplate} dom
       * @return {null}
       * @protected
       */
      _attachDom(dom) {
        this.appendChild(dom);
      }
    }
    defineCustomElement(LoginForm);
    const loginOverlayWrapper = css$e`
  :host {
    inset: 0;
  }

  [part='backdrop'] {
    background: var(--lumo-base-color) linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));
  }

  [part='content'] {
    padding: 0;
  }

  [part='overlay'] {
    background: none;
    border-radius: 0;
    box-shadow: none;
    width: 100%;
    height: 100%;
  }

  [part='card'] {
    width: calc(var(--lumo-size-m) * 10);
    background: var(--lumo-base-color) linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
  }

  [part='brand'] {
    padding: var(--lumo-space-l) var(--lumo-space-xl) var(--lumo-space-l) var(--lumo-space-l);
    background-color: var(--lumo-primary-color);
    color: var(--lumo-primary-contrast-color);
    min-height: calc(var(--lumo-size-m) * 5);
  }

  [part='description'] {
    line-height: var(--lumo-line-height-s);
    color: var(--lumo-tint-70pct);
    margin-bottom: 0;
  }

  [part='content'] {
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  [part='card'] {
    border-radius: var(--lumo-border-radius-l);
    box-shadow: var(--lumo-box-shadow-s);
    margin: var(--lumo-space-s);
    height: auto;
  }

  /* Small screen */
  @media only screen and (max-width: 500px) {
    [part='overlay'],
    [part='content'] {
      height: 100%;
    }

    [part='content'] {
      min-height: 100%;
      background: var(--lumo-base-color);
      align-items: flex-start;
    }

    [part='card'],
    [part='overlay'] {
      width: 100%;
      border-radius: 0;
      box-shadow: none;
      margin: 0;
    }

    /* RTL styles */
    :host([dir='rtl']) [part='brand'] {
      padding: var(--lumo-space-l) var(--lumo-space-l) var(--lumo-space-l) var(--lumo-space-xl);
    }
  }

  /* Landscape small screen */
  @media only screen and (max-height: 600px) and (min-width: 600px) and (orientation: landscape) {
    [part='card'] {
      flex-direction: row;
      align-items: stretch;
      max-width: calc(var(--lumo-size-m) * 16);
      width: 100%;
    }

    [part='brand'],
    [part='form'] {
      flex: auto;
      flex-basis: 0;
      box-sizing: border-box;
    }

    [part='brand'] {
      justify-content: flex-start;
    }

    [part='form'] {
      padding: var(--lumo-space-l);
      overflow: auto;
    }
  }

  /* Landscape really small screen */
  @media only screen and (max-height: 500px) and (min-width: 600px) and (orientation: landscape),
    only screen and (max-width: 600px) and (min-width: 600px) and (orientation: landscape) {
    [part='content'] {
      height: 100vh;
    }

    [part='card'] {
      margin: 0;
      width: 100%;
      max-width: none;
      height: 100%;
      flex: auto;
      border-radius: 0;
      box-shadow: none;
    }

    [part='form'] {
      height: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
  }

  /* Handle iPhone X notch */
  @media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {
    [part='card'] {
      padding-right: constant(safe-area-inset-right);
      padding-right: env(safe-area-inset-right);

      padding-left: constant(safe-area-inset-left);
      padding-left: env(safe-area-inset-left);
    }

    [part='brand'] {
      margin-left: calc(constant(safe-area-inset-left) * -1);
      margin-left: calc(env(safe-area-inset-left) * -1);

      padding-left: calc(var(--lumo-space-l) + constant(safe-area-inset-left));
      padding-left: calc(var(--lumo-space-l) + env(safe-area-inset-left));
    }

    /* RTL styles */
    :host([dir='rtl']) [part='card'] {
      padding-left: constant(safe-area-inset-right);
      padding-left: env(safe-area-inset-right);
      padding-right: constant(safe-area-inset-left);
      padding-right: env(safe-area-inset-left);
    }

    :host([dir='rtl']) [part='brand'] {
      margin-right: calc(constant(safe-area-inset-left) * -1);
      margin-right: calc(env(safe-area-inset-left) * -1);
      padding-right: calc(var(--lumo-space-l) + constant(safe-area-inset-left));
      padding-right: calc(var(--lumo-space-l) + env(safe-area-inset-left));
    }
  }
`;
    registerStyles$1("vaadin-login-overlay-wrapper", [color$h, typography, overlay, loginOverlayWrapper], {
      moduleId: "lumo-login-overlay-wrapper"
    });
    const loginFormWrapper = css$e`
  :host([theme~='with-overlay']) {
    min-height: 100%;
    display: flex;
    justify-content: center;
    max-width: 100%;
  }

  /* Landscape small screen */
  @media only screen and (max-height: 600px) and (min-width: 600px) and (orientation: landscape) {
    :host([theme~='with-overlay']) [part='form'] {
      height: 100%;
      -webkit-overflow-scrolling: touch;
      flex: 1;
      padding: 2px;
    }
  }
`;
    registerStyles$1("vaadin-login-form-wrapper", [loginFormWrapper], {
      moduleId: "lumo-login-overlay"
    });
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const loginOverlayWrapperStyles = css$e`
  [part='overlay'] {
    outline: none;
  }

  [part='card'] {
    max-width: 100%;
    box-sizing: border-box;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  [part='brand'] {
    box-sizing: border-box;
    overflow: hidden;
    flex-grow: 1;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
  }

  [part='brand'] h1 {
    color: inherit;
    margin: 0;
  }
`;
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-login-overlay-wrapper", [overlayStyles, loginOverlayWrapperStyles], {
      moduleId: "vaadin-login-overlay-wrapper-styles"
    });
    class LoginOverlayWrapper extends OverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
      static get is() {
        return "vaadin-login-overlay-wrapper";
      }
      static get properties() {
        return {
          /**
           * Title of the application.
           */
          title: {
            type: String
          },
          /**
           * Application description. Displayed under the title.
           */
          description: {
            type: String
          }
        };
      }
      static get template() {
        return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <section part="card">
            <div part="brand">
              <slot name="title">
                <h1 part="title">[[title]]</h1>
              </slot>
              <p part="description">[[description]]</p>
            </div>
            <div part="form">
              <slot></slot>
            </div>
          </section>
        </div>
      </div>
    `;
      }
    }
    defineCustomElement(LoginOverlayWrapper);
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const LoginOverlayMixin = (superClass) => class LoginOverlayMixin extends OverlayClassMixin(LoginMixin(superClass)) {
      static get properties() {
        return {
          /**
           * Defines the application description
           * @type {string}
           */
          description: {
            type: String,
            value: "Application description",
            notify: true
          },
          /**
           * True if the overlay is currently displayed.
           * @type {boolean}
           */
          opened: {
            type: Boolean,
            value: false,
            observer: "_onOpenedChange"
          },
          /**
           * Defines the application title
           * @type {string}
           */
          title: {
            type: String,
            value: "App name"
          }
        };
      }
      static get observers() {
        return ["__i18nChanged(i18n)"];
      }
      /** @protected */
      ready() {
        super.ready();
        this._overlayElement = this.$.vaadinLoginOverlayWrapper;
      }
      /** @protected */
      connectedCallback() {
        super.connectedCallback();
        if (this.__restoreOpened) {
          this.opened = true;
        }
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.__restoreOpened = this.opened;
        this.opened = false;
      }
      /** @private */
      __i18nChanged(i18n) {
        const header = i18n && i18n.header;
        if (!header) {
          return;
        }
        this.title = header.title;
        this.description = header.description;
      }
      /** @protected */
      _preventClosingLogin(e2) {
        e2.preventDefault();
      }
      /**
       * @param {!Event} e
       * @protected
       */
      _retargetEvent(e2) {
        e2.stopPropagation();
        const { detail, composed, cancelable, bubbles } = e2;
        const firedEvent = this.dispatchEvent(new CustomEvent(e2.type, { bubbles, cancelable, composed, detail }));
        if (!firedEvent) {
          e2.preventDefault();
        }
      }
      /** @private */
      async _onOpenedChange() {
        const form = this.$.vaadinLoginForm;
        if (!form.$ && this.updateComplete) {
          await this.updateComplete;
        }
        if (!this.opened) {
          form.$.vaadinLoginUsername.value = "";
          form.$.vaadinLoginPassword.value = "";
          this.disabled = false;
          if (this._undoTitleTeleport) {
            this._undoTitleTeleport();
          }
          if (this._undoFieldsTeleport) {
            this._undoFieldsTeleport();
          }
          if (this._undoFooterTeleport) {
            this._undoFooterTeleport();
          }
        } else {
          this._undoTitleTeleport = this._teleport("title", this.$.vaadinLoginOverlayWrapper);
          this._undoFieldsTeleport = this._teleport(
            "custom-form-area",
            form.$.vaadinLoginFormWrapper,
            form.querySelector("vaadin-button")
          );
          this._undoFooterTeleport = this._teleport("footer", form.$.vaadinLoginFormWrapper);
          document.body.style.pointerEvents = this.$.vaadinLoginOverlayWrapper._previousDocumentPointerEvents;
        }
      }
      /** @private */
      _teleport(slot, target, refNode) {
        const teleported = [...this.querySelectorAll(`[slot="${slot}"]`)].map((el) => {
          if (refNode) {
            target.insertBefore(el, refNode);
          } else {
            target.appendChild(el);
          }
          return el;
        });
        return () => {
          this.append(...teleported);
        };
      }
    };
    /**
     * @license
     * Copyright (c) 2018 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class LoginOverlay extends LoginOverlayMixin(ElementMixin(ThemableMixin(PolymerElement))) {
      static get template() {
        return html`
      <vaadin-login-overlay-wrapper
        id="vaadinLoginOverlayWrapper"
        opened="{{opened}}"
        focus-trap
        with-backdrop
        title="[[title]]"
        description="[[description]]"
        theme$="[[_theme]]"
        on-vaadin-overlay-escape-press="_preventClosingLogin"
        on-vaadin-overlay-outside-click="_preventClosingLogin"
      >
        <vaadin-login-form
          theme="with-overlay"
          id="vaadinLoginForm"
          action="[[action]]"
          disabled="{{disabled}}"
          error="{{error}}"
          no-autofocus="[[noAutofocus]]"
          no-forgot-password="[[noForgotPassword]]"
          i18n="{{i18n}}"
          on-login="_retargetEvent"
          on-forgot-password="_retargetEvent"
        ></vaadin-login-form>
      </vaadin-login-overlay-wrapper>

      <div hidden>
        <slot name="custom-form-area"></slot>
        <slot name="footer"></slot>
      </div>
    `;
      }
      static get is() {
        return "vaadin-login-overlay";
      }
    }
    defineCustomElement(LoginOverlay);
    (function() {
      const tryCatchWrapper = function(callback) {
        return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Menu Bar");
      };
      function initLazy(menubar, appId) {
        if (menubar.$connector) {
          return;
        }
        const observer = new MutationObserver((records) => {
          const hasChangedAttributes = records.some((entry) => {
            const oldValue = entry.oldValue;
            const newValue = entry.target.getAttribute(entry.attributeName);
            return oldValue !== newValue;
          });
          if (hasChangedAttributes) {
            menubar.$connector.generateItems();
          }
        });
        menubar.$connector = {
          /**
           * Generates and assigns the items to the menu bar.
           *
           * When the method is called without providing a node id,
           * the previously generated items tree will be used.
           * That can be useful if you only want to sync the disabled and hidden properties of root items.
           *
           * @param {number | undefined} nodeId
           */
          generateItems: tryCatchWrapper((nodeId) => {
            if (!menubar.shadowRoot) {
              setTimeout(() => menubar.$connector.generateItems(nodeId));
              return;
            }
            if (!menubar._container) {
              queueMicrotask(() => menubar.$connector.generateItems(nodeId));
              return;
            }
            if (nodeId) {
              menubar.__generatedItems = window.Vaadin.Flow.contextMenuConnector.generateItemsTree(appId, nodeId);
            }
            let items = menubar.__generatedItems || [];
            items.forEach((item2) => {
              item2.disabled = item2.component.disabled;
              item2.component._rootItem = item2;
            });
            items.forEach((item2) => {
              observer.observe(item2.component, {
                attributeFilter: ["hidden", "disabled"],
                attributeOldValue: true
              });
            });
            items = items.filter((item2) => !item2.component.hidden);
            menubar.items = items;
            menubar._buttons.forEach((button2) => {
              if (button2.item && button2.item.component) {
                button2.addEventListener("click", (e2) => {
                  if (e2.composedPath().indexOf(button2.item.component) === -1) {
                    button2.item.component.click();
                    e2.stopPropagation();
                  }
                });
              }
            });
          })
        };
      }
      function setClassName(component) {
        const item2 = component._rootItem || component._item;
        if (item2) {
          item2.className = component.className;
        }
      }
      window.Vaadin.Flow.menubarConnector = {
        initLazy(...args) {
          return tryCatchWrapper(initLazy)(...args);
        },
        setClassName(...args) {
          return tryCatchWrapper(setClassName)(...args);
        }
      };
    })();
    registerStyles$1(
      "vaadin-message-input",
      css$e`
    :host {
      padding: var(--lumo-space-s) var(--lumo-space-m);
    }

    ::slotted([slot='textarea']) {
      margin-inline-end: var(--lumo-space-s);
    }
  `,
      { moduleId: "lumo-message-input" }
    );
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class MessageInput extends ElementMixin(ThemableMixin(ControllerMixin(PolymerElement))) {
      static get properties() {
        return {
          /**
           * Current content of the text input field
           */
          value: {
            type: String,
            value: ""
          },
          /**
           * The object used to localize this component.
           * For changing the default localization, change the entire
           * `i18n` object.
           *
           * The object has the following JSON structure and default values:
           *
           * ```
           * {
           *   // Used as the button label
           *   send: 'Send',
           *
           *   // Used as the input field's placeholder and aria-label
           *   message: 'Message'
           * }
           * ```
           *
           * @type {!MessageInputI18n}
           * @default {English}
           */
          i18n: {
            type: Object,
            value: () => ({
              send: "Send",
              message: "Message"
            })
          },
          /**
           * Set to true to disable this element.
           * @type {boolean}
           */
          disabled: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          /** @private */
          _button: {
            type: Object
          },
          /** @private */
          _textArea: {
            type: Object
          }
        };
      }
      static get template() {
        return html`
      <style>
        :host {
          align-items: flex-start;
          box-sizing: border-box;
          display: flex;
          max-height: 50vh;
          overflow: hidden;
          flex-shrink: 0;
        }

        :host([hidden]) {
          display: none !important;
        }

        ::slotted([slot='button']) {
          flex-shrink: 0;
        }

        ::slotted([slot='textarea']) {
          align-self: stretch;
          flex-grow: 1;
        }
      </style>
      <slot name="textarea"></slot>

      <slot name="button"></slot>

      <slot name="tooltip"></slot>
    `;
      }
      static get is() {
        return "vaadin-message-input";
      }
      static get observers() {
        return [
          "__buttonPropsChanged(_button, disabled, i18n)",
          "__textAreaPropsChanged(_textArea, disabled, i18n, value)"
        ];
      }
      /** @protected */
      ready() {
        super.ready();
        this._buttonController = new SlotController(this, "button", "vaadin-button", {
          initializer: (btn) => {
            btn.setAttribute("theme", "primary contained");
            btn.addEventListener("click", () => {
              this.__submit();
            });
            this._button = btn;
          }
        });
        this.addController(this._buttonController);
        this._textAreaController = new SlotController(this, "textarea", "vaadin-text-area", {
          initializer: (textarea) => {
            textarea.addEventListener("value-changed", (event) => {
              this.value = event.detail.value;
            });
            textarea.addEventListener("keydown", (event) => {
              if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault();
                event.stopImmediatePropagation();
                this.__submit();
              }
            });
            const input = textarea.inputElement;
            input.removeAttribute("aria-labelledby");
            input.setAttribute("rows", 1);
            input.style.minHeight = "0";
            this._textArea = textarea;
          }
        });
        this.addController(this._textAreaController);
        this._tooltipController = new TooltipController(this);
        this.addController(this._tooltipController);
      }
      focus() {
        if (this._textArea) {
          this._textArea.focus();
        }
      }
      /** @private */
      __buttonPropsChanged(button2, disabled, i18n) {
        if (button2) {
          button2.disabled = disabled;
          button2.textContent = i18n.send;
        }
      }
      /** @private */
      __textAreaPropsChanged(textArea, disabled, i18n, value) {
        if (textArea) {
          textArea.disabled = disabled;
          textArea.value = value;
          const message = i18n.message;
          textArea.placeholder = message;
          if (message) {
            textArea.inputElement.setAttribute("aria-label", message);
          } else {
            textArea.inputElement.removeAttribute("aria-label");
          }
        }
      }
      /**
       * Submits the current value as an custom event named 'submit'.
       * It also clears the text input and refocuses it for sending another message.
       * In UI, can be triggered by pressing the submit button or pressing enter key when field is focused.
       * It does not submit anything if text is empty.
       */
      __submit() {
        if (this.value !== "") {
          this.dispatchEvent(new CustomEvent("submit", { detail: { value: this.value } }));
          this.value = "";
        }
        this._textArea.focus();
      }
      /**
       * Fired when a new message is submitted with `<vaadin-message-input>`, either
       * by clicking the "send" button, or pressing the Enter key.
       * @event submit
       */
    }
    defineCustomElement(MessageInput);
    (function() {
      const tryCatchWrapper = function(callback) {
        return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Message List");
      };
      window.Vaadin.Flow.messageListConnector = {
        setItems: (list, items, locale2) => tryCatchWrapper(function(list2, items2, locale3) {
          const formatter = new Intl.DateTimeFormat(locale3, {
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "numeric",
            minute: "numeric"
          });
          list2.items = items2.map(
            (item2) => item2.time ? Object.assign(item2, {
              time: formatter.format(new Date(item2.time))
            }) : item2
          );
        })(list, items, locale2)
      };
    })();
    registerStyles$1(
      "vaadin-message",
      css$e`
    :host {
      color: var(--lumo-body-text-color);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      line-height: var(--lumo-line-height-m);
      padding: var(--lumo-space-s) var(--lumo-space-m);
      -moz-osx-font-smoothing: grayscale;
      -webkit-font-smoothing: antialiased;
      -webkit-text-size-adjust: 100%;
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    }

    :host([focus-ring]) {
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    [part='header'] {
      min-height: calc(var(--lumo-font-size-m) * var(--lumo-line-height-m));
    }

    [part='name'] {
      margin-right: var(--lumo-space-s);
    }

    [part='name']:empty {
      margin-right: 0;
    }

    :host([dir='rtl']) [part='name'] {
      margin-left: var(--lumo-space-s);
      margin-right: 0;
    }

    :host([dir='rtl']) [part='name']:empty {
      margin-left: 0;
    }

    [part='time'] {
      color: var(--lumo-secondary-text-color);
      font-size: var(--lumo-font-size-s);
    }

    ::slotted([slot='avatar']) {
      --vaadin-avatar-size: var(--lumo-size-m);
      margin-top: calc(var(--lumo-space-s));
      margin-inline-end: calc(var(--lumo-space-m));
    }
  `,
      { moduleId: "lumo-message" }
    );
    registerStyles$1("vaadin-message-list", css$e``, { moduleId: "lumo-message-list" });
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class Message extends FocusMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
      static get properties() {
        return {
          /**
           * Time of sending the message. It is rendered as-is to the part='time' slot,
           * so the formatting is up to you.
           */
          time: {
            type: String
          },
          /**
           * The name of the user posting the message.
           * It will be placed in the name part to indicate who has sent the message.
           * It is also used as a tooltip for the avatar.
           * Example: `message.userName = "Jessica Jacobs";`
           * @attr {string} user-name
           */
          userName: {
            type: String
          },
          /**
           * The abbreviation of the user.
           * The abbreviation will be passed on to avatar of the message.
           * If the user does not have an avatar picture set with `userImg`, `userAbbr` will be shown in the avatar.
           * Example: `message.userAbbr = "JJ";`
           * @attr {string} user-abbr
           */
          userAbbr: {
            type: String
          },
          /**
           * An URL for a user image.
           * The image will be used in the avatar component to show who has sent the message.
           * Example: `message.userImg = "/static/img/avatar.jpg";`
           * @attr {string} user-img
           */
          userImg: {
            type: String
          },
          /**
           * A color index to be used to render the color of the avatar.
           * With no `userColorIndex` set, the basic avatar color will be used.
           * By setting a userColorIndex, the component will check if there exists a CSS variable defining the color, and uses it if there is one.
           * If now CSS variable is found for the color index, the property for the color will not be set.
           *
           * Example:
           * CSS:
           * ```css
           * html {
           *   --vaadin-user-color-1: red;
           * }
           * ```
           *
           * JavaScript:
           * ```js
           * message.userColorIndex = 1;
           * ```
           * @attr {number} user-color-index
           */
          userColorIndex: {
            type: Number
          },
          /** @private */
          _avatar: {
            ttype: Object
          }
        };
      }
      static get template() {
        return html`
      <style>
        :host {
          display: flex;
          flex-direction: row;
          outline: none;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='content'] {
          display: flex;
          flex-direction: column;
          flex-grow: 1;
        }

        [part='header'] {
          align-items: baseline;
          display: flex;
          flex-direction: row;
          flex-wrap: wrap;
        }

        [part='name'] {
          font-weight: 500;
        }

        [part='message'] {
          white-space: pre-wrap;
        }

        ::slotted([slot='avatar']) {
          --vaadin-avatar-outline-width: 0px;
          flex-shrink: 0;
        }
      </style>
      <slot name="avatar"></slot>
      <div part="content">
        <div part="header">
          <span part="name">[[userName]]</span>
          <span part="time">[[time]]</span>
        </div>
        <div part="message"><slot></slot></div>
      </div>
    `;
      }
      static get is() {
        return "vaadin-message";
      }
      static get observers() {
        return ["__avatarChanged(_avatar, userName, userAbbr, userImg, userColorIndex)"];
      }
      /** @protected */
      ready() {
        super.ready();
        this._avatarController = new SlotController(this, "avatar", "vaadin-avatar", {
          initializer: (avatar) => {
            avatar.setAttribute("tabindex", "-1");
            avatar.setAttribute("aria-hidden", "true");
            this._avatar = avatar;
          }
        });
        this.addController(this._avatarController);
      }
      /** @private */
      __avatarChanged(avatar, userName, userAbbr, userImg, userColorIndex) {
        if (avatar) {
          avatar.setProperties({
            name: userName,
            abbr: userAbbr,
            img: userImg,
            colorIndex: userColorIndex
          });
        }
      }
    }
    defineCustomElement(Message);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class MessageList extends KeyboardDirectionMixin(ElementMixin(ThemableMixin(PolymerElement))) {
      static get is() {
        return "vaadin-message-list";
      }
      static get properties() {
        return {
          /**
           * An array of objects which will be rendered as messages.
           * The message objects can have the following properties:
           * ```js
           * Array<{
           *   text: string,
           *   time: string,
           *   userName: string,
           *   userAbbr: string,
           *   userImg: string,
           *   userColorIndex: number,
           *   className: string,
           *   theme: string
           * }>
           * ```
           */
          items: {
            type: Array,
            value: () => [],
            observer: "_itemsChanged"
          }
        };
      }
      static get template() {
        return html`
      <style>
        :host {
          display: block;
          overflow: auto;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <div part="list" role="list">
        <slot></slot>
      </div>
    `;
      }
      /** @protected */
      get _messages() {
        return [...this.querySelectorAll("vaadin-message")];
      }
      /** @protected */
      ready() {
        super.ready();
        this.setAttribute("aria-relevant", "additions");
        this.setAttribute("role", "log");
      }
      /**
       * Override method inherited from `KeyboardDirectionMixin`
       * to use the list of message elements as items.
       *
       * @return {Element[]}
       * @protected
       * @override
       */
      _getItems() {
        return this._messages;
      }
      /** @private */
      _itemsChanged(newVal, oldVal) {
        const items = newVal || [];
        const oldItems = oldVal || [];
        if (items.length || oldItems.length) {
          const focusedIndex = this._getIndexOfFocusableElement();
          const closeToBottom = this.scrollHeight < this.clientHeight + this.scrollTop + 50;
          this._renderMessages(items);
          this._setTabIndexesByIndex(focusedIndex);
          requestAnimationFrame(() => {
            if (items.length > oldItems.length && closeToBottom) {
              this._scrollToLastMessage();
            }
          });
        }
      }
      /** @private */
      _renderMessages(items) {
        render(
          html$1`
        ${items.map(
            (item2) => html$1`
              <vaadin-message
                role="listitem"
                .time="${item2.time}"
                .userAbbr="${item2.userAbbr}"
                .userName="${item2.userName}"
                .userImg="${item2.userImg}"
                .userColorIndex="${item2.userColorIndex}"
                theme="${ifDefined(item2.theme)}"
                class="${ifDefined(item2.className)}"
                @focusin="${this._onMessageFocusIn}"
                >${item2.text}<vaadin-avatar slot="avatar"></vaadin-avatar
              ></vaadin-message>
            `
          )}
      `,
          this,
          { host: this }
        );
      }
      /** @private */
      _scrollToLastMessage() {
        if (this.items.length > 0) {
          this.scrollTop = this.scrollHeight - this.clientHeight;
        }
      }
      /** @private */
      _onMessageFocusIn(e2) {
        const target = e2.composedPath().find((node) => node instanceof Message);
        this._setTabIndexesByMessage(target);
      }
      /**
       * @param {number} idx
       * @protected
       */
      _setTabIndexesByIndex(index) {
        const message = this._messages[index] || this._messages[0];
        this._setTabIndexesByMessage(message);
      }
      /** @private */
      _setTabIndexesByMessage(message) {
        this._messages.forEach((e2) => {
          e2.tabIndex = e2 === message ? 0 : -1;
        });
      }
      /** @private */
      _getIndexOfFocusableElement() {
        const index = this._messages.findIndex((e2) => e2.tabIndex === 0);
        return index !== -1 ? index : 0;
      }
    }
    defineCustomElement(MessageList);
    registerStyles$1(
      "vaadin-notification-card",
      css$e`
    :host {
      position: relative;
      margin: var(--lumo-space-s);
    }

    [part='overlay'] {
      background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
      border-radius: var(--lumo-border-radius-l);
      box-shadow: 0 0 0 1px var(--lumo-contrast-10pct), var(--lumo-box-shadow-l);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      font-weight: 400;
      line-height: var(--lumo-line-height-s);
      letter-spacing: 0;
      text-transform: none;
      -webkit-text-size-adjust: 100%;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    [part='content'] {
      padding: var(--lumo-space-wide-l);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    [part='content'] ::slotted(vaadin-button) {
      flex: none;
      margin: 0 calc(var(--lumo-space-s) * -1) 0 var(--lumo-space-m);
    }

    :host([slot^='middle']) {
      max-width: 80vw;
      margin: var(--lumo-space-s) auto;
    }

    :host([slot\$='stretch']) {
      margin: 0;
    }

    :host([slot\$='stretch']) [part='overlay'] {
      border-radius: 0;
    }

    @media (min-width: 421px) {
      :host(:not([slot\$='stretch'])) {
        display: flex;
      }

      :host([slot\$='end']) {
        justify-content: flex-end;
      }

      :host([slot^='middle']),
      :host([slot\$='center']) {
        display: flex;
        justify-content: center;
      }
    }

    @keyframes lumo-notification-exit-fade-out {
      100% {
        opacity: 0;
      }
    }

    @keyframes lumo-notification-enter-fade-in {
      0% {
        opacity: 0;
      }
    }

    @keyframes lumo-notification-enter-slide-down {
      0% {
        transform: translateY(-200%);
        opacity: 0;
      }
    }

    @keyframes lumo-notification-exit-slide-up {
      100% {
        transform: translateY(-200%);
        opacity: 0;
      }
    }

    @keyframes lumo-notification-enter-slide-up {
      0% {
        transform: translateY(200%);
        opacity: 0;
      }
    }

    @keyframes lumo-notification-exit-slide-down {
      100% {
        transform: translateY(200%);
        opacity: 0;
      }
    }

    :host([slot='middle'][opening]) {
      animation: lumo-notification-enter-fade-in 300ms;
    }

    :host([slot='middle'][closing]) {
      animation: lumo-notification-exit-fade-out 300ms;
    }

    :host([slot^='top'][opening]) {
      animation: lumo-notification-enter-slide-down 300ms;
    }

    :host([slot^='top'][closing]) {
      animation: lumo-notification-exit-slide-up 300ms;
    }

    :host([slot^='bottom'][opening]) {
      animation: lumo-notification-enter-slide-up 300ms;
    }

    :host([slot^='bottom'][closing]) {
      animation: lumo-notification-exit-slide-down 300ms;
    }

    :host([theme~='primary']) [part='overlay'] {
      background: var(--lumo-primary-color);
      color: var(--lumo-primary-contrast-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='primary']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-primary-contrast-color);
      --vaadin-button-primary-background: var(--lumo-primary-contrast-color);
      --vaadin-button-primary-text-color: var(--lumo-primary-text-color);
    }

    :host([theme~='contrast']) [part='overlay'] {
      background: var(--lumo-contrast);
      color: var(--lumo-base-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='contrast']) {
      --vaadin-button-background: var(--lumo-contrast-20pct);
      --vaadin-button-text-color: var(--lumo-base-color);
      --vaadin-button-primary-background: var(--lumo-base-color);
      --vaadin-button-primary-text-color: var(--lumo-contrast);
    }

    :host([theme~='success']) [part='overlay'] {
      background: var(--lumo-success-color);
      color: var(--lumo-success-contrast-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='success']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-success-contrast-color);
      --vaadin-button-primary-background: var(--lumo-success-contrast-color);
      --vaadin-button-primary-text-color: var(--lumo-success-text-color);
    }

    :host([theme~='error']) [part='overlay'] {
      background: var(--lumo-error-color);
      color: var(--lumo-error-contrast-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='error']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-error-contrast-color);
      --vaadin-button-primary-background: var(--lumo-error-contrast-color);
      --vaadin-button-primary-text-color: var(--lumo-error-text-color);
    }

    :host([theme~='warning']) [part='overlay'] {
      background: var(--lumo-warning-color);
      color: var(--lumo-warning-contrast-color);
      box-shadow: inset 0 0 0 1px var(--lumo-contrast-20pct), var(--lumo-box-shadow-l);
    }

    :host([theme~='warning']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-warning-contrast-color);
      --vaadin-button-primary-background: var(--lumo-shade-50pct);
      --vaadin-button-primary-text-color: var(--lumo-primary-contrast-color);
    }
  `,
      { moduleId: "lumo-notification-card" }
    );
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class NotificationContainer extends ThemableMixin(ElementMixin(PolymerElement)) {
      static get template() {
        return html`
      <style>
        :host {
          position: fixed;
          z-index: 1000;
          top: 0;
          left: 0;
          bottom: 0;
          right: 0;
          box-sizing: border-box;

          display: flex;
          flex-direction: column;
          align-items: stretch;
          pointer-events: none;
        }

        [region-group] {
          flex: 1 1 0%;
          display: flex;
        }

        [region-group='top'] {
          align-items: flex-start;
        }

        [region-group='bottom'] {
          align-items: flex-end;
        }

        [region-group] > [region] {
          flex: 1 1 0%;
        }

        @media (max-width: 420px) {
          [region-group] {
            flex-direction: column;
            align-items: stretch;
          }

          [region-group='top'] {
            justify-content: flex-start;
          }

          [region-group='bottom'] {
            justify-content: flex-end;
          }

          [region-group] > [region] {
            flex: initial;
          }
        }
      </style>

      <div region="top-stretch"><slot name="top-stretch"></slot></div>
      <div region-group="top">
        <div region="top-start"><slot name="top-start"></slot></div>
        <div region="top-center"><slot name="top-center"></slot></div>
        <div region="top-end"><slot name="top-end"></slot></div>
      </div>
      <div region="middle"><slot name="middle"></slot></div>
      <div region-group="bottom">
        <div region="bottom-start"><slot name="bottom-start"></slot></div>
        <div region="bottom-center"><slot name="bottom-center"></slot></div>
        <div region="bottom-end"><slot name="bottom-end"></slot></div>
      </div>
      <div region="bottom-stretch"><slot name="bottom-stretch"></slot></div>
    `;
      }
      static get is() {
        return "vaadin-notification-container";
      }
      static get properties() {
        return {
          /**
           * True when the container is opened
           * @type {boolean}
           */
          opened: {
            type: Boolean,
            value: false,
            observer: "_openedChanged"
          }
        };
      }
      constructor() {
        super();
        this._boundVaadinOverlayClose = this._onVaadinOverlayClose.bind(this);
        if (isIOS) {
          this._boundIosResizeListener = () => this._detectIosNavbar();
        }
      }
      /** @private */
      _openedChanged(opened) {
        if (opened) {
          document.body.appendChild(this);
          document.addEventListener("vaadin-overlay-close", this._boundVaadinOverlayClose);
          if (this._boundIosResizeListener) {
            this._detectIosNavbar();
            window.addEventListener("resize", this._boundIosResizeListener);
          }
        } else {
          document.body.removeChild(this);
          document.removeEventListener("vaadin-overlay-close", this._boundVaadinOverlayClose);
          if (this._boundIosResizeListener) {
            window.removeEventListener("resize", this._boundIosResizeListener);
          }
        }
      }
      /** @private */
      _detectIosNavbar() {
        const innerHeight = window.innerHeight;
        const innerWidth = window.innerWidth;
        const landscape = innerWidth > innerHeight;
        const clientHeight = document.documentElement.clientHeight;
        if (landscape && clientHeight > innerHeight) {
          this.style.bottom = `${clientHeight - innerHeight}px`;
        } else {
          this.style.bottom = "0";
        }
      }
      /** @private */
      _onVaadinOverlayClose(event) {
        const sourceEvent = event.detail.sourceEvent;
        const isFromNotification = sourceEvent && sourceEvent.composedPath().indexOf(this) >= 0;
        if (isFromNotification) {
          event.preventDefault();
        }
      }
    }
    class NotificationCard extends ThemableMixin(PolymerElement) {
      static get template() {
        return html`
      <style>
        :host {
          display: block;
        }

        [part='overlay'] {
          pointer-events: auto;
        }

        @media (forced-colors: active) {
          [part='overlay'] {
            outline: 3px solid;
          }
        }
      </style>

      <div part="overlay">
        <div part="content">
          <slot></slot>
        </div>
      </div>
    `;
      }
      static get is() {
        return "vaadin-notification-card";
      }
      /** @protected */
      ready() {
        super.ready();
        this.setAttribute("role", "alert");
        this.setAttribute("aria-live", "polite");
      }
    }
    class Notification extends OverlayClassMixin(ThemePropertyMixin(ElementMixin(PolymerElement))) {
      static get template() {
        return html`
      <style>
        :host {
          display: none !important;
        }
      </style>
      <vaadin-notification-card theme$="[[_theme]]"> </vaadin-notification-card>
    `;
      }
      static get is() {
        return "vaadin-notification";
      }
      static get properties() {
        return {
          /**
           * The duration in milliseconds to show the notification.
           * Set to `0` or a negative number to disable the notification auto-closing.
           * @type {number}
           */
          duration: {
            type: Number,
            value: 5e3
          },
          /**
           * True if the notification is currently displayed.
           * @type {boolean}
           */
          opened: {
            type: Boolean,
            value: false,
            notify: true,
            observer: "_openedChanged"
          },
          /**
           * Alignment of the notification in the viewport
           * Valid values are `top-stretch|top-start|top-center|top-end|middle|bottom-start|bottom-center|bottom-end|bottom-stretch`
           * @type {!NotificationPosition}
           */
          position: {
            type: String,
            value: "bottom-start",
            observer: "_positionChanged"
          },
          /**
           * Custom function for rendering the content of the notification.
           * Receives two arguments:
           *
           * - `root` The `<vaadin-notification-card>` DOM element. Append
           *   your content to it.
           * - `notification` The reference to the `<vaadin-notification>` element.
           * @type {!NotificationRenderer | undefined}
           */
          renderer: Function
        };
      }
      static get observers() {
        return ["_durationChanged(duration, opened)", "_rendererChanged(renderer, opened, _overlayElement)"];
      }
      /**
       * Shows a notification with the given content.
       * By default, positions the notification at `bottom-start` and uses a 5 second duration.
       * An options object can be passed to configure the notification.
       * The options object has the following structure:
       *
       * ```
       * {
       *   position?: string
       *   duration?: number
       *   theme?: string
       * }
       * ```
       *
       * See the individual documentation for:
       * - [`position`](#/elements/vaadin-notification#property-position)
       * - [`duration`](#/elements/vaadin-notification#property-duration)
       *
       * @param contents the contents to show, either as a string or a Lit template.
       * @param options optional options for customizing the notification.
       */
      static show(contents, options) {
        if (isTemplateResult(contents)) {
          return Notification._createAndShowNotification((root2) => {
            render(contents, root2);
          }, options);
        }
        return Notification._createAndShowNotification((root2) => {
          root2.innerText = contents;
        }, options);
      }
      /** @private */
      static _createAndShowNotification(renderer, options) {
        const notification = document.createElement(Notification.is);
        if (options && Number.isFinite(options.duration)) {
          notification.duration = options.duration;
        }
        if (options && options.position) {
          notification.position = options.position;
        }
        if (options && options.theme) {
          notification.setAttribute("theme", options.theme);
        }
        notification.renderer = renderer;
        document.body.appendChild(notification);
        notification.opened = true;
        notification.addEventListener("opened-changed", (e2) => {
          if (!e2.detail.value) {
            notification.remove();
          }
        });
        return notification;
      }
      /** @private */
      get _container() {
        if (!Notification._container) {
          Notification._container = document.createElement("vaadin-notification-container");
          document.body.appendChild(Notification._container);
        }
        return Notification._container;
      }
      /** @protected */
      get _card() {
        return this._overlayElement;
      }
      /** @protected */
      ready() {
        super.ready();
        this._overlayElement = this.shadowRoot.querySelector("vaadin-notification-card");
        processTemplates(this);
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback();
        queueMicrotask(() => {
          if (!this.isConnected) {
            this.opened = false;
          }
        });
      }
      /**
       * Requests an update for the content of the notification.
       * While performing the update, it invokes the renderer passed in the `renderer` property.
       *
       * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
       */
      requestContentUpdate() {
        if (!this.renderer) {
          return;
        }
        this.renderer(this._card, this);
      }
      /** @private */
      _rendererChanged(renderer, opened, card) {
        if (!card) {
          return;
        }
        const rendererChanged = this._oldRenderer !== renderer;
        this._oldRenderer = renderer;
        if (rendererChanged) {
          card.innerHTML = "";
          delete card._$litPart$;
        }
        if (opened) {
          if (!this._didAnimateNotificationAppend) {
            this._animatedAppendNotificationCard();
          }
          this.requestContentUpdate();
        }
      }
      /**
       * Opens the notification.
       */
      open() {
        this.opened = true;
      }
      /**
       * Closes the notification.
       */
      close() {
        this.opened = false;
      }
      /** @private */
      _openedChanged(opened) {
        if (opened) {
          this._container.opened = true;
          this._animatedAppendNotificationCard();
        } else if (this._card) {
          this._closeNotificationCard();
        }
      }
      /** @private */
      __cleanUpOpeningClosingState() {
        this._card.removeAttribute("opening");
        this._card.removeAttribute("closing");
        this._card.removeEventListener("animationend", this.__animationEndListener);
      }
      /** @private */
      _animatedAppendNotificationCard() {
        if (this._card) {
          this.__cleanUpOpeningClosingState();
          this._card.setAttribute("opening", "");
          this._appendNotificationCard();
          this.__animationEndListener = () => this.__cleanUpOpeningClosingState();
          this._card.addEventListener("animationend", this.__animationEndListener);
          this._didAnimateNotificationAppend = true;
        } else {
          this._didAnimateNotificationAppend = false;
        }
      }
      /** @private */
      _appendNotificationCard() {
        if (!this._card) {
          return;
        }
        if (!this._container.shadowRoot.querySelector(`slot[name="${this.position}"]`)) {
          console.warn(`Invalid alignment parameter provided: position=${this.position}`);
          return;
        }
        this._card.slot = this.position;
        if (this._container.firstElementChild && /top/u.test(this.position)) {
          this._container.insertBefore(this._card, this._container.firstElementChild);
        } else {
          this._container.appendChild(this._card);
        }
      }
      /** @private */
      _removeNotificationCard() {
        if (this._card.parentNode) {
          this._card.parentNode.removeChild(this._card);
        }
        this._card.removeAttribute("closing");
        this._container.opened = Boolean(this._container.firstElementChild);
      }
      /** @private */
      _closeNotificationCard() {
        if (this._durationTimeoutId) {
          clearTimeout(this._durationTimeoutId);
        }
        this._animatedRemoveNotificationCard();
      }
      /** @private */
      _animatedRemoveNotificationCard() {
        this.__cleanUpOpeningClosingState();
        this._card.setAttribute("closing", "");
        const name = getComputedStyle(this._card).getPropertyValue("animation-name");
        if (name && name !== "none") {
          this.__animationEndListener = () => {
            this._removeNotificationCard();
            this.__cleanUpOpeningClosingState();
          };
          this._card.addEventListener("animationend", this.__animationEndListener);
        } else {
          this._removeNotificationCard();
        }
      }
      /** @private */
      _positionChanged() {
        if (this.opened) {
          this._animatedAppendNotificationCard();
        }
      }
      /** @private */
      _durationChanged(duration, opened) {
        if (opened) {
          clearTimeout(this._durationTimeoutId);
          if (duration > 0) {
            this._durationTimeoutId = setTimeout(() => this.close(), duration);
          }
        }
      }
    }
    defineCustomElement(NotificationContainer);
    defineCustomElement(NotificationCard);
    defineCustomElement(Notification);
    const scroller = css$e`
  :host {
    outline: none;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focus-ring]) {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  /* Show dividers when content overflows */

  :host([theme~='overflow-indicators'])::before,
  :host([theme~='overflow-indicators'])::after {
    content: '';
    display: none;
    position: sticky;
    inset: 0;
    z-index: 9999;
    height: 1px;
    margin-bottom: -1px;
    background: var(--lumo-contrast-10pct);
  }

  :host([theme~='overflow-indicators'])::after {
    margin-bottom: 0;
    margin-top: -1px;
  }

  :host([theme~='overflow-indicators'][overflow~='top'])::before,
  :host([theme~='overflow-indicators'][overflow~='bottom'])::after {
    display: block;
  }
`;
    registerStyles$1("vaadin-scroller", scroller, { moduleId: "lumo-scroller" });
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class OverflowController {
      constructor(host, scrollTarget) {
        this.host = host;
        this.scrollTarget = scrollTarget || host;
        this.__boundOnScroll = this.__onScroll.bind(this);
      }
      hostConnected() {
        if (!this.initialized) {
          this.initialized = true;
          this.observe();
        }
      }
      /**
       * Setup scroll listener and observers to update overflow.
       * Also performs one-time update synchronously when called.
       * @protected
       */
      observe() {
        const { host } = this;
        this.__resizeObserver = new ResizeObserver((entries) => {
          this.__debounceOverflow = Debouncer$1.debounce(this.__debounceOverflow, animationFrame, () => {
            this.__updateOverflow();
          });
        });
        this.__resizeObserver.observe(host);
        [...host.children].forEach((child) => {
          this.__resizeObserver.observe(child);
        });
        this.__childObserver = new MutationObserver((mutations) => {
          mutations.forEach(({ addedNodes, removedNodes }) => {
            addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                this.__resizeObserver.observe(node);
              }
            });
            removedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                this.__resizeObserver.unobserve(node);
              }
            });
          });
          this.__updateOverflow();
        });
        this.__childObserver.observe(host, { childList: true });
        this.scrollTarget.addEventListener("scroll", this.__boundOnScroll);
        this.__updateOverflow();
      }
      /** @private */
      __onScroll() {
        this.__updateOverflow();
      }
      /** @private */
      __updateOverflow() {
        const target = this.scrollTarget;
        let overflow = "";
        if (target.scrollTop > 0) {
          overflow += " top";
        }
        if (Math.ceil(target.scrollTop) < Math.ceil(target.scrollHeight - target.clientHeight)) {
          overflow += " bottom";
        }
        const scrollLeft = Math.abs(target.scrollLeft);
        if (scrollLeft > 0) {
          overflow += " start";
        }
        if (Math.ceil(scrollLeft) < Math.ceil(target.scrollWidth - target.clientWidth)) {
          overflow += " end";
        }
        overflow = overflow.trim();
        if (overflow.length > 0 && this.host.getAttribute("overflow") !== overflow) {
          this.host.setAttribute("overflow", overflow);
        } else if (overflow.length === 0 && this.host.hasAttribute("overflow")) {
          this.host.removeAttribute("overflow");
        }
      }
    }
    /**
     * @license
     * Copyright (c) 2020 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class Scroller extends FocusMixin(ElementMixin(ControllerMixin(ThemableMixin(PolymerElement)))) {
      static get template() {
        return html`
      <style>
        :host([hidden]) {
          display: none !important;
        }

        :host {
          display: block;
          overflow: auto;
        }

        :host([scroll-direction='vertical']) {
          overflow-x: hidden;
        }

        :host([scroll-direction='horizontal']) {
          overflow-y: hidden;
        }

        :host([scroll-direction='none']) {
          overflow: hidden;
        }
      </style>

      <slot></slot>
    `;
      }
      static get is() {
        return "vaadin-scroller";
      }
      static get properties() {
        return {
          /**
           * This property indicates the scroll direction. Supported values are `vertical`, `horizontal`, `none`.
           * When `scrollDirection` is undefined scrollbars will be shown in both directions.
           * @attr {string} scroll-direction
           */
          scrollDirection: {
            type: String,
            reflectToAttribute: true
          },
          /**
           * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
           * @protected
           */
          tabindex: {
            type: Number,
            value: 0,
            reflectToAttribute: true
          }
        };
      }
      /** @protected */
      ready() {
        super.ready();
        this.__overflowController = new OverflowController(this);
        this.addController(this.__overflowController);
      }
      /**
       * Override method inherited from `FocusMixin` to mark the scroller as focused
       * only when the host is focused.
       * @param {Event} event
       * @return {boolean}
       * @protected
       */
      _shouldSetFocus(event) {
        return event.target === this;
      }
    }
    defineCustomElement(Scroller);
    registerStyles$1(
      "vaadin-progress-bar",
      css$e`
    :host {
      height: calc(var(--lumo-size-l) / 10);
      margin: var(--lumo-space-s) 0;
    }

    [part='bar'] {
      border-radius: var(--lumo-border-radius-m);
      background-color: var(--lumo-contrast-10pct);
    }

    [part='value'] {
      border-radius: var(--lumo-border-radius-m);
      background-color: var(--lumo-primary-color);
      /* Use width instead of transform to preserve border radius */
      transform: none;
      width: calc(var(--vaadin-progress-value) * 100%);
      will-change: width;
      transition: 0.1s width linear;
    }

    /* Indeterminate mode */
    :host([indeterminate]) [part='value'] {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to right,
        var(--lumo-primary-color-10pct) 10%,
        var(--lumo-primary-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to left,
        var(--lumo-primary-color-10pct) 10%,
        var(--lumo-primary-color)
      );
      width: 100%;
      background-color: transparent !important;
      background-image: var(--lumo-progress-indeterminate-progress-bar-background);
      opacity: 0.75;
      will-change: transform;
      animation: vaadin-progress-indeterminate 1.6s infinite cubic-bezier(0.645, 0.045, 0.355, 1);
    }

    @keyframes vaadin-progress-indeterminate {
      0% {
        transform: scaleX(0.015);
        transform-origin: 0% 0%;
      }

      25% {
        transform: scaleX(0.4);
      }

      50% {
        transform: scaleX(0.015);
        transform-origin: 100% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background);
      }

      50.1% {
        transform: scaleX(0.015);
        transform-origin: 100% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
      }

      75% {
        transform: scaleX(0.4);
      }

      100% {
        transform: scaleX(0.015);
        transform-origin: 0% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
      }
    }

    :host(:not([aria-valuenow])) [part='value']::before,
    :host([indeterminate]) [part='value']::before {
      content: '';
      display: block;
      width: 100%;
      height: 100%;
      border-radius: inherit;
      background-color: var(--lumo-primary-color);
      will-change: opacity;
      animation: vaadin-progress-pulse3 1.6s infinite cubic-bezier(0.645, 0.045, 0.355, 1);
    }

    @keyframes vaadin-progress-pulse3 {
      0% {
        opacity: 1;
      }

      10% {
        opacity: 0;
      }

      40% {
        opacity: 0;
      }

      50% {
        opacity: 1;
      }

      50.1% {
        opacity: 1;
      }

      60% {
        opacity: 0;
      }

      90% {
        opacity: 0;
      }

      100% {
        opacity: 1;
      }
    }

    /* Contrast color */
    :host([theme~='contrast']) [part='value'],
    :host([theme~='contrast']) [part='value']::before {
      background-color: var(--lumo-contrast-80pct);
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to right,
        var(--lumo-contrast-5pct) 10%,
        var(--lumo-contrast-80pct)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to left,
        var(--lumo-contrast-5pct) 10%,
        var(--lumo-contrast-60pct)
      );
    }

    /* Error color */
    :host([theme~='error']) [part='value'],
    :host([theme~='error']) [part='value']::before {
      background-color: var(--lumo-error-color);
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to right,
        var(--lumo-error-color-10pct) 10%,
        var(--lumo-error-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to left,
        var(--lumo-error-color-10pct) 10%,
        var(--lumo-error-color)
      );
    }

    /* Primary color */
    :host([theme~='success']) [part='value'],
    :host([theme~='success']) [part='value']::before {
      background-color: var(--lumo-success-color);
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to right,
        var(--lumo-success-color-10pct) 10%,
        var(--lumo-success-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to left,
        var(--lumo-success-color-10pct) 10%,
        var(--lumo-success-color)
      );
    }

    /* RTL specific styles */
    :host([indeterminate][dir='rtl']) [part='value'] {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to left,
        var(--lumo-primary-color-10pct) 10%,
        var(--lumo-primary-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to right,
        var(--lumo-primary-color-10pct) 10%,
        var(--lumo-primary-color)
      );
      animation: vaadin-progress-indeterminate-rtl 1.6s infinite cubic-bezier(0.355, 0.045, 0.645, 1);
    }

    :host(:not([aria-valuenow])[dir='rtl']) [part='value']::before,
    :host([indeterminate][dir='rtl']) [part='value']::before {
      animation: vaadin-progress-pulse3 1.6s infinite cubic-bezier(0.355, 0.045, 0.645, 1);
    }

    @keyframes vaadin-progress-indeterminate-rtl {
      0% {
        transform: scaleX(0.015);
        transform-origin: 100% 0%;
      }

      25% {
        transform: scaleX(0.4);
      }

      50% {
        transform: scaleX(0.015);
        transform-origin: 0% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background);
      }

      50.1% {
        transform: scaleX(0.015);
        transform-origin: 0% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
      }

      75% {
        transform: scaleX(0.4);
      }

      100% {
        transform: scaleX(0.015);
        transform-origin: 100% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
      }
    }

    /* Contrast color */
    :host([theme~='contrast'][dir='rtl']) [part='value'],
    :host([theme~='contrast'][dir='rtl']) [part='value']::before {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to left,
        var(--lumo-contrast-5pct) 10%,
        var(--lumo-contrast-80pct)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to right,
        var(--lumo-contrast-5pct) 10%,
        var(--lumo-contrast-60pct)
      );
    }

    /* Error color */
    :host([theme~='error'][dir='rtl']) [part='value'],
    :host([theme~='error'][dir='rtl']) [part='value']::before {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to left,
        var(--lumo-error-color-10pct) 10%,
        var(--lumo-error-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to right,
        var(--lumo-error-color-10pct) 10%,
        var(--lumo-error-color)
      );
    }

    /* Primary color */
    :host([theme~='success'][dir='rtl']) [part='value'],
    :host([theme~='success'][dir='rtl']) [part='value']::before {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to left,
        var(--lumo-success-color-10pct) 10%,
        var(--lumo-success-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to right,
        var(--lumo-success-color-10pct) 10%,
        var(--lumo-success-color)
      );
    }
  `,
      { moduleId: "lumo-progress-bar" }
    );
    const template$2 = document.createElement("template");
    template$2.innerHTML = `
  <style>
    @keyframes vaadin-progress-pulse3 {
      0% { opacity: 1; }
      10% { opacity: 0; }
      40% { opacity: 0; }
      50% { opacity: 1; }
      50.1% { opacity: 1; }
      60% { opacity: 0; }
      90% { opacity: 0; }
      100% { opacity: 1; }
    }
  </style>
`;
    document.head.appendChild(template$2.content);
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const progressBarStyles = css$e`
  :host {
    display: block;
    width: 100%; /* prevent collapsing inside non-stretching column flex */
    height: 8px;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='bar'] {
    height: 100%;
  }

  [part='value'] {
    height: 100%;
    transform-origin: 0 50%;
    transform: scaleX(var(--vaadin-progress-value));
  }

  :host([dir='rtl']) [part='value'] {
    transform-origin: 100% 50%;
  }

  @media (forced-colors: active) {
    [part='bar'] {
      outline: 1px solid;
    }

    [part='value'] {
      background-color: AccentColor !important;
      forced-color-adjust: none;
    }
  }
`;
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const ProgressMixin = (superClass) => class VaadinProgressMixin extends superClass {
      static get properties() {
        return {
          /**
           * Current progress value.
           */
          value: {
            type: Number,
            observer: "_valueChanged"
          },
          /**
           * Minimum bound of the progress bar.
           * @type {number}
           */
          min: {
            type: Number,
            value: 0,
            observer: "_minChanged"
          },
          /**
           * Maximum bound of the progress bar.
           * @type {number}
           */
          max: {
            type: Number,
            value: 1,
            observer: "_maxChanged"
          },
          /**
           * Indeterminate state of the progress bar.
           * This property takes precedence over other state properties (min, max, value).
           * @type {boolean}
           */
          indeterminate: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          }
        };
      }
      static get observers() {
        return ["_normalizedValueChanged(value, min, max)"];
      }
      /** @protected */
      ready() {
        super.ready();
        this.setAttribute("role", "progressbar");
      }
      /** @private */
      _normalizedValueChanged(value, min, max) {
        const newNormalizedValue = this._normalizeValue(value, min, max);
        this.style.setProperty("--vaadin-progress-value", newNormalizedValue);
      }
      /** @private */
      _valueChanged(newV) {
        this.setAttribute("aria-valuenow", newV);
      }
      /** @private */
      _minChanged(newV) {
        this.setAttribute("aria-valuemin", newV);
      }
      /** @private */
      _maxChanged(newV) {
        this.setAttribute("aria-valuemax", newV);
      }
      /**
       * Percent of current progress relative to whole progress bar (max - min)
       * @private
       */
      _normalizeValue(value, min, max) {
        let nV;
        if (!value && value !== 0) {
          nV = 0;
        } else if (min >= max) {
          nV = 1;
        } else {
          nV = (value - min) / (max - min);
          nV = Math.min(Math.max(nV, 0), 1);
        }
        return nV;
      }
    };
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-progress-bar", progressBarStyles, { moduleId: "vaadin-progress-bar-styles" });
    class ProgressBar extends ElementMixin(ThemableMixin(ProgressMixin(PolymerElement))) {
      static get is() {
        return "vaadin-progress-bar";
      }
      static get template() {
        return html`
      <div part="bar">
        <div part="value"></div>
      </div>
    `;
      }
    }
    defineCustomElement(ProgressBar);
    registerStyles$1(
      "vaadin-radio-button",
      css$e`
    :host {
      color: var(--vaadin-radio-button-label-color, var(--lumo-body-text-color));
      font-size: var(--vaadin-radio-button-label-font-size, var(--lumo-font-size-m));
      font-family: var(--lumo-font-family);
      line-height: var(--lumo-line-height-s);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      cursor: default;
      outline: none;
      --_radio-button-size: var(--vaadin-radio-button-size, calc(var(--lumo-size-m) / 2));
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
    }

    :host([has-label]) ::slotted(label) {
      padding: var(
        --vaadin-radio-button-label-padding,
        var(--lumo-space-xs) var(--lumo-space-s) var(--lumo-space-xs) var(--lumo-space-xs)
      );
    }

    [part='radio'] {
      width: var(--_radio-button-size);
      height: var(--_radio-button-size);
      margin: var(--lumo-space-xs);
      position: relative;
      border-radius: 50%;
      background: var(--vaadin-radio-button-background, var(--lumo-contrast-20pct));
      transition: transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2), background-color 0.15s;
      will-change: transform;
      cursor: var(--lumo-clickable-cursor);
      /* Default field border color */
      --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
    }

    /* Used for activation "halo" */
    [part='radio']::before {
      pointer-events: none;
      color: transparent;
      width: 100%;
      height: 100%;
      line-height: var(--_radio-button-size);
      border-radius: inherit;
      background-color: inherit;
      transform: scale(1.4);
      opacity: 0;
      transition: transform 0.1s, opacity 0.8s;
      will-change: transform, opacity;
    }

    /* Used for the dot */
    [part='radio']::after {
      content: '';
      pointer-events: none;
      width: 0;
      height: 0;
      border: var(--vaadin-radio-button-dot-size, 3px) solid
        var(--vaadin-radio-button-dot-color, var(--lumo-primary-contrast-color));
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      transition: 0.25s transform;
      will-change: transform;
      background-clip: content-box;
    }

    :host([checked]) {
      --vaadin-input-field-border-color: transparent;
    }

    :host([checked]) [part='radio'] {
      background-color: var(--_selection-color);
    }

    :host([checked]) [part='radio']::after {
      transform: translate(-50%, -50%) scale(1);
    }

    :host(:not([checked]):not([disabled]):hover) [part='radio'] {
      background: var(--vaadin-radio-button-background-hover, var(--lumo-contrast-30pct));
    }

    :host([active]) [part='radio'] {
      transform: scale(0.9);
      transition-duration: 0.05s;
    }

    :host([active][checked]) [part='radio'] {
      transform: scale(1.1);
    }

    :host([active]:not([checked])) [part='radio']::before {
      transition-duration: 0.01s, 0.01s;
      transform: scale(0);
      opacity: 0.4;
    }

    :host([focus-ring]) [part='radio'] {
      box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color),
        inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
    }

    :host([disabled]) {
      pointer-events: none;
      color: var(--lumo-disabled-text-color);
      --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
    }

    :host([disabled]) ::slotted(label) {
      color: inherit;
    }

    :host([disabled]) [part='radio'] {
      background-color: var(--lumo-contrast-10pct);
    }

    :host([disabled]) [part='radio']::after {
      border-color: var(--lumo-contrast-30pct);
    }

    /* RTL specific styles */
    :host([dir='rtl'][has-label]) ::slotted(label) {
      padding: var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-s);
    }
  `,
      { moduleId: "lumo-radio-button" }
    );
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const RadioButtonMixin = (superclass) => class RadioButtonMixinClass extends LabelMixin(CheckedMixin(DelegateFocusMixin(ActiveMixin(superclass)))) {
      static get properties() {
        return {
          /**
           * The name of the radio button.
           *
           * @type {string}
           */
          name: {
            type: String,
            value: ""
          },
          /**
           * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
           *
           * @override
           * @protected
           */
          tabindex: {
            type: Number,
            value: 0,
            reflectToAttribute: true
          }
        };
      }
      /** @override */
      static get delegateAttrs() {
        return [...super.delegateAttrs, "name"];
      }
      constructor() {
        super();
        this._setType("radio");
        this.value = "on";
      }
      /** @protected */
      ready() {
        super.ready();
        this.addController(
          new InputController(this, (input) => {
            this._setInputElement(input);
            this._setFocusElement(input);
            this.stateTarget = input;
            this.ariaTarget = input;
          })
        );
        this.addController(new LabelledInputController(this.inputElement, this._labelController));
      }
    };
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const radioButtonStyles = css$e`
  :host {
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([disabled]) {
    -webkit-tap-highlight-color: transparent;
  }

  .vaadin-radio-button-container {
    display: grid;
    grid-template-columns: auto 1fr;
    align-items: baseline;
  }

  [part='radio'],
  ::slotted(input),
  ::slotted(label) {
    grid-row: 1;
  }

  [part='radio'],
  ::slotted(input) {
    grid-column: 1;
  }

  [part='radio'] {
    width: var(--vaadin-radio-button-size, 1em);
    height: var(--vaadin-radio-button-size, 1em);
    --_input-border-width: var(--vaadin-input-field-border-width, 0);
    --_input-border-color: var(--vaadin-input-field-border-color, transparent);
    box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
  }

  [part='radio']::before {
    display: block;
    content: '\\202F';
    line-height: var(--vaadin-radio-button-size, 1em);
    contain: paint;
  }

  /* visually hidden */
  ::slotted(input) {
    opacity: 0;
    cursor: inherit;
    margin: 0;
    align-self: stretch;
    -webkit-appearance: none;
    width: initial;
    height: initial;
  }

  @media (forced-colors: active) {
    [part='radio'] {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([focused]) [part='radio'] {
      outline-width: 2px;
    }

    :host([disabled]) [part='radio'] {
      outline-color: GrayText;
    }
  }
`;
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-radio-button", radioButtonStyles, { moduleId: "vaadin-radio-button-styles" });
    class RadioButton extends RadioButtonMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
      static get is() {
        return "vaadin-radio-button";
      }
      static get template() {
        return html`
      <div class="vaadin-radio-button-container">
        <div part="radio" aria-hidden="true"></div>
        <slot name="input"></slot>
        <slot name="label"></slot>
      </div>
    `;
      }
    }
    defineCustomElement(RadioButton);
    const radioGroup = css$e`
  :host {
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-m);
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: var(--lumo-space-xs) 0;
  }

  :host::before {
    /* Effective height of vaadin-radio-button */
    height: var(--lumo-size-s);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  :host([theme~='vertical']) [part='group-field'] {
    flex-direction: column;
  }

  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([focused]:not([readonly])) [part='label'] {
    color: var(--lumo-primary-text-color);
  }

  :host(:hover:not([readonly]):not([focused])) [part='label'],
  :host(:hover:not([readonly])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused])) [part='label'] {
      color: var(--lumo-secondary-text-color);
    }
  }
`;
    registerStyles$1("vaadin-radio-group", [requiredField, helper, radioGroup], { moduleId: "lumo-radio-group" });
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const RadioGroupMixin = (superclass) => class RadioGroupMixinClass extends FieldMixin(FocusMixin(DisabledMixin(KeyboardMixin(superclass)))) {
      static get properties() {
        return {
          /**
           * The value of the radio group.
           *
           * @type {string}
           */
          value: {
            type: String,
            notify: true,
            value: "",
            observer: "__valueChanged"
          },
          /**
           * When present, the user cannot modify the value of the radio group.
           * The property works similarly to the `disabled` property.
           * While the `disabled` property disables all radio buttons inside the group,
           * the `readonly` property disables only unchecked ones.
           *
           * @type {boolean}
           */
          readonly: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            observer: "__readonlyChanged"
          },
          /**
           * @type {string}
           * @private
           */
          _fieldName: {
            type: String
          }
        };
      }
      constructor() {
        super();
        this.__registerRadioButton = this.__registerRadioButton.bind(this);
        this.__unregisterRadioButton = this.__unregisterRadioButton.bind(this);
        this.__onRadioButtonCheckedChange = this.__onRadioButtonCheckedChange.bind(this);
        this._tooltipController = new TooltipController(this);
        this._tooltipController.addEventListener("tooltip-changed", (event) => {
          const tooltip = event.detail.node;
          if (tooltip && tooltip.isConnected) {
            const inputs = this.__radioButtons.map((radio) => radio.inputElement);
            this._tooltipController.setAriaTarget(inputs);
          } else {
            this._tooltipController.setAriaTarget([]);
          }
        });
      }
      /**
       * A collection of the group's radio buttons.
       *
       * @return {!Array<!RadioButton>}
       * @private
       */
      get __radioButtons() {
        return this.__filterRadioButtons([...this.children]);
      }
      /**
       * A currently selected radio button.
       *
       * @return {!RadioButton | undefined}
       * @private
       */
      get __selectedRadioButton() {
        return this.__radioButtons.find((radioButton) => radioButton.checked);
      }
      /**
       * @return {boolean}
       * @private
       */
      get isHorizontalRTL() {
        return this.__isRTL && this._theme !== "vertical";
      }
      /** @protected */
      ready() {
        super.ready();
        this.ariaTarget = this;
        this.setAttribute("role", "radiogroup");
        this._fieldName = `${this.localName}-${generateUniqueId()}`;
        const slot = this.shadowRoot.querySelector("slot:not([name])");
        this._observer = new SlotObserver(slot, ({ addedNodes, removedNodes }) => {
          this.__filterRadioButtons(addedNodes).reverse().forEach(this.__registerRadioButton);
          this.__filterRadioButtons(removedNodes).forEach(this.__unregisterRadioButton);
          const inputs = this.__radioButtons.map((radio) => radio.inputElement);
          this._tooltipController.setAriaTarget(inputs);
        });
        this.addController(this._tooltipController);
      }
      /**
       * @param {!Array<!Node>} nodes
       * @return {!Array<!RadioButton>}
       * @private
       */
      __filterRadioButtons(nodes) {
        return nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && node.localName === "vaadin-radio-button");
      }
      /**
       * Override method inherited from `KeyboardMixin`
       * to implement the custom keyboard navigation as a replacement for the native one
       * in order for the navigation to work the same way across different browsers.
       *
       * @param {!KeyboardEvent} event
       * @override
       * @protected
       */
      _onKeyDown(event) {
        super._onKeyDown(event);
        const radioButton = event.composedPath().find((node) => node.nodeType === Node.ELEMENT_NODE && node.localName === "vaadin-radio-button");
        if (["ArrowLeft", "ArrowUp"].includes(event.key)) {
          event.preventDefault();
          this.__selectNextRadioButton(radioButton);
        }
        if (["ArrowRight", "ArrowDown"].includes(event.key)) {
          event.preventDefault();
          this.__selectPrevRadioButton(radioButton);
        }
      }
      /**
       * Override an observer from `FieldMixin`.
       *
       * @param {boolean} invalid
       * @protected
       * @override
       */
      _invalidChanged(invalid) {
        super._invalidChanged(invalid);
        if (invalid) {
          this.setAttribute("aria-invalid", "true");
        } else {
          this.removeAttribute("aria-invalid");
        }
      }
      /**
       * @param {number} index
       * @private
       */
      __selectNextRadioButton(radioButton) {
        const index = this.__radioButtons.indexOf(radioButton);
        this.__selectIncRadioButton(index, this.isHorizontalRTL ? 1 : -1);
      }
      /**
       * @param {number} index
       * @private
       */
      __selectPrevRadioButton(radioButton) {
        const index = this.__radioButtons.indexOf(radioButton);
        this.__selectIncRadioButton(index, this.isHorizontalRTL ? -1 : 1);
      }
      /**
       * @param {number} index
       * @param {number} step
       * @private
       */
      __selectIncRadioButton(index, step) {
        const newIndex = (this.__radioButtons.length + index + step) % this.__radioButtons.length;
        const newRadioButton = this.__radioButtons[newIndex];
        if (newRadioButton.disabled) {
          this.__selectIncRadioButton(newIndex, step);
        } else {
          newRadioButton.focusElement.focus();
          newRadioButton.focusElement.click();
        }
      }
      /**
       * Registers the radio button after adding it to the group.
       *
       * @param {!RadioButton} radioButton
       * @private
       */
      __registerRadioButton(radioButton) {
        radioButton.name = this._fieldName;
        radioButton.addEventListener("checked-changed", this.__onRadioButtonCheckedChange);
        if (this.disabled || this.readonly) {
          radioButton.disabled = true;
        }
        if (radioButton.checked) {
          this.__selectRadioButton(radioButton);
        }
      }
      /**
       * Unregisters the radio button before removing it from the group.
       *
       * @param {!RadioButton} radioButton
       * @private
       */
      __unregisterRadioButton(radioButton) {
        radioButton.removeEventListener("checked-changed", this.__onRadioButtonCheckedChange);
        if (radioButton.value === this.value) {
          this.__selectRadioButton(null);
        }
      }
      /**
       * @param {!CustomEvent} event
       * @private
       */
      __onRadioButtonCheckedChange(event) {
        if (event.target.checked) {
          this.__selectRadioButton(event.target);
        }
      }
      /**
       * Whenever the user sets a non-empty value,
       * the method tries to select the radio button with that value
       * showing a warning if no radio button was found with the given value.
       * If the new value is empty, the method deselects the currently selected radio button.
       * At last, the method toggles the `has-value` attribute considering the new value.
       *
       * @param {string | null | undefined} newValue
       * @param {string | null | undefined} oldValue
       * @private
       */
      __valueChanged(newValue, oldValue) {
        if (oldValue === void 0 && newValue === "") {
          return;
        }
        if (newValue) {
          const newSelectedRadioButton = this.__radioButtons.find((radioButton) => {
            return radioButton.value === newValue;
          });
          if (newSelectedRadioButton) {
            this.__selectRadioButton(newSelectedRadioButton);
            this.toggleAttribute("has-value", true);
          } else {
            console.warn(`The radio button with the value "${newValue}" was not found.`);
          }
        } else {
          this.__selectRadioButton(null);
          this.removeAttribute("has-value");
        }
        if (oldValue !== void 0) {
          this.validate();
        }
      }
      /**
       * Whenever `readonly` property changes on the group element,
       * the method updates the `disabled` property for the radio buttons.
       *
       * @param {boolean} newValue
       * @param {boolean} oldValue
       * @private
       */
      __readonlyChanged(newValue, oldValue) {
        if (!newValue && oldValue === void 0) {
          return;
        }
        if (oldValue !== newValue) {
          this.__updateRadioButtonsDisabledProperty();
        }
      }
      /**
       * Override method inherited from `DisabledMixin`
       * to update the `disabled` property for the radio buttons
       * whenever the property changes on the group element.
       *
       * @param {boolean} newValue
       * @param {boolean} oldValue
       * @override
       * @protected
       */
      _disabledChanged(newValue, oldValue) {
        super._disabledChanged(newValue, oldValue);
        if (!newValue && oldValue === void 0) {
          return;
        }
        if (oldValue !== newValue) {
          this.__updateRadioButtonsDisabledProperty();
        }
      }
      /**
       * Override method inherited from `FocusMixin`
       * to prevent removing the `focused` attribute
       * when focus moves between radio buttons inside the group.
       *
       * @param {!FocusEvent} event
       * @return {boolean}
       * @protected
       */
      _shouldRemoveFocus(event) {
        return !this.contains(event.relatedTarget);
      }
      /**
       * Override method inherited from `FocusMixin`
       * to run validation when the group loses focus.
       *
       * @param {boolean} focused
       * @override
       * @protected
       */
      _setFocused(focused) {
        super._setFocused(focused);
        if (!focused && document.hasFocus()) {
          this.validate();
        }
      }
      /**
       * @param {RadioButton} radioButton
       * @private
       */
      __selectRadioButton(radioButton) {
        if (radioButton) {
          this.value = radioButton.value;
        } else {
          this.value = "";
        }
        this.__radioButtons.forEach((button2) => {
          button2.checked = button2 === radioButton;
        });
        if (this.readonly) {
          this.__updateRadioButtonsDisabledProperty();
        }
      }
      /**
       * If the group is read-only, the method disables the unchecked radio buttons.
       * Otherwise, the method propagates the group's `disabled` property to the radio buttons.
       *
       * @private
       */
      __updateRadioButtonsDisabledProperty() {
        this.__radioButtons.forEach((button2) => {
          if (this.readonly) {
            button2.disabled = button2 !== this.__selectedRadioButton;
          } else {
            button2.disabled = this.disabled;
          }
        });
      }
    };
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const radioGroupStyles = css$e`
  :host {
    display: inline-flex;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  .vaadin-group-field-container {
    display: flex;
    flex-direction: column;
    width: 100%;
  }

  [part='group-field'] {
    display: flex;
    flex-wrap: wrap;
  }

  :host(:not([has-label])) [part='label'] {
    display: none;
  }
`;
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-radio-group", radioGroupStyles, { moduleId: "vaadin-radio-group-styles" });
    class RadioGroup extends RadioGroupMixin(ElementMixin(ThemableMixin(PolymerElement))) {
      static get is() {
        return "vaadin-radio-group";
      }
      static get template() {
        return html`
      <div class="vaadin-group-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div part="group-field">
          <slot></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
      }
    }
    defineCustomElement(RadioGroup);
    (function() {
      const tryCatchWrapper = function(callback) {
        return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Select");
      };
      window.Vaadin.Flow.selectConnector = {
        initLazy: (select) => tryCatchWrapper(function(select2) {
          if (select2.$connector) {
            return;
          }
          select2.$connector = {};
          select2.renderer = tryCatchWrapper(function(root2) {
            const listBox2 = select2.querySelector("vaadin-select-list-box");
            if (listBox2) {
              if (root2.firstChild) {
                root2.removeChild(root2.firstChild);
              }
              root2.appendChild(listBox2);
            }
          });
        })(select)
      };
    })();
    const _window$1 = window;
    _window$1.Vaadin ||= {};
    _window$1.Vaadin.Flow ||= {};
    _window$1.Vaadin.Flow.tooltip ||= {};
    Object.assign(_window$1.Vaadin.Flow.tooltip, {
      setDefaultHideDelay: (hideDelay) => Tooltip$1.setDefaultHideDelay(hideDelay),
      setDefaultFocusDelay: (focusDelay) => Tooltip$1.setDefaultFocusDelay(focusDelay),
      setDefaultHoverDelay: (hoverDelay) => Tooltip$1.setDefaultHoverDelay(hoverDelay)
    });
    const { defaultHideDelay, defaultFocusDelay, defaultHoverDelay } = _window$1.Vaadin.Flow.tooltip;
    if (defaultHideDelay) {
      Tooltip$1.setDefaultHideDelay(defaultHideDelay);
    }
    if (defaultFocusDelay) {
      Tooltip$1.setDefaultFocusDelay(defaultFocusDelay);
    }
    if (defaultHoverDelay) {
      Tooltip$1.setDefaultHoverDelay(defaultHoverDelay);
    }
    const sideNavItemStyles = css$e`
  :host {
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  [part='link'] {
    width: 100%;
    gap: var(--lumo-space-xs);
    padding: var(--lumo-space-s);
    padding-inline-start: calc(var(--lumo-space-s) + var(--_child-indent, 0px));
    border-radius: var(--lumo-border-radius-m);
    transition: background-color 140ms, color 140ms;
    cursor: var(--lumo-clickable-cursor, default);
    min-height: var(--lumo-icon-size-m);
  }

  [part='link'][href] {
    cursor: pointer;
  }

  :host([disabled]) [part='link'] {
    color: var(--lumo-disabled-text-color);
  }

  [part='toggle-button'] {
    margin-inline-end: calc(var(--lumo-space-xs) * -1);
    width: var(--lumo-size-s);
    height: var(--lumo-size-s);
  }

  :host([has-children]) [part='content'] {
    padding-inline-end: var(--lumo-space-s);
  }

  @media (any-hover: hover) {
    [part='link']:hover {
      color: var(--lumo-header-text-color);
    }

    [part='toggle-button']:hover {
      color: var(--lumo-body-text-color);
    }
  }

  [part='link']:active:focus {
    background-color: var(--lumo-contrast-5pct);
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
    transform: rotate(-90deg);
    transition: transform 140ms;
  }

  :host([dir='rtl']) [part='toggle-button']::before {
    transform: rotate(90deg);
  }

  :host([expanded]) [part='toggle-button']::before {
    transform: none;
  }

  @supports selector(:focus-visible) {
    [part='link'],
    [part='toggle-button'] {
      outline: none;
    }

    [part='link']:focus-visible,
    [part='toggle-button']:focus-visible {
      border-radius: var(--lumo-border-radius-m);
      box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }
  }

  [part='link']:active {
    color: var(--lumo-header-text-color);
  }

  slot:not([name]) {
    margin: 0 var(--lumo-space-s);
  }

  slot[name='prefix']::slotted(:is(vaadin-icon, [class*='icon'])) {
    padding: 0.1em;
    flex-shrink: 0;
    color: var(--lumo-contrast-60pct);
  }

  :host([disabled]) slot[name='prefix']::slotted(:is(vaadin-icon, [class*='icon'])) {
    color: var(--lumo-disabled-text-color);
  }

  :host([current]) slot[name='prefix']::slotted(:is(vaadin-icon, [class*='icon'])) {
    color: inherit;
  }

  slot[name='children'] {
    --_child-indent: calc(var(--_child-indent-2, 0px) + var(--vaadin-side-nav-child-indent, var(--lumo-space-l)));
  }

  slot[name='children']::slotted(*) {
    --_child-indent-2: var(--_child-indent);
  }

  :host([current]) [part='content'] {
    background-color: var(--lumo-primary-color-10pct);
    color: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    border-radius: var(--lumo-border-radius-m);
  }
`;
    registerStyles$1("vaadin-side-nav-item", [fieldButton, sideNavItemStyles], { moduleId: "lumo-side-nav-item" });
    const appliedClassMixins = /* @__PURE__ */ new WeakMap();
    function wasMixinPreviouslyApplied(mixin, superClass) {
      let klass = superClass;
      while (klass) {
        if (appliedClassMixins.get(klass) === mixin) {
          return true;
        }
        klass = Object.getPrototypeOf(klass);
      }
      return false;
    }
    function dedupeMixin(mixin) {
      return (superClass) => {
        if (wasMixinPreviouslyApplied(mixin, superClass)) {
          return superClass;
        }
        const mixedClass = mixin(superClass);
        appliedClassMixins.set(mixedClass, mixin);
        return mixedClass;
      };
    }
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const caseMap = {};
    const CAMEL_TO_DASH = /([A-Z])/gu;
    function camelToDash(camel) {
      if (!caseMap[camel]) {
        caseMap[camel] = camel.replace(CAMEL_TO_DASH, "-$1").toLowerCase();
      }
      return caseMap[camel];
    }
    function upper(name) {
      return name[0].toUpperCase() + name.substring(1);
    }
    function parseObserver(observerString) {
      const [method, rest] = observerString.split("(");
      const observerProps = rest.replace(")", "").split(",").map((prop) => prop.trim());
      return {
        method,
        observerProps
      };
    }
    function getOrCreateMap(obj, name) {
      if (!Object.prototype.hasOwnProperty.call(obj, name)) {
        obj[name] = new Map(obj[name]);
      }
      return obj[name];
    }
    const PolylitMixinImplementation = (superclass) => {
      class PolylitMixinClass extends superclass {
        static createProperty(name, options) {
          if ([String, Boolean, Number, Array].includes(options)) {
            options = {
              type: options
            };
          }
          if (options.reflectToAttribute) {
            options.reflect = true;
          }
          super.createProperty(name, options);
        }
        static getOrCreateMap(name) {
          return getOrCreateMap(this, name);
        }
        /**
         * @protected
         * @override
         */
        static finalize() {
          super.finalize();
          if (Array.isArray(this.observers)) {
            const complexObservers = this.getOrCreateMap("__complexObservers");
            this.observers.forEach((observer) => {
              const { method, observerProps } = parseObserver(observer);
              complexObservers.set(method, observerProps);
            });
          }
        }
        static addCheckedInitializer(initializer) {
          super.addInitializer((instance) => {
            if (instance instanceof this) {
              initializer(instance);
            }
          });
        }
        static getPropertyDescriptor(name, key, options) {
          const defaultDescriptor = super.getPropertyDescriptor(name, key, options);
          let result2 = defaultDescriptor;
          this.getOrCreateMap("__propKeys").set(name, key);
          if (options.sync) {
            result2 = {
              get: defaultDescriptor.get,
              set(value) {
                const oldValue = this[name];
                this[key] = value;
                this.requestUpdate(name, oldValue, options);
                if (this.hasUpdated) {
                  this.performUpdate();
                }
              },
              configurable: true,
              enumerable: true
            };
          }
          if (options.readOnly) {
            const setter = defaultDescriptor.set;
            this.addCheckedInitializer((instance) => {
              instance[`_set${upper(name)}`] = function(value) {
                setter.call(instance, value);
                if (options.sync) {
                  this.performUpdate();
                }
              };
            });
            result2 = {
              get: defaultDescriptor.get,
              set() {
              },
              configurable: true,
              enumerable: true
            };
          }
          if ("value" in options) {
            this.addCheckedInitializer((instance) => {
              const value = typeof options.value === "function" ? options.value.call(instance) : options.value;
              if (options.readOnly) {
                instance[`_set${upper(name)}`](value);
              } else {
                instance[name] = value;
              }
            });
          }
          if (options.observer) {
            const method = options.observer;
            this.getOrCreateMap("__observers").set(name, method);
            this.addCheckedInitializer((instance) => {
              if (!instance[method]) {
                console.warn(`observer method ${method} not defined`);
              }
            });
          }
          if (options.notify) {
            if (!this.__notifyProps) {
              this.__notifyProps = /* @__PURE__ */ new Set();
            } else if (!this.hasOwnProperty("__notifyProps")) {
              const notifyProps = this.__notifyProps;
              this.__notifyProps = new Set(notifyProps);
            }
            this.__notifyProps.add(name);
          }
          if (options.computed) {
            const assignComputedMethod = `__assignComputed${name}`;
            const observer = parseObserver(options.computed);
            this.prototype[assignComputedMethod] = function(...props) {
              this[name] = this[observer.method](...props);
            };
            this.getOrCreateMap("__complexObservers").set(assignComputedMethod, observer.observerProps);
          }
          if (!options.attribute) {
            options.attribute = camelToDash(name);
          }
          return result2;
        }
        /** @protected */
        firstUpdated() {
          super.firstUpdated();
          if (!this.$) {
            this.$ = {};
          }
          this.renderRoot.querySelectorAll("[id]").forEach((node) => {
            this.$[node.id] = node;
          });
        }
        /** @protected */
        ready() {
        }
        /** @protected */
        updated(props) {
          if (this.constructor.__observers) {
            this.__runObservers(props, this.constructor.__observers);
          }
          if (this.constructor.__complexObservers) {
            this.__runComplexObservers(props, this.constructor.__complexObservers);
          }
          if (this.__dynamicObservers) {
            this.__runComplexObservers(props, this.__dynamicObservers);
          }
          if (this.constructor.__notifyProps) {
            this.__runNotifyProps(props, this.constructor.__notifyProps);
          }
          if (!this.__isReadyInvoked) {
            this.__isReadyInvoked = true;
            this.ready();
          }
        }
        /**
         * Set several properties at once and perform synchronous update.
         * @protected
         */
        setProperties(props) {
          Object.entries(props).forEach(([name, value]) => {
            const key = this.constructor.__propKeys.get(name);
            const oldValue = this[key];
            this[key] = value;
            this.requestUpdate(name, oldValue);
          });
          if (this.hasUpdated) {
            this.performUpdate();
          }
        }
        /** @protected */
        _createMethodObserver(observer) {
          const dynamicObservers = getOrCreateMap(this, "__dynamicObservers");
          const { method, observerProps } = parseObserver(observer);
          dynamicObservers.set(method, observerProps);
        }
        /** @private */
        __runComplexObservers(props, observers) {
          observers.forEach((observerProps, method) => {
            if (observerProps.some((prop) => props.has(prop))) {
              if (!this[method]) {
                console.warn(`observer method ${method} not defined`);
              } else {
                this[method](...observerProps.map((prop) => this[prop]));
              }
            }
          });
        }
        /** @private */
        __runObservers(props, observers) {
          props.forEach((v, k) => {
            const observer = observers.get(k);
            if (observer !== void 0 && this[observer]) {
              this[observer](this[k], v);
            }
          });
        }
        /** @private */
        __runNotifyProps(props, notifyProps) {
          props.forEach((_, k) => {
            if (notifyProps.has(k)) {
              this.dispatchEvent(
                new CustomEvent(`${camelToDash(k)}-changed`, {
                  detail: {
                    value: this[k]
                  }
                })
              );
            }
          });
        }
        /** @protected */
        _get(path, object) {
          return get(path, object);
        }
        /** @protected */
        _set(path, value, object) {
          set(path, value, object);
        }
      }
      return PolylitMixinClass;
    };
    const PolylitMixin = dedupeMixin(PolylitMixinImplementation);
    /**
     * @license
     * Copyright (c) 2023 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    function containsQueryParams(actual, expected) {
      return [...expected.entries()].every(([key, value]) => {
        return actual.getAll(key).includes(value);
      });
    }
    function matchPaths(actual, expected) {
      const base = document.baseURI;
      const actualUrl = new URL(actual, base);
      const expectedUrl = new URL(expected, base);
      return actualUrl.origin === expectedUrl.origin && actualUrl.pathname === expectedUrl.pathname && containsQueryParams(actualUrl.searchParams, expectedUrl.searchParams);
    }
    /**
     * @license
     * Copyright (c) 2023 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const sideNavItemBaseStyles = css$e`
  :host {
    display: block;
  }

  :host([hidden]),
  [hidden] {
    display: none !important;
  }

  :host([disabled]) {
    pointer-events: none;
  }

  [part='content'] {
    display: flex;
    align-items: center;
  }

  [part='link'] {
    flex: auto;
    min-width: 0;
    display: flex;
    align-items: center;
    text-decoration: none;
    color: inherit;
    font: inherit;
  }

  button {
    -webkit-appearance: none;
    appearance: none;
    flex: none;
    position: relative;
    margin: 0;
    padding: 0;
    border: 0;
    background: transparent;
  }

  [part='children'] {
    padding: 0;
    margin: 0;
    list-style-type: none;
  }

  :host(:not([has-children])) button {
    display: none !important;
  }

  slot[name='prefix'],
  slot[name='suffix'] {
    flex: none;
  }

  slot:not([name]) {
    display: block;
    flex: auto;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;
    const sideNavBaseStyles = css$e`
  :host {
    display: block;
  }

  :host([hidden]) {
    display: none !important;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: inherit;
    width: 100%;
    margin: 0;
    padding: 0;
    background-color: initial;
    color: inherit;
    border: initial;
    outline: none;
    font: inherit;
    text-align: inherit;
  }

  [part='children'] {
    padding: 0;
    margin: 0;
    list-style-type: none;
  }
`;
    /**
     * @license
     * Copyright (c) 2023 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class ChildrenController extends SlotController {
      constructor(host, slotName) {
        super(host, slotName, null, { observe: true, multiple: true });
      }
      /**
       * @protected
       * @override
       */
      initAddedNode() {
        this.host.requestUpdate();
      }
      /**
       * @protected
       * @override
       */
      teardownNode() {
        this.host.requestUpdate();
      }
    }
    const SideNavChildrenMixin = (superClass) => class SideNavChildrenMixin extends superClass {
      static get properties() {
        return {
          /**
           * The object used to localize this component.
           *
           * To change the default localization, replace the entire
           * `i18n` object with a custom one.
           *
           * The object has the following structure and default values:
           * ```
           * {
           *   toggle: 'Toggle child items'
           * }
           * ```
           *
           * @type {SideNavI18n}
           * @default {English/US}
           */
          i18n: {
            type: Object,
            value: () => {
              return {
                toggle: "Toggle child items"
              };
            }
          },
          /**
           * Count of child items.
           * @protected
           */
          _itemsCount: {
            type: Number,
            value: 0
          }
        };
      }
      constructor() {
        super();
        this._childrenController = new ChildrenController(this, this._itemsSlotName);
      }
      /**
       * List of child items of this component.
       * @protected
       */
      get _items() {
        return this._childrenController.nodes;
      }
      /**
       * Name of the slot to be used for children.
       * @protected
       */
      get _itemsSlotName() {
        return "children";
      }
      /** @protected */
      firstUpdated() {
        super.firstUpdated();
        this.addController(this._childrenController);
      }
      /**
       * @protected
       * @override
       */
      willUpdate(props) {
        super.willUpdate(props);
        this._itemsCount = this._items.length;
      }
      /**
       * @protected
       * @override
       */
      updated(props) {
        super.updated(props);
        if (props.has("_itemsCount")) {
          this.toggleAttribute("has-children", this._itemsCount > 0);
        }
        if (props.has("_itemsCount") || props.has("i18n")) {
          this._items.forEach((item2) => {
            item2.i18n = this.i18n;
          });
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2023 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class SideNavItem extends SideNavChildrenMixin(DisabledMixin(ElementMixin(ThemableMixin(PolylitMixin(LitElement))))) {
      static get is() {
        return "vaadin-side-nav-item";
      }
      static get properties() {
        return {
          /**
           * The path to navigate to
           */
          path: String,
          /**
           * The list of alternative paths matching this item
           *
           * @type {!Array<string>}
           */
          pathAliases: {
            type: Array,
            value: () => []
          },
          /**
           * Whether to show the child items or not
           *
           * @type {boolean}
           */
          expanded: {
            type: Boolean,
            value: false,
            notify: true,
            reflectToAttribute: true
          },
          /**
           * Whether the item's path matches the current browser URL.
           *
           * A match occurs when both share the same base origin (like https://example.com),
           * the same path (like /path/to/page), and the browser URL contains at least
           * all the query parameters with the same values from the item's path.
           *
           * The state is updated when the item is added to the DOM or when the browser
           * navigates to a new page.
           *
           * @type {boolean}
           */
          current: {
            type: Boolean,
            value: false,
            readOnly: true,
            reflectToAttribute: true
          },
          /**
           * The target of the link. Works only when `path` is set.
           */
          target: String,
          /**
           * Whether to exclude the item from client-side routing. When enabled,
           * this causes the item to behave like a regular anchor, causing a full
           * page reload. This only works with supported routers, such as the one
           * provided in Vaadin apps, or when using the side nav `onNavigate` hook.
           *
           * @type {boolean}
           * @attr {boolean} router-ignore
           */
          routerIgnore: {
            type: Boolean,
            value: false
          }
        };
      }
      static get styles() {
        return [screenReaderOnly, sideNavItemBaseStyles];
      }
      constructor() {
        super();
        this.__boundUpdateCurrent = this.__updateCurrent.bind(this);
      }
      /** @protected */
      get _button() {
        return this.shadowRoot.querySelector("button");
      }
      /**
       * @protected
       * @override
       */
      firstUpdated() {
        super.firstUpdated();
        if (!this.hasAttribute("role")) {
          this.setAttribute("role", "listitem");
        }
      }
      /**
       * @protected
       * @override
       */
      updated(props) {
        super.updated(props);
        if (props.has("path") || props.has("pathAliases")) {
          this.__updateCurrent();
        }
        if (props.has("disabled") || props.has("_itemsCount")) {
          this._items.forEach((item2) => {
            item2.disabled = this.disabled;
          });
        }
      }
      /** @protected */
      connectedCallback() {
        super.connectedCallback();
        this.__updateCurrent();
        window.addEventListener("popstate", this.__boundUpdateCurrent);
        window.addEventListener("vaadin-navigated", this.__boundUpdateCurrent);
        window.addEventListener("side-nav-location-changed", this.__boundUpdateCurrent);
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback();
        window.removeEventListener("popstate", this.__boundUpdateCurrent);
        window.removeEventListener("vaadin-navigated", this.__boundUpdateCurrent);
        window.removeEventListener("side-nav-location-changed", this.__boundUpdateCurrent);
      }
      /** @protected */
      render() {
        return html$1`
      <div part="content" @click="${this._onContentClick}">
        <a
          id="link"
          ?disabled="${this.disabled}"
          tabindex="${this.disabled || this.path == null ? "-1" : "0"}"
          href="${ifDefined(this.disabled ? null : this.path)}"
          target="${ifDefined(this.target)}"
          ?router-ignore="${this.routerIgnore}"
          part="link"
          aria-current="${this.current ? "page" : "false"}"
        >
          <slot name="prefix"></slot>
          <slot></slot>
          <slot name="suffix"></slot>
        </a>
        <button
          part="toggle-button"
          ?disabled="${this.disabled}"
          @click="${this._onButtonClick}"
          aria-controls="children"
          aria-expanded="${this.expanded}"
          aria-labelledby="link i18n"
        ></button>
      </div>
      <ul part="children" role="list" ?hidden="${!this.expanded}" aria-hidden="${this.expanded ? "false" : "true"}">
        <slot name="children"></slot>
      </ul>
      <div class="sr-only" id="i18n">${this.i18n.toggle}</div>
    `;
      }
      /** @private */
      _onButtonClick(event) {
        event.stopPropagation();
        this.__toggleExpanded();
      }
      /** @private */
      _onContentClick() {
        if (this.path == null && this.hasAttribute("has-children")) {
          this.__toggleExpanded();
        }
      }
      /** @private */
      __toggleExpanded() {
        this.expanded = !this.expanded;
      }
      /** @private */
      __updateCurrent() {
        this._setCurrent(this.__isCurrent());
        if (this.current) {
          this.__expandParentItems();
          this.expanded = this._items.length > 0;
        }
      }
      /** @private */
      __expandParentItems() {
        const parentItem = this.__getParentItem();
        if (parentItem) {
          parentItem.__expandParentItems();
        }
        this.expanded = true;
      }
      /** @private */
      __getParentItem() {
        return this.parentElement instanceof SideNavItem ? this.parentElement : null;
      }
      /** @private */
      __isCurrent() {
        if (this.path == null) {
          return false;
        }
        const browserPath = `${document.location.pathname}${document.location.search}`;
        return matchPaths(browserPath, this.path) || this.pathAliases.some((alias) => matchPaths(browserPath, alias));
      }
    }
    defineCustomElement(SideNavItem);
    const sideNavStyles = css$e`
  :host {
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 500;
    line-height: var(--lumo-line-height-xs);
    color: var(--lumo-body-text-color);
    -webkit-tap-highlight-color: transparent;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  [part='label'] {
    display: flex;
    align-items: center;
    width: 100%;
    outline: none;
    box-sizing: border-box;
    border-radius: var(--lumo-border-radius-m);
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-s);
    font-weight: 500;
    line-height: var(--lumo-line-height-xs);
  }

  [part='label'] ::slotted([slot='label']) {
    color: var(--lumo-secondary-text-color);
    margin: var(--lumo-space-s);
  }

  :host([focus-ring]) [part='label'] {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part='toggle-button'] {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--lumo-size-s);
    height: var(--lumo-size-s);
    margin-inline-start: auto;
    margin-inline-end: var(--lumo-space-xs);
    font-size: var(--lumo-icon-size-m);
    line-height: 1;
    color: var(--lumo-contrast-60pct);
    font-family: 'lumo-icons';
    cursor: var(--lumo-clickable-cursor);
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-angle-right);
    transition: transform 140ms;
  }

  :host(:not([collapsible])) [part='toggle-button'] {
    display: none !important;
  }

  :host(:not([collapsed])) [part='toggle-button']::before {
    transform: rotate(90deg);
  }

  :host([collapsed][dir='rtl']) [part='toggle-button']::before {
    transform: rotate(180deg);
  }

  @media (any-hover: hover) {
    [part='label']:hover [part='toggle-button'] {
      color: var(--lumo-body-text-color);
    }
  }
`;
    registerStyles$1("vaadin-side-nav", sideNavStyles, { moduleId: "lumo-side-nav" });
    /**
     * @license
     * Copyright (c) 2023 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class SideNav extends SideNavChildrenMixin(FocusMixin(ElementMixin(ThemableMixin(PolylitMixin(LitElement))))) {
      static get is() {
        return "vaadin-side-nav";
      }
      static get shadowRootOptions() {
        return { ...LitElement.shadowRootOptions, delegatesFocus: true };
      }
      static get properties() {
        return {
          /**
           * Whether the side nav is collapsible. When enabled, the toggle icon is shown.
           *
           * @type {boolean}
           */
          collapsible: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          /**
           * Whether the side nav is collapsed. When collapsed, the items are hidden.
           *
           * @type {boolean}
           */
          collapsed: {
            type: Boolean,
            value: false,
            notify: true,
            reflectToAttribute: true
          },
          /**
           * Callback function for router integration.
           *
           * When a side nav item link is clicked, this function is called and the default click action is cancelled.
           * This delegates the responsibility of navigation to the function's logic.
           *
           * The click event action is not cancelled in the following cases:
           * - The click event has a modifier (e.g. `metaKey`, `shiftKey`)
           * - The click event is on an external link
           * - The click event is on a link with `target="_blank"`
           * - The function explicitly returns `false`
           *
           * The function receives an object with the properties of the clicked side-nav item:
           * - `path`: The path of the navigation item.
           * - `target`: The target of the navigation item.
           * - `current`: A boolean indicating whether the navigation item is currently selected.
           * - `expanded`: A boolean indicating whether the navigation item is expanded.
           * - `pathAliases`: An array of path aliases for the navigation item.
           * - `originalEvent`: The original DOM event that triggered the navigation.
           *
           * Also see the `location` property for updating the highlighted navigation item on route change.
           *
           * @type {function(Object): boolean | undefined}
           */
          onNavigate: {
            attribute: false
          },
          /**
           * A change to this property triggers an update of the highlighted item in the side navigation. While it typically
           * corresponds to the browser's URL, the specific value assigned to the property is irrelevant. The component has
           * its own internal logic for determining which item is highlighted.
           *
           * The main use case for this property is when the side navigation is used with a client-side router. In this case,
           * the component needs to be informed about route changes so it can update the highlighted item.
           *
           * @type {any}
           */
          location: {
            observer: "__locationChanged"
          }
        };
      }
      static get styles() {
        return sideNavBaseStyles;
      }
      constructor() {
        super();
        this._labelId = `side-nav-label-${generateUniqueId()}`;
        this.addEventListener("click", this.__onClick);
      }
      /**
       * Name of the slot to be used for children.
       * @protected
       * @override
       */
      get _itemsSlotName() {
        return "";
      }
      /** @protected */
      get focusElement() {
        return this.shadowRoot.querySelector("button");
      }
      /** @protected */
      firstUpdated() {
        super.firstUpdated();
        if (!this.hasAttribute("role")) {
          this.setAttribute("role", "navigation");
        }
      }
      /** @protected */
      render() {
        return html$1`
      ${this.collapsible ? html$1`
            <button
              part="label"
              @click="${this._onLabelClick}"
              aria-expanded="${!this.collapsed}"
              aria-controls="children"
            >
              <slot name="label" @slotchange="${this._onLabelSlotChange}"></slot>
              <span part="toggle-button" aria-hidden="true"></span>
            </button>
          ` : html$1`
            <div part="label">
              <slot name="label" @slotchange="${this._onLabelSlotChange}"></slot>
            </div>
          `}
      <ul
        id="children"
        role="list"
        part="children"
        ?hidden="${this.collapsed}"
        aria-hidden="${this.collapsed ? "true" : "false"}"
      >
        <slot></slot>
      </ul>
    `;
      }
      /**
       * @param {Event} event
       * @return {boolean}
       * @protected
       * @override
       */
      _shouldSetFocus(event) {
        return event.composedPath()[0] === this.focusElement;
      }
      /** @private */
      _onLabelClick() {
        if (this.collapsible) {
          this.__toggleCollapsed();
        }
      }
      /** @private */
      _onLabelSlotChange() {
        const label = this.querySelector('[slot="label"]');
        if (label) {
          if (!label.id) {
            label.id = this._labelId;
          }
          this.setAttribute("aria-labelledby", label.id);
        } else {
          this.removeAttribute("aria-labelledby");
        }
      }
      /** @private */
      __locationChanged() {
        window.dispatchEvent(new CustomEvent("side-nav-location-changed"));
      }
      /** @private */
      __toggleCollapsed() {
        this.collapsed = !this.collapsed;
      }
      /** @private */
      __onClick(e2) {
        if (!this.onNavigate) {
          return;
        }
        const hasModifier = e2.metaKey || e2.shiftKey;
        if (hasModifier) {
          return;
        }
        const composedPath = e2.composedPath();
        const item2 = composedPath.find((el) => el.localName && el.localName.includes("side-nav-item"));
        const anchor = composedPath.find((el) => el instanceof HTMLAnchorElement);
        if (!item2 || !item2.shadowRoot.contains(anchor)) {
          return;
        }
        const isRelative = anchor.href && anchor.href.startsWith(location.origin);
        if (!isRelative) {
          return;
        }
        if (item2.target === "_blank") {
          return;
        }
        if (item2.routerIgnore) {
          return;
        }
        const result2 = this.onNavigate({
          path: item2.path,
          target: item2.target,
          current: item2.current,
          expanded: item2.expanded,
          pathAliases: item2.pathAliases,
          originalEvent: e2
        });
        if (result2 !== false) {
          e2.preventDefault();
        }
      }
    }
    defineCustomElement(SideNav);
    registerStyles$1(
      "vaadin-split-layout",
      css$e`
    [part='splitter'] {
      min-width: var(--lumo-space-s);
      min-height: var(--lumo-space-s);
      background-color: var(--lumo-contrast-5pct);
      transition: 0.1s background-color;
    }

    [part='handle'] {
      display: flex;
      align-items: center;
      justify-content: center;
      width: var(--lumo-size-m);
      height: var(--lumo-size-m);
    }

    [part='handle']::after {
      content: '';
      display: block;
      --_handle-size: 4px;
      width: var(--_handle-size);
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      border-radius: var(--lumo-border-radius-s);
      background-color: var(--lumo-contrast-30pct);
      transition: 0.1s opacity, 0.1s background-color;
    }

    :host([orientation='vertical']) [part='handle']::after {
      width: 100%;
      height: var(--_handle-size);
    }

    /* Hover style */
    @media (any-hover: hover) {
      [part='splitter']:hover [part='handle']::after {
        background-color: var(--lumo-contrast-40pct);
      }
    }

    /* Active style */
    [part='splitter']:active [part='handle']::after {
      background-color: var(--lumo-contrast-50pct);
    }

    /* Small/minimal */
    :host([theme~='small']) > [part='splitter'] {
      border-left: 1px solid var(--lumo-contrast-10pct);
      border-top: 1px solid var(--lumo-contrast-10pct);
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter'] {
      min-width: 0;
      min-height: 0;
      background-color: transparent;
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter']::after {
      content: '';
      position: absolute;
      inset: -4px;
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter'] > [part='handle'] {
      left: calc(50% - 0.5px);
      top: calc(50% - 0.5px);
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter'] > [part='handle']::after {
      opacity: 0;
      --_handle-size: 5px;
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter']:hover > [part='handle']::after,
    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter']:active > [part='handle']::after {
      opacity: 1;
    }
  `,
      { moduleId: "lumo-split-layout" }
    );
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const SplitLayoutMixin = (superClass) => class SplitLayoutMixin extends superClass {
      static get properties() {
        return {
          /**
           * The split layout's orientation. Possible values are: `horizontal|vertical`.
           * @type {string}
           */
          orientation: {
            type: String,
            reflectToAttribute: true,
            value: "horizontal"
          },
          /** @private */
          _previousPrimaryPointerEvents: String,
          /** @private */
          _previousSecondaryPointerEvents: String
        };
      }
      /** @protected */
      ready() {
        super.ready();
        this._processChildren();
        this.__observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            this._cleanupNodes(mutation.removedNodes);
          });
          this._processChildren();
        });
        this.__observer.observe(this, { childList: true });
        const splitter = this.$.splitter;
        addListener(splitter, "track", this._onHandleTrack.bind(this));
        addListener(splitter, "down", this._setPointerEventsNone.bind(this));
        addListener(splitter, "up", this._restorePointerEvents.bind(this));
      }
      /** @private */
      _cleanupNodes(nodes) {
        nodes.forEach((node) => {
          if (!(node.parentElement instanceof this.constructor)) {
            const slot = node.getAttribute("slot");
            if (slot) {
              this[`_${slot}Child`] = null;
              node.removeAttribute("slot");
            }
          }
        });
      }
      /** @private */
      _processChildren() {
        const children = [...this.children];
        children.filter((child) => child.hasAttribute("slot")).forEach((child) => this._processChildWithSlot(child));
        children.filter((child) => !child.hasAttribute("slot")).forEach((child, i) => this._processChildWithoutSlot(child, i));
      }
      /** @private */
      _processChildWithSlot(child) {
        const slot = child.getAttribute("slot");
        if (child.__autoSlotted) {
          this[`_${slot}Child`] = null;
          child.removeAttribute("slot");
        } else {
          this[`_${slot}Child`] = child;
        }
      }
      /** @private */
      _processChildWithoutSlot(child, idx) {
        let slotName;
        if (this._primaryChild || this._secondaryChild) {
          slotName = this._primaryChild ? "secondary" : "primary";
        } else {
          slotName = idx === 0 ? "primary" : "secondary";
        }
        this[`_${slotName}Child`] = child;
        child.setAttribute("slot", slotName);
        child.__autoSlotted = true;
      }
      /** @private */
      _setFlexBasis(element, flexBasis, containerSize) {
        flexBasis = Math.max(0, Math.min(flexBasis, containerSize));
        if (flexBasis === 0) {
          flexBasis = 1e-6;
        }
        element.style.flex = `1 1 ${flexBasis}px`;
      }
      /** @private */
      _setPointerEventsNone(event) {
        if (!this._primaryChild || !this._secondaryChild) {
          return;
        }
        this._previousPrimaryPointerEvents = this._primaryChild.style.pointerEvents;
        this._previousSecondaryPointerEvents = this._secondaryChild.style.pointerEvents;
        this._primaryChild.style.pointerEvents = "none";
        this._secondaryChild.style.pointerEvents = "none";
        event.preventDefault();
      }
      /** @private */
      _restorePointerEvents() {
        if (!this._primaryChild || !this._secondaryChild) {
          return;
        }
        this._primaryChild.style.pointerEvents = this._previousPrimaryPointerEvents;
        this._secondaryChild.style.pointerEvents = this._previousSecondaryPointerEvents;
      }
      /** @private */
      _onHandleTrack(event) {
        if (!this._primaryChild || !this._secondaryChild) {
          return;
        }
        const size = this.orientation === "vertical" ? "height" : "width";
        if (event.detail.state === "start") {
          this._startSize = {
            container: this.getBoundingClientRect()[size] - this.$.splitter.getBoundingClientRect()[size],
            primary: this._primaryChild.getBoundingClientRect()[size],
            secondary: this._secondaryChild.getBoundingClientRect()[size]
          };
          return;
        }
        const distance = this.orientation === "vertical" ? event.detail.dy : event.detail.dx;
        const isRtl = this.orientation !== "vertical" && this.__isRTL;
        const dirDistance = isRtl ? -distance : distance;
        this._setFlexBasis(this._primaryChild, this._startSize.primary + dirDistance, this._startSize.container);
        this._setFlexBasis(this._secondaryChild, this._startSize.secondary - dirDistance, this._startSize.container);
        if (event.detail.state === "end") {
          this.dispatchEvent(new CustomEvent("splitter-dragend"));
          delete this._startSize;
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const splitLayoutStyles = css$e`
  :host {
    display: flex;
    overflow: hidden !important;
    transform: translateZ(0);
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([orientation='vertical']) {
    flex-direction: column;
  }

  :host ::slotted(*) {
    flex: 1 1 auto;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  [part='splitter'] {
    flex: none;
    position: relative;
    z-index: 1;
    overflow: visible;
    min-width: 8px;
    min-height: 8px;
  }

  :host(:not([orientation='vertical'])) > [part='splitter'] {
    cursor: ew-resize;
  }

  :host([orientation='vertical']) > [part='splitter'] {
    cursor: ns-resize;
  }

  [part='handle'] {
    width: 40px;
    height: 40px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate3d(-50%, -50%, 0);
  }

  @media (forced-colors: active) {
    [part~='splitter'] {
      outline: 1px solid;
    }

    [part~='handle']::after {
      background-color: AccentColor !important;
      forced-color-adjust: none;
    }
  }
`;
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-split-layout", splitLayoutStyles, { moduleId: "vaadin-split-layout-styles" });
    class SplitLayout extends SplitLayoutMixin(ElementMixin(ThemableMixin(PolymerElement))) {
      static get template() {
        return html`
      <slot id="primary" name="primary"></slot>
      <div part="splitter" id="splitter">
        <div part="handle"></div>
      </div>
      <slot id="secondary" name="secondary"></slot>
    `;
      }
      static get is() {
        return "vaadin-split-layout";
      }
      /**
       * Fired after dragging the splitter have ended.
       *
       * @event splitter-dragend
       */
    }
    defineCustomElement(SplitLayout);
    registerStyles$1(
      "vaadin-tab",
      css$e`
    :host {
      box-sizing: border-box;
      padding: 0.5rem 0.75rem;
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      line-height: var(--lumo-line-height-xs);
      font-weight: 500;
      opacity: 1;
      color: var(--lumo-secondary-text-color);
      transition: 0.15s color, 0.2s transform;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      position: relative;
      cursor: var(--lumo-clickable-cursor);
      transform-origin: 50% 100%;
      outline: none;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow: hidden;
      min-width: var(--lumo-size-m);
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
      --_selection-color-text: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    }

    :host(:not([orientation='vertical'])) {
      text-align: center;
    }

    :host([orientation='vertical']) {
      transform-origin: 0% 50%;
      padding: 0.25rem 1rem;
      min-height: var(--lumo-size-m);
      min-width: 0;
    }

    @media (forced-colors: active) {
      :host([focused]) {
        outline: 1px solid;
        outline-offset: -1px;
      }

      :host([orientation='vertical'][selected]) {
        border-bottom: none;
        border-left: 2px solid;
      }
    }

    :host(:hover),
    :host([focus-ring]) {
      color: var(--lumo-body-text-color);
    }

    :host([selected]) {
      color: var(--_selection-color-text);
      transition: 0.6s color;
    }

    :host([active]:not([selected])) {
      color: var(--_selection-color-text);
      transition-duration: 0.1s;
    }

    :host::before,
    :host::after {
      content: '';
      position: absolute;
      display: var(--_lumo-tab-marker-display, block);
      bottom: 0;
      left: 50%;
      width: var(--lumo-size-s);
      height: 2px;
      background-color: var(--lumo-contrast-60pct);
      border-radius: var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0 0;
      transform: translateX(-50%) scale(0);
      transform-origin: 50% 100%;
      transition: 0.14s transform cubic-bezier(0.12, 0.32, 0.54, 1);
      will-change: transform;
    }

    :host([selected])::before,
    :host([selected])::after {
      background-color: var(--_selection-color);
    }

    :host([orientation='vertical'])::before,
    :host([orientation='vertical'])::after {
      left: 0;
      bottom: 50%;
      transform: translateY(50%) scale(0);
      width: 2px;
      height: var(--lumo-size-xs);
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
      transform-origin: 100% 50%;
    }

    :host::after {
      box-shadow: 0 0 0 4px var(--_selection-color);
      opacity: 0.15;
      transition: 0.15s 0.02s transform, 0.8s 0.17s opacity;
    }

    :host([selected])::before,
    :host([selected])::after {
      transform: translateX(-50%) scale(1);
      transition-timing-function: cubic-bezier(0.12, 0.32, 0.54, 1.5);
    }

    :host([orientation='vertical'][selected])::before,
    :host([orientation='vertical'][selected])::after {
      transform: translateY(50%) scale(1);
    }

    :host([selected]:not([active]))::after {
      opacity: 0;
    }

    :host(:not([orientation='vertical'])) ::slotted(a[href]) {
      justify-content: center;
    }

    :host ::slotted(a) {
      display: flex;
      width: 100%;
      align-items: center;
      height: 100%;
      margin: -0.5rem -0.75rem;
      padding: 0.5rem 0.75rem;
      outline: none;

      /*
          Override the CSS inherited from \`lumo-color\` and \`lumo-typography\`.
          Note: \`!important\` is needed because of the \`:slotted\` specificity.
        */
      text-decoration: none !important;
      color: inherit !important;
    }

    :host ::slotted(vaadin-icon) {
      margin: 0 4px;
      width: var(--lumo-icon-size-m);
      height: var(--lumo-icon-size-m);
    }

    /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
    :host ::slotted(vaadin-icon[icon^='vaadin:']) {
      padding: 0.25rem;
      box-sizing: border-box !important;
    }

    :host(:not([dir='rtl'])) ::slotted(vaadin-icon:first-child) {
      margin-left: 0;
    }

    :host(:not([dir='rtl'])) ::slotted(vaadin-icon:last-child) {
      margin-right: 0;
    }

    :host([theme~='icon-on-top']) {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-around;
      text-align: center;
      padding-bottom: 0.5rem;
      padding-top: 0.25rem;
    }

    :host([theme~='icon-on-top']) ::slotted(a) {
      flex-direction: column;
      align-items: center;
      margin-top: -0.25rem;
      padding-top: 0.25rem;
    }

    :host([theme~='icon-on-top']) ::slotted(vaadin-icon) {
      margin: 0;
    }

    /* Disabled */

    :host([disabled]) {
      pointer-events: none;
      opacity: 1;
      color: var(--lumo-disabled-text-color);
    }

    /* Focus-ring */

    :host([focus-ring]) {
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
      border-radius: var(--lumo-border-radius-m);
    }

    /* RTL specific styles */

    :host([dir='rtl'])::before,
    :host([dir='rtl'])::after {
      left: auto;
      right: 50%;
      transform: translateX(50%) scale(0);
    }

    :host([dir='rtl'][selected]:not([orientation='vertical']))::before,
    :host([dir='rtl'][selected]:not([orientation='vertical']))::after {
      transform: translateX(50%) scale(1);
    }

    :host([dir='rtl']) ::slotted(vaadin-icon:first-child) {
      margin-right: 0;
    }

    :host([dir='rtl']) ::slotted(vaadin-icon:last-child) {
      margin-left: 0;
    }

    :host([orientation='vertical'][dir='rtl']) {
      transform-origin: 100% 50%;
    }

    :host([dir='rtl'][orientation='vertical'])::before,
    :host([dir='rtl'][orientation='vertical'])::after {
      left: auto;
      right: 0;
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
      transform-origin: 0% 50%;
    }
  `,
      { moduleId: "lumo-tab" }
    );
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const TabMixin = (superClass) => class TabMixinClass extends ItemMixin(superClass) {
      /** @protected */
      ready() {
        super.ready();
        this.setAttribute("role", "tab");
      }
      /**
       * Override an event listener from `KeyboardMixin`
       * to handle clicking anchors inside the tabs.
       * @param {!KeyboardEvent} event
       * @protected
       * @override
       */
      _onKeyUp(event) {
        const willClick = this.hasAttribute("active");
        super._onKeyUp(event);
        if (willClick) {
          const anchor = this.querySelector("a");
          if (anchor) {
            anchor.click();
          }
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const tabStyles = css$e`
  :host {
    display: block;
  }

  :host([hidden]) {
    display: none !important;
  }

  @media (forced-colors: active) {
    :host([focused]) {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([selected]) {
      border-bottom: 2px solid;
    }
  }
`;
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-tab", tabStyles, { moduleId: "vaadin-tab-styles" });
    class Tab extends ElementMixin(ThemableMixin(TabMixin(ControllerMixin(PolymerElement)))) {
      static get template() {
        return html`
      <slot></slot>
      <slot name="tooltip"></slot>
    `;
      }
      static get is() {
        return "vaadin-tab";
      }
      /** @protected */
      ready() {
        super.ready();
        this._tooltipController = new TooltipController(this);
        this.addController(this._tooltipController);
      }
    }
    defineCustomElement(Tab);
    registerStyles$1(
      "vaadin-tabs",
      css$e`
    :host {
      -webkit-tap-highlight-color: transparent;
    }

    :host(:not([orientation='vertical'])) {
      box-shadow: inset 0 -1px 0 0 var(--lumo-contrast-10pct);
      position: relative;
      min-height: var(--lumo-size-l);
    }

    :host([orientation='horizontal']) [part='tabs'] ::slotted(vaadin-tab:not([theme~='icon-on-top'])) {
      justify-content: center;
    }

    :host([orientation='vertical']) {
      box-shadow: -1px 0 0 0 var(--lumo-contrast-10pct);
    }

    :host([orientation='horizontal']) [part='tabs'] {
      margin: 0 0.75rem;
    }

    :host([orientation='vertical']) [part='tabs'] {
      width: 100%;
      margin: 0.5rem 0;
    }

    [part='forward-button'],
    [part='back-button'] {
      position: absolute;
      z-index: 1;
      font-family: lumo-icons;
      color: var(--lumo-tertiary-text-color);
      font-size: var(--lumo-icon-size-m);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 1.5em;
      height: 100%;
      transition: 0.2s opacity;
      top: 0;
    }

    [part='forward-button']:hover,
    [part='back-button']:hover {
      color: inherit;
    }

    :host(:not([dir='rtl'])) [part='forward-button'] {
      right: 0;
    }

    [part='forward-button']::after {
      content: var(--lumo-icons-angle-right);
    }

    [part='back-button']::after {
      content: var(--lumo-icons-angle-left);
    }

    /* Tabs overflow */

    [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: none;
      -webkit-mask-image: var(--_lumo-tabs-overflow-mask-image);
      mask-image: var(--_lumo-tabs-overflow-mask-image);
    }

    /* Horizontal tabs overflow */

    /* Both ends overflowing */
    :host([overflow~='start'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(
        90deg,
        transparent 2em,
        #000 4em,
        #000 calc(100% - 4em),
        transparent calc(100% - 2em)
      );
    }

    /* End overflowing */
    :host([overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, #000 calc(100% - 4em), transparent calc(100% - 2em));
    }

    /* Start overflowing */
    :host([overflow~='start']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, transparent 2em, #000 4em);
    }

    /* Vertical tabs overflow */

    /* Both ends overflowing */
    :host([overflow~='start'][overflow~='end'][orientation='vertical']) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(transparent, #000 2em, #000 calc(100% - 2em), transparent);
    }

    /* End overflowing */
    :host([overflow~='end'][orientation='vertical']) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(#000 calc(100% - 2em), transparent);
    }

    /* Start overflowing */
    :host([overflow~='start'][orientation='vertical']) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(transparent, #000 2em);
    }

    :host [part='tabs'] ::slotted(:not(vaadin-tab)) {
      margin-left: var(--lumo-space-m);
    }

    /* Centered */

    :host([theme~='centered'][orientation='horizontal']) ::slotted(vaadin-tab:first-of-type) {
      margin-inline-start: auto;
    }

    :host([theme~='centered'][orientation='horizontal']) ::slotted(vaadin-tab:last-of-type) {
      margin-inline-end: auto;
    }

    /* Small */

    :host([theme~='small']),
    :host([theme~='small']) [part='tabs'] {
      min-height: var(--lumo-size-m);
    }

    :host([theme~='small']) [part='tabs'] ::slotted(vaadin-tab) {
      font-size: var(--lumo-font-size-s);
    }

    /* Minimal */

    :host([theme~='minimal']) {
      box-shadow: none;
      --_lumo-tab-marker-display: none;
    }

    /* Hide-scroll-buttons */

    :host([theme~='hide-scroll-buttons']) [part='back-button'],
    :host([theme~='hide-scroll-buttons']) [part='forward-button'] {
      display: none;
    }

    /* prettier-ignore */
    :host([theme~='hide-scroll-buttons'][overflow~='start'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(
        90deg,
        transparent,
        #000 2em,
        #000 calc(100% - 2em),
        transparent 100%
      );
    }

    :host([theme~='hide-scroll-buttons'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, #000 calc(100% - 2em), transparent 100%);
    }

    :host([theme~='hide-scroll-buttons'][overflow~='start']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, transparent, #000 2em);
    }

    /* Equal-width tabs */
    :host([theme~='equal-width-tabs']) {
      flex: auto;
    }

    :host([theme~='equal-width-tabs']) [part='tabs'] ::slotted(vaadin-tab) {
      flex: 1 0 0%;
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part='forward-button']::after {
      content: var(--lumo-icons-angle-left);
    }

    :host([dir='rtl']) [part='back-button']::after {
      content: var(--lumo-icons-angle-right);
    }

    :host([orientation='vertical'][dir='rtl']) {
      box-shadow: 1px 0 0 0 var(--lumo-contrast-10pct);
    }

    :host([dir='rtl']) [part='forward-button'] {
      left: 0;
    }

    :host([dir='rtl']) [part='tabs'] ::slotted(:not(vaadin-tab)) {
      margin-left: 0;
      margin-right: var(--lumo-space-m);
    }

    /* Both ends overflowing */
    :host([dir='rtl'][overflow~='start'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(
        -90deg,
        transparent 2em,
        #000 4em,
        #000 calc(100% - 4em),
        transparent calc(100% - 2em)
      );
    }

    /* End overflowing */
    :host([dir='rtl'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, #000 calc(100% - 4em), transparent calc(100% - 2em));
    }

    /* Start overflowing */
    :host([dir='rtl'][overflow~='start']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, transparent 2em, #000 4em);
    }

    :host([dir='rtl'][theme~='hide-scroll-buttons'][overflow~='start'][overflow~='end']:not([orientation='vertical']))
      [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(
        -90deg,
        transparent,
        #000 2em,
        #000 calc(100% - 2em),
        transparent 100%
      );
    }

    :host([dir='rtl'][theme~='hide-scroll-buttons'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, #000 calc(100% - 2em), transparent 100%);
    }

    :host([dir='rtl'][theme~='hide-scroll-buttons'][overflow~='start']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, transparent, #000 2em);
    }
  `,
      { moduleId: "lumo-tabs" }
    );
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const TabsMixin = (superClass) => class TabsMixinClass extends ResizeMixin(ListMixin(superClass)) {
      static get properties() {
        return {
          /**
           * Set tabs disposition. Possible values are `horizontal|vertical`
           * @type {!TabsOrientation}
           */
          orientation: {
            value: "horizontal",
            type: String
          },
          /**
           * The index of the selected tab.
           */
          selected: {
            value: 0,
            type: Number
          }
        };
      }
      static get observers() {
        return ["__tabsItemsChanged(items)"];
      }
      constructor() {
        super();
        this.__itemsResizeObserver = new ResizeObserver(() => {
          setTimeout(() => this._updateOverflow());
        });
      }
      /**
       * @return {number}
       * @protected
       */
      get _scrollOffset() {
        return this._vertical ? this._scrollerElement.offsetHeight : this._scrollerElement.offsetWidth;
      }
      /**
       * @return {!HTMLElement}
       * @protected
       * @override
       */
      get _scrollerElement() {
        return this.$.scroll;
      }
      /** @private */
      get __direction() {
        return !this._vertical && this.__isRTL ? 1 : -1;
      }
      /** @protected */
      ready() {
        super.ready();
        this._scrollerElement.addEventListener("scroll", () => this._updateOverflow());
        this.setAttribute("role", "tablist");
        afterNextRender(this, () => {
          this._updateOverflow();
        });
      }
      /**
       * @protected
       * @override
       */
      _onResize() {
        this._updateOverflow();
      }
      /** @private */
      __tabsItemsChanged(items) {
        this.__itemsResizeObserver.disconnect();
        (items || []).forEach((item2) => {
          this.__itemsResizeObserver.observe(item2);
        });
        this._updateOverflow();
      }
      /** @protected */
      _scrollForward() {
        const forwardButtonVisibleWidth = this._getNavigationButtonVisibleWidth("forward-button");
        const backButtonVisibleWidth = this._getNavigationButtonVisibleWidth("back-button");
        const scrollerRect = this._scrollerElement.getBoundingClientRect();
        const itemToScrollTo = [...this.items].reverse().find((item2) => this._isItemVisible(item2, forwardButtonVisibleWidth, backButtonVisibleWidth, scrollerRect));
        const itemRect = itemToScrollTo.getBoundingClientRect();
        const overflowIndicatorCompensation = 20;
        const totalCompensation = overflowIndicatorCompensation + this.shadowRoot.querySelector('[part="back-button"]').clientWidth;
        let scrollOffset;
        if (this.__isRTL) {
          const scrollerRightEdge = scrollerRect.right - totalCompensation;
          scrollOffset = itemRect.right - scrollerRightEdge;
        } else {
          const scrollerLeftEdge = scrollerRect.left + totalCompensation;
          scrollOffset = itemRect.left - scrollerLeftEdge;
        }
        if (-this.__direction * scrollOffset < 1) {
          scrollOffset = -this.__direction * (this._scrollOffset - totalCompensation);
        }
        this._scroll(scrollOffset);
      }
      /** @protected */
      _scrollBack() {
        const forwardButtonVisibleWidth = this._getNavigationButtonVisibleWidth("forward-button");
        const backButtonVisibleWidth = this._getNavigationButtonVisibleWidth("back-button");
        const scrollerRect = this._scrollerElement.getBoundingClientRect();
        const itemToScrollTo = this.items.find(
          (item2) => this._isItemVisible(item2, forwardButtonVisibleWidth, backButtonVisibleWidth, scrollerRect)
        );
        const itemRect = itemToScrollTo.getBoundingClientRect();
        const overflowIndicatorCompensation = 20;
        const totalCompensation = overflowIndicatorCompensation + this.shadowRoot.querySelector('[part="forward-button"]').clientWidth;
        let scrollOffset;
        if (this.__isRTL) {
          const scrollerLeftEdge = scrollerRect.left + totalCompensation;
          scrollOffset = itemRect.left - scrollerLeftEdge;
        } else {
          const scrollerRightEdge = scrollerRect.right - totalCompensation;
          scrollOffset = itemRect.right - scrollerRightEdge;
        }
        if (this.__direction * scrollOffset < 1) {
          scrollOffset = this.__direction * (this._scrollOffset - totalCompensation);
        }
        this._scroll(scrollOffset);
      }
      /** @private */
      _isItemVisible(item2, forwardButtonVisibleWidth, backButtonVisibleWidth, scrollerRect) {
        if (this._vertical) {
          throw new Error("Visibility check is only supported for horizontal tabs.");
        }
        const buttonOnTheRightWidth = this.__isRTL ? backButtonVisibleWidth : forwardButtonVisibleWidth;
        const buttonOnTheLeftWidth = this.__isRTL ? forwardButtonVisibleWidth : backButtonVisibleWidth;
        const scrollerRightEdge = scrollerRect.right - buttonOnTheRightWidth;
        const scrollerLeftEdge = scrollerRect.left + buttonOnTheLeftWidth;
        const itemRect = item2.getBoundingClientRect();
        return scrollerRightEdge > Math.floor(itemRect.left) && scrollerLeftEdge < Math.ceil(itemRect.right);
      }
      /** @private */
      _getNavigationButtonVisibleWidth(buttonPartName) {
        const navigationButton = this.shadowRoot.querySelector(`[part="${buttonPartName}"]`);
        if (window.getComputedStyle(navigationButton).opacity === "0") {
          return 0;
        }
        return navigationButton.clientWidth;
      }
      /** @private */
      _updateOverflow() {
        const scrollPosition = this._vertical ? this._scrollerElement.scrollTop : getNormalizedScrollLeft(this._scrollerElement, this.getAttribute("dir"));
        const scrollSize = this._vertical ? this._scrollerElement.scrollHeight : this._scrollerElement.scrollWidth;
        let overflow = Math.floor(scrollPosition) > 1 ? "start" : "";
        if (Math.ceil(scrollPosition) < Math.ceil(scrollSize - this._scrollOffset)) {
          overflow += " end";
        }
        if (this.__direction === 1) {
          overflow = overflow.replace(/start|end/giu, (matched) => {
            return matched === "start" ? "end" : "start";
          });
        }
        if (overflow) {
          this.setAttribute("overflow", overflow.trim());
        } else {
          this.removeAttribute("overflow");
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const tabsStyles = css$e`
  :host {
    display: flex;
    align-items: center;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([orientation='vertical']) {
    display: block;
  }

  :host([orientation='horizontal']) [part='tabs'] {
    flex-grow: 1;
    display: flex;
    align-self: stretch;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* This seems more future-proof than \`overflow: -moz-scrollbars-none\` which is marked obsolete
         and is no longer guaranteed to work:
         https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#Mozilla_Extensions */
  @-moz-document url-prefix() {
    :host([orientation='horizontal']) [part='tabs'] {
      overflow: hidden;
    }
  }

  :host([orientation='horizontal']) [part='tabs']::-webkit-scrollbar {
    display: none;
  }

  :host([orientation='vertical']) [part='tabs'] {
    height: 100%;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  [part='back-button'],
  [part='forward-button'] {
    pointer-events: none;
    opacity: 0;
    cursor: default;
  }

  :host([overflow~='start']) [part='back-button'],
  :host([overflow~='end']) [part='forward-button'] {
    pointer-events: auto;
    opacity: 1;
  }

  [part='back-button']::after {
    content: '\\25C0';
  }

  [part='forward-button']::after {
    content: '\\25B6';
  }

  :host([orientation='vertical']) [part='back-button'],
  :host([orientation='vertical']) [part='forward-button'] {
    display: none;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='back-button']::after {
    content: '\\25B6';
  }

  :host([dir='rtl']) [part='forward-button']::after {
    content: '\\25C0';
  }
`;
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-tabs", tabsStyles, { moduleId: "vaadin-tabs-styles" });
    class Tabs extends TabsMixin(ElementMixin(ThemableMixin(PolymerElement))) {
      static get template() {
        return html`
      <div on-click="_scrollBack" part="back-button" aria-hidden="true"></div>

      <div id="scroll" part="tabs">
        <slot></slot>
      </div>

      <div on-click="_scrollForward" part="forward-button" aria-hidden="true"></div>
    `;
      }
      static get is() {
        return "vaadin-tabs";
      }
    }
    defineCustomElement(Tabs);
    const tabsheet = css$e`
  :host {
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-m);
    font-family: var(--lumo-font-family);
  }

  :host([theme~='bordered']) {
    border: 1px solid var(--lumo-contrast-20pct);
    border-radius: var(--lumo-border-radius-l);
  }

  [part='tabs-container'] {
    box-shadow: inset 0 -1px 0 0 var(--lumo-contrast-10pct);
    padding: var(--lumo-space-xs) var(--lumo-space-s);
    gap: var(--lumo-space-s);
  }

  ::slotted([slot='tabs']) {
    box-shadow: initial;
    margin: calc(var(--lumo-space-xs) * -1) calc(var(--lumo-space-s) * -1);
  }

  [part='content'] {
    padding: var(--lumo-space-s) var(--lumo-space-m);
    border-bottom-left-radius: inherit;
    border-bottom-right-radius: inherit;
  }

  :host([loading]) [part='content'] {
    display: flex;
    align-items: center;
    justify-content: center;
  }
`;
    registerStyles$1("vaadin-tabsheet", [tabsheet, loader], { moduleId: "lumo-tabsheet" });
    /**
     * @license
     * Copyright (c) 2022 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class TabsheetScroller extends Scroller {
      static get is() {
        return "vaadin-tabsheet-scroller";
      }
    }
    defineCustomElement(TabsheetScroller);
    /**
     * @license
     * Copyright (c) 2022 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class TabsSlotController extends SlotController {
      constructor(host) {
        super(host, "tabs");
        this.__tabsItemsChangedListener = this.__tabsItemsChangedListener.bind(this);
        this.__tabsSelectedChangedListener = this.__tabsSelectedChangedListener.bind(this);
        this.__tabIdObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            const tab = mutation.target;
            host.__linkTabAndPanel(tab);
            if (tab.selected) {
              host.__togglePanels(tab);
            }
          });
        });
      }
      /** @private */
      __tabsItemsChangedListener() {
        this.__tabIdObserver.disconnect();
        const items = this.tabs.items || [];
        items.forEach((tab) => {
          this.__tabIdObserver.observe(tab, {
            attributeFilter: ["id"]
          });
        });
        this.host._setItems(items);
      }
      /** @private */
      __tabsSelectedChangedListener() {
        this.host.selected = this.tabs.selected;
      }
      initCustomNode(tabs) {
        if (!(tabs instanceof customElements.get("vaadin-tabs"))) {
          throw Error('The "tabs" slot of a <vaadin-tabsheet> must only contain a <vaadin-tabs> element!');
        }
        this.tabs = tabs;
        tabs.addEventListener("items-changed", this.__tabsItemsChangedListener);
        tabs.addEventListener("selected-changed", this.__tabsSelectedChangedListener);
        this.host.__tabs = tabs;
        this.host.stateTarget = tabs;
        this.__tabsItemsChangedListener();
      }
      teardownNode(tabs) {
        this.tabs = null;
        tabs.removeEventListener("items-changed", this.__tabsItemsChangedListener);
        tabs.removeEventListener("selected-changed", this.__tabsSelectedChangedListener);
        this.host.__tabs = null;
        this.host._setItems([]);
        this.host.stateTarget = void 0;
      }
    }
    const TabSheetMixin = (superClass) => class extends DelegateStateMixin(superClass) {
      static get properties() {
        return {
          /**
           * The list of `<vaadin-tab>`s from which a selection can be made.
           * It is populated from the elements passed inside the slotted
           * `<vaadin-tabs>`, and updated dynamically when adding or removing items.
           *
           * Note: unlike `<vaadin-combo-box>`, this property is read-only.
           * @type {!Array<!Tab> | undefined}
           */
          items: {
            type: Array,
            readOnly: true,
            notify: true
          },
          /**
           * The index of the selected tab.
           */
          selected: {
            value: 0,
            type: Number,
            notify: true
          },
          /**
           * The slotted <vaadin-tabs> element.
           */
          __tabs: {
            type: Object
          },
          /**
           * The panel elements.
           */
          __panels: {
            type: Array
          }
        };
      }
      static get observers() {
        return ["__itemsOrPanelsChanged(items, __panels)", "__selectedTabItemChanged(selected, items, __panels)"];
      }
      /** @override */
      static get delegateProps() {
        return ["selected"];
      }
      /** @override */
      static get delegateAttrs() {
        return ["theme"];
      }
      /** @protected */
      ready() {
        super.ready();
        this.__overflowController = new OverflowController(this, this.shadowRoot.querySelector('[part="content"]'));
        this.addController(this.__overflowController);
        this._tabsSlotController = new TabsSlotController(this);
        this.addController(this._tabsSlotController);
        const panelSlot = this.shadowRoot.querySelector("#panel-slot");
        this.__panelsObserver = new SlotObserver(panelSlot, () => {
          this.__panels = Array.from(
            panelSlot.assignedNodes({
              flatten: true
            })
          ).filter((node) => node.nodeType === Node.ELEMENT_NODE);
        });
      }
      /**
       * An observer which applies the necessary roles and ARIA attributes
       * to associate the tab elements with the panels.
       * @private
       */
      __itemsOrPanelsChanged(items, panels) {
        if (!items || !panels) {
          return;
        }
        items.forEach((tabItem) => {
          this.__linkTabAndPanel(tabItem, panels);
        });
      }
      /**
       * An observer which toggles the visibility of the panels based on the selected tab.
       * @private
       */
      __selectedTabItemChanged(selected, items, panels) {
        if (!items || !panels || selected === void 0) {
          return;
        }
        this.__togglePanels(items[selected], panels);
      }
      /** @private */
      __togglePanels(selectedTab, panels = this.__panels) {
        const selectedTabId = selectedTab ? selectedTab.id : "";
        const selectedPanel = panels.find((panel) => panel.getAttribute("tab") === selectedTabId);
        const content = this.shadowRoot.querySelector('[part="content"]');
        this.toggleAttribute("loading", !selectedPanel);
        const hasOneVisiblePanel = panels.filter((panel) => !panel.hidden).length === 1;
        if (selectedPanel) {
          content.style.minHeight = "";
        } else if (hasOneVisiblePanel) {
          content.style.minHeight = `${content.offsetHeight}px`;
        }
        panels.forEach((panel) => {
          panel.hidden = panel !== selectedPanel;
        });
      }
      /** @private */
      __linkTabAndPanel(tab, panels = this.__panels) {
        const panel = panels.find((panel2) => panel2.getAttribute("tab") === tab.id);
        if (panel) {
          panel.role = "tabpanel";
          if (!panel.id) {
            panel.id = `tabsheet-panel-${generateUniqueId()}`;
          }
          panel.setAttribute("aria-labelledby", tab.id);
          tab.setAttribute("aria-controls", panel.id);
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2022 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class TabSheet extends TabSheetMixin(ThemableMixin(ElementMixin(ControllerMixin(PolymerElement)))) {
      static get template() {
        return html`
      <style>
        :host([hidden]) {
          display: none !important;
        }

        :host {
          display: flex;
          flex-direction: column;
        }

        [part='tabs-container'] {
          position: relative;
          display: flex;
          align-items: center;
        }

        ::slotted([slot='tabs']) {
          flex: 1;
          align-self: stretch;
          min-width: 8em;
        }

        [part='content'] {
          position: relative;
          flex: 1;
          box-sizing: border-box;
        }
      </style>

      <div part="tabs-container">
        <slot name="prefix"></slot>
        <slot name="tabs"></slot>
        <slot name="suffix"></slot>
      </div>

      <vaadin-tabsheet-scroller part="content">
        <div part="loader"></div>
        <slot id="panel-slot"></slot>
      </vaadin-tabsheet-scroller>
    `;
      }
      static get is() {
        return "vaadin-tabsheet";
      }
    }
    defineCustomElement(TabSheet);
    (function() {
      let memoizedTemplate2;
      customElements.whenDefined("vaadin-text-field").then(() => {
        class BigDecimalFieldElement extends customElements.get("vaadin-text-field") {
          static get template() {
            if (!memoizedTemplate2) {
              memoizedTemplate2 = super.template.cloneNode(true);
              memoizedTemplate2.innerHTML += `<style>
                  :host {
                    width: 8em;
                  }

                  :host([dir="rtl"]) [part="input-field"] {
                    direction: ltr;
                  }

                  :host([dir="rtl"]) [part="input-field"] ::slotted(input) {
                    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em) !important;
                  }
            </style>`;
            }
            return memoizedTemplate2;
          }
          static get is() {
            return "vaadin-big-decimal-field";
          }
          static get properties() {
            return {
              _decimalSeparator: {
                type: String,
                value: ".",
                observer: "__decimalSeparatorChanged"
              }
            };
          }
          ready() {
            super.ready();
            this.inputElement.setAttribute("inputmode", "decimal");
          }
          __decimalSeparatorChanged(separator, oldSeparator) {
            this.allowedCharPattern = "[-+\\d" + separator + "]";
            if (this.value && oldSeparator) {
              this.value = this.value.split(oldSeparator).join(separator);
            }
          }
        }
        customElements.define(BigDecimalFieldElement.is, BigDecimalFieldElement);
      });
    })();
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const emailField = css$e`
  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }
`;
    registerStyles$1("vaadin-email-field", [inputFieldShared, emailField], {
      moduleId: "lumo-email-field"
    });
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const emailFieldStyles = css$e`
  :host([dir='rtl']) [part='input-field'] {
    direction: ltr;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
    direction: rtl;
    text-align: left;
  }
`;
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-email-field", emailFieldStyles, { moduleId: "vaadin-email-field-styles" });
    class EmailField extends TextField {
      static get is() {
        return "vaadin-email-field";
      }
      constructor() {
        super();
        this._setType("email");
        this.pattern = "^[a-zA-Z0-9_\\-+]+(?:\\.[a-zA-Z0-9_\\-+]+)*@[a-zA-Z0-9\\-.]+\\.[a-zA-Z0-9\\-]{2,}$";
      }
      /** @protected */
      ready() {
        super.ready();
        if (this.inputElement) {
          this.inputElement.autocapitalize = "off";
        }
      }
    }
    defineCustomElement(EmailField);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const numberField = css$e`
  :host([step-buttons-visible]:not([theme~='align-right'])) ::slotted(input) {
    text-align: center;
  }

  [part$='button'][disabled] {
    opacity: 0.2;
  }

  :host([step-buttons-visible]) [part='input-field'] {
    padding: 0;
  }

  [part\$='button'] {
    cursor: pointer;
    font-size: var(--lumo-icon-size-s);
    width: 1.6em;
    height: 1.6em;
  }

  [part\$='button']::before {
    margin-top: 0.3em;
  }

  [part='decrease-button']::before {
    content: var(--lumo-icons-minus);
  }

  [part='increase-button']::before {
    content: var(--lumo-icons-plus);
  }

  /* RTL specific styles */
  :host([dir='rtl']:not([theme~='align-right'])) ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }
`;
    registerStyles$1("vaadin-number-field", [inputFieldShared, fieldButton, numberField], {
      moduleId: "lumo-number-field"
    });
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const NumberFieldMixin = (superClass) => class NumberFieldMixinClass extends InputFieldMixin(superClass) {
      static get properties() {
        return {
          /**
           * The minimum value of the field.
           */
          min: {
            type: Number
          },
          /**
           * The maximum value of the field.
           */
          max: {
            type: Number
          },
          /**
           * Specifies the allowed number intervals of the field.
           * @type {number}
           */
          step: {
            type: Number
          },
          /**
           * Set to true to show increase/decrease buttons.
           * @attr {boolean} step-buttons-visible
           */
          stepButtonsVisible: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          }
        };
      }
      static get observers() {
        return ["_stepChanged(step, inputElement)"];
      }
      static get delegateProps() {
        return [...super.delegateProps, "min", "max"];
      }
      static get constraints() {
        return [...super.constraints, "min", "max", "step"];
      }
      constructor() {
        super();
        this._setType("number");
        this.__onWheel = this.__onWheel.bind(this);
      }
      /** @protected */
      get slotStyles() {
        const tag = this.localName;
        return [
          `
          ${tag} input[type="number"]::-webkit-outer-spin-button,
          ${tag} input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
          }

          ${tag} input[type="number"] {
            -moz-appearance: textfield;
          }

          ${tag}[dir='rtl'] input[type="number"]::placeholder {
            direction: rtl;
          }

          ${tag}[dir='rtl']:not([step-buttons-visible]) input[type="number"]::placeholder {
            text-align: left;
          }
        `
        ];
      }
      /**
       * Used by `InputControlMixin` as a reference to the clear button element.
       * @protected
       */
      get clearElement() {
        return this.$.clearButton;
      }
      /**
       * Whether the input element's value is unparsable.
       *
       * @private
       */
      get __hasUnparsableValue() {
        return this.inputElement.validity.badInput;
      }
      /** @protected */
      ready() {
        super.ready();
        this.addController(
          new InputController(this, (input) => {
            this._setInputElement(input);
            this._setFocusElement(input);
            this.stateTarget = input;
            this.ariaTarget = input;
          })
        );
        this.addController(new LabelledInputController(this.inputElement, this._labelController));
      }
      /**
       * Override the method from `InputConstraintsMixin`
       * to enforce HTML constraint validation even if
       * the user didn't add any constraints explicitly:
       * the field has to be regardless checked for bad input.
       *
       * @override
       */
      checkValidity() {
        if (this.inputElement) {
          return this.inputElement.checkValidity();
        }
        return !this.invalid;
      }
      /**
       * Override the method from `InputMixin` to add
       * a wheel event listener to the input element.
       *
       * @param {HTMLElement} input
       * @override
       * @protected
       */
      _addInputListeners(input) {
        super._addInputListeners(input);
        input.addEventListener("wheel", this.__onWheel);
      }
      /**
       * Override the method from `InputMixin` to remove
       * the wheel event listener from the input element.
       *
       * @param {HTMLElement} input
       * @override
       * @protected
       */
      _removeInputListeners(input) {
        super._removeInputListeners(input);
        input.removeEventListener("wheel", this.__onWheel);
      }
      /**
       * Prevents default browser behavior for wheel events on the input element
       * when it's focused. More precisely, this prevents the browser from attempting
       * to increment or decrement the value when the mouse wheel is used within
       * the input element.
       *
       * CAVEAT: As a side-effect, this also prevents page scrolling when
       * the pointer is positioned over the field and the field is focused.
       *
       * @param {WheelEvent} event
       * @private
       */
      __onWheel(event) {
        if (this.hasAttribute("focused")) {
          event.preventDefault();
        }
      }
      /** @protected */
      _onDecreaseButtonTouchend(e2) {
        if (e2.cancelable) {
          e2.preventDefault();
          this._decreaseValue();
        }
      }
      /** @protected */
      _onIncreaseButtonTouchend(e2) {
        if (e2.cancelable) {
          e2.preventDefault();
          this._increaseValue();
        }
      }
      /** @protected */
      _onDecreaseButtonClick() {
        this._decreaseValue();
      }
      /** @protected */
      _onIncreaseButtonClick() {
        this._increaseValue();
      }
      /** @private */
      _decreaseValue() {
        this._incrementValue(-1);
      }
      /** @private */
      _increaseValue() {
        this._incrementValue(1);
      }
      /** @private */
      _incrementValue(incr) {
        if (this.disabled || this.readonly) {
          return;
        }
        const step = this.step || 1;
        let value = parseFloat(this.value);
        if (!this.value) {
          if (this.min === 0 && incr < 0 || this.max === 0 && incr > 0 || this.max === 0 && this.min === 0) {
            incr = 0;
            value = 0;
          } else if ((this.max == null || this.max >= 0) && (this.min == null || this.min <= 0)) {
            value = 0;
          } else if (this.min > 0) {
            value = this.min;
            if (this.max < 0 && incr < 0) {
              value = this.max;
            }
            incr = 0;
          } else if (this.max < 0) {
            value = this.max;
            if (incr < 0) {
              incr = 0;
            } else if (this._getIncrement(1, value - step) > this.max) {
              value -= 2 * step;
            } else {
              value -= step;
            }
          }
        } else if (value < this.min) {
          incr = 0;
          value = this.min;
        } else if (value > this.max) {
          incr = 0;
          value = this.max;
        }
        const newValue = this._getIncrement(incr, value);
        if (!this.value || incr === 0 || this._incrementIsInsideTheLimits(incr, value)) {
          this.inputElement.value = String(parseFloat(newValue));
          this.inputElement.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
          this.__commitValueChange();
        }
      }
      /** @private */
      _getIncrement(incr, currentValue) {
        let step = this.step || 1, min = this.min || 0;
        const multiplier = Math.max(
          this._getMultiplier(currentValue),
          this._getMultiplier(step),
          this._getMultiplier(min)
        );
        step *= multiplier;
        currentValue = Math.round(currentValue * multiplier);
        min *= multiplier;
        const margin = (currentValue - min) % step;
        if (incr > 0) {
          return (currentValue - margin + step) / multiplier;
        } else if (incr < 0) {
          return (currentValue - (margin || step)) / multiplier;
        }
        return currentValue / multiplier;
      }
      /** @private */
      _getDecimalCount(number) {
        const s = String(number);
        const i = s.indexOf(".");
        return i === -1 ? 1 : s.length - i - 1;
      }
      /** @private */
      _getMultiplier(number) {
        if (!isNaN(number)) {
          return 10 ** this._getDecimalCount(number);
        }
      }
      /** @private */
      _incrementIsInsideTheLimits(incr, value) {
        if (incr < 0) {
          return this.min == null || this._getIncrement(incr, value) >= this.min;
        } else if (incr > 0) {
          return this.max == null || this._getIncrement(incr, value) <= this.max;
        }
        return this._getIncrement(incr, value) <= this.max && this._getIncrement(incr, value) >= this.min;
      }
      /** @protected */
      _isButtonEnabled(sign) {
        const incr = sign * (this.step || 1);
        const value = parseFloat(this.value);
        return !this.value || !this.disabled && this._incrementIsInsideTheLimits(incr, value);
      }
      /**
       * @param {number} step
       * @param {HTMLElement | undefined} inputElement
       * @protected
       */
      _stepChanged(step, inputElement) {
        if (inputElement) {
          inputElement.step = step || "any";
        }
      }
      /**
       * @param {unknown} newVal
       * @param {unknown} oldVal
       * @protected
       * @override
       */
      _valueChanged(newVal, oldVal) {
        if (newVal && isNaN(parseFloat(newVal))) {
          this.value = "";
        } else if (typeof this.value !== "string") {
          this.value = String(this.value);
        }
        super._valueChanged(this.value, oldVal);
        if (!this.__keepCommittedValue) {
          this.__committedValue = this.value;
          this.__committedUnparsableValueStatus = false;
        }
      }
      /**
       * Override an event listener from `InputControlMixin`
       * to avoid adding a separate listener.
       * @param {!KeyboardEvent} event
       * @protected
       * @override
       */
      _onKeyDown(event) {
        if (event.key === "ArrowUp") {
          event.preventDefault();
          this._increaseValue();
        } else if (event.key === "ArrowDown") {
          event.preventDefault();
          this._decreaseValue();
        }
        super._onKeyDown(event);
      }
      /**
       * Native [type=number] inputs don't update their value
       * when you are entering input that the browser is unable to parse
       * e.g. "--5", hence we have to override this method from `InputMixin`
       * so that, when value is empty, it would additionally check
       * for bad input based on the native `validity.badInput` property.
       *
       * @param {InputEvent} event
       * @protected
       * @override
       */
      _setHasInputValue(event) {
        const target = event.composedPath()[0];
        this._hasInputValue = target.value.length > 0 || this.__hasUnparsableValue;
      }
      /**
       * Override this method from `InputMixin` to prevent
       * the value change caused by user input from being treated
       * as initiated programmatically by the developer and therefore
       * from getting silently committed by the value observer without
       * any change event. The value change will be committed later
       * on blur or Enter.
       *
       * @param {InputEvent} event
       * @override
       * @protected
       */
      _onInput(event) {
        this.__keepCommittedValue = true;
        super._onInput(event);
        this.__keepCommittedValue = false;
      }
      /**
       * Override this method from `InputControlMixin`
       * to stop propagation of the native change event.
       *
       * @param {Event}
       * @override
       * @protected
       */
      _onChange(event) {
        event.stopPropagation();
      }
      /**
       * Override this method from `ClearButtonMixin`
       * to properly commit the empty value since
       * the change handler doesn't do that anymore.
       *
       * @param {MouseEvent} event
       * @override
       * @protected
       */
      _onClearAction(event) {
        super._onClearAction(event);
        this.__commitValueChange();
      }
      /**
       * Override this method from `FocusMixin`
       * to commit a possible pending value change on blur.
       *
       * @param {boolean} focused
       * @override
       * @protected
       */
      _setFocused(focused) {
        super._setFocused(focused);
        if (!focused) {
          this.__commitValueChange();
        }
      }
      /**
       * Override this method from `KeyboardMixin`
       * to commit a possible pending value change on Enter.
       *
       * @param {KeyboardEvent} event
       * @override
       * @protected
       */
      _onEnter(event) {
        super._onEnter(event);
        this.__commitValueChange();
      }
      /**
       * Depending on the nature of the value change that has occurred since
       * the last commit attempt, triggers validation and fires an event:
       *
       * Value change             | Event
       * :------------------------|:------------------
       * empty => parsable        | change
       * empty => unparsable      | unparsable-change
       * parsable => empty        | change
       * parsable => parsable     | change
       * parsable => unparsable   | change
       * unparsable => empty      | unparsable-change
       * unparsable => parsable   | change
       * unparsable => unparsable | -
       *
       * Note, there is currently no way to detect unparsable => unparsable changes
       * because the browser doesn't provide access to unparsable values of native
       * [type=number] inputs.
       *
       * @private
       */
      __commitValueChange() {
        if (this.__committedValue !== this.value) {
          this.validate();
          this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
        } else if (this.__committedUnparsableValueStatus !== this.__hasUnparsableValue) {
          this.validate();
          this.dispatchEvent(new CustomEvent("unparsable-change"));
        }
        this.__committedValue = this.value;
        this.__committedUnparsableValueStatus = this.__hasUnparsableValue;
      }
    };
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const numberFieldStyles = css$e`
  :host([readonly]) [part$='button'] {
    pointer-events: none;
  }

  [part='decrease-button']::before {
    content: '\\2212';
  }

  [part='increase-button']::before {
    content: '+';
  }

  [part='decrease-button'],
  [part='increase-button'] {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
  }

  :host([dir='rtl']) [part='input-field'] {
    direction: ltr;
  }
`;
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-number-field", [inputFieldShared$1, numberFieldStyles], {
      moduleId: "vaadin-number-field-styles"
    });
    class NumberField extends NumberFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
      static get is() {
        return "vaadin-number-field";
      }
      static get template() {
        return html`
      <div class="vaadin-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <div
            disabled$="[[!_isButtonEnabled(-1, value, min, max, step)]]"
            part="decrease-button"
            on-click="_onDecreaseButtonClick"
            on-touchend="_onDecreaseButtonTouchend"
            hidden$="[[!stepButtonsVisible]]"
            aria-hidden="true"
            slot="prefix"
          ></div>
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <slot name="suffix" slot="suffix"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div
            disabled$="[[!_isButtonEnabled(1, value, min, max, step)]]"
            part="increase-button"
            on-click="_onIncreaseButtonClick"
            on-touchend="_onIncreaseButtonTouchend"
            hidden$="[[!stepButtonsVisible]]"
            aria-hidden="true"
            slot="suffix"
          ></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
      }
      /** @protected */
      ready() {
        super.ready();
        this._tooltipController = new TooltipController(this);
        this.addController(this._tooltipController);
        this._tooltipController.setPosition("top");
        this._tooltipController.setAriaTarget(this.inputElement);
      }
    }
    defineCustomElement(NumberField);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class IntegerField extends NumberField {
      static get is() {
        return "vaadin-integer-field";
      }
      constructor() {
        super();
        this.allowedCharPattern = "[-+\\d]";
      }
      /**
       * Override an observer from `InputMixin` to clear the value
       * when trying to type invalid characters.
       * @param {string | undefined} newVal
       * @param {string | undefined} oldVal
       * @protected
       * @override
       */
      _valueChanged(newVal, oldVal) {
        if (newVal !== "" && !this.__isInteger(newVal)) {
          console.warn(`Trying to set non-integer value "${newVal}" to <vaadin-integer-field>. Clearing the value.`);
          this.value = "";
          return;
        }
        super._valueChanged(newVal, oldVal);
      }
      /**
       * Override an observer from `NumberField` to reset the step
       * property when an invalid step is set.
       * @param {number} newVal
       * @param {HTMLElement | undefined} inputElement
       * @protected
       * @override
       */
      _stepChanged(step, inputElement) {
        if (step != null && !this.__hasOnlyDigits(step)) {
          console.warn(
            `<vaadin-integer-field> The \`step\` property must be a positive integer but \`${step}\` was provided, so the property was reset to \`null\`.`
          );
          this.step = null;
          return;
        }
        super._stepChanged(step, inputElement);
      }
      /** @private */
      __isInteger(value) {
        return /^(-\d)?\d*$/u.test(String(value));
      }
      /** @private */
      __hasOnlyDigits(value) {
        return /^\d+$/u.test(String(value));
      }
    }
    defineCustomElement(IntegerField);
    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    class LiveDirective extends Directive {
      constructor(partInfo) {
        super(partInfo);
        if (!(partInfo.type === PartType.PROPERTY || partInfo.type === PartType.ATTRIBUTE || partInfo.type === PartType.BOOLEAN_ATTRIBUTE)) {
          throw new Error("The `live` directive is not allowed on child or event bindings");
        }
        if (!isSingleExpression(partInfo)) {
          throw new Error("`live` bindings can only contain a single expression");
        }
      }
      render(value) {
        return value;
      }
      update(part, [value]) {
        if (value === noChange || value === nothing) {
          return value;
        }
        const element = part.element;
        const name = part.name;
        if (part.type === PartType.PROPERTY) {
          if (value === element[name]) {
            return noChange;
          }
        } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {
          if (!!value === element.hasAttribute(name)) {
            return noChange;
          }
        } else if (part.type === PartType.ATTRIBUTE) {
          if (element.getAttribute(name) === String(value)) {
            return noChange;
          }
        }
        setCommittedValue(part);
        return value;
      }
    }
    const live = directive(LiveDirective);
    const _window = window;
    _window.Vaadin = _window.Vaadin || {};
    _window.Vaadin.setLitRenderer = (component, rendererName, templateExpression, returnChannel, clientCallables, propertyNamespace) => {
      const renderFunction = Function(`
    "use strict";

    const [render, html, live, returnChannel] = arguments;

    return (root, model, itemKey) => {
      const { item, index } = model;
      ${clientCallables.map((clientCallable) => {
        return `
          const ${clientCallable} = (...args) => {
            if (itemKey !== undefined) {
              returnChannel('${clientCallable}', itemKey, args[0] instanceof Event ? [] : [...args]);
            }
          }`;
      }).join("")}

      render(html\`${templateExpression}\`, root)
    }
  `)(render, html$1, live, returnChannel);
      const renderer = (root2, _, model) => {
        const { item: item2 } = model;
        if (root2.__litRenderer !== renderer) {
          root2.innerHTML = "";
          delete root2._$litPart$;
          root2.__litRenderer = renderer;
        }
        const mappedItem = {};
        for (const key in item2) {
          if (key.startsWith(propertyNamespace)) {
            mappedItem[key.replace(propertyNamespace, "")] = item2[key];
          }
        }
        renderFunction(root2, { ...model, item: mappedItem }, item2.key);
      };
      renderer.__rendererId = propertyNamespace;
      component[rendererName] = renderer;
    };
    _window.Vaadin.unsetLitRenderer = (component, rendererName, rendererId) => {
      if (component[rendererName]?.__rendererId === rendererId) {
        component[rendererName] = void 0;
      }
    };
    registerStyles$1(
      "vaadin-upload",
      css$e`
    :host {
      line-height: var(--lumo-line-height-m);
    }

    :host(:not([nodrop])) {
      overflow: hidden;
      border: 1px dashed var(--lumo-contrast-20pct);
      border-radius: var(--lumo-border-radius-l);
      padding: var(--lumo-space-m);
      transition: background-color 0.6s, border-color 0.6s;
    }

    [part='drop-label'] {
      display: inline-block;
      white-space: normal;
      padding: 0 var(--lumo-space-s);
      color: var(--lumo-secondary-text-color);
      font-family: var(--lumo-font-family);
    }

    :host([dragover-valid]) {
      border-color: var(--lumo-primary-color-50pct);
      background: var(--lumo-primary-color-10pct);
      transition: background-color 0.1s, border-color 0.1s;
    }

    :host([dragover-valid]) [part='drop-label'] {
      color: var(--lumo-primary-text-color);
    }

    :host([max-files-reached]) [part='drop-label'] {
      color: var(--lumo-disabled-text-color);
    }
  `,
      { moduleId: "lumo-upload" }
    );
    registerStyles$1(
      "vaadin-upload-icon",
      css$e`
    :host::before {
      content: var(--lumo-icons-upload);
      font-family: lumo-icons;
      font-size: var(--lumo-icon-size-m);
      line-height: 1;
      vertical-align: -0.25em;
    }
  `,
      { moduleId: "lumo-upload-icon" }
    );
    registerStyles$1(
      "vaadin-upload-file-list",
      css$e`
    ::slotted(li:not(:first-of-type)) {
      border-top: 1px solid var(--lumo-contrast-10pct);
    }
  `,
      { moduleId: "lumo-upload-file-list" }
    );
    const uploadFile = css$e`
  :host {
    padding: var(--lumo-space-s) 0;
    outline: none;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focus-ring]) [part='row'] {
    border-radius: var(--lumo-border-radius-s);
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part='row'] {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
  }

  [part='status'],
  [part='error'] {
    color: var(--lumo-secondary-text-color);
    font-size: var(--lumo-font-size-s);
  }

  [part='info'] {
    display: flex;
    align-items: baseline;
    flex: auto;
  }

  [part='meta'] {
    width: 0.001px;
    flex: 1 1 auto;
  }

  [part='name'] {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  [part='commands'] {
    display: flex;
    align-items: baseline;
    flex: none;
  }

  [part$='icon'] {
    margin-right: var(--lumo-space-xs);
    font-size: var(--lumo-icon-size-m);
    font-family: 'lumo-icons';
    line-height: 1;
  }

  /* When both icons are hidden, let us keep space for one */
  [part='done-icon'][hidden] + [part='warning-icon'][hidden] {
    display: block !important;
    visibility: hidden;
  }

  [part$='button'] {
    flex: none;
    margin-left: var(--lumo-space-xs);
    cursor: var(--lumo-clickable-cursor);
  }

  [part$='button']:focus {
    outline: none;
    border-radius: var(--lumo-border-radius-s);
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part$='icon']::before,
  [part$='button']::before {
    vertical-align: -0.25em;
  }

  [part='done-icon']::before {
    content: var(--lumo-icons-checkmark);
    color: var(--lumo-primary-text-color);
  }

  [part='warning-icon']::before {
    content: var(--lumo-icons-error);
    color: var(--lumo-error-text-color);
  }

  [part='start-button']::before {
    content: var(--lumo-icons-play);
  }

  [part='retry-button']::before {
    content: var(--lumo-icons-reload);
  }

  [part='remove-button']::before {
    content: var(--lumo-icons-cross);
  }

  [part='error'] {
    color: var(--lumo-error-text-color);
  }

  ::slotted([slot='progress']) {
    width: auto;
    margin-left: calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));
    margin-right: calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));
  }
`;
    registerStyles$1("vaadin-upload-file", [fieldButton, uploadFile], { moduleId: "lumo-upload-file" });
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class UploadIcon extends ThemableMixin(PolymerElement) {
      static get is() {
        return "vaadin-upload-icon";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
    `;
      }
    }
    defineCustomElement(UploadIcon);
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const template$1 = document.createElement("template");
    template$1.innerHTML = `
  <style>
    @font-face {
      font-family: 'vaadin-upload-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAasAAsAAAAABmAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIF5mNtYXAAAAFoAAAAVAAAAFQXVtKMZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAfQAAAH0bBJxYWhlYWQAAAO4AAAANgAAADYPD267aGhlYQAAA/AAAAAkAAAAJAfCA8tobXR4AAAEFAAAACgAAAAoHgAAx2xvY2EAAAQ8AAAAFgAAABYCSgHsbWF4cAAABFQAAAAgAAAAIAAOADVuYW1lAAAEdAAAAhYAAAIWmmcHf3Bvc3QAAAaMAAAAIAAAACAAAwAAAAMDtwGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QUDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkF//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAgAA/8AEAAPAABkAMgAAEz4DMzIeAhczLgMjIg4CBycRIScFIRcOAyMiLgInIx4DMzI+AjcXphZGWmo6SH9kQwyADFiGrmJIhXJbIEYBAFoDWv76YBZGXGw8Rn5lRQyADFmIrWBIhHReIkYCWjJVPSIyVnVDXqN5RiVEYTxG/wBa2loyVT0iMlZ1Q16jeUYnRWE5RgAAAAABAIAAAAOAA4AAAgAAExEBgAMAA4D8gAHAAAAAAwAAAAAEAAOAAAIADgASAAAJASElIiY1NDYzMhYVFAYnETMRAgD+AAQA/gAdIyMdHSMjXYADgPyAgCMdHSMjHR0jwAEA/wAAAQANADMD5gNaAAUAACUBNwUBFwHT/jptATMBppMzAU2a4AIgdAAAAAEAOv/6A8YDhgALAAABJwkBBwkBFwkBNwEDxoz+xv7GjAFA/sCMAToBOoz+wAL6jP7AAUCM/sb+xowBQP7AjAE6AAAAAwAA/8AEAAPAAAcACwASAAABFSE1IREhEQEjNTMJAjMRIRECwP6A/sAEAP0AgIACQP7A/sDAAQABQICA/oABgP8AgAHAAUD+wP6AAYAAAAABAAAAAQAAdhiEdV8PPPUACwQAAAAAANX4FR8AAAAA1fgVHwAA/8AEAAPAAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAQAAAEAAAAAAAAAAAAAAAAAAAAKBAAAAAAAAAAAAAAAAgAAAAQAAAAEAACABAAAAAQAAA0EAAA6BAAAAAAAAAAACgAUAB4AagB4AJwAsADSAPoAAAABAAAACgAzAAMAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAADgCuAAEAAAAAAAEAEwAAAAEAAAAAAAIABwDMAAEAAAAAAAMAEwBaAAEAAAAAAAQAEwDhAAEAAAAAAAUACwA5AAEAAAAAAAYAEwCTAAEAAAAAAAoAGgEaAAMAAQQJAAEAJgATAAMAAQQJAAIADgDTAAMAAQQJAAMAJgBtAAMAAQQJAAQAJgD0AAMAAQQJAAUAFgBEAAMAAQQJAAYAJgCmAAMAAQQJAAoANAE0dmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzVmVyc2lvbiAxLjAAVgBlAHIAcwBpAG8AbgAgADEALgAwdmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzdmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzUmVndWxhcgBSAGUAZwB1AGwAYQBydmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzRm9udCBnZW5lcmF0ZWQgYnkgSWNvTW9vbi4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
    document.head.appendChild(template$1.content);
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const UploadFileMixin = (superClass) => class UploadFileMixin extends FocusMixin(superClass) {
      static get properties() {
        return {
          /**
           * True if uploading is completed, false otherwise.
           */
          complete: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          /**
           * Error message returned by the server, if any.
           */
          errorMessage: {
            type: String,
            value: "",
            observer: "_errorMessageChanged"
          },
          /**
           * The object representing a file.
           */
          file: {
            type: Object
          },
          /**
           * Name of the uploading file.
           */
          fileName: {
            type: String
          },
          /**
           * True if uploading is not started, false otherwise.
           */
          held: {
            type: Boolean,
            value: false
          },
          /**
           * True if remaining time is unknown, false otherwise.
           */
          indeterminate: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          /**
           * The object used to localize this component.
           */
          i18n: {
            type: Object
          },
          /**
           * Number representing the uploading progress.
           */
          progress: {
            type: Number
          },
          /**
           * Uploading status.
           */
          status: {
            type: String
          },
          /**
           * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
           * @protected
           */
          tabindex: {
            type: Number,
            value: 0,
            reflectToAttribute: true
          },
          /**
           * True if uploading is in progress, false otherwise.
           */
          uploading: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          /** @private */
          _progress: {
            type: Object
          }
        };
      }
      static get observers() {
        return ["__updateProgress(_progress, progress, indeterminate)"];
      }
      /** @protected */
      ready() {
        super.ready();
        this.addController(
          new SlotController(this, "progress", "vaadin-progress-bar", {
            initializer: (progress) => {
              this._progress = progress;
            }
          })
        );
        this.shadowRoot.addEventListener("focusin", (e2) => {
          const target = e2.composedPath()[0];
          if (target.getAttribute("part").endsWith("button")) {
            this._setFocused(false);
          }
        });
        this.shadowRoot.addEventListener("focusout", (e2) => {
          if (e2.relatedTarget === this) {
            this._setFocused(true);
          }
        });
      }
      /**
       * Override method inherited from `FocusMixin` to mark the file as focused
       * only when the host is focused.
       * @param {Event} event
       * @return {boolean}
       * @protected
       */
      _shouldSetFocus(event) {
        return event.composedPath()[0] === this;
      }
      /** @private */
      _errorMessageChanged(errorMessage) {
        this.toggleAttribute("error", Boolean(errorMessage));
      }
      /** @private */
      __updateProgress(progress, value, indeterminate) {
        if (progress) {
          progress.value = isNaN(value) ? 0 : value / 100;
          progress.indeterminate = indeterminate;
        }
      }
      /** @private */
      _fireFileEvent(e2) {
        e2.preventDefault();
        return this.dispatchEvent(
          new CustomEvent(e2.target.getAttribute("file-event"), {
            detail: { file: this.file },
            bubbles: true,
            composed: true
          })
        );
      }
    };
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const uploadFileStyles = css$e`
  :host {
    display: block;
  }

  [hidden] {
    display: none;
  }

  [part='row'] {
    list-style-type: none;
  }

  button {
    background: transparent;
    padding: 0;
    border: none;
    box-shadow: none;
  }

  :host([complete]) ::slotted([slot='progress']),
  :host([error]) ::slotted([slot='progress']) {
    display: none !important;
  }
`;
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-upload-file", uploadFileStyles, { moduleId: "vaadin-upload-file-styles" });
    class UploadFile extends UploadFileMixin(ThemableMixin(ControllerMixin(PolymerElement))) {
      static get template() {
        return html`
      <div part="row">
        <div part="info">
          <div part="done-icon" hidden$="[[!complete]]" aria-hidden="true"></div>
          <div part="warning-icon" hidden$="[[!errorMessage]]" aria-hidden="true"></div>

          <div part="meta">
            <div part="name" id="name">[[fileName]]</div>
            <div part="status" hidden$="[[!status]]" id="status">[[status]]</div>
            <div part="error" id="error" hidden$="[[!errorMessage]]">[[errorMessage]]</div>
          </div>
        </div>
        <div part="commands">
          <button
            type="button"
            part="start-button"
            file-event="file-start"
            on-click="_fireFileEvent"
            hidden$="[[!held]]"
            aria-label$="[[i18n.file.start]]"
            aria-describedby="name"
          ></button>
          <button
            type="button"
            part="retry-button"
            file-event="file-retry"
            on-click="_fireFileEvent"
            hidden$="[[!errorMessage]]"
            aria-label$="[[i18n.file.retry]]"
            aria-describedby="name"
          ></button>
          <button
            type="button"
            part="remove-button"
            file-event="file-abort"
            on-click="_fireFileEvent"
            aria-label$="[[i18n.file.remove]]"
            aria-describedby="name"
          ></button>
        </div>
      </div>

      <slot name="progress"></slot>
    `;
      }
      static get is() {
        return "vaadin-upload-file";
      }
      /**
       * Fired when the retry button is pressed. It is listened by `vaadin-upload`
       * which will start a new upload process of this file.
       *
       * @event file-retry
       * @param {Object} detail
       * @param {Object} detail.file file to retry upload of
       */
      /**
       * Fired when the start button is pressed. It is listened by `vaadin-upload`
       * which will start a new upload process of this file.
       *
       * @event file-start
       * @param {Object} detail
       * @param {Object} detail.file file to start upload of
       */
      /**
       * Fired when abort button is pressed. It is listened by `vaadin-upload` which
       * will abort the upload in progress, and then remove the file from the list.
       *
       * @event file-abort
       * @param {Object} detail
       * @param {Object} detail.file file to abort upload of
       */
    }
    defineCustomElement(UploadFile);
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const UploadFileListMixin = (superClass) => class UploadFileListMixin extends superClass {
      static get properties() {
        return {
          /**
           * The array of files being processed, or already uploaded.
           */
          items: {
            type: Array
          },
          /**
           * The object used to localize upload files.
           */
          i18n: {
            type: Object
          }
        };
      }
      static get observers() {
        return ["__updateItems(items, i18n)"];
      }
      /** @private */
      __updateItems(items, i18n) {
        if (items && i18n) {
          this.requestContentUpdate();
        }
      }
      /**
       * Requests an update for the `vaadin-upload-file` elements.
       *
       * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
       */
      requestContentUpdate() {
        const { items, i18n } = this;
        render(
          html$1`
          ${items.map(
            (file) => html$1`
              <li>
                <vaadin-upload-file
                  .file="${file}"
                  .complete="${file.complete}"
                  .errorMessage="${file.error}"
                  .fileName="${file.name}"
                  .held="${file.held}"
                  .indeterminate="${file.indeterminate}"
                  .progress="${file.progress}"
                  .status="${file.status}"
                  .uploading="${file.uploading}"
                  .i18n="${i18n}"
                ></vaadin-upload-file>
              </li>
            `
          )}
        `,
          this
        );
      }
    };
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class UploadFileList extends UploadFileListMixin(ThemableMixin(PolymerElement)) {
      static get is() {
        return "vaadin-upload-file-list";
      }
      static get template() {
        return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='list'] {
          padding: 0;
          margin: 0;
          list-style-type: none;
        }
      </style>
      <ul part="list">
        <slot></slot>
      </ul>
    `;
      }
    }
    defineCustomElement(UploadFileList);
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class AddButtonController extends SlotController {
      constructor(host) {
        super(host, "add-button", "vaadin-button");
      }
      /**
       * Override method inherited from `SlotController`
       * to add listeners to default and custom node.
       *
       * @param {Node} node
       * @protected
       * @override
       */
      initNode(node) {
        if (node._isDefault) {
          this.defaultNode = node;
        }
        node.addEventListener("touchend", (e2) => {
          this.host._onAddFilesTouchEnd(e2);
        });
        node.addEventListener("click", (e2) => {
          this.host._onAddFilesClick(e2);
        });
        this.host._addButton = node;
      }
    }
    class DropLabelController extends SlotController {
      constructor(host) {
        super(host, "drop-label", "span");
      }
      /**
       * Override method inherited from `SlotController`
       * to add listeners to default and custom node.
       *
       * @param {Node} node
       * @protected
       * @override
       */
      initNode(node) {
        if (node._isDefault) {
          this.defaultNode = node;
        }
        this.host._dropLabel = node;
      }
    }
    const UploadMixin = (superClass) => class UploadMixin extends superClass {
      static get properties() {
        return {
          /**
           * Define whether the element supports dropping files on it for uploading.
           * By default it's enabled in desktop and disabled in touch devices
           * because mobile devices do not support drag events in general. Setting
           * it false means that drop is enabled even in touch-devices, and true
           * disables drop in all devices.
           *
           * @type {boolean}
           * @default true in touch-devices, false otherwise.
           */
          nodrop: {
            type: Boolean,
            reflectToAttribute: true,
            value: isTouch
          },
          /**
           * The server URL. The default value is an empty string, which means that
           * _window.location_ will be used.
           * @type {string}
           */
          target: {
            type: String,
            value: ""
          },
          /**
           * HTTP Method used to send the files. Only POST and PUT are allowed.
           * @type {!UploadMethod}
           */
          method: {
            type: String,
            value: "POST"
          },
          /**
           * Key-Value map to send to the server. If you set this property as an
           * attribute, use a valid JSON string, for example:
           * ```
           * <vaadin-upload headers='{"X-Foo": "Bar"}'></vaadin-upload>
           * ```
           * @type {object | string}
           */
          headers: {
            type: Object,
            value: {}
          },
          /**
           * Max time in milliseconds for the entire upload process, if exceeded the
           * request will be aborted. Zero means that there is no timeout.
           * @type {number}
           */
          timeout: {
            type: Number,
            value: 0
          },
          /** @private */
          _dragover: {
            type: Boolean,
            value: false,
            observer: "_dragoverChanged"
          },
          /**
           * The array of files being processed, or already uploaded.
           *
           * Each element is a [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)
           * object with a number of extra properties  to track the upload process:
           * - `uploadTarget`: The target URL used to upload this file.
           * - `elapsed`: Elapsed time since the upload started.
           * - `elapsedStr`: Human-readable elapsed time.
           * - `remaining`: Number of seconds remaining for the upload to finish.
           * - `remainingStr`: Human-readable remaining time for the upload to finish.
           * - `progress`: Percentage of the file already uploaded.
           * - `speed`: Upload speed in kB/s.
           * - `size`: File size in bytes.
           * - `totalStr`: Human-readable total size of the file.
           * - `loaded`: Bytes transferred so far.
           * - `loadedStr`: Human-readable uploaded size at the moment.
           * - `status`: Status of the upload process.
           * - `error`: Error message in case the upload failed.
           * - `abort`: True if the file was canceled by the user.
           * - `complete`: True when the file was transferred to the server.
           * - `uploading`: True while transferring data to the server.
           * @type {!Array<!UploadFile>}
           */
          files: {
            type: Array,
            notify: true,
            value: () => [],
            sync: true
          },
          /**
           * Limit of files to upload, by default it is unlimited. If the value is
           * set to one, native file browser will prevent selecting multiple files.
           * @attr {number} max-files
           * @type {number}
           */
          maxFiles: {
            type: Number,
            value: Infinity,
            sync: true
          },
          /**
           * Specifies if the maximum number of files have been uploaded
           * @attr {boolean} max-files-reached
           * @type {boolean}
           */
          maxFilesReached: {
            type: Boolean,
            value: false,
            notify: true,
            readOnly: true,
            reflectToAttribute: true
          },
          /**
           * Specifies the types of files that the server accepts.
           * Syntax: a comma-separated list of MIME type patterns (wildcards are
           * allowed) or file extensions.
           * Notice that MIME types are widely supported, while file extensions
           * are only implemented in certain browsers, so avoid using it.
           * Example: accept="video/*,image/tiff" or accept=".pdf,audio/mp3"
           * @type {string}
           */
          accept: {
            type: String,
            value: ""
          },
          /**
           * Specifies the maximum file size in bytes allowed to upload.
           * Notice that it is a client-side constraint, which will be checked before
           * sending the request. Obviously you need to do the same validation in
           * the server-side and be sure that they are aligned.
           * @attr {number} max-file-size
           * @type {number}
           */
          maxFileSize: {
            type: Number,
            value: Infinity
          },
          /**
           * Specifies if the dragover is validated with maxFiles and
           * accept properties.
           * @private
           */
          _dragoverValid: {
            type: Boolean,
            value: false,
            observer: "_dragoverValidChanged"
          },
          /**
           * Specifies the 'name' property at Content-Disposition
           * @attr {string} form-data-name
           * @type {string}
           */
          formDataName: {
            type: String,
            value: "file"
          },
          /**
           * Prevents upload(s) from immediately uploading upon adding file(s).
           * When set, you must manually trigger uploads using the `uploadFiles` method
           * @attr {boolean} no-auto
           * @type {boolean}
           */
          noAuto: {
            type: Boolean,
            value: false
          },
          /**
           * Set the withCredentials flag on the request.
           * @attr {boolean} with-credentials
           * @type {boolean}
           */
          withCredentials: {
            type: Boolean,
            value: false
          },
          /**
           * Pass-through to input's capture attribute. Allows user to trigger device inputs
           * such as camera or microphone immediately.
           */
          capture: String,
          /**
           * The object used to localize this component.
           * For changing the default localization, change the entire
           * _i18n_ object or just the property you want to modify.
           *
           * The object has the following JSON structure and default values:
           *
           * ```
           * {
           *   dropFiles: {
           *     one: 'Drop file here',
           *     many: 'Drop files here'
           *   },
           *   addFiles: {
           *     one: 'Select File...',
           *     many: 'Upload Files...'
           *   },
           *   error: {
           *     tooManyFiles: 'Too Many Files.',
           *     fileIsTooBig: 'File is Too Big.',
           *     incorrectFileType: 'Incorrect File Type.'
           *   },
           *   uploading: {
           *     status: {
           *       connecting: 'Connecting...',
           *       stalled: 'Stalled',
           *       processing: 'Processing File...',
           *       held: 'Queued'
           *     },
           *     remainingTime: {
           *       prefix: 'remaining time: ',
           *       unknown: 'unknown remaining time'
           *     },
           *     error: {
           *       serverUnavailable: 'Server Unavailable',
           *       unexpectedServerError: 'Unexpected Server Error',
           *       forbidden: 'Forbidden'
           *     }
           *   },
           *   file: {
           *     retry: 'Retry',
           *     start: 'Start',
           *     remove: 'Remove'
           *   },
           *   units: {
           *     size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
           *     sizeBase: 1000
           *   },
           *   formatSize: function(bytes) {
           *     // returns the size followed by the best suitable unit
           *   },
           *   formatTime: function(seconds, [secs, mins, hours]) {
           *     // returns a 'HH:MM:SS' string
           *   }
           * }
           * ```
           *
           * @type {!UploadI18n}
           * @default {English}
           */
          i18n: {
            type: Object,
            value() {
              return {
                dropFiles: {
                  one: "Drop file here",
                  many: "Drop files here"
                },
                addFiles: {
                  one: "Upload File...",
                  many: "Upload Files..."
                },
                error: {
                  tooManyFiles: "Too Many Files.",
                  fileIsTooBig: "File is Too Big.",
                  incorrectFileType: "Incorrect File Type."
                },
                uploading: {
                  status: {
                    connecting: "Connecting...",
                    stalled: "Stalled",
                    processing: "Processing File...",
                    held: "Queued"
                  },
                  remainingTime: {
                    prefix: "remaining time: ",
                    unknown: "unknown remaining time"
                  },
                  error: {
                    serverUnavailable: "Upload failed, please try again later",
                    unexpectedServerError: "Upload failed due to server error",
                    forbidden: "Upload forbidden"
                  }
                },
                file: {
                  retry: "Retry",
                  start: "Start",
                  remove: "Remove"
                },
                units: {
                  size: ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
                }
              };
            }
          },
          /** @private */
          _addButton: {
            type: Object
          },
          /** @private */
          _dropLabel: {
            type: Object
          },
          /** @private */
          _fileList: {
            type: Object
          },
          /** @private */
          _files: {
            type: Array
          }
        };
      }
      static get observers() {
        return [
          "__updateAddButton(_addButton, maxFiles, i18n, maxFilesReached)",
          "__updateDropLabel(_dropLabel, maxFiles, i18n)",
          "__updateFileList(_fileList, files, i18n)",
          "__updateMaxFilesReached(maxFiles, files)"
        ];
      }
      /** @private */
      get __acceptRegexp() {
        if (!this.accept) {
          return null;
        }
        const processedTokens = this.accept.split(",").map((token) => {
          let processedToken = token.trim();
          processedToken = processedToken.replace(/[+.]/gu, "\\$&");
          if (processedToken.startsWith("\\.")) {
            processedToken = `.*${processedToken}$`;
          }
          return processedToken.replace(/\/\*/gu, "/.*");
        });
        return new RegExp(`^(${processedTokens.join("|")})$`, "iu");
      }
      /** @protected */
      ready() {
        super.ready();
        this.addEventListener("dragover", this._onDragover.bind(this));
        this.addEventListener("dragleave", this._onDragleave.bind(this));
        this.addEventListener("drop", this._onDrop.bind(this));
        this.addEventListener("file-retry", this._onFileRetry.bind(this));
        this.addEventListener("file-abort", this._onFileAbort.bind(this));
        this.addEventListener("file-start", this._onFileStart.bind(this));
        this.addEventListener("file-reject", this._onFileReject.bind(this));
        this.addEventListener("upload-start", this._onUploadStart.bind(this));
        this.addEventListener("upload-success", this._onUploadSuccess.bind(this));
        this.addEventListener("upload-error", this._onUploadError.bind(this));
        this._addButtonController = new AddButtonController(this);
        this.addController(this._addButtonController);
        this._dropLabelController = new DropLabelController(this);
        this.addController(this._dropLabelController);
        this.addController(
          new SlotController(this, "file-list", "vaadin-upload-file-list", {
            initializer: (list) => {
              this._fileList = list;
            }
          })
        );
        this.addController(new SlotController(this, "drop-label-icon", "vaadin-upload-icon"));
      }
      /** @private */
      _formatSize(bytes) {
        if (typeof this.i18n.formatSize === "function") {
          return this.i18n.formatSize(bytes);
        }
        const base = this.i18n.units.sizeBase || 1e3;
        const unit = ~~(Math.log(bytes) / Math.log(base));
        const dec = Math.max(0, Math.min(3, unit - 1));
        const size = parseFloat((bytes / base ** unit).toFixed(dec));
        return `${size} ${this.i18n.units.size[unit]}`;
      }
      /** @private */
      _splitTimeByUnits(time) {
        const unitSizes = [60, 60, 24, Infinity];
        const timeValues = [0];
        for (let i = 0; i < unitSizes.length && time > 0; i++) {
          timeValues[i] = time % unitSizes[i];
          time = Math.floor(time / unitSizes[i]);
        }
        return timeValues;
      }
      /** @private */
      _formatTime(seconds, split) {
        if (typeof this.i18n.formatTime === "function") {
          return this.i18n.formatTime(seconds, split);
        }
        while (split.length < 3) {
          split.push(0);
        }
        return split.reverse().map((number) => {
          return (number < 10 ? "0" : "") + number;
        }).join(":");
      }
      /** @private */
      _formatFileProgress(file) {
        const remainingTime = file.loaded > 0 ? this.i18n.uploading.remainingTime.prefix + file.remainingStr : this.i18n.uploading.remainingTime.unknown;
        return `${file.totalStr}: ${file.progress}% (${remainingTime})`;
      }
      /** @private */
      __updateMaxFilesReached(maxFiles, files) {
        this._setMaxFilesReached(maxFiles >= 0 && files.length >= maxFiles);
      }
      /** @private */
      __updateAddButton(addButton, maxFiles, i18n, maxFilesReached) {
        if (addButton) {
          addButton.disabled = maxFilesReached;
          if (addButton === this._addButtonController.defaultNode) {
            addButton.textContent = this._i18nPlural(maxFiles, i18n.addFiles);
          }
        }
      }
      /** @private */
      __updateDropLabel(dropLabel, maxFiles, i18n) {
        if (dropLabel && dropLabel === this._dropLabelController.defaultNode) {
          dropLabel.textContent = this._i18nPlural(maxFiles, i18n.dropFiles);
        }
      }
      /** @private */
      __updateFileList(list, files, i18n) {
        if (list) {
          list.items = [...files];
          list.i18n = i18n;
        }
      }
      /** @private */
      _onDragover(event) {
        event.preventDefault();
        if (!this.nodrop && !this._dragover) {
          this._dragoverValid = !this.maxFilesReached;
          this._dragover = true;
        }
        event.dataTransfer.dropEffect = !this._dragoverValid || this.nodrop ? "none" : "copy";
      }
      /** @private */
      _onDragleave(event) {
        event.preventDefault();
        if (this._dragover && !this.nodrop) {
          this._dragover = this._dragoverValid = false;
        }
      }
      /** @private */
      _onDrop(event) {
        if (!this.nodrop) {
          event.preventDefault();
          this._dragover = this._dragoverValid = false;
          this._addFiles(event.dataTransfer.files);
        }
      }
      /** @private */
      _createXhr() {
        return new XMLHttpRequest();
      }
      /** @private */
      _configureXhr(xhr) {
        if (typeof this.headers === "string") {
          try {
            this.headers = JSON.parse(this.headers);
          } catch (e2) {
            this.headers = void 0;
          }
        }
        Object.entries(this.headers).forEach(([key, value]) => {
          xhr.setRequestHeader(key, value);
        });
        if (this.timeout) {
          xhr.timeout = this.timeout;
        }
        xhr.withCredentials = this.withCredentials;
      }
      /** @private */
      _setStatus(file, total, loaded, elapsed) {
        file.elapsed = elapsed;
        file.elapsedStr = this._formatTime(file.elapsed, this._splitTimeByUnits(file.elapsed));
        file.remaining = Math.ceil(elapsed * (total / loaded - 1));
        file.remainingStr = this._formatTime(file.remaining, this._splitTimeByUnits(file.remaining));
        file.speed = ~~(total / elapsed / 1024);
        file.totalStr = this._formatSize(total);
        file.loadedStr = this._formatSize(loaded);
        file.status = this._formatFileProgress(file);
      }
      /**
       * Triggers the upload of any files that are not completed
       *
       * @param {!UploadFile | !Array<!UploadFile>=} files - Files being uploaded. Defaults to all outstanding files
       */
      uploadFiles(files = this.files) {
        if (files && !Array.isArray(files)) {
          files = [files];
        }
        files = files.filter((file) => !file.complete);
        Array.prototype.forEach.call(files, this._uploadFile.bind(this));
      }
      /** @private */
      _uploadFile(file) {
        if (file.uploading) {
          return;
        }
        const ini = Date.now();
        const xhr = file.xhr = this._createXhr();
        let stalledId, last;
        xhr.upload.onprogress = (e2) => {
          clearTimeout(stalledId);
          last = Date.now();
          const elapsed = (last - ini) / 1e3;
          const loaded = e2.loaded, total = e2.total, progress = ~~(loaded / total * 100);
          file.loaded = loaded;
          file.progress = progress;
          file.indeterminate = loaded <= 0 || loaded >= total;
          if (file.error) {
            file.indeterminate = file.status = void 0;
          } else if (!file.abort) {
            if (progress < 100) {
              this._setStatus(file, total, loaded, elapsed);
              stalledId = setTimeout(() => {
                file.status = this.i18n.uploading.status.stalled;
                this._renderFileList();
              }, 2e3);
            } else {
              file.loadedStr = file.totalStr;
              file.status = this.i18n.uploading.status.processing;
            }
          }
          this._renderFileList();
          this.dispatchEvent(new CustomEvent("upload-progress", { detail: { file, xhr } }));
        };
        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            clearTimeout(stalledId);
            file.indeterminate = file.uploading = false;
            if (file.abort) {
              return;
            }
            file.status = "";
            const evt2 = this.dispatchEvent(
              new CustomEvent("upload-response", {
                detail: { file, xhr },
                cancelable: true
              })
            );
            if (!evt2) {
              return;
            }
            if (xhr.status === 0) {
              file.error = this.i18n.uploading.error.serverUnavailable;
            } else if (xhr.status >= 500) {
              file.error = this.i18n.uploading.error.unexpectedServerError;
            } else if (xhr.status >= 400) {
              file.error = this.i18n.uploading.error.forbidden;
            }
            file.complete = !file.error;
            this.dispatchEvent(
              new CustomEvent(`upload-${file.error ? "error" : "success"}`, {
                detail: { file, xhr }
              })
            );
            this._renderFileList();
          }
        };
        const formData = new FormData();
        file.uploadTarget = file.uploadTarget || this.target || "";
        file.formDataName = this.formDataName;
        const evt = this.dispatchEvent(
          new CustomEvent("upload-before", {
            detail: { file, xhr },
            cancelable: true
          })
        );
        if (!evt) {
          return;
        }
        formData.append(file.formDataName, file, file.name);
        xhr.open(this.method, file.uploadTarget, true);
        this._configureXhr(xhr);
        file.status = this.i18n.uploading.status.connecting;
        file.uploading = file.indeterminate = true;
        file.complete = file.abort = file.error = file.held = false;
        xhr.upload.onloadstart = () => {
          this.dispatchEvent(
            new CustomEvent("upload-start", {
              detail: { file, xhr }
            })
          );
          this._renderFileList();
        };
        const uploadEvt = this.dispatchEvent(
          new CustomEvent("upload-request", {
            detail: { file, xhr, formData },
            cancelable: true
          })
        );
        if (uploadEvt) {
          xhr.send(formData);
        }
      }
      /** @private */
      _retryFileUpload(file) {
        const evt = this.dispatchEvent(
          new CustomEvent("upload-retry", {
            detail: { file, xhr: file.xhr },
            cancelable: true
          })
        );
        if (evt) {
          this._uploadFile(file);
        }
      }
      /** @private */
      _abortFileUpload(file) {
        const evt = this.dispatchEvent(
          new CustomEvent("upload-abort", {
            detail: { file, xhr: file.xhr },
            cancelable: true
          })
        );
        if (evt) {
          file.abort = true;
          if (file.xhr) {
            file.xhr.abort();
          }
          this._removeFile(file);
        }
      }
      /** @private */
      _renderFileList() {
        if (this._fileList) {
          this._fileList.requestContentUpdate();
        }
      }
      /** @private */
      _addFiles(files) {
        Array.prototype.forEach.call(files, this._addFile.bind(this));
      }
      /**
       * Add the file for uploading. Called internally for each file after picking files from dialog or dropping files.
       *
       * @param {!UploadFile} file File being added
       * @protected
       */
      _addFile(file) {
        if (this.maxFilesReached) {
          this.dispatchEvent(
            new CustomEvent("file-reject", {
              detail: { file, error: this.i18n.error.tooManyFiles }
            })
          );
          return;
        }
        if (this.maxFileSize >= 0 && file.size > this.maxFileSize) {
          this.dispatchEvent(
            new CustomEvent("file-reject", {
              detail: { file, error: this.i18n.error.fileIsTooBig }
            })
          );
          return;
        }
        const re = this.__acceptRegexp;
        if (re && !(re.test(file.type) || re.test(file.name))) {
          this.dispatchEvent(
            new CustomEvent("file-reject", {
              detail: { file, error: this.i18n.error.incorrectFileType }
            })
          );
          return;
        }
        file.loaded = 0;
        file.held = true;
        file.status = this.i18n.uploading.status.held;
        this.files = [file, ...this.files];
        if (!this.noAuto) {
          this._uploadFile(file);
        }
      }
      /**
       * Remove file from upload list. Called internally if file upload was canceled.
       * @param {!UploadFile} file File to remove
       * @protected
       */
      _removeFile(file) {
        if (this.files.indexOf(file) > -1) {
          this.files = this.files.filter((i) => i !== file);
          this.dispatchEvent(
            new CustomEvent("file-remove", {
              detail: { file },
              bubbles: true,
              composed: true
            })
          );
        }
      }
      /** @private */
      _onAddFilesTouchEnd(e2) {
        e2.preventDefault();
        this._onAddFilesClick(e2);
      }
      /** @private */
      _onAddFilesClick(e2) {
        if (this.maxFilesReached) {
          return;
        }
        e2.stopPropagation();
        this.$.fileInput.value = "";
        this.$.fileInput.click();
      }
      /** @private */
      _onFileInputChange(event) {
        this._addFiles(event.target.files);
      }
      /** @private */
      _onFileStart(event) {
        this._uploadFile(event.detail.file);
      }
      /** @private */
      _onFileRetry(event) {
        this._retryFileUpload(event.detail.file);
      }
      /** @private */
      _onFileAbort(event) {
        this._abortFileUpload(event.detail.file);
      }
      /** @private */
      _onFileReject(event) {
        announce(`${event.detail.file.name}: ${event.detail.error}`, { mode: "alert" });
      }
      /** @private */
      _onUploadStart(event) {
        announce(`${event.detail.file.name}: 0%`, { mode: "alert" });
      }
      /** @private */
      _onUploadSuccess(event) {
        announce(`${event.detail.file.name}: 100%`, { mode: "alert" });
      }
      /** @private */
      _onUploadError(event) {
        announce(`${event.detail.file.name}: ${event.detail.file.error}`, { mode: "alert" });
      }
      /** @private */
      _dragoverChanged(dragover) {
        if (dragover) {
          this.setAttribute("dragover", dragover);
        } else {
          this.removeAttribute("dragover");
        }
      }
      /** @private */
      _dragoverValidChanged(dragoverValid) {
        if (dragoverValid) {
          this.setAttribute("dragover-valid", dragoverValid);
        } else {
          this.removeAttribute("dragover-valid");
        }
      }
      /** @private */
      _i18nPlural(value, plural) {
        return value === 1 ? plural.one : plural.many;
      }
      /** @protected */
      _isMultiple(maxFiles) {
        return maxFiles !== 1;
      }
    };
    /**
     * @license
     * Copyright (c) 2016 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    class Upload extends UploadMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
      static get template() {
        return html`
      <style>
        :host {
          display: block;
          position: relative;
          box-sizing: border-box;
        }

        :host([hidden]) {
          display: none !important;
        }

        [hidden] {
          display: none !important;
        }
      </style>

      <div part="primary-buttons">
        <slot name="add-button"></slot>
        <div part="drop-label" hidden$="[[nodrop]]" id="dropLabelContainer" aria-hidden="true">
          <slot name="drop-label-icon"></slot>
          <slot name="drop-label"></slot>
        </div>
      </div>
      <slot name="file-list"></slot>
      <slot></slot>
      <input
        type="file"
        id="fileInput"
        hidden
        on-change="_onFileInputChange"
        accept$="{{accept}}"
        multiple$="[[_isMultiple(maxFiles)]]"
        capture$="[[capture]]"
      />
    `;
      }
      static get is() {
        return "vaadin-upload";
      }
      /**
       * Fired when a file cannot be added to the queue due to a constrain:
       *  file-size, file-type or maxFiles
       *
       * @event file-reject
       * @param {Object} detail
       * @param {Object} detail.file the file added
       * @param {string} detail.error the cause
       */
      /**
       * Fired before the XHR is opened. Could be used for changing the request
       * URL. If the default is prevented, then XHR would not be opened.
       *
       * @event upload-before
       * @param {Object} detail
       * @param {Object} detail.xhr the xhr
       * @param {Object} detail.file the file being uploaded
       * @param {Object} detail.file.uploadTarget the upload request URL, initialized with the value of vaadin-upload `target` property
       */
      /**
       * Fired when the XHR has been opened but not sent yet. Useful for appending
       * data keys to the FormData object, for changing some parameters like
       * headers, etc. If the event is defaultPrevented, `vaadin-upload` will not
       * send the request allowing the user to do something on his own.
       *
       * @event upload-request
       * @param {Object} detail
       * @param {Object} detail.xhr the xhr
       * @param {Object} detail.file the file being uploaded
       * @param {Object} detail.formData the FormData object
       */
      /**
       * Fired when the XHR is sent.
       *
       * @event upload-start
       * @param {Object} detail
       * @param {Object} detail.xhr the xhr
       * @param {Object} detail.file the file being uploaded
       */
      /**
       * Fired as many times as the progress is updated.
       *
       * @event upload-progress
       * @param {Object} detail
       * @param {Object} detail.xhr the xhr
       * @param {Object} detail.file the file being uploaded with loaded info
       */
      /**
       * Fired when we have the actual server response, and before the component
       * analyses it. It's useful for developers to make the upload fail depending
       * on the server response. If the event is defaultPrevented the vaadin-upload
       * will return allowing the user to do something on his own like retry the
       * upload, etc. since he has full access to the `xhr` and `file` objects.
       * Otherwise, if the event is not prevented default `vaadin-upload` continues
       * with the normal workflow checking the `xhr.status` and `file.error`
       * which also might be modified by the user to force a customized response.
       *
       * @event upload-response
       * @param {Object} detail
       * @param {Object} detail.xhr the xhr
       * @param {Object} detail.file the file being uploaded
       */
      /**
       * Fired in case the upload process succeed.
       *
       * @event upload-success
       * @param {Object} detail
       * @param {Object} detail.xhr the xhr
       * @param {Object} detail.file the file being uploaded with loaded info
       */
      /**
       * Fired in case the upload process failed.
       *
       * @event upload-error
       * @param {Object} detail
       * @param {Object} detail.xhr the xhr
       * @param {Object} detail.file the file being uploaded
       */
      /**
       * Fired when retry upload is requested. If the default is prevented, then
       * retry would not be performed.
       *
       * @event upload-retry
       * @param {Object} detail
       * @param {Object} detail.xhr the previous upload xhr
       * @param {Object} detail.file the file being uploaded
       */
      /**
       * Fired when retry abort is requested. If the default is prevented, then the
       * file upload would not be aborted.
       *
       * @event upload-abort
       * @param {Object} detail
       * @param {Object} detail.xhr the xhr
       * @param {Object} detail.file the file being uploaded
       */
    }
    defineCustomElement(Upload);
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const VirtualListMixin = (superClass) => class VirtualListMixinClass extends ControllerMixin(superClass) {
      static get properties() {
        return {
          /**
           * An array containing items determining how many instances to render.
           * @type {Array<!VirtualListItem> | undefined}
           */
          items: { type: Array, sync: true },
          /**
           * Custom function for rendering the content of every item.
           * Receives three arguments:
           *
           * - `root` The render target element representing one item at a time.
           * - `virtualList` The reference to the `<vaadin-virtual-list>` element.
           * - `model` The object with the properties related with the rendered
           *   item, contains:
           *   - `model.index` The index of the rendered item.
           *   - `model.item` The item.
           * @type {VirtualListRenderer | undefined}
           */
          renderer: { type: Function, sync: true },
          /** @private */
          __virtualizer: Object
        };
      }
      static get observers() {
        return ["__itemsOrRendererChanged(items, renderer, __virtualizer)"];
      }
      /**
       * Gets the index of the first visible item in the viewport.
       *
       * @return {number}
       */
      get firstVisibleIndex() {
        return this.__virtualizer.firstVisibleIndex;
      }
      /**
       * Gets the index of the last visible item in the viewport.
       *
       * @return {number}
       */
      get lastVisibleIndex() {
        return this.__virtualizer.lastVisibleIndex;
      }
      /** @protected */
      ready() {
        super.ready();
        this.__virtualizer = new Virtualizer({
          createElements: this.__createElements,
          updateElement: this.__updateElement.bind(this),
          elementsContainer: this,
          scrollTarget: this,
          scrollContainer: this.shadowRoot.querySelector("#items"),
          reorderElements: true
        });
        this.__overflowController = new OverflowController(this);
        this.addController(this.__overflowController);
        processTemplates(this);
      }
      /**
       * Scroll to a specific index in the virtual list.
       *
       * @param {number} index Index to scroll to
       */
      scrollToIndex(index) {
        this.__virtualizer.scrollToIndex(index);
      }
      /** @private */
      __createElements(count) {
        return [...Array(count)].map(() => document.createElement("div"));
      }
      /** @private */
      __updateElement(el, index) {
        if (el.__renderer !== this.renderer) {
          el.__renderer = this.renderer;
          this.__clearRenderTargetContent(el);
        }
        if (this.renderer) {
          this.renderer(el, this, { item: this.items[index], index });
        }
      }
      /**
       * Clears the content of a render target.
       * @private
       */
      __clearRenderTargetContent(element) {
        element.innerHTML = "";
        delete element._$litPart$;
      }
      /** @private */
      __itemsOrRendererChanged(items, renderer, virtualizer) {
        const hasRenderedItems = this.childElementCount > 0;
        if ((renderer || hasRenderedItems) && virtualizer) {
          virtualizer.size = (items || []).length;
          virtualizer.update();
        }
      }
      /**
       * Requests an update for the content of the rows.
       * While performing the update, it invokes the renderer passed in the `renderer` property for each visible row.
       *
       * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
       */
      requestContentUpdate() {
        if (this.__virtualizer) {
          this.__virtualizer.update();
        }
      }
    };
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const virtualListStyles = css$e`
  :host {
    display: block;
    height: 400px;
    overflow: auto;
    flex: auto;
    align-self: stretch;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host(:not([grid])) #items > ::slotted(*) {
    width: 100%;
  }

  #items {
    position: relative;
  }
`;
    /**
     * @license
     * Copyright (c) 2021 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    registerStyles$1("vaadin-virtual-list", virtualListStyles, { moduleId: "vaadin-virtual-list-styles" });
    class VirtualList extends ElementMixin(ThemableMixin(VirtualListMixin(PolymerElement))) {
      static get template() {
        return html`
      <div id="items">
        <slot></slot>
      </div>
    `;
      }
      static get is() {
        return "vaadin-virtual-list";
      }
    }
    defineCustomElement(VirtualList);
    window.Vaadin.Flow.virtualListConnector = {
      initLazy: function(list) {
        if (list.$connector) {
          return;
        }
        const extraItemsBuffer = 20;
        let lastRequestedRange = [0, 0];
        list.$connector = {};
        list.$connector.placeholderItem = { __placeholder: true };
        const updateRequestedItem = function() {
          const visibleIndexes = [...list.children].filter((el) => "__virtualListIndex" in el).map((el) => el.__virtualListIndex);
          const firstNeededItem = Math.min(...visibleIndexes);
          const lastNeededItem = Math.max(...visibleIndexes);
          let first = Math.max(0, firstNeededItem - extraItemsBuffer);
          let last = Math.min(lastNeededItem + extraItemsBuffer, list.items.length);
          if (lastRequestedRange[0] != first || lastRequestedRange[1] != last) {
            lastRequestedRange = [first, last];
            const count = 1 + last - first;
            list.$server.setRequestedRange(first, count);
          }
        };
        const scheduleUpdateRequest = function() {
          list.__requestDebounce = Debouncer.debounce(list.__requestDebounce, timeOut.after(50), updateRequestedItem);
        };
        requestAnimationFrame(() => updateRequestedItem);
        list.patchVirtualListRenderer = function() {
          if (!list.renderer || list.renderer.__virtualListConnectorPatched) {
            return;
          }
          const originalRenderer = list.renderer;
          const renderer = (root2, list2, model) => {
            root2.__virtualListIndex = model.index;
            if (model.item === void 0) {
              if (list2.$connector.placeholderElement) {
                if (!root2.__hasComponentRendererPlaceholder) {
                  root2.innerHTML = "";
                  delete root2._$litPart$;
                  root2.appendChild(list2.$connector.placeholderElement.cloneNode(true));
                  root2.__hasComponentRendererPlaceholder = true;
                }
              } else {
                originalRenderer.call(list2, root2, list2, {
                  ...model,
                  item: list2.$connector.placeholderItem
                });
              }
            } else {
              if (root2.__hasComponentRendererPlaceholder) {
                root2.innerHTML = "";
                root2.__hasComponentRendererPlaceholder = false;
              }
              originalRenderer.call(list2, root2, list2, model);
            }
            scheduleUpdateRequest();
          };
          renderer.__virtualListConnectorPatched = true;
          renderer.__rendererId = originalRenderer.__rendererId;
          list.renderer = renderer;
        };
        list._createPropertyObserver("renderer", "patchVirtualListRenderer", true);
        list.patchVirtualListRenderer();
        list.items = [];
        list.$connector.set = function(index, items) {
          list.items.splice(index, items.length, ...items);
          list.items = [...list.items];
        };
        list.$connector.clear = function(index, length) {
          const clearCount = Math.min(length, list.items.length - index);
          list.$connector.set(index, [...Array(clearCount)]);
        };
        list.$connector.updateData = function(items) {
          const updatedItemsMap = items.reduce((map, item2) => {
            map[item2.key] = item2;
            return map;
          }, {});
          list.items = list.items.map((item2) => {
            if (!item2) {
              return item2;
            }
            return updatedItemsMap[item2.key] || item2;
          });
        };
        list.$connector.updateSize = function(newSize) {
          const delta = newSize - list.items.length;
          if (delta > 0) {
            list.items = [...list.items, ...Array(delta)];
          } else if (delta < 0) {
            list.items = list.items.slice(0, newSize);
          }
        };
        list.$connector.setPlaceholderItem = function(placeholderItem = {}, appId) {
          placeholderItem.__placeholder = true;
          list.$connector.placeholderItem = placeholderItem;
          const nodeId = Object.entries(placeholderItem).find(([key]) => key.endsWith("_nodeid"));
          list.$connector.placeholderElement = nodeId ? Vaadin.Flow.clients[appId].getByNodeId(nodeId[1]) : null;
        };
      }
    };
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    addLumoGlobalStyles("color", color$h);
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const typographyWithoutHost = css$e`
  ${unsafeCSS(typography.cssText.replace(/,\s*:host/su, ""))}
`;
    addLumoGlobalStyles("typography", typographyWithoutHost);
    /**
     * @license
     * Copyright (c) 2017 - 2024 Vaadin Ltd.
     * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
     */
    const template = document.createElement("template");
    template.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg"><defs>
<g id="lumo:align-center"><path d="M167 217c0-18 17-33 38-34H795c21 0 38 15 38 34 0 18-17 33-38 33H205C184 250 167 235 167 217z m83 191c0-18 13-33 29-33H721c16 0 29 15 29 33 0 18-13 33-29 34H279C263 442 250 427 250 408zM250 792c0-18 13-33 29-34H721c16 0 29 15 29 34s-13 33-29 33H279C263 825 250 810 250 792z m-83-192c0-18 17-33 38-33H795c21 0 38 15 38 33s-17 33-38 33H205C184 633 167 618 167 600z" fill-rule="evenodd" clip-rule="evenodd"></path></g>
<g id="lumo:align-left"><path d="M167 217c0-18 17-33 38-34H795c21 0 38 15 38 34 0 18-17 33-38 33H205C184 250 167 235 167 217z m0 191c0-18 13-33 28-33H638c16 0 29 15 29 33 0 18-13 33-29 34H195C179 442 167 427 167 408zM167 792c0-18 13-33 28-34H638c16 0 29 15 29 34s-13 33-29 33H195C179 825 167 810 167 792z m0-192c0-18 17-33 38-33H795c21 0 38 15 38 33s-17 33-38 33H205C184 633 167 618 167 600z" fill-rule="evenodd" clip-rule="evenodd"></path></g>
<g id="lumo:align-right"><path d="M167 217c0-18 17-33 38-34H795c21 0 38 15 38 34 0 18-17 33-38 33H205C184 250 167 235 167 217z m166 191c0-18 13-33 29-33H805c16 0 29 15 28 33 0 18-13 33-28 34H362C346 442 333 427 333 408zM333 792c0-18 13-33 29-34H805c16 0 29 15 28 34s-13 33-28 33H362C346 825 333 810 333 792z m-166-192c0-18 17-33 38-33H795c21 0 38 15 38 33s-17 33-38 33H205C184 633 167 618 167 600z" fill-rule="evenodd" clip-rule="evenodd"></path></g>
<g id="lumo:angle-down"><path d="M283 391c-18-16-46-15-63 4-16 18-15 46 3 63l244 224c17 15 43 15 60 0l250-229c18-16 20-45 3-63-16-18-45-20-63-4l-220 203-214-198z"></path></g>
<g id="lumo:angle-left"><path d="M601 710c16 18 15 46-3 63-18 16-46 15-63-4l-224-244c-15-17-15-43 0-59l229-250c16-18 45-20 63-4 18 16 20 45 3 63l-203 220 198 215z"></path></g>
<g id="lumo:angle-right"><path d="M399 275c-16-18-15-46 3-63 18-16 46-15 63 4l224 244c15 17 15 43 0 59l-229 250c-16 18-45 20-63 4-18-16-20-45-3-63l203-220-198-215z"></path></g>
<g id="lumo:angle-up"><path d="M283 635c-18 16-46 15-63-3-16-18-15-46 3-63l244-224c17-15 43-15 60 0l250 229c18 16 20 45 3 63-16 18-45 20-63 3l-220-202L283 635z"></path></g>
<g id="lumo:arrow-down"><path d="M538 646l125-112c15-14 39-12 53 4 14 15 12 39-4 53l-187 166c0 0 0 0 0 0-14 13-36 12-50 0l-187-166c-15-14-17-37-4-53 14-15 37-17 53-4L462 646V312c0-21 17-38 38-37s38 17 37 37v334z"></path></g>
<g id="lumo:arrow-left"><path d="M375 538l111 125c14 15 12 39-3 53-15 14-39 12-53-4l-166-187c0 0 0 0 0 0-13-14-12-36 0-50l166-187c14-15 37-17 53-4 15 14 17 37 3 53L375 463h333c21 0 38 17 38 37 0 21-17 38-38 38h-333z"></path></g>
<g id="lumo:arrow-right"><path d="M625 538h-333c-21 0-38-17-38-38 0-21 17-38 38-37h333l-111-126c-14-15-12-39 3-53 15-14 39-12 53 4l166 187c13 14 13 36 0 50 0 0 0 0 0 0l-166 187c-14 15-37 17-53 4-15-14-17-37-3-53l111-125z"></path></g>
<g id="lumo:arrow-up"><path d="M538 354V688c0 21-17 38-38 37s-38-17-38-38V354l-125 112c-15 14-39 12-53-4-14-15-12-39 4-53l187-166c14-13 36-13 50 0 0 0 0 0 0 0l187 166c15 14 17 37 4 53-14 15-37 17-53 4L538 354z"></path></g>
<g id="lumo:bar-chart"><path d="M175 500h108c28 0 50 22 50 50v233c0 28-22 50-50 50H175c-28 0-50-22-50-50v-233c0-28 22-50 50-50z m33 67c-9 0-17 7-16 16v167c0 9 7 17 16 17h42c9 0 17-7 17-17v-167c0-9-7-17-17-16H208zM446 167h108c28 0 50 22 50 50v566c0 28-22 50-50 50h-108c-28 0-50-22-50-50V217c0-28 22-50 50-50z m33 66c-9 0-17 7-17 17v500c0 9 7 17 17 17h42c9 0 17-7 16-17V250c0-9-7-17-16-17h-42zM717 333h108c28 0 50 22 50 50v400c0 28-22 50-50 50h-108c-28 0-50-22-50-50V383c0-28 22-50 50-50z m33 67c-9 0-17 7-17 17v333c0 9 7 17 17 17h42c9 0 17-7 16-17v-333c0-9-7-17-16-17h-42z"></path></g>
<g id="lumo:bell"><path d="M367 675H292v-258C292 325 366 250 459 250H458V208c0-23 18-42 42-41 23 0 42 18 42 41v42h-1C634 250 708 325 708 417V675h-75v-258c0-51-41-92-91-92h-84C408 325 367 366 367 417V675z m-159 37c0-21 17-38 38-37h508c21 0 37 17 38 37 0 21-17 38-38 38H246C225 750 208 733 208 713z m230 71h125v32c0 17-14 31-32 31h-62c-17 0-32-14-31-31v-32z"></path></g>
<g id="lumo:calendar"><path d="M375 208h250v-20C625 176 634 167 646 167h41C699 167 708 176 708 188V208h74c23 0 41 19 41 42v42C823 315 804 333 782 333H218C196 333 177 315 177 292V250C177 227 196 208 218 208H292v-20C292 176 301 167 313 167h41C366 167 375 176 375 188V208zM229 375h42C283 375 292 384 292 396v41C292 449 282 458 271 458h-42C217 458 208 449 208 437v-41C208 384 218 375 229 375z m125 0h42C408 375 417 384 417 396v41C417 449 407 458 396 458h-42C342 458 333 449 333 437v-41C333 384 343 375 354 375z m125 0h42C533 375 542 384 542 396v41C542 449 532 458 521 458h-42C467 458 458 449 458 437v-41C458 384 468 375 479 375z m-250 125h42C283 500 292 509 292 521v41C292 574 282 583 271 583h-42C217 583 208 574 208 562v-41C208 509 218 500 229 500z m125 0h42C408 500 417 509 417 521v41C417 574 407 583 396 583h-42C342 583 333 574 333 562v-41C333 509 343 500 354 500z m125 0h42c12 0 21 9 21 21v41C542 574 532 583 521 583h-42C467 583 458 574 458 562v-41C458 509 468 500 479 500z m-250 125h42C283 625 292 634 292 646v41C292 699 282 708 271 708h-42C217 708 208 699 208 687v-41C208 634 218 625 229 625z m125 0h42C408 625 417 634 417 646v41C417 699 407 708 396 708h-42C342 708 333 699 333 687v-41C333 634 343 625 354 625z m125 0h42c12 0 21 9 21 21v41C542 699 532 708 521 708h-42C467 708 458 699 458 687v-41C458 634 468 625 479 625z m125-250h42C658 375 667 384 667 396v41C667 449 657 458 646 458h-42C592 458 583 449 583 437v-41C583 384 593 375 604 375z m0 125h42c12 0 21 9 21 21v41C667 574 657 583 646 583h-42C592 583 583 574 583 562v-41C583 509 593 500 604 500z m0 125h42c12 0 21 9 21 21v41C667 699 657 708 646 708h-42C592 708 583 699 583 687v-41C583 634 593 625 604 625z m125 0h42c12 0 21 9 21 21v41C792 699 782 708 771 708h-42C717 708 708 699 708 687v-41C708 634 718 625 729 625z m-500 125h42C283 750 292 759 292 771v41C292 824 282 833 271 833h-42C217 833 208 824 208 812v-41C208 759 218 750 229 750z m125 0h42C408 750 417 759 417 771v41C417 824 407 833 396 833h-42C342 833 333 824 333 812v-41C333 759 343 750 354 750z m125 0h42c12 0 21 9 21 21v41C542 824 532 833 521 833h-42C467 833 458 824 458 812v-41C458 759 468 750 479 750z m125 0h42c12 0 21 9 21 21v41C667 824 657 833 646 833h-42C592 833 583 824 583 812v-41C583 759 593 750 604 750z m125 0h42c12 0 21 9 21 21v41C792 824 782 833 771 833h-42C717 833 708 824 708 812v-41C708 759 718 750 729 750z m0-250h42c12 0 21 9 21 21v41C792 574 782 583 771 583h-42C717 583 708 574 708 562v-41C708 509 718 500 729 500z m0-125h42C783 375 792 384 792 396v41C792 449 782 458 771 458h-42C717 458 708 449 708 437v-41C708 384 718 375 729 375z"></path></g>
<g id="lumo:checkmark"><path d="M318 493c-15-15-38-15-53 0-15 15-15 38 0 53l136 136c15 15 38 15 53 0l323-322c15-15 15-38 0-53-15-15-38-15-54 0l-295 296-110-110z"></path></g>
<g id="lumo:chevron-down"><path d="M533 654l210-199c9-9 9-23 0-32C739 419 733 417 726 417H274C261 417 250 427 250 439c0 6 2 12 7 16l210 199c18 17 48 17 66 0z"></path></g>
<g id="lumo:chevron-left"><path d="M346 533l199 210c9 9 23 9 32 0 4-4 7-10 6-17V274C583 261 573 250 561 250c-6 0-12 2-16 7l-199 210c-17 18-17 48 0 66z"></path></g>
<g id="lumo:chevron-right"><path d="M654 533L455 743c-9 9-23 9-32 0C419 739 417 733 417 726V274C417 261 427 250 439 250c6 0 12 2 16 7l199 210c17 18 17 48 0 66z"></path></g>
<g id="lumo:chevron-up"><path d="M533 346l210 199c9 9 9 23 0 32-4 4-10 7-17 6H274C261 583 250 573 250 561c0-6 2-12 7-16l210-199c18-17 48-17 66 0z"></path></g>
<g id="lumo:clock"><path d="M538 489l85 85c15 15 15 38 0 53-15 15-38 15-53 0l-93-93a38 38 0 0 1-2-2C467 525 462 515 462 504V308c0-21 17-38 38-37 21 0 38 17 37 37v181zM500 833c-184 0-333-149-333-333s149-333 333-333 333 149 333 333-149 333-333 333z m0-68c146 0 265-118 265-265 0-146-118-265-265-265-146 0-265 118-265 265 0 146 118 265 265 265z"></path></g>
<g id="lumo:cog"><path d="M833 458l-81-18c-8-25-17-50-29-75L767 292 708 233l-72 49c-21-12-46-25-75-30L542 167h-84l-19 79c-25 8-50 17-71 30L296 233 233 296l47 69c-12 21-21 46-29 71L167 458v84l84 25c8 25 17 50 29 75L233 708 292 767l76-44c21 12 46 25 75 29L458 833h84l19-81c25-8 50-17 75-29L708 767l59-59-44-66c12-21 25-46 29-75L833 542v-84z m-333 217c-96 0-175-79-175-175 0-96 79-175 175-175 96 0 175 79 175 175 0 96-79 175-175 175z"></path></g>
<g id="lumo:cross"><path d="M445 500l-142-141c-15-15-15-40 0-56 15-15 40-15 56 0L500 445l141-142c15-15 40-15 56 0 15 15 15 40 0 56L555 500l142 141c15 15 15 40 0 56-15 15-40 15-56 0L500 555l-141 142c-15 15-40 15-56 0-15-15-15-40 0-56L445 500z"></path></g>
<g id="lumo:download"><path d="M538 521l125-112c15-14 39-12 53 4 14 15 12 39-4 53l-187 166a38 38 0 0 1 0 0c-14 13-36 12-50 0l-187-166c-15-14-17-37-4-53 14-15 37-17 53-4L462 521V188c0-21 17-38 38-38s38 17 37 38v333zM758 704c0-21 17-38 38-37 21 0 38 17 37 37v92c0 21-17 38-37 37H204c-21 0-38-17-37-37v-92c0-21 17-38 37-37s38 17 38 37v54h516v-54z"></path></g>
<g id="lumo:dropdown"><path d="M317 393c-15-14-39-13-53 3-14 15-13 39 3 53l206 189c14 13 36 13 50 0l210-193c15-14 17-38 3-53-14-15-38-17-53-3l-185 171L317 393z"></path></g>
<g id="lumo:edit"><path d="M673 281l62 56-205 233c-9 10-38 24-85 39a8 8 0 0 1-5 0c-4-1-7-6-6-10l0 0c14-47 25-76 35-86l204-232z m37-42l52-59c15-17 41-18 58-2 17 16 18 42 3 59L772 295l-62-56zM626 208l-67 75h-226C305 283 283 306 283 333v334C283 695 306 717 333 717h334c28 0 50-22 50-50v-185L792 398v269C792 736 736 792 667 792H333C264 792 208 736 208 667V333C208 264 264 208 333 208h293z"></path></g>
<g id="lumo:error"><path d="M500 833c-184 0-333-149-333-333s149-333 333-333 333 149 333 333-149 333-333 333z m0-68c146 0 265-118 265-265 0-146-118-265-265-265-146 0-265 118-265 265 0 146 118 265 265 265zM479 292h42c12 0 21 9 20 20l-11 217c0 8-6 13-13 13h-34c-7 0-13-6-13-13l-11-217C459 301 468 292 479 292zM483 608h34c12 0 21 9 20 21v33c0 12-9 21-20 21h-34c-12 0-21-9-21-21v-33c0-12 9-21 21-21z"></path></g>
<g id="lumo:eye"><path d="M500 750c-187 0-417-163-417-250s230-250 417-250 417 163 417 250-230 250-417 250z m-336-231c20 22 47 46 78 69C322 644 411 678 500 678s178-34 258-90c31-22 59-46 78-69 6-7 12-14 16-19-4-6-9-12-16-19-20-22-47-46-78-69C678 356 589 322 500 322s-178 34-258 90c-31 22-59 46-78 69-6 7-12 14-16 19 4 6 9 12 16 19zM500 646c-81 0-146-65-146-146s65-146 146-146 146 65 146 146-65 146-146 146z m0-75c39 0 71-32 71-71 0-39-32-71-71-71-39 0-71 32-71 71 0 39 32 71 71 71z"></path></g>
<g id="lumo:eye-disabled"><path d="M396 735l60-60c15 2 30 3 44 3 89 0 178-34 258-90 31-22 59-46 78-69 6-7 12-14 16-19-4-6-9-12-16-19-20-22-47-46-78-69-8-5-15-11-23-15l50-51C862 397 917 458 917 500c0 87-230 250-417 250-34 0-69-5-104-15zM215 654C138 603 83 542 83 500c0-87 230-250 417-250 34 0 69 5 104 15l-59 60c-15-2-30-3-45-3-89 0-178 34-258 90-31 22-59 46-78 69-6 7-12 14-16 19 4 6 9 12 16 19 20 22 47 46 78 69 8 5 16 11 24 16L215 654z m271-9l159-159c0 5 1 9 1 14 0 81-65 146-146 146-5 0-9 0-14-1z m-131-131C354 510 354 505 354 500c0-81 65-146 146-146 5 0 10 0 14 1l-159 159z m-167 257L780 179c12-12 32-12 44 0 12 12 12 32 0 44L232 815c-12 12-32 12-44 0s-12-32 0-44z"></path></g>
<g id="lumo:menu"><path d="M167 292c0-23 19-42 41-42h584C815 250 833 268 833 292c0 23-19 42-41 41H208C185 333 167 315 167 292z m0 208c0-23 19-42 41-42h584C815 458 833 477 833 500c0 23-19 42-41 42H208C185 542 167 523 167 500z m0 208c0-23 19-42 41-41h584C815 667 833 685 833 708c0 23-19 42-41 42H208C185 750 167 732 167 708z"></path></g>
<g id="lumo:minus"><path d="M261 461c-22 0-39 18-39 39 0 22 18 39 39 39h478c22 0 39-18 39-39 0-22-18-39-39-39H261z"></path></g>
<g id="lumo:ordered-list"><path d="M138 333V198H136l-43 28v-38l45-31h45V333H138z m-61 128c0-35 27-59 68-59 39 0 66 21 66 53 0 20-11 37-43 64l-29 27v2h74V583H80v-30l55-52c26-24 32-33 33-43 0-13-10-22-24-22-15 0-26 10-26 25v1h-41v-1zM123 759v-31h21c15 0 25-8 25-21 0-13-10-21-25-21-15 0-26 9-26 23h-41c1-34 27-56 68-57 39 0 66 20 66 49 0 20-14 36-33 39v3c24 3 40 19 39 41 0 32-30 54-73 54-41 0-69-22-70-57h43c1 13 11 22 28 22 16 0 27-9 27-22 0-14-10-22-28-22h-21zM333 258c0-18 15-33 34-33h516c18 0 33 15 34 33 0 18-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z"></path></g>
<g id="lumo:phone"><path d="M296 208l42-37c17-15 44-13 58 4a42 42 0 0 1 5 7L459 282c12 20 5 45-15 57l-7 4c-17 10-25 30-19 48l20 66a420 420 0 0 0 93 157l41 45c13 14 35 17 51 8l7-5c20-12 45-5 57 16L745 777c12 20 5 45-15 57a42 42 0 0 1-8 4l-52 17c-61 21-129 4-174-43l-50-52c-81-85-141-189-175-302l-24-78c-19-62 0-129 49-172z"></path></g>
<g id="lumo:photo"><path d="M208 167h584c69 0 125 56 125 125v416c0 69-56 125-125 125H208c-69 0-125-56-125-125V292c0-69 56-125 125-125z m584 75H208c-28 0-50 22-50 50v416c0 28 22 50 50 50h584c28 0 50-22 50-50V292c0-28-22-50-50-50zM239 740l167-167c12-12 31-14 45-6l73 43 172-201c13-15 34-18 50-7l95 67v92l-111-78-169 199c-12 14-32 17-47 8l-76-43-111 111H229c2-7 5-13 10-18zM458 427C458 490 407 542 344 542S229 490 229 427c0-63 51-115 115-115S458 364 458 427z m-62 0C396 398 373 375 344 375S292 398 292 427c0 29 23 52 52 52s52-23 52-52z"></path></g>
<g id="lumo:play"><path d="M689 528l-298 175c-13 8-34 8-48 0-6-4-10-9-10-14V311C333 300 348 292 367 292c9 0 17 2 24 5l298 175c26 15 26 40 0 56z"></path></g>
<g id="lumo:plus"><path d="M461 461H261c-22 0-39 18-39 39 0 22 18 39 39 39h200v200c0 22 18 39 39 39 22 0 39-18 39-39v-200h200c22 0 39-18 39-39 0-22-18-39-39-39h-200V261c0-22-18-39-39-39-22 0-39 18-39 39v200z"></path></g>
<g id="lumo:redo"><path d="M290 614C312 523 393 458 491 458c55 0 106 22 144 57l-88 88c-3 3-5 7-5 11 0 8 6 15 15 15l193-5c17 0 31-15 31-32l5-192c0-4-1-8-4-11-6-6-16-6-22 0l-66 67C641 406 570 375 491 375c-136 0-248 90-281 215-1 2-1 5-1 8-8 44 45 68 73 32 4-5 7-11 8-16z"></path></g>
<g id="lumo:reload"><path d="M500 233V137c0-9 7-16 15-16 4 0 8 2 10 4l133 140c12 12 12 32 0 45l-133 140c-6 6-15 6-21 0C502 447 500 443 500 438V308c-117 0-212 95-212 213 0 117 95 212 212 212 117 0 212-95 212-212 0-21 17-38 38-38s38 17 37 38c0 159-129 288-287 287-159 0-288-129-288-287 0-159 129-288 288-288z"></path></g>
<g id="lumo:search"><path d="M662 603l131 131c16 16 16 42 0 59-16 16-43 16-59 0l-131-131C562 691 512 708 458 708c-138 0-250-112-250-250 0-138 112-250 250-250 138 0 250 112 250 250 0 54-17 104-46 145zM458 646c104 0 188-84 188-188S562 271 458 271 271 355 271 458s84 188 187 188z"></path></g>
<g id="lumo:undo"><path d="M710 614C688 523 607 458 509 458c-55 0-106 22-144 57l88 88c3 3 5 7 5 11 0 8-6 15-15 15l-193-5c-17 0-31-15-31-32L214 400c0-4 1-8 4-11 6-6 16-6 22 0l66 67C359 406 430 375 509 375c136 0 248 90 281 215 1 2 1 5 1 8 8 44-45 68-73 32-4-5-7-11-8-16z"></path></g>
<g id="lumo:unordered-list"><path d="M146 325c-42 0-67-26-67-63 0-37 25-63 67-63 42 0 67 26 67 63 0 37-25 63-67 63z m0 250c-42 0-67-26-67-63 0-37 25-63 67-63 42 0 67 26 67 63 0 37-25 63-67 63z m0 250c-42 0-67-26-67-63 0-37 25-63 67-63 42 0 67 26 67 63 0 37-25 63-67 63zM333 258c0-18 15-33 34-33h516c18 0 33 15 34 33 0 18-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z"></path></g>
<g id="lumo:upload"><path d="M454 271V604c0 21-17 38-37 38s-38-17-38-38V271L254 382c-15 14-39 12-53-3-14-15-12-39 3-53L391 160c14-13 36-13 51-1 0 0 0 0 0 1l187 166c15 14 17 37 3 53-14 15-37 17-53 3L454 271zM675 704c0-21 17-38 37-37 21 0 38 17 38 37v92c0 21-17 38-38 37H121c-21 0-38-17-38-37v-92c0-21 17-38 38-37s38 17 37 37v54h517v-54z"></path></g>
<g id="lumo:user"><path d="M500 500c-69 0-125-56-125-125s56-125 125-125 125 56 125 125-56 125-125 125z m-292 292c0-115 131-208 292-209s292 93 292 209H208z"></path></g>
</defs></svg>`;
    Iconset.register("lumo", 1e3, template);
    injectGlobalCss($cssFromFile_0.toString(), "CSSImport end", document);
    const loadOnDemand = (key) => {
      return Promise.resolve(0);
    };
    window.Vaadin = window.Vaadin || {};
    window.Vaadin.Flow = window.Vaadin.Flow || {};
    window.Vaadin.Flow.loadOnDemand = loadOnDemand;
    window.Vaadin.Flow.resetFocus = () => {
      let ae = document.activeElement;
      while (ae && ae.shadowRoot) ae = ae.shadowRoot.activeElement;
      return !ae || ae.blur() || ae.focus() || true;
    };
  }
});
export default require_generated_flow_imports_00c();
